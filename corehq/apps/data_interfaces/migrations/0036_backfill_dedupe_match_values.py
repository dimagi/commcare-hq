# Generated by Django 3.2.23 on 2023-12-12 01:18

from django.db import migrations, transaction


def forwards_func(apps, schema_editor):
    db_alias = schema_editor.connection.alias
    process_records(db_alias=db_alias)


def reverse_func(apps, schema_editor):
    # Reverse isn't particularly important here, because generally we'd want to revert both this
    # and the prior commit, dropping the table entirely
    pass


def process_records(batch_size=100, db_alias=None):
    from corehq.form_processor.models.cases import CommCareCase
    from corehq.apps.data_interfaces.models import CaseDuplicate, CaseDuplicateNew

    query = CaseDuplicate.objects.using(db_alias).all().order_by('id')
    for (start, end, total, batch) in batch_qs(query, batch_size):
        with transaction.atomic():
            inserts = []
            for duplicate in batch:
                case = CommCareCase.objects.get_case(duplicate.case_id)
                new_record = CaseDuplicateNew.create(case, duplicate.action, save=False)
                inserts.append(new_record)
            CaseDuplicateNew.objects.bulk_create(inserts, ignore_conflicts=True)


# Copied from: https://djangosnippets.org/snippets/1170/
def batch_qs(qs, batch_size=1000):
    """
    Returns a (start, end, total, queryset) tuple for each batch in the given
    queryset.

    Usage:
        # Make sure to order your querset
        article_qs = Article.objects.order_by('id')
        for start, end, total, qs in batch_qs(article_qs):
            print "Now processing %s - %s of %s" % (start + 1, end, total)
            for article in qs:
                print article.body
    """
    total = qs.count()
    for start in range(0, total, batch_size):
        end = min(start + batch_size, total)
        yield (start, end, total, qs[start:end])


class Migration(migrations.Migration):

    dependencies = [
        ('data_interfaces', '0035_add_case_duplicate_new'),
    ]

    operations = [
        migrations.RunPython(forwards_func, reverse_func, elidable=True)
    ]
