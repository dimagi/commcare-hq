from StringIO import StringIO
import datetime
import logging
from tempfile import NamedTemporaryFile
from decimal import Decimal
from couchdbkit import ResourceNotFound
from corehq.util.global_request import get_request
from dimagi.ext.couchdbkit import DateTimeProperty, StringProperty, SafeSaveDocument

from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist, ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models, transaction
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _
from corehq.const import USER_DATE_FORMAT
from corehq.util.view_utils import absolute_reverse
from dimagi.utils.web import get_site_domain

from django_prbac.models import Role

from dimagi.utils.decorators.memoized import memoized
from dimagi.utils.django.cached_object import CachedObject

from corehq.apps.hqwebapp.tasks import send_html_email_async
from corehq.apps.users.models import WebUser

from corehq.apps.accounting.exceptions import (
    CreditLineError, AccountingError, SubscriptionAdjustmentError,
    SubscriptionChangeError, NewSubscriptionError, InvoiceEmailThrottledError,
    SubscriptionReminderError, SubscriptionRenewalError, ProductPlanNotFoundError,
)
from corehq.apps.accounting.invoice_pdf import InvoiceTemplate
from corehq.apps.accounting.signals import subscription_upgrade_or_downgrade
from corehq.apps.accounting.utils import (
    get_privileges, get_first_last_days,
    get_address_from_invoice, get_dimagi_from_email_by_product,
    fmt_dollar_amount, EXCHANGE_RATE_DECIMAL_PLACES,
    ensure_domain_instance, get_change_status,
    is_active_subscription,
)
from corehq.apps.accounting.subscription_changes import (
    DomainDowngradeActionHandler, DomainUpgradeActionHandler,
)
from corehq.apps.domain.models import Domain

logger = logging.getLogger('accounting')
integer_field_validators = [MaxValueValidator(2147483647), MinValueValidator(-2147483648)]

MAX_INVOICE_COMMUNICATIONS = 5
SMALL_INVOICE_THRESHOLD = 100


class BillingAccountType(object):
    CONTRACT = "CONTRACT"
    USER_CREATED = "USER_CREATED"
    GLOBAL_SERVICES = "GLOBAL_SERVICES"
    INVOICE_GENERATED = "INVOICE_GENERATED"
    TRIAL = "TRIAL"
    CHOICES = (
        (CONTRACT, "Created by contract"),
        (USER_CREATED, "Created by user"),
        (GLOBAL_SERVICES, "Created by Global Services"),
        (INVOICE_GENERATED, "Generated by an invoice"),
        (TRIAL, "Is trial account"),
    )


class FeatureType(object):
    USER = "User"
    SMS = "SMS"
    API = "API"
    CHOICES = (
        (USER, USER),
        (SMS, SMS),
    )


class SoftwareProductType(object):
    COMMCARE = "CommCare"
    COMMTRACK = "CommTrack"
    COMMCONNECT = "CommConnect"
    CHOICES = (
        (COMMCARE, COMMCARE),
        (COMMTRACK, COMMTRACK),
        (COMMCONNECT, COMMCONNECT),
    )

    @classmethod
    def get_type_by_domain(cls, domain):
        if domain.commtrack_enabled:
            return cls.COMMTRACK
        if domain.commconnect_enabled:
            return cls.COMMCONNECT
        return cls.COMMCARE


class SoftwarePlanEdition(object):
    COMMUNITY = "Community"
    STANDARD = "Standard"
    PRO = "Pro"
    ADVANCED = "Advanced"
    ENTERPRISE = "Enterprise"
    CHOICES = (
        (COMMUNITY, COMMUNITY),
        (STANDARD, STANDARD),
        (PRO, PRO),
        (ADVANCED, ADVANCED),
        (ENTERPRISE, ENTERPRISE),
    )
    ORDER = [
        COMMUNITY,
        STANDARD,
        PRO,
        ADVANCED,
    ]


class SoftwarePlanVisibility(object):
    PUBLIC = "PUBLIC"
    INTERNAL = "INTERNAL"
    TRIAL = "TRIAL"
    TRIAL_INTERNAL = "TRIAL_INT"
    CHOICES = (
        (PUBLIC, "Anyone can subscribe"),
        (INTERNAL, "Dimagi must create subscription"),
        (TRIAL, "This is a Trial Plan"),
        (TRIAL_INTERNAL, "This is special Trial plan that Dimagi manages."),
    )


class CreditAdjustmentReason(object):
    DIRECT_PAYMENT = "DIRECT_PAYMENT"
    SALESFORCE = "SALESFORCE"
    INVOICE = "INVOICE"
    LINE_ITEM = "LINE_ITEM"
    TRANSFER = "TRANSFER"
    MANUAL = "MANUAL"
    CHOICES = (
        (MANUAL, "manual"),
        (SALESFORCE, "via Salesforce"),
        (INVOICE, "invoice generated"),
        (LINE_ITEM, "line item generated"),
        (TRANSFER, "transfer from another credit line"),
        (DIRECT_PAYMENT, "payment from client received"),
    )


class SubscriptionAdjustmentReason(object):
    CREATE = "CREATE"
    MODIFY = "MODIFY"
    CANCEL = "CANCEL"
    UPGRADE = "UPGRADE"
    DOWNGRADE = "DOWNGRADE"
    SWITCH = "SWITCH"
    REACTIVATE = "REACTIVATE"
    RENEW = "RENEW"
    CHOICES = (
        (CREATE, "A new subscription created from scratch."),
        (MODIFY, "Some part of the subscription was modified...likely a date."),
        (CANCEL, "The subscription was cancelled with no followup subscription."),
        (UPGRADE, "The subscription was upgraded to the related subscription."),
        (DOWNGRADE, "The subscription was downgraded to the related subscription."),
        (SWITCH, "The plan was changed to the related subscription and "
                 "was neither an upgrade or downgrade."),
        (REACTIVATE, "The subscription was reactivated."),
        (RENEW, "The subscription was renewed."),
    )


class SubscriptionAdjustmentMethod(object):
    USER = "USER"
    INTERNAL = "INTERNAL"
    TASK = "TASK"
    TRIAL = "TRIAL"
    TRIAL_INTERNAL = "TRIAL_INT"
    CHOICES = (
        (USER, "User"),
        (INTERNAL, "Ops"),
        (TASK, "Task (Invoicing)"),
        (TRIAL, "30 Day Trial"),
        (TRIAL_INTERNAL, "Custom Trial Period"),
    )


class PaymentMethodType(object):
    STRIPE = "Stripe"
    CHOICES = (
        (STRIPE, STRIPE),
    )


class SubscriptionType(object):
    CONTRACTED = "CONTRACTED"
    SELF_SERVICE = "SELF_SERVICE"
    NOT_SET = "NOT_SET"
    CHOICES = (
        (CONTRACTED, "Contracted"),
        (SELF_SERVICE, "Self-service"),
        (NOT_SET, "Not Set"),
    )


class ProBonoStatus(object):
    YES = "YES"
    NO = "NO"
    DISCOUNTED = "DISCOUNTED"
    NOT_SET = "NOT_SET"
    CHOICES = (
        (YES, "Yes"),
        (NO, "No"),
        (DISCOUNTED, "Discounted"),
        (NOT_SET, "Not Set"),
    )


class EntryPoint(object):
    CONTRACTED = "CONTRACTED"
    SELF_STARTED = "SELF_STARTED"
    NOT_SET = "NOT_SET"
    CHOICES = (
        (CONTRACTED, "Contracted"),
        (SELF_STARTED, "Self-started"),
        (NOT_SET, "Not Set"),
    )


class Currency(models.Model):
    """
    Keeps track of the current conversion rates so that we don't have to poll the free, but rate limited API
    from Open Exchange Rates. Necessary for billing things like MACH SMS.
    """
    code = models.CharField(max_length=3, unique=True)
    name = models.CharField(max_length=25, db_index=True)
    symbol = models.CharField(max_length=10)
    rate_to_default = models.DecimalField(
        default=Decimal('1.0'), max_digits=20,
        decimal_places=EXCHANGE_RATE_DECIMAL_PLACES,
    )
    date_updated = models.DateField(auto_now=True)

    @classmethod
    def get_default(cls):
        default, _ = cls.objects.get_or_create(code=settings.DEFAULT_CURRENCY)
        return default


class BillingAccount(models.Model):
    """
    The key model that links a Subscription to its financial source and methods of payment.
    """
    name = models.CharField(max_length=200, db_index=True)
    salesforce_account_id = models.CharField(
        db_index=True,
        max_length=80,
        blank=True,
        null=True,
        help_text="This is how we link to the salesforce account",
    )
    created_by = models.CharField(max_length=80)
    created_by_domain = models.CharField(max_length=256, null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    dimagi_contact = models.CharField(max_length=80, null=True, blank=True)
    currency = models.ForeignKey(Currency, on_delete=models.PROTECT)
    is_auto_invoiceable = models.BooleanField(default=False)
    date_confirmed_extra_charges = models.DateTimeField(null=True, blank=True)
    account_type = models.CharField(
        max_length=25,
        default=BillingAccountType.CONTRACT,
        choices=BillingAccountType.CHOICES,
    )
    is_active = models.BooleanField(default=True)
    entry_point = models.CharField(
        max_length=25,
        default=EntryPoint.NOT_SET,
        choices=EntryPoint.CHOICES,
    )
    last_modified = models.DateTimeField(auto_now=True)

    @property
    def balance(self):
        # todo compute
        return 0.0

    @classmethod
    def get_or_create_account_by_domain(cls, domain,
                                        created_by=None, account_type=None,
                                        created_by_invoicing=False,
                                        entry_point=None):
        """
        First try to grab the account used for the last subscription.
        If an account is not found, create it.
        """
        is_new = False
        account = cls.get_account_by_domain(domain)
        if account is None:
            is_new = True
            account_type = account_type or BillingAccountType.INVOICE_GENERATED
            entry_point = entry_point or EntryPoint.NOT_SET
            account = BillingAccount(
                name="Account for Project %s" % domain,
                created_by=created_by,
                created_by_domain=domain,
                currency=Currency.get_default(),
                account_type=account_type,
                entry_point=entry_point,
            )
            account.save()
        return account, is_new

    @classmethod
    def get_account_by_domain(cls, domain):
        try:
            last_subscription = Subscription.objects.filter(
                is_trial=False, subscriber__domain=domain).latest('date_end')
            return last_subscription.account
        except ObjectDoesNotExist:
            pass
        try:
            return cls.objects.exclude(
                account_type=BillingAccountType.TRIAL
            ).get(created_by_domain=domain)
        except cls.DoesNotExist:
            pass
        except cls.MultipleObjectsReturned:
            logger.error(
                "[BILLING] "
                "Multiple billing accounts showed up for the domain '%s'. The "
                "latest one was served, but you should reconcile very soon."
                % domain
            )
            return cls.objects.exclude(
                account_type=BillingAccountType.TRIAL
            ).filter(created_by_domain=domain).latest('date_created')
        return None


class BillingContactInfo(models.Model):
    account = models.OneToOneField(BillingAccount, primary_key=True, null=False)
    first_name = models.CharField(
        max_length=50, null=True, blank=True, verbose_name=_("First Name")
    )
    last_name = models.CharField(
        max_length=50, null=True, blank=True, verbose_name=_("Last Name")
    )
    emails = models.CharField(
        max_length=200, null=True,
        verbose_name=_("Contact Emails"),
        help_text=_("We will email communications regarding your account "
                    "to the emails specified here.")
    )
    phone_number = models.CharField(
        max_length=20, null=True, blank=True, verbose_name=_("Phone Number")
    )
    company_name = models.CharField(
        max_length=50, null=True, blank=True,
        verbose_name=_("Company / Organization")
    )
    first_line = models.CharField(
        max_length=50, null=False,
        verbose_name=_("Address First Line")
    )
    second_line = models.CharField(
        max_length=50, null=True, blank=True,
        verbose_name=_("Address Second Line")
    )
    city = models.CharField(
        max_length=50, null=False, verbose_name=_("City")
    )
    state_province_region = models.CharField(
        max_length=50, null=False,
        verbose_name=_("State / Province / Region"),
    )
    postal_code = models.CharField(
        max_length=20, null=False, verbose_name=_("Postal Code")
    )
    country = models.CharField(
        max_length=50, null=False, verbose_name=_("Country")
    )
    last_modified = models.DateTimeField(auto_now=True)

    @property
    def full_name(self):
        if not self.first_name:
            return self.last_name
        elif not self.last_name:
            return self.first_name
        else:
            return "%s %s" % (self.first_name, self.last_name)


class SoftwareProduct(models.Model):
    """
    Specifies a product name that can be included in a subscription. e.g. CommTrack Pro, CommCare Community, etc.
    """
    name = models.CharField(max_length=40, unique=True)
    product_type = models.CharField(max_length=25, db_index=True, choices=SoftwareProductType.CHOICES)
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        return "Software Product '%s' of type '%s'" % (self.name, self.product_type)

    def get_rate(self, default_instance=True):
        try:
            return self.softwareproductrate_set.filter(is_active=True).latest('date_created')
        except SoftwareProductRate.DoesNotExist:
            return SoftwareProductRate() if default_instance else None  # the defaults


class SoftwareProductRate(models.Model):
    """
    Links a SoftwareProduct to a monthly fee.
    Once created, ProductRates cannot be modified. Instead, a new ProductRate must be created.
    """
    product = models.ForeignKey(SoftwareProduct, on_delete=models.PROTECT)
    monthly_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        return '%s @ $%s /month' % (self.product.name, self.monthly_fee)

    def __eq__(self, other):
        if not isinstance(other, self.__class__) or not self.product.pk == other.product.pk:
            return False
        for field in ['monthly_fee', 'is_active']:
            if not getattr(self, field) == getattr(other, field):
                return False
        return True

    @classmethod
    def new_rate(cls, product_name, monthly_fee, save=True):
        product, _ = SoftwareProduct.objects.get_or_create(name=product_name)
        rate = SoftwareProductRate(product=product, monthly_fee=monthly_fee)
        if save:
            rate.save()
        return rate


class Feature(models.Model):
    """
    This is what will link a feature type (USER, API, etc.) to a name (Users Pro, API Standard, etc.) and will be what
    the FeatureRate references to provide a monthly fee, limit and per-excess fee.
    """
    name = models.CharField(max_length=40, unique=True)
    feature_type = models.CharField(max_length=10, db_index=True, choices=FeatureType.CHOICES)
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        return "Feature '%s' of type '%s'" % (self.name, self.feature_type)

    def get_rate(self, default_instance=True):
        try:
            return self.featurerate_set.filter(is_active=True).latest('date_created')
        except FeatureRate.DoesNotExist:
            return FeatureRate() if default_instance else None  # the defaults


class FeatureRate(models.Model):
    """
    Links a feature to a monthly fee, monthly limit, and a per-excess fee for exceeding the monthly limit.
    Once created, Feature Rates cannot be modified. Instead, a new Feature Rate must be created.
    """
    feature = models.ForeignKey(Feature, on_delete=models.PROTECT)
    monthly_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2,
                                      verbose_name="Monthly Fee")
    monthly_limit = models.IntegerField(default=0,
                                        verbose_name="Monthly Included Limit",
                                        validators=integer_field_validators)
    per_excess_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2,
                                         verbose_name="Fee Per Excess of Limit")
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        return '%s @ $%s /month, $%s /excess, limit: %d' % (
            self.feature.name, self.monthly_fee, self.per_excess_fee, self.monthly_limit
        )

    def __eq__(self, other):
        if not isinstance(other, self.__class__) or not self.feature.pk == other.feature.pk:
            return False
        for field in ['monthly_fee', 'monthly_limit', 'per_excess_fee', 'is_active']:
            if not getattr(self, field) == getattr(other, field):
                return False
        return True

    @classmethod
    def new_rate(cls, feature_name, feature_type,
                 monthly_fee=None, monthly_limit=None, per_excess_fee=None, save=True):
        feature, _ = Feature.objects.get_or_create(name=feature_name, feature_type=feature_type)
        rate = FeatureRate(feature=feature)

        if monthly_fee is not None:
            rate.monthly_fee = monthly_fee
        if monthly_limit is not None:
            rate.monthly_limit = monthly_limit
        if per_excess_fee is not None:
            rate.per_excess_fee = per_excess_fee

        if save:
            rate.save()
        return rate


class SoftwarePlan(models.Model):
    """
    Subscriptions are created for Software Plans. Software Plans can have many Software Plan Versions, which
    link the Software Plan to a set of permissions roles.
    """
    name = models.CharField(max_length=80, unique=True)
    description = models.TextField(blank=True,
                                   help_text="If the visibility is INTERNAL, this description field will be used.")
    edition = models.CharField(
        max_length=25,
        default=SoftwarePlanEdition.ENTERPRISE,
        choices=SoftwarePlanEdition.CHOICES,
    )
    visibility = models.CharField(
        max_length=10,
        default=SoftwarePlanVisibility.INTERNAL,
        choices=SoftwarePlanVisibility.CHOICES,
    )
    last_modified = models.DateTimeField(auto_now=True)

    def get_version(self):
        try:
            return self.softwareplanversion_set.filter(is_active=True).latest('date_created')
        except SoftwarePlanVersion.DoesNotExist:
            return None


class DefaultProductPlan(models.Model):
    """
    This links a product type to its default SoftwarePlan (i.e. the Community Plan).
    The latest SoftwarePlanVersion that's linked to this plan will be the one used to create a new subscription if
    nothing is found for that domain.
    """
    product_type = models.CharField(max_length=25, choices=SoftwareProductType.CHOICES)
    edition = models.CharField(
        default=SoftwarePlanEdition.COMMUNITY,
        choices=SoftwarePlanEdition.CHOICES,
        max_length=25,
    )
    plan = models.ForeignKey(SoftwarePlan, on_delete=models.PROTECT)
    is_trial = models.BooleanField(default=False)
    last_modified = models.DateTimeField(auto_now=True)

    @classmethod
    def get_default_plan_by_domain(cls, domain, edition=None, is_trial=False):
        domain = ensure_domain_instance(domain)
        edition = edition or SoftwarePlanEdition.COMMUNITY
        product_type = SoftwareProductType.get_type_by_domain(domain)
        try:
            default_product_plan = DefaultProductPlan.objects.get(
                product_type=product_type, edition=edition, is_trial=is_trial
            )
            return default_product_plan.plan.get_version()
        except DefaultProductPlan.DoesNotExist:
            raise AccountingError("No default product plan was set up, did you forget to bootstrap plans?")

    @classmethod
    def get_lowest_edition_by_domain(cls, domain, requested_privileges,
                                     return_plan=False):
        for edition in SoftwarePlanEdition.ORDER:
            plan_version = cls.get_default_plan_by_domain(
                domain, edition=edition
            )
            privileges = get_privileges(plan_version)
            if privileges.issuperset(requested_privileges):
                return (plan_version if return_plan
                        else plan_version.plan.edition)
        return None if return_plan else SoftwarePlanEdition.ENTERPRISE


class SoftwarePlanVersion(models.Model):
    """
    Links a plan to its rates and provides versioning information.
    Once a new SoftwarePlanVersion is created, it cannot be modified. Instead, a new SofwarePlanVersion
    must be created.
    """
    plan = models.ForeignKey(SoftwarePlan, on_delete=models.PROTECT)
    product_rates = models.ManyToManyField(SoftwareProductRate, blank=True)
    feature_rates = models.ManyToManyField(FeatureRate, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    role = models.ForeignKey(Role)
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        return "%(plan_name)s (v%(version_num)d)" % {
            'plan_name': self.plan.name,
            'version_num': self.version,
        }

    @property
    def core_product(self):
        try:
            product_rate = self.product_rates.all()[0]
            return product_rate.product.product_type
        except (IndexError, SoftwareProductRate.DoesNotExist):
            pass
        return "CommCare"

    @property
    def version(self):
        return (self.plan.softwareplanversion_set.count() -
                self.plan.softwareplanversion_set.filter(
                    date_created__gt=self.date_created).count())

    @property
    def user_facing_description(self):
        from corehq.apps.accounting.user_text import DESC_BY_EDITION, FEATURE_TYPE_TO_NAME
        product = self.product_rates.get()
        desc = {
            'name': self.plan.name,
            'description': self.plan.description,
        }
        try:
            if (self.plan.visibility == SoftwarePlanVisibility.PUBLIC
                or self.plan.visibility == SoftwarePlanVisibility.TRIAL):
                desc['description'] = DESC_BY_EDITION[self.plan.edition]['description']
            else:
                for desc_key in desc:
                    if not desc[desc_key]:
                        desc[desc_key] = DESC_BY_EDITION[self.plan.edition][desc_key]
        except KeyError:
            pass
        desc.update({
            'monthly_fee': 'USD %s' % product.monthly_fee,
            'rates': [{'name': FEATURE_TYPE_TO_NAME[r.feature.feature_type],
                       'included': 'Infinite' if r.monthly_limit == -1 else r.monthly_limit}
                      for r in self.feature_rates.all()],
            'edition': self.plan.edition,
        })
        return desc

    @property
    @memoized
    def user_feature(self):
        user_features = self.feature_rates.filter(feature__feature_type=FeatureType.USER)
        try:
            user_feature = user_features.order_by('monthly_limit')[0]
            if not user_feature.monthly_limit == -1:
                user_feature = user_features.order_by('-monthly_limit')[0]
            return user_feature
        except IndexError:
            pass

    @property
    def user_limit(self):
        if self.user_feature is not None:
            return self.user_feature.monthly_limit
        return -1

    @property
    def user_fee(self):
        if self.user_feature is not None:
            return "USD %d" % self.user_feature.per_excess_fee

    def feature_charges_exist_for_domain(self, domain,
                                         start_date=None, end_date=None):
        domain = ensure_domain_instance(domain)
        if domain is None:
            return False
        from corehq.apps.accounting.usage import FeatureUsageCalculator
        for feature_rate in self.feature_rates.all():
            # -1 is the special infinity charge
            if feature_rate.monthly_limit != -1:
                calc = FeatureUsageCalculator(
                    feature_rate, domain.name, start_date=start_date,
                    end_date=end_date
                )
                if calc.get_usage() > feature_rate.monthly_limit:
                    return True
        return False


class SubscriberManager(models.Manager):

    def safe_get(self, *args, **kwargs):
        try:
            return self.get(*args, **kwargs)
        except Subscriber.DoesNotExist:
            return None


class Subscriber(models.Model):
    """
    The objects that can be subscribed to a Subscription.
    """
    domain = models.CharField(max_length=256, null=True, db_index=True)
    organization = models.CharField(max_length=256, null=True, db_index=True)
    last_modified = models.DateTimeField(auto_now=True)

    objects = SubscriberManager()

    def __str__(self):
        if self.organization:
            return "ORGANIZATION %s" % self.organization
        return "DOMAIN %s" % self.domain

    def apply_upgrades_and_downgrades(self, downgraded_privileges=None,
                                      upgraded_privileges=None,
                                      new_plan_version=None,
                                      verbose=False,
                                      web_user=None,
                                      old_subscription=None,
                                      new_subscription=None,
                                      internal_change=False):

        if self.organization is not None:
            raise SubscriptionChangeError("Only domain upgrades and downgrades are possible.")

        if new_plan_version is None:
            new_plan_version = DefaultProductPlan.get_default_plan_by_domain(self.domain)

        if downgraded_privileges is None or upgraded_privileges is None:
            dp, up = get_change_status(None, new_plan_version)[1:]
            downgraded_privileges = downgraded_privileges or dp
            upgraded_privileges = upgraded_privileges or up

        if downgraded_privileges:
            downgrade_handler = DomainDowngradeActionHandler(
                self.domain, new_plan_version, downgraded_privileges,
                verbose=verbose, web_user=web_user,
            )
            if not downgrade_handler.get_response():
                raise SubscriptionChangeError("The downgrade was not successful.")

        if upgraded_privileges:
            upgrade_handler = DomainUpgradeActionHandler(
                self.domain, new_plan_version, upgraded_privileges,
                verbose=verbose, web_user=web_user,
            )
            if not upgrade_handler.get_response():
                raise SubscriptionChangeError("The upgrade was not successful.")

        if not (
            (
                new_subscription
                and new_subscription.is_trial
            )
            or (
                old_subscription
                and old_subscription.is_trial
                and not new_subscription
            )
        ):
            from corehq.apps.domain.views import DefaultProjectSettingsView
            billing_account = (
                new_subscription.account if new_subscription else
                old_subscription.account if old_subscription else None
            )
            # this can be None, though usually this will be initiated
            # by an http request
            request = get_request()
            email_context = {
                'domain': self.domain,
                'domain_url': absolute_reverse(
                    DefaultProjectSettingsView.urlname,
                    args=[self.domain],
                ),
                'old_plan': old_subscription.plan_version if old_subscription else None,
                'new_plan': new_subscription.plan_version if new_subscription else None,
                'old_subscription': old_subscription,
                'new_subscription': new_subscription,
                'billing_account': billing_account,
                'request': request,
                'referer': request.META.get('HTTP_REFERER') if request else None,
            }
            sub_change_email_address = (settings.INTERNAL_SUBSCRIPTION_CHANGE_EMAIL
                                        if internal_change else settings.SUBSCRIPTION_CHANGE_EMAIL)
            env = ("[{}] ".format(settings.SERVER_ENVIRONMENT.upper())
                   if settings.SERVER_ENVIRONMENT == "staging" else "")
            email_subject = "{env}Subscription Change Alert: {domain} from {old_plan} to {new_plan}".format(
                env=env,
                domain=email_context['domain'],
                old_plan=email_context['old_plan'],
                new_plan=email_context['new_plan'],
            )

            send_html_email_async.delay(
                email_subject,
                sub_change_email_address,
                render_to_string('accounting/subscription_change_email.html', email_context),
                text_content=render_to_string('accounting/subscription_change_email.txt', email_context),
            )

        subscription_upgrade_or_downgrade.send_robust(self.domain, domain=self.domain)


class Subscription(models.Model):
    """
    Links a Subscriber to a SoftwarePlan and BillingAccount, necessary for invoicing.
    """
    account = models.ForeignKey(BillingAccount, on_delete=models.PROTECT)
    plan_version = models.ForeignKey(SoftwarePlanVersion, on_delete=models.PROTECT)
    subscriber = models.ForeignKey(Subscriber, on_delete=models.PROTECT)
    salesforce_contract_id = models.CharField(blank=True, null=True, max_length=80)
    date_start = models.DateField()
    date_end = models.DateField(blank=True, null=True)
    date_delay_invoicing = models.DateField(blank=True, null=True)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=False)
    do_not_invoice = models.BooleanField(default=False)
    auto_generate_credits = models.BooleanField(default=False)
    is_trial = models.BooleanField(default=False)
    service_type = models.CharField(
        max_length=25,
        choices=SubscriptionType.CHOICES,
        default=SubscriptionType.NOT_SET,
    )
    pro_bono_status = models.CharField(
        max_length=25,
        choices=ProBonoStatus.CHOICES,
        default=ProBonoStatus.NOT_SET,
    )
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        return ("Subscription to %(plan_version)s for %(subscriber)s. "
                "[%(date_start)s - %(date_end)s]" % {
                    'plan_version': self.plan_version,
                    'subscriber': self.subscriber,
                    'date_start': self.date_start.strftime(USER_DATE_FORMAT),
                    'date_end': (self.date_end.strftime(USER_DATE_FORMAT)
                                 if self.date_end is not None else "--"),
                })

    def __eq__(self, other):
        return (
            other is not None
            and other.__class__.__name__ == self.__class__.__name__
            and other.plan_version.pk == self.plan_version.pk
            and other.date_start == self.date_start
            and other.date_end == self.date_end
            and other.subscriber.pk == self.subscriber.pk
            and other.account.pk == self.account.pk
        )

    def save(self, *args, **kwargs):
        """
        Overloaded to update domain pillow with subscription information
        """
        super(Subscription, self).save(*args, **kwargs)
        try:
            Domain.get_by_name(self.subscriber.domain).save()
        except Exception as e:
            # If a subscriber doesn't have a valid domain associated with it
            # we don't care the pillow won't be updated
            pass

    @property
    def allowed_attr_changes(self):
        """
        These are the attributes of a Subscription that can always be
        changed while the subscription is active (or reactivated)
        """
        return ['do_not_invoice', 'salesforce_contract_id']

    @property
    def is_renewed(self):
        """
        Checks to see if there's another Subscription for this subscriber
        that starts after this subscription.
        """
        return Subscription.objects.filter(
            subscriber=self.subscriber, date_start__gt=self.date_start
        ).exclude(pk=self.pk).exists()

    @property
    def next_subscription(self):
        try:
            return Subscription.objects.filter(
                subscriber=self.subscriber, date_start__gt=self.date_start
            ).exclude(pk=self.pk).order_by('date_start')[0]
        except (Subscription.DoesNotExist, IndexError):
            return None

    def cancel_subscription(self, adjustment_method=None, web_user=None, note=None):
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL
        today = datetime.date.today()
        if self.date_end is not None and today > self.date_end:
            raise SubscriptionAdjustmentError("The end date for this subscription already passed.")

        self.date_end = today
        if self.date_start > today:
            self.date_start = today

        self.is_active = False
        self.save()

        self.subscriber.apply_upgrades_and_downgrades(
            web_user=web_user,
            old_subscription=self,
        )

        # transfer existing credit lines to the account
        self.transfer_credits()

        SubscriptionAdjustment.record_adjustment(
            self, reason=SubscriptionAdjustmentReason.CANCEL, method=adjustment_method, note=note, web_user=web_user,
        )

    def raise_conflicting_dates(self, date_start, date_end):
        """Raises a subscription Adjustment error if the specified date range
        conflicts with other subscriptions related to this subscriber.
        """
        for sub in Subscription.objects.filter(
            subscriber=self.subscriber).exclude(id=self.id
        ).all():
            related_has_no_end = sub.date_end is None
            current_has_no_end = date_end is None
            start_before_related_end = (
                date_start is not None and sub.date_end is not None
                and date_start < sub.date_end
            )
            start_before_related_start = (
                date_start is not None and date_start < sub.date_start
            )
            start_after_related_start = (
                date_start is not None and date_start > sub.date_start
            )
            end_before_related_end = (
                date_end is not None and sub.date_end is not None
                and date_end < sub.date_end
            )
            end_after_related_end = (
                date_end is not None and sub.date_end is not None
                and date_end > sub.date_end
            )
            end_after_related_start = (
                date_end is not None and date_end > sub.date_start
            )

            if ((start_before_related_end and start_after_related_start)
                or (start_after_related_start and related_has_no_end)
                or (end_after_related_start and end_before_related_end)
                or (end_after_related_start and related_has_no_end)
                or (start_before_related_start and end_after_related_end)
                or (start_before_related_end and current_has_no_end)
            ):
                raise SubscriptionAdjustmentError(
                    "The start date of %(start_date)s conflicts with the "
                    "subscription dates to %(related_sub)s." % {
                        'start_date': self.date_start.strftime(USER_DATE_FORMAT),
                        'related_sub': sub,
                   }
                )

    def terminate_all_active_subscriptions(self, excluded_id=None,
                                           web_user=None, note=None,
                                           method=None):
        active_subs = Subscription.objects.filter(
            subscriber=self.subscriber, is_active=True
        )
        if excluded_id is not None:
            active_subs = active_subs.exclude(id=excluded_id)
        today = datetime.date.today()

        for sub in active_subs:
            if sub.id == self.id:
                sub = self
            sub.is_active = False
            if sub.date_end is None or sub.date_end > today:
                sub.date_end = today
            sub.save()
            SubscriptionAdjustment.record_adjustment(
                sub, reason=SubscriptionAdjustmentReason.MODIFY,
                method=method, note=note, web_user=web_user,
            )

    def update_subscription(self, date_start=None, date_end=None,
                            date_delay_invoicing=None, do_not_invoice=False,
                            salesforce_contract_id=None,
                            auto_generate_credits=False,
                            web_user=None, note=None, adjustment_method=None,
                            service_type=None, pro_bono_status=None):
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL

        today = datetime.date.today()
        if self.date_end is None or self.date_end > today:
            self.date_end = date_end
        if self.is_active and self.date_end is not None and self.date_end <= today:
            self.is_active = False

        if (self.date_start > today and date_start is not None
            and date_start > today and (self.date_end is None or not date_start > self.date_end)
        ):
            self.date_start = date_start
        elif self.date_end is not None and date_start > self.date_end:
            raise SubscriptionAdjustmentError(
                "Can't have a subscription start after the end date."
            )
        elif date_start is not None and date_start != self.date_start:
            raise SubscriptionAdjustmentError(
                "Can't change the start date of a subscription to a date that "
                "is today or in the past."
            )

        self.raise_conflicting_dates(self.date_start, self.date_end)

        if self.date_delay_invoicing is None or self.date_delay_invoicing > today:
            self.date_delay_invoicing = date_delay_invoicing

        self.do_not_invoice = do_not_invoice
        self.auto_generate_credits = auto_generate_credits
        self.salesforce_contract_id = salesforce_contract_id
        if service_type is not None:
            self.service_type = service_type
        if pro_bono_status is not None:
            self.pro_bono_status = pro_bono_status
        self.save()

        SubscriptionAdjustment.record_adjustment(
            self, method=adjustment_method, note=note, web_user=web_user,
            reason=SubscriptionAdjustmentReason.MODIFY
        )

    @transaction.atomic
    def change_plan(self, new_plan_version, date_end=None,
                    note=None, web_user=None, adjustment_method=None,
                    service_type=None, pro_bono_status=None,
                    transfer_credits=True, internal_change=False, account=None,
                    do_not_invoice=None, **kwargs):
        """
        Changing a plan TERMINATES the current subscription and
        creates a NEW SUBSCRIPTION where the old plan left off.
        This is not the same thing as simply updating the subscription.
        """
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL

        adjustment_reason, downgrades, upgrades = get_change_status(self.plan_version, new_plan_version)

        today = datetime.date.today()
        new_start_date = today if self.date_start < today else self.date_start

        if self.date_start > today:
            self.date_start = today
        if self.date_end is None or self.date_end > today:
            self.date_end = today
        if (self.date_delay_invoicing is not None
           and self.date_delay_invoicing > today):
            self.date_delay_invoicing = today
        self.is_active = False
        self.save()

        new_subscription = Subscription(
            account=account if account else self.account,
            plan_version=new_plan_version,
            subscriber=self.subscriber,
            salesforce_contract_id=self.salesforce_contract_id,
            date_start=new_start_date,
            date_end=date_end,
            date_delay_invoicing=self.date_delay_invoicing,
            is_active=is_active_subscription(new_start_date, date_end),
            do_not_invoice=do_not_invoice if do_not_invoice else self.do_not_invoice,
            service_type=(service_type or SubscriptionType.NOT_SET),
            pro_bono_status=(pro_bono_status or ProBonoStatus.NOT_SET),
            **kwargs
        )
        new_subscription.save()

        new_subscription.set_billing_account_entry_point()

        self.subscriber.apply_upgrades_and_downgrades(
            downgraded_privileges=downgrades,
            upgraded_privileges=upgrades,
            new_plan_version=new_plan_version,
            web_user=web_user,
            old_subscription=self,
            new_subscription=new_subscription,
            internal_change=internal_change,
        )

        # transfer existing credit lines to the new subscription
        if transfer_credits:
            self.transfer_credits(new_subscription)

        # record transfer from old subscription
        SubscriptionAdjustment.record_adjustment(
            self, method=adjustment_method, note=note, web_user=web_user,
            reason=adjustment_reason, related_subscription=new_subscription
        )

        return new_subscription

    def reactivate_subscription(self, date_end=None, note=None, web_user=None,
                                adjustment_method=None, **kwargs):
        """
        This assumes that a subscription was cancelled then recreated with the
        same date_start as the last subscription's date_end (with no other subscriptions
        created in between).
        """
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL
        self.date_end = date_end
        self.is_active = True
        for allowed_attr in self.allowed_attr_changes:
            if allowed_attr in kwargs.keys():
                setattr(self, allowed_attr, kwargs[allowed_attr])
        self.save()
        self.subscriber.apply_upgrades_and_downgrades(
            new_plan_version=self.plan_version,
            web_user=web_user,
            old_subscription=self,
            new_subscription=self,
        )
        SubscriptionAdjustment.record_adjustment(
            self, reason=SubscriptionAdjustmentReason.REACTIVATE,
            method=adjustment_method, note=note, web_user=web_user,
        )

    def renew_subscription(self, date_end=None, note=None, web_user=None,
                           adjustment_method=None,
                           service_type=None, pro_bono_status=None,
                           new_version=None):
        """
        This creates a new subscription with a date_start that is
        equivalent to the current subscription's date_end.
        - The date_end is left None.
        - The plan_version is the cheapest self-subscribable plan with the
          same set of privileges that the current plan has.
        """
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL

        if self.subscriber.organization is not None:
            raise SubscriptionRenewalError(
                "Can't renew subscription because organizations are not "
                "supported for this method."
            )
        if self.date_end is None:
            raise SubscriptionRenewalError(
                "Cannot renew a subscription with no date_end set."
            )

        if new_version is None:
            current_privileges = get_privileges(self.plan_version)
            new_version = DefaultProductPlan.get_lowest_edition_by_domain(
                self.subscriber.domain, current_privileges,
                return_plan=True,
            )

        if new_version is None:
            # this should NEVER happen, but on the off-chance that it does...
            raise SubscriptionRenewalError(
                "There was an issue renewing your subscription. Someone "
                "from Dimagi will get back to you shortly."
            )
        renewed_subscription = Subscription(
            account=self.account,
            plan_version=new_version,
            subscriber=self.subscriber,
            salesforce_contract_id=self.salesforce_contract_id,
            date_start=self.date_end,
            date_end=date_end,
        )
        if service_type is not None:
            renewed_subscription.service_type = service_type
        if pro_bono_status is not None:
            renewed_subscription.pro_bono_status = pro_bono_status
        if datetime.date.today() == self.date_end:
            renewed_subscription.is_active = True
        renewed_subscription.save()

        # transfer existing credit lines to the renewed subscription
        self.transfer_credits(renewed_subscription)

        # record renewal from old subscription
        SubscriptionAdjustment.record_adjustment(
            self, method=adjustment_method, note=note, web_user=web_user,
            reason=SubscriptionAdjustmentReason.RENEW,
        )

        return renewed_subscription

    def transfer_credits(self, subscription=None):
        """Transfers all credit balances related to an account or subscription
        (if specified).
        """
        if subscription is not None and self.account.pk != subscription.account.pk:
            raise CreditLineError(
                "Can only transfer subscription credits under the same "
                "Billing Account."
            )
        source_credits = CreditLine.objects.filter(
            account=self.account,
            subscription=self,
        ).all()
        for credit_line in source_credits:
            transferred_credit = CreditLine.add_credit(
                credit_line.balance,
                account=self.account,
                subscription=subscription,
                feature_type=credit_line.feature_type,
                product_type=credit_line.product_type,
                related_credit=credit_line
            )
            credit_line.is_active = False
            credit_line.adjust_credit_balance(
                credit_line.balance * Decimal('-1.0'),
                related_credit=transferred_credit,
            )

    def send_ending_reminder_email(self):
        """
        Sends a reminder email to the emails specified in the accounting
        contacts that the subscription will end on the specified end date.
        """
        if self.date_end is None:
            raise SubscriptionReminderError(
                "This subscription has no end date."
            )
        if self.subscriber.organization is not None:
            raise SubscriptionReminderError(
                "This reminder email does not yet handle organization "
                "subscribers."
            )
        if self.is_renewed:
            # no need to send a reminder email if the subscription
            # is already renewed
            return
        today = datetime.date.today()
        num_days_left = (self.date_end - today).days
        if num_days_left == 1:
            ending_on = _("tomorrow!")
        else:
            ending_on = _("on %s." % self.date_end.strftime(USER_DATE_FORMAT))

        user_desc = self.plan_version.user_facing_description
        plan_name = user_desc['name']
        domain_name = self.subscriber.domain
        product = self.plan_version.core_product
        emails = {a.username for a in WebUser.get_admins_by_domain(domain_name)}
        emails |= {e for e in WebUser.get_dimagi_emails_by_domain(domain_name)}
        if self.is_trial:
            subject = _("%(product)s Alert: 30 day trial for '%(domain)s' "
                        "ends %(ending_on)s") % {
                'product': product,
                'domain': domain_name,
                'ending_on': ending_on,
            }
            template = 'accounting/trial_ending_reminder_email.html'
            template_plaintext = 'accounting/trial_ending_reminder_email_plaintext.txt'
        else:
            subject = _("%(product)s Alert: %(domain)s's subscription to "
                        "%(plan_name)s ends %(ending_on)s") % {
                            'product': product,
                            'plan_name': plan_name,
                            'domain': domain_name,
                            'ending_on': ending_on,
                        }

            billing_contact_emails = BillingContactInfo.objects.get(account=self.account).emails.split(',')
            emails |= {billing_contact_email for billing_contact_email in billing_contact_emails}

            template = 'accounting/subscription_ending_reminder_email.html'
            template_plaintext = 'accounting/subscription_ending_reminder_email_plaintext.html'

        from corehq.apps.domain.views import DomainSubscriptionView
        context = {
            'domain': domain_name,
            'plan_name': plan_name,
            'product': product,
            'ending_on': ending_on,
            'subscription_url': absolute_reverse(
                DomainSubscriptionView.urlname, args=[self.subscriber.domain]),
            'base_url': get_site_domain(),
            'invoicing_contact_email': settings.INVOICING_CONTACT_EMAIL,
        }
        email_html = render_to_string(template, context)
        email_plaintext = render_to_string(template_plaintext, context)
        bcc = [settings.ACCOUNTS_EMAIL] if not self.is_trial else []
        if self.account.dimagi_contact is not None:
            bcc.append(self.account.dimagi_contact)
        for email in emails:
            send_html_email_async.delay(
                subject, email, email_html,
                text_content=email_plaintext,
                email_from=get_dimagi_from_email_by_product(product),
                bcc=bcc,
            )
            logger.info(
                "[BILLING] Sent %(days_left)s-day subscription reminder "
                "email for %(domain)s to %(email)s." % {
                    'days_left': num_days_left,
                    'domain': domain_name,
                    'email': email,
                })

    def send_dimagi_ending_reminder_email(self):
        if self.date_end is None:
            raise SubscriptionReminderError(
                "This subscription has no end date."
            )
        if self.account.dimagi_contact is None:
            raise SubscriptionReminderError(
                "This subscription has no Dimagi contact."
            )

        domain = self.subscriber.domain
        end_date = self.date_end.strftime(USER_DATE_FORMAT)
        email = self.account.dimagi_contact
        subject = "Alert: {domain}'s subscription is ending on {end_date}".format(
                  domain=domain,
                  end_date=end_date)
        template = 'accounting/subscription_ending_reminder_dimagi.html'
        template_plaintext = 'accounting/subscription_ending_reminder_dimagi_plaintext.html'
        context = {
            'domain': domain,
            'end_date': end_date,
            'contacts': self.account.billingcontactinfo.emails,
            'dimagi_contact': email,
        }
        email_html = render_to_string(template, context)
        email_plaintext = render_to_string(template_plaintext, context)
        send_html_email_async.delay(
            subject, email, email_html,
            text_content=email_plaintext,
            email_from=settings.DEFAULT_FROM_EMAIL,
        )

    def set_billing_account_entry_point(self):
        no_current_entry_point = self.account.entry_point == EntryPoint.NOT_SET
        self_serve = self.service_type == SubscriptionType.SELF_SERVICE
        if (no_current_entry_point and self_serve and not self.is_trial):
            self.account.entry_point = EntryPoint.SELF_STARTED
            self.account.save()

    @classmethod
    def _get_plan_by_subscriber(cls, subscriber):
        active_subscriptions = cls.objects\
            .filter(subscriber=subscriber, is_active=True)\
            .order_by('-date_created')[:2]\
            .select_related('plan_version__role')

        if not active_subscriptions:
            return None, None

        if len(active_subscriptions) > 1:
            logger.error(
                "[BILLING] "
                "There seem to be multiple ACTIVE subscriptions for the "
                "subscriber %s. Odd, right? The latest one by "
                "date_created was used, but consider this an issue."
                % subscriber
            )
        current_subscription = active_subscriptions[0]
        return current_subscription.plan_version, current_subscription

    @classmethod
    def get_subscribed_plan_by_organization(cls, organization):
        """
        Returns SoftwarePlanVersion, Subscription for the given organization.
        """
        subscriber = Subscriber.objects.safe_get(organization=organization, domain=None)
        return cls._get_plan_by_subscriber(subscriber) if subscriber else None, None

    @classmethod
    def get_subscribed_plan_by_domain(cls, domain):
        """
        Returns SoftwarePlanVersion, Subscription for the given domain.
        """
        domain_obj = ensure_domain_instance(domain)
        if domain_obj is None:
            try:
                plan_version = DefaultProductPlan.objects.get(
                    edition=SoftwarePlanEdition.COMMUNITY,
                    product_type=SoftwareProductType.COMMCARE,
                ).plan.get_version()
                return plan_version, None
            except DefaultProductPlan.DoesNotExist:
                raise ProductPlanNotFoundError
        domain = domain_obj
        subscriber = Subscriber.objects.safe_get(domain=domain.name, organization=None)
        plan_version, subscription = (cls._get_plan_by_subscriber(subscriber) if subscriber
                                      else cls.get_subscribed_plan_by_organization(domain.organization))
        if plan_version is None:
            plan_version = DefaultProductPlan.get_default_plan_by_domain(domain)
        return plan_version, subscription

    @classmethod
    def new_domain_subscription(cls, account, domain, plan_version,
                                date_start=None, date_end=None, note=None,
                                web_user=None, adjustment_method=None, internal_change=False,
                                **kwargs):
        subscriber = Subscriber.objects.get_or_create(domain=domain, organization=None)[0]
        today = datetime.date.today()
        date_start = date_start or today

        # find subscriptions that end in the future / after this subscription
        available_subs = Subscription.objects.filter(
            subscriber=subscriber,
        )

        future_subscription_no_end = available_subs.filter(
            date_end__exact=None,
        )
        if date_end is not None:
            future_subscription_no_end = future_subscription_no_end.filter(date_start__lt=date_end)
        if future_subscription_no_end.count() > 0:
            raise NewSubscriptionError(_(
                "There is already a subscription '%s' with no end date "
                "that conflicts with the start and end dates of this "
                "subscription.") %
                future_subscription_no_end.latest('date_created')
            )

        future_subscriptions = available_subs.filter(
            date_end__gt=date_start
        )
        if date_end is not None:
            future_subscriptions = future_subscriptions.filter(date_start__lt=date_end)
        if future_subscriptions.count() > 0:
            raise NewSubscriptionError(unicode(_(
                "There is already a subscription '%(sub)s' that has an end date "
                "that conflicts with the start and end dates of this "
                "subscription %(start)s - %(end)s.") % {
                    'sub': future_subscriptions.latest('date_created'),
                    'start': date_start,
                    'end': date_end
                }
            ))

        can_reactivate, last_subscription = cls.can_reactivate_domain_subscription(
            account, domain, plan_version, date_start=date_start
        )
        if can_reactivate:
            last_subscription.reactivate_subscription(
                date_end=date_end, note=note, web_user=web_user,
                adjustment_method=adjustment_method,
                **kwargs
            )
            return last_subscription

        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL
        subscription = Subscription.objects.create(
            account=account,
            plan_version=plan_version,
            subscriber=subscriber,
            date_start=date_start,
            date_end=date_end,
            **kwargs
        )
        subscription.is_active = is_active_subscription(date_start, date_end)
        if subscription.is_active:
            subscriber.apply_upgrades_and_downgrades(
                new_plan_version=plan_version,
                web_user=web_user,
                new_subscription=subscription,
                internal_change=internal_change,
            )
        SubscriptionAdjustment.record_adjustment(
            subscription, method=adjustment_method, note=note,
            web_user=web_user
        )
        subscription.save()

        subscription.set_billing_account_entry_point()

        return subscription

    @classmethod
    def can_reactivate_domain_subscription(cls, account, domain, plan_version,
                                           date_start=None):
        subscriber = Subscriber.objects.get_or_create(
            domain=domain, organization=None)[0]
        date_start = date_start or datetime.date.today()
        last_subscription = Subscription.objects.filter(
            subscriber=subscriber, date_end=date_start
        )
        if not last_subscription.exists():
            return False, None
        last_subscription = last_subscription.latest('date_created')
        return (last_subscription.account.pk == account.pk and
                last_subscription.plan_version.pk == plan_version.pk
               ), last_subscription


class InvoiceBaseManager(models.Manager):
    def get_queryset(self):
        return super(InvoiceBaseManager, self).get_queryset().filter(is_hidden_to_ops=False)


class InvoiceBase(models.Model):
    date_created = models.DateTimeField(auto_now_add=True)
    date_received = models.DateField(blank=True, db_index=True, null=True)
    is_hidden = models.BooleanField(default=False)
    tax_rate = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    balance = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    date_due = models.DateField(db_index=True, null=True)
    date_paid = models.DateField(blank=True, null=True)
    date_start = models.DateField()
    date_end = models.DateField()
    # If set to True invoice will not appear in invoice report. There is no UI to
    # control this filter
    is_hidden_to_ops = models.BooleanField(default=False)
    last_modified = models.DateTimeField(auto_now=True)

    objects = InvoiceBaseManager()

    class Meta:
        abstract = True

    @property
    def invoice_number(self):
        ops_num = settings.INVOICE_STARTING_NUMBER + self.id
        return "%s%d" % (settings.INVOICE_PREFIX, ops_num)

    @property
    def is_wire(self):
        return False

    def get_domain(self):
        raise NotImplementedError()

    @property
    def is_paid(self):
        return bool(self.date_paid)

    @property
    def email_recipients(self):
        return self.contact_emails

    @property
    def contact_emails(self):
        contact_emails = self.account.billingcontactinfo.emails
        contact_emails = (contact_emails.split(',')
                          if contact_emails is not None else [])
        if not contact_emails:
            admins = WebUser.get_admins_by_domain(
                self.get_domain()
            )
            contact_emails = [a.email if a.email else a.username for a in admins]
            logger.error(
                "[BILLING] "
                "Could not find an email to send the invoice "
                "email to for the domain %s. Sending to domain admins instead: "
                "%s." %
                (self.get_domain(), ', '.join(contact_emails))
            )
        return contact_emails


class WireInvoice(InvoiceBase):
    # WireInvoice is tied to a domain, rather than a subscription
    domain = models.CharField(max_length=80)

    @property
    @memoized
    def account(self):
        return BillingAccount.get_account_by_domain(self.domain)

    @property
    def subtotal(self):
        return self.balance

    @property
    def is_wire(self):
        return True

    @property
    def is_prepayment(self):
        return False

    def get_domain(self):
        return self.domain

    def get_total(self):
        return self.balance


class WirePrepaymentInvoice(WireInvoice):
    class Meta:
        proxy = True

    items = []

    @property
    def is_prepayment(self):
        return True


class Invoice(InvoiceBase):
    """
    This is what we'll use to calculate the balance on the accounts based on the current balance
    held by the Invoice. Balance updates will be tied to CreditAdjustmentTriggers which are tied
    to CreditAdjustments.
    """
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT)

    @property
    def email_recipients(self):
        if self.subscription.service_type == SubscriptionType.CONTRACTED:
            return [settings.FINANCE_EMAIL]
        else:
            return self.contact_emails

    @property
    def subtotal(self):
        """
        This will be inserted in the subtotal field on the printed invoice.
        """
        if self.lineitem_set.count() == 0:
            return Decimal('0.0000')
        return sum([line_item.total for line_item in self.lineitem_set.all()])

    @property
    def applied_tax(self):
        return self.tax_rate * self.subtotal

    @property
    @memoized
    def account(self):
        return self.subscription.account

    @property
    def applied_credit(self):
        if self.creditadjustment_set.count() == 0:
            return Decimal('0.0000')
        return sum([credit.amount for credit in self.creditadjustment_set.all()])

    def get_total(self):
        """
        This will be inserted in the total field on the printed invoice.
        """
        return self.subtotal + self.applied_tax + self.applied_credit

    def update_balance(self):
        self.balance = self.get_total()
        if self.balance <= 0:
            self.date_paid = datetime.date.today()
        else:
            self.date_paid = None

    def calculate_credit_adjustments(self):
        """
        This goes through all credit lines that:
        - do not have feature/product rates, but specify the related subscription and billing account
        - do not have feature/product rates or a subscription, but specify the related billing account
        """
        # first apply credits to all the line items
        for line_item in self.lineitem_set.all():
            line_item.calculate_credit_adjustments()

        # finally, apply credits to the leftover invoice balance
        current_total = self.get_total()
        credit_lines = CreditLine.get_credits_for_invoice(self)
        CreditLine.apply_credits_toward_balance(credit_lines, current_total, dict(invoice=self))

    @classmethod
    def exists_for_domain(cls, domain):
        return cls.objects.filter(
            subscription__subscriber__domain=domain, is_hidden=False
        ).count() > 0

    def get_domain(self):
        return self.subscription.subscriber.domain


class SubscriptionAdjustment(models.Model):
    """
    A record of any adjustments made to a subscription, so we always have a paper trail.
    Things that cannot be modified after a subscription is created:
    - account
    - plan
    - subscriber
    Things that have limited modification abilities:
    - dates if the current date is today or earlier
    All other modifications require cancelling the current subscription and creating a new one.

    Note: related_subscription is the subscription to be filled in when the subscription is upgraded / downgraded.
    """
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT)
    reason = models.CharField(max_length=50, default=SubscriptionAdjustmentReason.CREATE,
                              choices=SubscriptionAdjustmentReason.CHOICES)
    method = models.CharField(max_length=50, default=SubscriptionAdjustmentMethod.INTERNAL,
                              choices=SubscriptionAdjustmentMethod.CHOICES)
    note = models.TextField(null=True)
    web_user = models.CharField(max_length=80, null=True)
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True)
    related_subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT, null=True,
                                             related_name='subscriptionadjustment_related')
    date_created = models.DateField(auto_now_add=True)
    new_date_start = models.DateField()
    new_date_end = models.DateField(blank=True, null=True)
    new_date_delay_invoicing = models.DateField(blank=True, null=True)
    new_salesforce_contract_id = models.CharField(blank=True, null=True, max_length=80)
    last_modified = models.DateTimeField(auto_now=True)

    @classmethod
    def record_adjustment(cls, subscription, **kwargs):
        adjustment = SubscriptionAdjustment(
            subscription=subscription,
            new_date_start=subscription.date_start,
            new_date_end=subscription.date_end,
            new_date_delay_invoicing=subscription.date_delay_invoicing,
            new_salesforce_contract_id=subscription.salesforce_contract_id,
            **kwargs
        )
        adjustment.save()
        return adjustment


class BillingRecordBase(models.Model):
    """
    This stores any interaction we have with the client in sending a physical / pdf invoice to their contact email.
    """
    date_created = models.DateTimeField(auto_now_add=True, db_index=True)
    emailed_to = models.CharField(max_length=254, db_index=True)
    skipped_email = models.BooleanField(default=False)
    pdf_data_id = models.CharField(max_length=48)
    last_modified = models.DateTimeField(auto_now=True)

    INVOICE_HTML_TEMPLATE = 'accounting/invoice_email.html'
    INVOICE_TEXT_TEMPLATE = 'accounting/invoice_email_plaintext.html'

    class Meta:
        abstract = True

    _pdf = None

    @property
    def pdf(self):
        if self._pdf is None:
            return InvoicePdf.get(self.pdf_data_id)
        return self._pdf

    @property
    def html_template(self):
        return self.INVOICE_HTML_TEMPLATE

    @property
    def text_template(self):
        return self.INVOICE_TEXT_TEMPLATE

    @property
    def should_send_email(self):
        raise NotImplementedError("should_send_email is required")

    @classmethod
    def generate_record(cls, invoice):
        record = cls(invoice=invoice)
        invoice_pdf = InvoicePdf()
        invoice_pdf.generate_pdf(record.invoice)
        record.pdf_data_id = invoice_pdf._id
        record._pdf = invoice_pdf
        record.save()
        return record

    def handle_throttled_email(self, contact_emails):
        self.skipped_email = True
        month_name = self.invoice.date_start.strftime("%B")
        self.save()
        logger.info(
            "[BILLING] Throttled billing statements for domain %(domain)s "
            "to %(emails)s." % {
                'domain': self.invoice.get_domain(),
                'emails': ', '.join(contact_emails),
            }
        )
        raise InvoiceEmailThrottledError(
            "Invoice communications exceeded the maximum limit of "
            "%(max_limit)d for domain %(domain)s for the month of "
            "%(month_name)s." % {
                'max_limit': MAX_INVOICE_COMMUNICATIONS,
                'domain': self.invoice.get_domain(),
                'month_name': month_name,
            })

    def email_context(self):
        from corehq.apps.domain.views import (
            DomainBillingStatementsView, DefaultProjectSettingsView,
        )

        month_name = self.invoice.date_start.strftime("%B")
        domain = self.invoice.get_domain()
        context = {
            'month_name': month_name,
            'domain': domain,
            'domain_url': absolute_reverse(DefaultProjectSettingsView.urlname,
                                           args=[domain]),
            'statement_number': self.invoice.invoice_number,
            'payment_status': (_("Paid") if self.invoice.is_paid
                               else _("Payment Required")),
            'amount_due': fmt_dollar_amount(self.invoice.balance),
            'statements_url': absolute_reverse(
                DomainBillingStatementsView.urlname, args=[domain]),
            'invoicing_contact_email': settings.INVOICING_CONTACT_EMAIL,
            'accounts_email': settings.ACCOUNTS_EMAIL,
        }
        return context

    def email_subject(self):
        raise NotImplementedError()

    def send_email(self, contact_emails=None):
        if not self.should_send_email:
            self.skipped_email = True
            self.save()
            return

        pdf_attachment = {
            'title': self.pdf.get_filename(self.invoice),
            'file_obj': StringIO(self.pdf.get_data(self.invoice)),
            'mimetype': 'application/pdf',
        }
        domain = self.invoice.get_domain()
        subject = self.email_subject()
        context = self.email_context()
        email_from = self.email_from()

        contact_emails = contact_emails or self.invoice.email_recipients
        if self.is_email_throttled():
            self.handle_throttled_email(contact_emails)

        for email in contact_emails:
            greeting = _("Hello,")
            can_view_statement = False
            try:
                web_user = WebUser.get_by_username(email)
                if web_user is not None:
                    greeting = _("Dear %s,") % web_user.first_name
                    can_view_statement = web_user.is_domain_admin(domain)
            except ResourceNotFound:
                pass
            context['greeting'] = greeting
            context['can_view_statement'] = can_view_statement
            email_html = render_to_string(self.html_template, context)
            email_plaintext = render_to_string(self.text_template, context)
            send_html_email_async.delay(
                subject, email, email_html,
                text_content=email_plaintext,
                email_from=email_from,
                file_attachments=[pdf_attachment]
            )
        self.emailed_to = ",".join(contact_emails)
        self.save()
        logger.info(
            "[BILLING] Sent billing statements for domain %(domain)s "
            "to %(emails)s." % {
                'domain': domain,
                'emails': ', '.join(contact_emails),
            }
        )


class WireBillingRecord(BillingRecordBase):
    invoice = models.ForeignKey(WireInvoice, on_delete=models.PROTECT)

    INVOICE_HTML_TEMPLATE = 'accounting/wire_invoice_email.html'
    INVOICE_TEXT_TEMPLATE = 'accounting/wire_invoice_email_plaintext.html'

    @property
    def should_send_email(self):
        hidden = self.invoice.is_hidden
        return not hidden

    def is_email_throttled(self):
        return False

    def email_subject(self):
        month_name = self.invoice.date_start.strftime("%B")
        return "Your %(month)s Bulk Billing Statement for Project Space %(domain)s" % {
            'month': month_name,
            'domain': self.invoice.get_domain(),
        }

    def email_from(self):
        return "Dimagi Accounting <{email}>".format(email=settings.INVOICING_CONTACT_EMAIL)


class WirePrepaymentBillingRecord(WireBillingRecord):
    class Meta:
        proxy = True

    def email_subject(self):
        return _("Your prepayment invoice")


class BillingRecord(BillingRecordBase):
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT)
    INVOICE_CONTRACTED_HTML_TEMPLATE = 'accounting/invoice_email_contracted.html'
    INVOICE_CONTRACTED_TEXT_TEMPLATE = 'accounting/invoice_email_contracted_plaintext.html'

    @property
    def html_template(self):
        if self.invoice.subscription.service_type == SubscriptionType.CONTRACTED:
            return self.INVOICE_CONTRACTED_HTML_TEMPLATE
        else:
            return self.INVOICE_HTML_TEMPLATE

    @property
    def text_template(self):
        if self.invoice.subscription.service_type == SubscriptionType.CONTRACTED:
            return self.INVOICE_CONTRACTED_TEXT_TEMPLATE
        else:
            return self.INVOICE_TEXT_TEMPLATE

    @property
    def should_send_email(self):
        subscription = self.invoice.subscription
        autogenerate = (subscription.auto_generate_credits and not self.invoice.balance)
        small_contracted = (self.invoice.balance <= SMALL_INVOICE_THRESHOLD and
                            subscription.service_type == SubscriptionType.CONTRACTED)
        hidden = self.invoice.is_hidden
        return not (autogenerate or small_contracted or hidden)

    def is_email_throttled(self):
        month = self.invoice.date_start.month
        year = self.invoice.date_start.year
        date_start, date_end = get_first_last_days(year, month)
        return self.__class__.objects.filter(
            invoice__date_start__lte=date_end, invoice__date_end__gte=date_start,
            invoice__subscription__subscriber=self.invoice.subscription.subscriber
        ).count() > MAX_INVOICE_COMMUNICATIONS

    def email_context(self):
        context = super(BillingRecord, self).email_context()
        total_balance = sum(invoice.balance for invoice in Invoice.objects.filter(
            is_hidden=False,
            subscription__subscriber__domain=self.invoice.get_domain(),
        ))
        is_small_invoice = self.invoice.balance < SMALL_INVOICE_THRESHOLD
        payment_status = (_("Paid")
                          if self.invoice.is_paid or total_balance == 0
                          else _("Payment Required"))
        context.update({
            'plan_name': self.invoice.subscription.plan_version.plan.name,
            'date_due': self.invoice.date_due,
            'is_small_invoice': is_small_invoice,
            'total_balance': total_balance,
            'is_total_balance_due': total_balance >= SMALL_INVOICE_THRESHOLD,
            'payment_status': payment_status,
        })
        if self.invoice.subscription.service_type == SubscriptionType.CONTRACTED:
            from corehq.apps.accounting.dispatcher import AccountingAdminInterfaceDispatcher
            context.update({
                'salesforce_contract_id': self.invoice.subscription.salesforce_contract_id,
                'billing_account': self.invoice.subscription.account.name,
                'billing_contacts': self.invoice.contact_emails,
                'admin_invoices_url': "{url}?subscriber={domain}".format(
                    url=absolute_reverse(AccountingAdminInterfaceDispatcher.name(), args=['invoices']),
                    domain=self.invoice.get_domain()
                )
            })
        return context

    def email_subject(self):
        month_name = self.invoice.date_start.strftime("%B")
        return "Your %(month)s %(product)s Billing Statement for Project Space %(domain)s" % {
            'product': self.invoice.subscription.plan_version.core_product,
            'month': month_name,
            'domain': self.invoice.subscription.subscriber.domain,
        }

    def email_from(self):
        return get_dimagi_from_email_by_product(self.invoice.subscription.plan_version.core_product)


class InvoicePdf(SafeSaveDocument):
    invoice_id = StringProperty()
    date_created = DateTimeProperty()

    def generate_pdf(self, invoice):
        self.save()
        pdf_data = NamedTemporaryFile()
        template = InvoiceTemplate(
            pdf_data.name,
            invoice_number=invoice.invoice_number,
            to_address=get_address_from_invoice(invoice),
            project_name=invoice.get_domain(),
            invoice_date=invoice.date_created.date(),
            due_date=invoice.date_due,
            date_start=invoice.date_start,
            date_end=invoice.date_end,
            subtotal=invoice.subtotal,
            tax_rate=invoice.tax_rate,
            applied_tax=getattr(invoice, 'applied_tax', Decimal('0.000')),
            applied_credit=getattr(invoice, 'applied_credit', Decimal('0.000')),
            total=invoice.get_total(),
            is_wire=invoice.is_wire,
            is_prepayment=invoice.is_wire and invoice.is_prepayment,
        )

        if not invoice.is_wire:
            for line_item in LineItem.objects.filter(invoice=invoice):
                is_unit = line_item.unit_description is not None
                description = (line_item.base_description
                               or line_item.unit_description)
                if line_item.quantity > 0:
                    template.add_item(
                        description,
                        line_item.quantity if is_unit else 1,
                        line_item.unit_cost if is_unit else line_item.subtotal,
                        line_item.subtotal,
                        line_item.applied_credit,
                        line_item.total
                    )

        if invoice.is_wire and invoice.is_prepayment:
            unit_cost = 1
            applied_credit = 0
            for item in invoice.items:
                template.add_item(item['type'],
                                  item['amount'],
                                  unit_cost,
                                  item['amount'],
                                  applied_credit,
                                  item['amount'])

        template.get_pdf()
        filename = self.get_filename(invoice)
        # this is slow and not unit tested
        # best to just skip during unit tests for speed
        if not settings.UNIT_TESTING:
            self.put_attachment(pdf_data, filename, 'application/pdf')
        else:
            self.put_attachment('', filename, 'application/pdf')
        pdf_data.close()

        self.invoice_id = str(invoice.id)
        self.date_created = datetime.datetime.utcnow()
        self.save()

    def get_filename(self, invoice):
        return "statement_%(year)d_%(month)d.pdf" % {
            'year': invoice.date_start.year,
            'month': invoice.date_start.month,
        }

    def get_data(self, invoice):
        obj = CachedObject('%s:InvoicePdf' % self._id)
        if not obj.is_cached():
            data = self.fetch_attachment(self.get_filename(invoice), True).read()
            metadata = {'content_type': 'application/pdf'}
            buff = StringIO(data)
            obj.cache_put(buff, metadata, timeout=0)
        else:
            buff = obj.get()[1]
            data = buff.getvalue()
        return data


class LineItemManager(models.Manager):
    def get_products(self):
        return self.get_query_set().filter(feature_rate__exact=None)

    def get_features(self):
        return self.get_query_set().filter(product_rate__exact=None)

    def get_feature_by_type(self, feature_type):
        return self.get_query_set().filter(feature_rate__feature__feature_type=feature_type)


class LineItem(models.Model):
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT)
    feature_rate = models.ForeignKey(FeatureRate, on_delete=models.PROTECT, null=True)
    product_rate = models.ForeignKey(SoftwareProductRate, on_delete=models.PROTECT, null=True)
    base_description = models.TextField(blank=True, null=True)
    base_cost = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    unit_description = models.TextField(blank=True, null=True)
    unit_cost = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    quantity = models.IntegerField(default=1)
    last_modified = models.DateTimeField(auto_now=True)

    objects = LineItemManager()

    @property
    def subtotal(self):
        return self.base_cost + self.unit_cost * self.quantity

    @property
    def applied_credit(self):
        """
        The total amount of credit applied specifically to this LineItem.
        """
        if self.creditadjustment_set.count() == 0:
            return Decimal('0.0000')
        return sum([credit.amount for credit in self.creditadjustment_set.all()])

    @property
    def total(self):
        return self.subtotal + self.applied_credit

    def calculate_credit_adjustments(self):
        """
        This goes through all credit lines that:
        - specify the related feature or product rate that generated this line item
        """
        current_total = self.total
        credit_lines = CreditLine.get_credits_for_line_item(self)
        CreditLine.apply_credits_toward_balance(credit_lines, current_total, dict(line_item=self))


class CreditLine(models.Model):
    """
    The amount of money in USD that exists can can be applied toward a specific account,
    a specific subscription, or specific rates in that subscription.
    """
    account = models.ForeignKey(BillingAccount, on_delete=models.PROTECT)
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT, null=True, blank=True)
    product_type = models.CharField(max_length=25, null=True, blank=True,
                                    choices=SoftwareProductType.CHOICES)
    feature_type = models.CharField(max_length=10, null=True, blank=True,
                                    choices=FeatureType.CHOICES)
    date_created = models.DateTimeField(auto_now_add=True)
    balance = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    is_active = models.BooleanField(default=True)
    last_modified = models.DateTimeField(auto_now=True)

    def __str__(self):
        credit_level = ("Account-Level" if self.subscription is None
                        else "Subscription-Level")
        return ("%(level)s credit [Account %(account_id)d]%(feature)s"
                "%(product)s, balance %(balance)s" % {
                    'level': credit_level,
                    'account_id': self.account.id,
                    'feature': (' for Feature %s' % self.feature_type
                                if self.feature_type is not None else ""),
                    'product': (' for Product %s' % self.product_type
                                if self.product_type is not None else ""),
                    'balance': self.balance,
                })

    def adjust_credit_balance(self, amount, is_new=False, note=None,
                              line_item=None, invoice=None,
                              payment_record=None, related_credit=None,
                              reason=None, web_user=None):
        note = note or ""
        if line_item is not None and invoice is not None:
            raise CreditLineError("You may only have an invoice OR a line item making this adjustment.")
        if reason is None:
            reason = CreditAdjustmentReason.MANUAL
            if payment_record is not None:
                reason = CreditAdjustmentReason.DIRECT_PAYMENT
            elif related_credit is not None:
                reason = CreditAdjustmentReason.TRANSFER
            elif invoice is not None:
                reason = CreditAdjustmentReason.INVOICE
            elif line_item is not None:
                reason = CreditAdjustmentReason.LINE_ITEM
        if is_new:
            note = "Initialization of credit line. %s" % note
        credit_adjustment = CreditAdjustment(
            credit_line=self,
            note=note,
            amount=amount,
            reason=reason,
            payment_record=payment_record,
            line_item=line_item,
            invoice=invoice,
            related_credit=related_credit,
            web_user=web_user,
        )
        credit_adjustment.save()
        self.balance += amount
        self.save()

    @classmethod
    def get_credits_for_line_item(cls, line_item):
        return cls.get_credits_by_subscription_and_features(
            line_item.invoice.subscription,
            product_type=(line_item.product_rate.product.product_type
                          if line_item.product_rate is not None else None),
            feature_type=(line_item.feature_rate.feature.feature_type
                          if line_item.feature_rate is not None else None),
        )

    @classmethod
    def get_credits_for_invoice(cls, invoice):
        return cls.get_credits_by_subscription_and_features(invoice.subscription)

    @classmethod
    def get_credits_for_account(cls, account, feature_type=None, product_type=None):
        return cls.objects.filter(
            account=account, subscription__exact=None
        ).filter(
            product_type__exact=product_type, feature_type__exact=feature_type
        ).all()

    @classmethod
    def get_credits_by_subscription_and_features(cls, subscription,
                                                 feature_type=None,
                                                 product_type=None):
        return cls.objects.filter(
            models.Q(subscription=subscription) |
            models.Q(account=subscription.account, subscription__exact=None)
        ).filter(
            product_type__exact=product_type, feature_type__exact=feature_type
        ).all()

    @classmethod
    def add_credit(cls, amount, account=None, subscription=None,
                   product_type=None, feature_type=None, payment_record=None,
                   invoice=None, line_item=None, related_credit=None,
                   note=None, reason=None, web_user=None, permit_inactive=False):
        if account is None and subscription is None:
            raise CreditLineError(
                "You must specify either a subscription "
                "or account to add this credit to."
            )
        if feature_type is not None and product_type is not None:
            raise CreditLineError(
                "Can only add credit for a product OR a feature, but not both."
            )
        account = account or subscription.account
        try:
            credit_line = cls.objects.get(
                account__exact=account,
                subscription__exact=subscription,
                product_type__exact=product_type,
                feature_type__exact=feature_type,
            )
            if not permit_inactive and not credit_line.is_active and not invoice:
                raise CreditLineError(
                    "Could not add credit to CreditLine %s because it is "
                    "inactive." % credit_line.__str__()
                )
            is_new = False
        except cls.MultipleObjectsReturned as e:
            raise CreditLineError(
                "Could not find a unique credit line for %(account)s"
                "%(subscription)s%(feature)s%(product)s. %(error)s"
                "instead." %{
                    'account': "Account ID %d" % account.id,
                    'subscription': (" | Subscription ID %d" % subscription.id
                                     if subscription is not None else ""),
                    'feature': (" | Feature %s" % feature_type
                                if feature_type is not None else ""),
                    'product': (" | Product %s" % product_type
                                if product_type is not None else ""),
                    'error': e.message,
                }
            )
        except cls.DoesNotExist:
            credit_line = cls.objects.create(
                account=account,
                subscription=subscription,
                product_type=product_type,
                feature_type=feature_type,
            )
            is_new = True
        credit_line.adjust_credit_balance(amount, is_new=is_new, note=note,
                                          payment_record=payment_record,
                                          invoice=invoice, line_item=line_item,
                                          related_credit=related_credit,
                                          reason=reason, web_user=web_user)
        return credit_line

    @classmethod
    def apply_credits_toward_balance(cls, credit_lines, balance, adjust_balance_kwarg):
        for credit_line in credit_lines:
            if balance == Decimal('0.0000'):
                return
            if balance <= Decimal('0.0000'):
                raise CreditLineError(
                    "A balance went below zero dollars when applying credits "
                    "to credit line %d." % credit_line.pk
                )
            adjustment_amount = min(credit_line.balance, balance)
            if adjustment_amount > Decimal('0.0000'):
                credit_line.adjust_credit_balance(-adjustment_amount, **adjust_balance_kwarg)
                balance -= adjustment_amount
        return balance

    @staticmethod
    def _validate_add_amount(amount):
        if not isinstance(amount, Decimal):
            raise ValueError("Amount must be a Decimal.")


class PaymentMethod(models.Model):
    """A link to a particular payment method for an account.
    Right now the only payment methods are via Stripe, but leaving that
    open for future changes.

    :customer_id: is used by the API of the payment method we're using that
    uniquely identifies the payer on their end.
    """
    web_user = models.CharField(max_length=80, null=True, db_index=True)
    method_type = models.CharField(max_length=50,
                                   default=PaymentMethodType.STRIPE,
                                   choices=PaymentMethodType.CHOICES,
                                   db_index=True)
    customer_id = models.CharField(max_length=255, null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    last_modified = models.DateTimeField(auto_now=True)


class PaymentRecord(models.Model):
    """Records the transaction with external payment APIs.
    """
    payment_method = models.ForeignKey(PaymentMethod, on_delete=models.PROTECT,
                                       db_index=True)
    date_created = models.DateTimeField(auto_now_add=True)
    transaction_id = models.CharField(max_length=255)
    amount = models.DecimalField(default=Decimal('0.0000'),
                                 max_digits=10, decimal_places=4)
    last_modified = models.DateTimeField(auto_now=True)

    @property
    def public_transaction_id(self):
        ops_num = settings.INVOICE_STARTING_NUMBER + self.id
        return "%sP-%d" % (settings.INVOICE_PREFIX, ops_num)

    @classmethod
    def create_record(cls, payment_method, transaction_id, amount):
        return cls.objects.create(
            payment_method=payment_method,
            transaction_id=transaction_id,
            amount=amount,
        )


class CreditAdjustment(models.Model):
    """
    A record of any additions (positive amounts) or deductions (negative amounts) that contributed to the
    current balance of the associated CreditLine.
    """
    credit_line = models.ForeignKey(CreditLine, on_delete=models.PROTECT)
    reason = models.CharField(max_length=25, default=CreditAdjustmentReason.MANUAL,
                              choices=CreditAdjustmentReason.CHOICES)
    note = models.TextField()
    amount = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    line_item = models.ForeignKey(LineItem, on_delete=models.PROTECT, null=True)
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True)
    payment_record = models.ForeignKey(PaymentRecord,
                                       on_delete=models.PROTECT, null=True)
    related_credit = models.ForeignKey(CreditLine, on_delete=models.PROTECT,
                                       null=True, related_name='creditadjustment_related')
    date_created = models.DateTimeField(auto_now_add=True)
    web_user = models.CharField(max_length=80, null=True)
    last_modified = models.DateTimeField(auto_now=True)

    def clean(self):
        """
        Only one of either a line item or invoice may be specified as the adjuster.
        """
        if self.line_item and self.invoice is not None:
            raise ValidationError(_("You can't specify both an invoice and a line item."))
