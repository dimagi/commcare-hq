import datetime
import itertools
from decimal import Decimal
from io import BytesIO
from tempfile import NamedTemporaryFile

from django.conf import settings
from django.contrib.postgres.fields import ArrayField
from django.core.exceptions import ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models, transaction
from django.db.models import F, Q
from django.db.models.manager import Manager
from django.template.loader import render_to_string
from django.utils.html import strip_tags
from django.utils.translation import ugettext_lazy as _

import jsonfield
import stripe
from django_prbac.models import Role
from memoized import memoized

from corehq.apps.domain.shortcuts import publish_domain_saved
from dimagi.ext.couchdbkit import (
    BooleanProperty,
    DateTimeProperty,
    SafeSaveDocument,
    StringProperty,
)
from dimagi.utils.web import get_site_domain

from corehq.apps.accounting.emails import send_subscription_change_alert
from corehq.apps.accounting.exceptions import (
    AccountingError,
    CreditLineError,
    InvoiceEmailThrottledError,
    NewSubscriptionError,
    ProductPlanNotFoundError,
    SubscriptionAdjustmentError,
    SubscriptionChangeError,
    SubscriptionReminderError,
    SubscriptionRenewalError,
)
from corehq.apps.accounting.invoice_pdf import InvoiceTemplate
from corehq.apps.accounting.signals import subscription_upgrade_or_downgrade
from corehq.apps.accounting.subscription_changes import (
    DomainDowngradeActionHandler,
    DomainUpgradeActionHandler,
)
from corehq.apps.accounting.utils import (
    EXCHANGE_RATE_DECIMAL_PLACES,
    ensure_domain_instance,
    fmt_dollar_amount,
    get_account_name_from_default_name,
    get_address_from_invoice,
    get_change_status,
    get_dimagi_from_email,
    get_privileges,
    is_active_subscription,
    log_accounting_error,
    log_accounting_info,
    quantize_accounting_decimal,
)
from corehq.apps.domain import UNKNOWN_DOMAIN
from corehq.apps.domain.models import Domain
from corehq.apps.hqwebapp.tasks import send_html_email_async
from corehq.apps.users.models import WebUser
from corehq.blobs.mixin import CODES, BlobMixin
from corehq.const import USER_DATE_FORMAT
from corehq.privileges import REPORT_BUILDER_ADD_ON_PRIVS
from corehq.util.dates import get_first_last_days
from corehq.util.mixin import ValidateModelMixin
from corehq.util.quickcache import quickcache
from corehq.util.soft_assert import soft_assert
from corehq.util.view_utils import absolute_reverse

integer_field_validators = [MaxValueValidator(2147483647), MinValueValidator(-2147483648)]

MAX_INVOICE_COMMUNICATIONS = 5
SMALL_INVOICE_THRESHOLD = 100

UNLIMITED_FEATURE_USAGE = -1

MINIMUM_SUBSCRIPTION_LENGTH = 30

_soft_assert_contact_emails_missing = soft_assert(
    to=['{}@{}'.format(email, 'dimagi.com') for email in [
        'accounts',
        'billing-dev',
    ]],
    exponential_backoff=False,
)


class BillingAccountType(object):
    CONTRACT = "CONTRACT"
    USER_CREATED = "USER_CREATED"
    GLOBAL_SERVICES = "GLOBAL_SERVICES"
    INVOICE_GENERATED = "INVOICE_GENERATED"
    TRIAL = "TRIAL"
    CHOICES = (
        (CONTRACT, "Created by contract"),
        (USER_CREATED, "Created by user"),
        (GLOBAL_SERVICES, "Created by Global Services"),
        (INVOICE_GENERATED, "Generated by an invoice"),
        (TRIAL, "Is trial account"),
    )


class InvoicingPlan(object):
    MONTHLY = "MONTHLY"
    QUARTERLY = "QUARTERLY"
    YEARLY = "YEARLY"
    CHOICES = (
        (MONTHLY, "Monthly"),
        (QUARTERLY, "Quarterly"),
        (YEARLY, "Yearly")
    )


class FeatureType(object):
    USER = "User"
    SMS = "SMS"

    CHOICES = (
        (USER, USER),
        (SMS, SMS),
    )


class SoftwarePlanEdition(object):
    COMMUNITY = "Community"
    STANDARD = "Standard"
    PRO = "Pro"
    ADVANCED = "Advanced"
    ENTERPRISE = "Enterprise"
    RESELLER = "Reseller"
    MANAGED_HOSTING = "Managed Hosting"
    PAUSED = "Paused"
    CHOICES = (
        (COMMUNITY, COMMUNITY),
        (STANDARD, STANDARD),
        (PRO, PRO),
        (ADVANCED, ADVANCED),
        (ENTERPRISE, ENTERPRISE),
        (PAUSED, PAUSED),
        (RESELLER, RESELLER),
        (MANAGED_HOSTING, MANAGED_HOSTING),
    )
    SELF_SERVICE_ORDER = [
        PAUSED,
        COMMUNITY,
        STANDARD,
        PRO,
        ADVANCED,
    ]


class SoftwarePlanVisibility(object):
    PUBLIC = "PUBLIC"
    INTERNAL = "INTERNAL"
    TRIAL = "TRIAL"
    CHOICES = (
        (PUBLIC, "Anyone can subscribe"),
        (INTERNAL, "Dimagi must create subscription"),
        (TRIAL, "This is a Trial Plan"),
    )


class CreditAdjustmentReason(object):
    DIRECT_PAYMENT = "DIRECT_PAYMENT"
    SALESFORCE = "SALESFORCE"
    INVOICE = "INVOICE"
    LINE_ITEM = "LINE_ITEM"
    TRANSFER = "TRANSFER"
    MANUAL = "MANUAL"
    FRIENDLY_WRITE_OFF = "FRIENDLY_WRITE_OFF"
    CHOICES = (
        (MANUAL, "Manual"),
        (FRIENDLY_WRITE_OFF, "Friendly Write-Off"),
        (SALESFORCE, "via Salesforce"),
        (INVOICE, "Invoice-generated"),
        (LINE_ITEM, "Line Item generated"),
        (TRANSFER, "Transfer from another credit line"),
        (DIRECT_PAYMENT, "Payment from client received"),
    )


class SubscriptionAdjustmentReason(object):
    CREATE = "CREATE"
    MODIFY = "MODIFY"
    CANCEL = "CANCEL"
    UPGRADE = "UPGRADE"
    DOWNGRADE = "DOWNGRADE"
    SWITCH = "SWITCH"
    REACTIVATE = "REACTIVATE"
    RENEW = "RENEW"
    CHOICES = (
        (CREATE, "A new subscription created from scratch."),
        (MODIFY, "Some part of the subscription was modified...likely a date."),
        (CANCEL, "The subscription was cancelled with no followup subscription."),
        (UPGRADE, "The subscription was upgraded to the related subscription."),
        (DOWNGRADE, "The subscription was downgraded to the related subscription."),
        (SWITCH, "The plan was changed to the related subscription and "
                 "was neither an upgrade or downgrade."),
        (REACTIVATE, "The subscription was reactivated."),
        (RENEW, "The subscription was renewed."),
    )


class SubscriptionAdjustmentMethod(object):
    USER = "USER"
    INTERNAL = "INTERNAL"
    TASK = "TASK"
    TRIAL = "TRIAL"
    AUTOMATIC_DOWNGRADE = 'AUTOMATIC_DOWNGRADE'
    DEFAULT_COMMUNITY = 'DEFAULT_COMMUNITY'
    INVOICING = 'INVOICING'
    CHOICES = (
        (USER, "User"),
        (INTERNAL, "Ops"),
        (TASK, "[Deprecated] Task (Invoicing)"),
        (TRIAL, "30 Day Trial"),
        (AUTOMATIC_DOWNGRADE, "Automatic Downgrade"),
        (DEFAULT_COMMUNITY, 'Default to Community'),
        (INVOICING, 'Invoicing')
    )


class PaymentMethodType(object):
    STRIPE = "Stripe"
    CHOICES = (
        (STRIPE, STRIPE),
    )


class SubscriptionType(object):
    IMPLEMENTATION = "IMPLEMENTATION"
    PRODUCT = "PRODUCT"
    TRIAL = "TRIAL"
    EXTENDED_TRIAL = "EXTENDED_TRIAL"
    SANDBOX = "SANDBOX"
    INTERNAL = "INTERNAL"
    NOT_SET = "NOT_SET"
    CHOICES = (
        (IMPLEMENTATION, "Implementation"),
        (PRODUCT, "Product"),
        (TRIAL, "Trial"),
        (EXTENDED_TRIAL, "Extended Trial"),
        (SANDBOX, "Sandbox"),
        (INTERNAL, "Internal"),
    )


class ProBonoStatus(object):
    YES = "PRO_BONO"
    NO = "FULL_PRICE"
    DISCOUNTED = "DISCOUNTED"
    CHOICES = (
        (NO, "Full Price"),
        (DISCOUNTED, "Discounted"),
        (YES, "Pro Bono"),
    )


class FundingSource(object):
    DIMAGI = "DIMAGI"
    CLIENT = "CLIENT"
    EXTERNAL = "EXTERNAL"
    CHOICES = (
        (DIMAGI, "Dimagi"),
        (CLIENT, "Client Funding"),
        (EXTERNAL, "External Funding"),
    )


class EntryPoint(object):
    CONTRACTED = "CONTRACTED"
    SELF_STARTED = "SELF_STARTED"
    NOT_SET = "NOT_SET"
    CHOICES = (
        (CONTRACTED, "Contracted"),
        (SELF_STARTED, "Self-started"),
        (NOT_SET, "Not Set"),
    )


class LastPayment(object):
    CC_ONE_TIME = "CC_ONE_TIME"
    CC_AUTO = "CC_AUTO"
    WIRE = "WIRE"
    ACH = "ACH"
    OTHER = "OTHER"
    BU_PAYMENT = "BU_PAYMENT"
    NONE = "NONE"
    CHOICES = (
        (CC_ONE_TIME, "Credit Card - One Time"),
        (CC_AUTO, "Credit Card - Autopay"),
        (WIRE, "Wire"),
        (ACH, "ACH"),
        (OTHER, "Other"),
        (BU_PAYMENT, "Payment to local BU"),
        (NONE, "None"),
    )


class PreOrPostPay(object):
    PREPAY = "PREPAY"
    POSTPAY = "POSTPAY"
    NOT_SET = "NOT_SET"
    CHOICES = (
        (PREPAY, "Prepay"),
        (POSTPAY, "Postpay"),
        (NOT_SET, "Not Set"),
    )


class CommunicationType(object):
    OTHER = "OTHER"
    OVERDUE_INVOICE = "OVERDUE_INVOICE"
    DOWNGRADE_WARNING = "DOWNGRADE_WARNING"
    CHOICES = (
        (OTHER, "other"),
        (OVERDUE_INVOICE, "Overdue Invoice"),
        (DOWNGRADE_WARNING, "Subscription Pause Warning"),
    )


class Currency(models.Model):
    """
    Keeps track of the current conversion rates so that we don't have to poll the free, but rate limited API
    from Open Exchange Rates. Necessary for billing things like MACH SMS.
    """
    code = models.CharField(max_length=3, unique=True)
    name = models.CharField(max_length=25, db_index=True)
    symbol = models.CharField(max_length=10)
    rate_to_default = models.DecimalField(
        default=Decimal('1.0'), max_digits=20,
        decimal_places=EXCHANGE_RATE_DECIMAL_PLACES,
    )
    date_updated = models.DateField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    @classmethod
    def get_default(cls):
        default, _ = cls.objects.get_or_create(code=settings.DEFAULT_CURRENCY)
        return default


DEFAULT_ACCOUNT_FORMAT = 'Account for Project %s'


class BillingAccount(ValidateModelMixin, models.Model):
    """
    The key model that links a Subscription to its financial source and methods of payment.
    """
    name = models.CharField(max_length=200, db_index=True, unique=True)
    salesforce_account_id = models.CharField(
        db_index=True,
        max_length=80,
        blank=True,
        null=True,
        help_text="This is how we link to the salesforce account",
    )
    created_by = models.CharField(max_length=80, blank=True)
    created_by_domain = models.CharField(max_length=256, null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    dimagi_contact = models.EmailField(blank=True)
    currency = models.ForeignKey(Currency, on_delete=models.PROTECT)
    is_auto_invoiceable = models.BooleanField(default=False)
    date_confirmed_extra_charges = models.DateTimeField(null=True, blank=True)
    account_type = models.CharField(
        max_length=25,
        default=BillingAccountType.CONTRACT,
        choices=BillingAccountType.CHOICES,
    )
    is_active = models.BooleanField(default=True)
    is_customer_billing_account = models.BooleanField(default=False, db_index=True)
    enterprise_admin_emails = ArrayField(models.EmailField(), default=list, blank=True)
    enterprise_restricted_signup_domains = ArrayField(models.CharField(max_length=128), default=list, blank=True)
    invoicing_plan = models.CharField(
        max_length=25,
        default=InvoicingPlan.MONTHLY,
        choices=InvoicingPlan.CHOICES
    )
    entry_point = models.CharField(
        max_length=25,
        default=EntryPoint.NOT_SET,
        choices=EntryPoint.CHOICES,
    )
    auto_pay_user = models.CharField(max_length=80, null=True, blank=True)
    last_modified = models.DateTimeField(auto_now=True)
    last_payment_method = models.CharField(
        max_length=25,
        default=LastPayment.NONE,
        choices=LastPayment.CHOICES,
    )
    pre_or_post_pay = models.CharField(
        max_length=25,
        default=PreOrPostPay.NOT_SET,
        choices=PreOrPostPay.CHOICES,
    )

    # Settings visible to external users
    restrict_domain_creation = models.BooleanField(default=False)
    restrict_signup = models.BooleanField(default=False, db_index=True)
    restrict_signup_message = models.CharField(max_length=512, null=True, blank=True)

    class Meta(object):
        app_label = 'accounting'

    @property
    def auto_pay_enabled(self):
        return self.auto_pay_user is not None

    @classmethod
    def create_account_for_domain(cls, domain,
                                  created_by=None, account_type=None,
                                  entry_point=None, last_payment_method=None,
                                  pre_or_post_pay=None):
        account_type = account_type or BillingAccountType.INVOICE_GENERATED
        entry_point = entry_point or EntryPoint.NOT_SET
        last_payment_method = last_payment_method or LastPayment.NONE
        pre_or_post_pay = pre_or_post_pay or PreOrPostPay.POSTPAY
        default_name = DEFAULT_ACCOUNT_FORMAT % domain
        name = get_account_name_from_default_name(default_name)
        return BillingAccount.objects.create(
            name=name,
            created_by=created_by,
            created_by_domain=domain,
            currency=Currency.get_default(),
            account_type=account_type,
            entry_point=entry_point,
            last_payment_method=last_payment_method,
            pre_or_post_pay=pre_or_post_pay
        )

    @classmethod
    def get_or_create_account_by_domain(cls, domain,
                                        created_by=None, account_type=None,
                                        entry_point=None, last_payment_method=None,
                                        pre_or_post_pay=None):
        """
        First try to grab the account used for the last subscription.
        If an account is not found, create it.
        """
        account = cls.get_account_by_domain(domain)
        if account:
            return account, False
        return cls.create_account_for_domain(
            domain,
            created_by=created_by,
            account_type=account_type,
            entry_point=entry_point,
            last_payment_method=last_payment_method,
            pre_or_post_pay=pre_or_post_pay,
        ), True

    @classmethod
    def get_account_by_domain(cls, domain):
        current_subscription = Subscription.get_active_subscription_by_domain(domain)
        if current_subscription is not None:
            return current_subscription.account
        else:
            return cls._get_account_by_created_by_domain(domain)

    @classmethod
    def _get_account_by_created_by_domain(cls, domain):
        try:
            return cls.objects.get(created_by_domain=domain)
        except cls.DoesNotExist:
            return None
        except cls.MultipleObjectsReturned:
            log_accounting_error(
                f"Multiple billing accounts showed up for the domain '{domain}'. The "
                "latest one was served, but you should reconcile very soon.",
                show_stack_trace=True,
            )
            return cls.objects.filter(created_by_domain=domain).latest('date_created')
        return None

    @classmethod
    @quickcache([], timeout=60 * 60)
    def get_enterprise_restricted_signup_accounts(cls):
        return BillingAccount.objects.filter(is_customer_billing_account=True, restrict_signup=True)

    @property
    def autopay_card(self):
        if not self.auto_pay_enabled:
            return None

        return StripePaymentMethod.objects.get(web_user=self.auto_pay_user).get_autopay_card(self)

    def has_enterprise_admin(self, email):
        return self.is_customer_billing_account and email in self.enterprise_admin_emails

    def update_autopay_user(self, new_user, domain):
        if self.auto_pay_enabled and new_user != self.auto_pay_user:
            self._send_autopay_card_removed_email(new_user=new_user, domain=domain)

        self.auto_pay_user = new_user
        self.save()
        self._send_autopay_card_added_email(domain)

    def remove_autopay_user(self):
        self.auto_pay_user = None
        self.save()

    def _send_autopay_card_removed_email(self, new_user, domain):
        """Sends an email to the old autopayer for this account telling them {new_user} is now the autopayer"""
        from corehq.apps.domain.views.accounting import EditExistingBillingAccountView
        old_user = self.auto_pay_user
        subject = _("Your card is no longer being used to auto-pay for {billing_account}").format(
            billing_account=self.name)
        old_web_user = WebUser.get_by_username(old_user)
        if old_web_user:
            old_user_name = old_web_user.first_name
        else:
            old_user_name = old_user

        context = {
            'new_user': new_user,
            'old_user_name': old_user_name,
            'billing_account_name': self.name,
            'billing_info_url': absolute_reverse(EditExistingBillingAccountView.urlname,
                                                 args=[domain]),
            'invoicing_contact_email': settings.INVOICING_CONTACT_EMAIL,
        }

        send_html_email_async(
            subject,
            old_user,
            render_to_string('accounting/email/autopay_card_removed.html', context),
            text_content=strip_tags(render_to_string('accounting/email/autopay_card_removed.html', context)),
        )

    def _send_autopay_card_added_email(self, domain):
        """Sends an email to the new autopayer for this account telling them they are now the autopayer"""
        from corehq.apps.domain.views.accounting import EditExistingBillingAccountView
        subject = _("Your card is being used to auto-pay for {billing_account}").format(
            billing_account=self.name)
        web_user = WebUser.get_by_username(self.auto_pay_user)
        new_user_name = web_user.first_name if web_user else self.auto_pay_user
        try:
            last_4 = self.autopay_card.last4
        except StripePaymentMethod.DoesNotExist:
            last_4 = None

        context = {
            'name': new_user_name,
            'email': self.auto_pay_user,
            'domain': domain,
            'last_4': last_4,
            'billing_account_name': self.name,
            'billing_info_url': absolute_reverse(EditExistingBillingAccountView.urlname,
                                                 args=[domain]),
            'invoicing_contact_email': settings.INVOICING_CONTACT_EMAIL,
        }

        send_html_email_async(
            subject,
            self.auto_pay_user,
            render_to_string('accounting/email/invoice_autopay_setup.html', context),
            text_content=strip_tags(render_to_string('accounting/email/invoice_autopay_setup.html', context)),
        )


class BillingContactInfo(models.Model):
    account = models.OneToOneField(BillingAccount, primary_key=True, null=False, on_delete=models.CASCADE)
    first_name = models.CharField(
        max_length=50, null=True, blank=True, verbose_name=_("First Name")
    )
    last_name = models.CharField(
        max_length=50, null=True, blank=True, verbose_name=_("Last Name")
    )
    # TODO - replace with models.ArrayField once django >= 1.9
    email_list = jsonfield.JSONField(
        default=list,
        verbose_name=_("Contact Emails"),
        help_text=_("We will email communications regarding your account "
                    "to the emails specified here.")
    )
    phone_number = models.CharField(
        max_length=20, null=True, blank=True, verbose_name=_("Phone Number")
    )
    company_name = models.CharField(
        max_length=50, null=True, blank=True,
        verbose_name=_("Company / Organization")
    )
    first_line = models.CharField(
        max_length=50, null=False,
        verbose_name=_("Address First Line")
    )
    second_line = models.CharField(
        max_length=50, null=True, blank=True,
        verbose_name=_("Address Second Line")
    )
    city = models.CharField(
        max_length=50, null=False, verbose_name=_("City")
    )
    state_province_region = models.CharField(
        max_length=50, null=False,
        verbose_name=_("State / Province / Region"),
    )
    postal_code = models.CharField(
        max_length=20, null=False, verbose_name=_("Postal Code")
    )
    country = models.CharField(
        max_length=50, null=False, verbose_name=_("Country")
    )
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    def __init__(self, *args, **kwargs):
        super(BillingContactInfo, self).__init__(*args, **kwargs)
        if self.email_list == '[]':
            self.email_list = []

    @property
    def full_name(self):
        if not self.first_name:
            return self.last_name
        elif not self.last_name:
            return self.first_name
        else:
            return "%s %s" % (self.first_name, self.last_name)


class SoftwareProductRate(models.Model):
    """
    Represents the monthly fixed fee for a software product.
    Once created, SoftwareProductRates cannot be modified. Instead, a new SoftwareProductRate must be created.
    """
    name = models.CharField(max_length=40)
    monthly_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    def __str__(self):
        return '%s @ $%s /month' % (self.name, self.monthly_fee)

    def __eq__(self, other):
        if not isinstance(other, self.__class__) or not self.name == other.name:
            return False
        for field in ['monthly_fee', 'is_active']:
            if not getattr(self, field) == getattr(other, field):
                return False
        return True

    @classmethod
    def new_rate(cls, product_name, monthly_fee, save=True):
        rate = SoftwareProductRate(name=product_name, monthly_fee=monthly_fee)
        if save:
            rate.save()
        return rate


class Feature(models.Model):
    """
    This is what will link a feature type (USER, API, etc.) to a name (Users Pro, API Standard, etc.)
    and will be what the FeatureRate references to provide a monthly fee, limit and per-excess fee.
    """
    name = models.CharField(max_length=40, unique=True)
    feature_type = models.CharField(max_length=10, db_index=True, choices=FeatureType.CHOICES)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    def __str__(self):
        return "Feature '%s' of type '%s'" % (self.name, self.feature_type)

    def get_rate(self, default_instance=True):
        try:
            return self.featurerate_set.filter(is_active=True).latest('date_created')
        except FeatureRate.DoesNotExist:
            return FeatureRate() if default_instance else None  # the defaults


class FeatureRate(models.Model):
    """
    Links a feature to a monthly fee, monthly limit, and a per-excess fee for exceeding the monthly limit.
    Once created, Feature Rates cannot be modified. Instead, a new Feature Rate must be created.
    """
    feature = models.ForeignKey(Feature, on_delete=models.PROTECT)
    monthly_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2,
                                      verbose_name="Monthly Fee")
    monthly_limit = models.IntegerField(default=0,
                                        verbose_name="Monthly Included Limit",
                                        validators=integer_field_validators)
    per_excess_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2,
                                         verbose_name="Fee Per Excess of Limit")
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    def __str__(self):
        return '%s @ $%s /month, $%s /excess, limit: %d' % (
            self.feature.name, self.monthly_fee, self.per_excess_fee, self.monthly_limit
        )

    def __eq__(self, other):
        if not isinstance(other, self.__class__) or not self.feature.pk == other.feature.pk:
            return False
        for field in ['monthly_fee', 'monthly_limit', 'per_excess_fee', 'is_active']:
            if not getattr(self, field) == getattr(other, field):
                return False
        return True

    @classmethod
    def new_rate(cls, feature_name, feature_type,
                 monthly_fee=None, monthly_limit=None, per_excess_fee=None, save=True):
        feature, _ = Feature.objects.get_or_create(name=feature_name, feature_type=feature_type)
        rate = FeatureRate(feature=feature)

        if monthly_fee is not None:
            rate.monthly_fee = monthly_fee
        if monthly_limit is not None:
            rate.monthly_limit = monthly_limit
        if per_excess_fee is not None:
            rate.per_excess_fee = per_excess_fee

        if save:
            rate.save()
        return rate


class SoftwarePlan(models.Model):
    """
    Subscriptions are created for Software Plans. Software Plans can have many Software Plan Versions, which
    link the Software Plan to a set of permissions roles.
    """
    name = models.CharField(max_length=80, unique=True)
    description = models.TextField(blank=True,
                                   help_text="If the visibility is INTERNAL, this description field will be used.")
    edition = models.CharField(
        max_length=25,
        default=SoftwarePlanEdition.ENTERPRISE,
        choices=SoftwarePlanEdition.CHOICES,
    )
    visibility = models.CharField(
        max_length=10,
        default=SoftwarePlanVisibility.INTERNAL,
        choices=SoftwarePlanVisibility.CHOICES,
    )
    last_modified = models.DateTimeField(auto_now=True)
    is_customer_software_plan = models.BooleanField(default=False)
    max_domains = models.IntegerField(blank=True, null=True)
    is_annual_plan = models.BooleanField(default=False)

    class Meta(object):
        app_label = 'accounting'

    @quickcache(vary_on=['self.pk'], timeout=10)
    def get_version(self):
        try:
            return self.softwareplanversion_set.filter(is_active=True).latest('date_created')
        except SoftwarePlanVersion.DoesNotExist:
            return None

    def at_max_domains(self):
        if not self.max_domains:
            return False

        subscription_count = 0
        for version in self.softwareplanversion_set.all():
            subscription_count += Subscription.visible_objects.filter(plan_version=version, is_active=True).count()
        return subscription_count >= self.max_domains


class DefaultProductPlan(models.Model):
    """
    This links a product type to its default SoftwarePlan (i.e. the Community Plan).
    The latest SoftwarePlanVersion that's linked to this plan will be the one used to create a new subscription if
    nothing is found for that domain.
    """
    edition = models.CharField(
        default=SoftwarePlanEdition.COMMUNITY,
        choices=SoftwarePlanEdition.CHOICES,
        max_length=25,
    )
    plan = models.ForeignKey(SoftwarePlan, on_delete=models.PROTECT)
    is_trial = models.BooleanField(default=False)
    is_report_builder_enabled = models.BooleanField(default=False)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'
        unique_together = ('edition', 'is_trial', 'is_report_builder_enabled')

    @classmethod
    @quickcache(['edition', 'is_trial', 'is_report_builder_enabled'],
                skip_arg=lambda *args, **kwargs: not settings.ENTERPRISE_MODE or settings.UNIT_TESTING)
    def get_default_plan_version(cls, edition=None, is_trial=False,
                                 is_report_builder_enabled=False):
        if not edition:
            edition = (SoftwarePlanEdition.ENTERPRISE if settings.ENTERPRISE_MODE
                       else SoftwarePlanEdition.COMMUNITY)
        try:
            default_product_plan = DefaultProductPlan.objects.select_related('plan').get(
                edition=edition, is_trial=is_trial,
                is_report_builder_enabled=is_report_builder_enabled
            )
            return default_product_plan.plan.get_version()
        except DefaultProductPlan.DoesNotExist:
            raise AccountingError(
                "No default product plan was set up, did you forget to run migrations?"
            )

    @classmethod
    def get_lowest_edition(cls, requested_privileges, return_plan=False):
        for edition in SoftwarePlanEdition.SELF_SERVICE_ORDER:
            plan_version = cls.get_default_plan_version(edition)
            privileges = get_privileges(plan_version) - REPORT_BUILDER_ADD_ON_PRIVS
            if privileges.issuperset(requested_privileges):
                return (plan_version if return_plan
                        else plan_version.plan.edition)
        return None if return_plan else SoftwarePlanEdition.ENTERPRISE


class SoftwarePlanVersion(models.Model):
    """
    Links a plan to its rates and provides versioning information.
    Once a new SoftwarePlanVersion is created, it cannot be modified. Instead, a new SoftwarePlanVersion
    must be created.
    """
    plan = models.ForeignKey(SoftwarePlan, on_delete=models.PROTECT)
    product_rate = models.ForeignKey(SoftwareProductRate, on_delete=models.CASCADE)
    feature_rates = models.ManyToManyField(FeatureRate, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    role = models.ForeignKey(Role, on_delete=models.CASCADE)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    def __str__(self):
        return "%(plan_name)s (v%(version_num)d)" % {
            'plan_name': self.plan.name,
            'version_num': self.version,
        }

    def save(self, *args, **kwargs):
        super(SoftwarePlanVersion, self).save(*args, **kwargs)
        SoftwarePlan.get_version.clear(self.plan)

    @property
    def version(self):
        return (self.plan.softwareplanversion_set.count() -
                self.plan.softwareplanversion_set.filter(
                    date_created__gt=self.date_created).count())

    @property
    def user_facing_description(self):
        from corehq.apps.accounting.user_text import DESC_BY_EDITION, FEATURE_TYPE_TO_NAME

        def _default_description(plan, monthly_limit):
            if plan.edition in [
                SoftwarePlanEdition.COMMUNITY,
                SoftwarePlanEdition.STANDARD,
                SoftwarePlanEdition.PRO,
                SoftwarePlanEdition.ADVANCED,
            ]:
                return DESC_BY_EDITION[plan.edition]['description'].format(monthly_limit)
            else:
                return DESC_BY_EDITION[plan.edition]['description']

        desc = {
            'name': self.plan.name,
        }
        if (
            self.plan.visibility == SoftwarePlanVisibility.PUBLIC
            or self.plan.visibility == SoftwarePlanVisibility.TRIAL
        ) or not self.plan.description:
            desc['description'] = _default_description(self.plan, self.user_feature.monthly_limit)
        else:
            desc['description'] = self.plan.description

        desc.update({
            'monthly_fee': 'USD %s' % self.product_rate.monthly_fee,
            'rates': [{'name': FEATURE_TYPE_TO_NAME[r.feature.feature_type],
                       'included': 'Infinite' if r.monthly_limit == UNLIMITED_FEATURE_USAGE else r.monthly_limit}
                      for r in self.feature_rates.all()],
            'edition': self.plan.edition,
        })
        return desc

    @property
    @memoized
    def user_feature(self):
        user_features = self.feature_rates.filter(feature__feature_type=FeatureType.USER)
        try:
            user_feature = user_features.order_by('monthly_limit')[0]
            if not user_feature.monthly_limit == UNLIMITED_FEATURE_USAGE:
                user_feature = user_features.order_by('-monthly_limit')[0]
            return user_feature
        except IndexError:
            pass

    @property
    def user_limit(self):
        if self.user_feature is not None:
            return self.user_feature.monthly_limit
        return UNLIMITED_FEATURE_USAGE

    @property
    def user_fee(self):
        if self.user_feature is not None:
            return "USD %d" % self.user_feature.per_excess_fee

    def feature_charges_exist_for_domain(self, domain, start_date=None, end_date=None):
        domain_obj = ensure_domain_instance(domain)
        if domain_obj is None:
            return False
        from corehq.apps.accounting.usage import FeatureUsageCalculator
        for feature_rate in self.feature_rates.all():
            if feature_rate.monthly_limit != UNLIMITED_FEATURE_USAGE:
                calc = FeatureUsageCalculator(
                    feature_rate, domain_obj.name, start_date=start_date,
                    end_date=end_date
                )
                if calc.get_usage() > feature_rate.monthly_limit:
                    return True
        return False

    @property
    def is_paused(self):
        return self.plan.edition == SoftwarePlanEdition.PAUSED


class SubscriberManager(models.Manager):

    def safe_get(self, *args, **kwargs):
        try:
            return self.get(*args, **kwargs)
        except Subscriber.DoesNotExist:
            return None


class Subscriber(models.Model):
    """
    The objects that can be subscribed to a Subscription.
    """
    domain = models.CharField(max_length=256, unique=True, db_index=True)
    last_modified = models.DateTimeField(auto_now=True)

    objects = SubscriberManager()

    class Meta(object):
        app_label = 'accounting'

    def __str__(self):
        return "DOMAIN %s" % self.domain

    def create_subscription(self, new_plan_version, new_subscription, is_internal_change):
        assert new_plan_version
        assert new_subscription
        return self._apply_upgrades_and_downgrades(
            new_plan_version=new_plan_version,
            new_subscription=new_subscription,
            internal_change=is_internal_change,
        )

    def change_subscription(self, downgraded_privileges, upgraded_privileges, new_plan_version,
                            old_subscription, new_subscription, internal_change):
        return self._apply_upgrades_and_downgrades(
            downgraded_privileges=downgraded_privileges,
            upgraded_privileges=upgraded_privileges,
            new_plan_version=new_plan_version,
            old_subscription=old_subscription,
            new_subscription=new_subscription,
            internal_change=internal_change,
        )

    def activate_subscription(self, upgraded_privileges, subscription):
        return self._apply_upgrades_and_downgrades(
            upgraded_privileges=upgraded_privileges,
            new_subscription=subscription,
        )

    def deactivate_subscription(self, downgraded_privileges, upgraded_privileges,
                                old_subscription, new_subscription):
        return self._apply_upgrades_and_downgrades(
            downgraded_privileges=downgraded_privileges,
            upgraded_privileges=upgraded_privileges,
            old_subscription=old_subscription,
            new_subscription=new_subscription,
        )

    def reactivate_subscription(self, new_plan_version, subscription):
        return self._apply_upgrades_and_downgrades(
            new_plan_version=new_plan_version,
            old_subscription=subscription,
            new_subscription=subscription,
        )

    def _apply_upgrades_and_downgrades(self, new_plan_version=None,
                                       downgraded_privileges=None,
                                       upgraded_privileges=None,
                                       old_subscription=None,
                                       new_subscription=None,
                                       internal_change=False):
        """
        downgraded_privileges is the list of privileges that should be removed
        upgraded_privileges is the list of privileges that should be added
        """
        if new_plan_version is None:
            new_plan_version = DefaultProductPlan.get_default_plan_version()

        if downgraded_privileges is None or upgraded_privileges is None:
            change_status_result = get_change_status(None, new_plan_version)
            downgraded_privileges = downgraded_privileges or change_status_result.downgraded_privs
            upgraded_privileges = upgraded_privileges or change_status_result.upgraded_privs

        if downgraded_privileges:
            Subscriber._process_downgrade(self.domain, downgraded_privileges, new_plan_version)

        if upgraded_privileges:
            Subscriber._process_upgrade(self.domain, upgraded_privileges, new_plan_version)

        if Subscriber.should_send_subscription_notification(old_subscription, new_subscription):
            send_subscription_change_alert(self.domain, new_subscription, old_subscription, internal_change)

        subscription_upgrade_or_downgrade.send_robust(None, domain=self.domain)

    @staticmethod
    def should_send_subscription_notification(old_subscription, new_subscription):
        if not old_subscription:
            return False
        is_new_trial = new_subscription and new_subscription.is_trial
        expired_trial = old_subscription.is_trial and not new_subscription
        return not is_new_trial and not expired_trial

    @staticmethod
    def _process_downgrade(domain, downgraded_privileges, new_plan_version):
        downgrade_handler = DomainDowngradeActionHandler(
            domain, new_plan_version, downgraded_privileges,
        )
        if not downgrade_handler.get_response():
            raise SubscriptionChangeError("The downgrade was not successful.")

    @staticmethod
    def _process_upgrade(domain, upgraded_privileges, new_plan_version):
        upgrade_handler = DomainUpgradeActionHandler(
            domain, new_plan_version, upgraded_privileges,
        )
        if not upgrade_handler.get_response():
            raise SubscriptionChangeError("The upgrade was not successful.")


class VisibleSubscriptionManager(models.Manager):
    use_in_migrations = True

    def get_queryset(self):
        return super(VisibleSubscriptionManager, self).get_queryset().filter(is_hidden_to_ops=False)


class DisabledManager(models.Manager):

    def get_queryset(self):
        raise NotImplementedError


class Subscription(models.Model):
    """
    Links a Subscriber to a SoftwarePlan and BillingAccount, necessary for invoicing.
    """
    account = models.ForeignKey(BillingAccount, on_delete=models.PROTECT)
    plan_version = models.ForeignKey(SoftwarePlanVersion, on_delete=models.PROTECT)
    subscriber = models.ForeignKey(Subscriber, on_delete=models.PROTECT)
    salesforce_contract_id = models.CharField(blank=True, max_length=80)
    date_start = models.DateField()
    date_end = models.DateField(blank=True, null=True)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=False)
    do_not_invoice = models.BooleanField(default=False)
    no_invoice_reason = models.CharField(blank=True, max_length=256)
    do_not_email_invoice = models.BooleanField(default=False)
    do_not_email_reminder = models.BooleanField(default=False)
    auto_generate_credits = models.BooleanField(default=False)
    is_trial = models.BooleanField(default=False)
    skip_invoicing_if_no_feature_charges = models.BooleanField(default=False)
    service_type = models.CharField(
        max_length=25,
        choices=SubscriptionType.CHOICES,
        default=SubscriptionType.NOT_SET
    )
    pro_bono_status = models.CharField(
        max_length=25,
        choices=ProBonoStatus.CHOICES,
        default=ProBonoStatus.NO,
    )
    funding_source = models.CharField(
        max_length=25,
        choices=FundingSource.CHOICES,
        default=FundingSource.CLIENT
    )
    last_modified = models.DateTimeField(auto_now=True)
    is_hidden_to_ops = models.BooleanField(default=False)
    skip_auto_downgrade = models.BooleanField(default=False)
    skip_auto_downgrade_reason = models.CharField(blank=True, max_length=256)

    visible_objects = VisibleSubscriptionManager()
    visible_and_suppressed_objects = models.Manager()
    objects = DisabledManager()

    class Meta(object):
        app_label = 'accounting'

    def __str__(self):
        return ("Subscription to %(plan_version)s for %(subscriber)s. "
                "[%(date_start)s - %(date_end)s]" % {
                    'plan_version': self.plan_version,
                    'subscriber': self.subscriber,
                    'date_start': self.date_start.strftime(USER_DATE_FORMAT),
                    'date_end': (self.date_end.strftime(USER_DATE_FORMAT)
                                 if self.date_end is not None else "--"),
                })

    def __eq__(self, other):
        return (
            other is not None
            and other.__class__.__name__ == self.__class__.__name__
            and other.plan_version.pk == self.plan_version.pk
            and other.date_start == self.date_start
            and other.date_end == self.date_end
            and other.subscriber.pk == self.subscriber.pk
            and other.account.pk == self.account.pk
        )

    def save(self, *args, **kwargs):
        """
        Overloaded to update domain pillow with subscription information
        """
        from corehq.apps.accounting.mixins import get_overdue_invoice

        super(Subscription, self).save(*args, **kwargs)
        Subscription._get_active_subscription_by_domain.clear(Subscription, self.subscriber.domain)
        get_overdue_invoice.clear(self.subscriber.domain)

        domain = Domain.get_by_name(self.subscriber.domain)
        # If a subscriber doesn't have a valid domain associated with it
        # we don't care the pillow won't be updated
        if domain:
            publish_domain_saved(domain)

    def delete(self, *args, **kwargs):
        super(Subscription, self).delete(*args, **kwargs)
        Subscription._get_active_subscription_by_domain.clear(Subscription, self.subscriber.domain)

    @property
    def is_community(self):
        return self.plan_version.plan.edition == SoftwarePlanEdition.COMMUNITY

    @property
    def allowed_attr_changes(self):
        """
        These are the attributes of a Subscription that can always be
        changed while the subscription is active (or reactivated)
        """
        return ['do_not_invoice', 'no_invoice_reason',
                'salesforce_contract_id', 'skip_auto_downgrade']

    @property
    def next_subscription_filter(self):
        return (Subscription.visible_objects.
                filter(subscriber=self.subscriber, date_start__gt=self.date_start).
                exclude(pk=self.pk).
                filter(Q(date_end__isnull=True) | ~Q(date_start=F('date_end'))))

    @property
    def previous_subscription_filter(self):
        return Subscription.visible_objects.filter(
            subscriber=self.subscriber,
            date_start__lt=self.date_start - datetime.timedelta(days=1)
        ).exclude(pk=self.pk)

    @property
    def is_renewed(self):
        """
        Checks to see if there's another Subscription for this subscriber
        that starts after this subscription.
        """
        return self.next_subscription_filter.exists()

    @property
    def next_subscription(self):
        try:
            return self.next_subscription_filter.order_by('date_start')[0]
        except (Subscription.DoesNotExist, IndexError):
            return None

    @property
    def previous_subscription(self):
        try:
            return self.previous_subscription_filter.order_by('-date_end')[0]
        except (Subscription.DoesNotExist, IndexError):
            return None

    def raise_conflicting_dates(self, date_start, date_end):
        """Raises a subscription Adjustment error if the specified date range
        conflicts with other subscriptions related to this subscriber.
        """
        assert date_start is not None
        for sub in Subscription.visible_objects.filter(
            Q(date_end__isnull=True) | Q(date_end__gt=F('date_start')),
            subscriber=self.subscriber,
        ).exclude(
            id=self.id,
        ):
            related_has_no_end = sub.date_end is None
            current_has_no_end = date_end is None
            start_before_related_end = sub.date_end is not None and date_start < sub.date_end
            start_before_related_start = date_start < sub.date_start
            start_after_related_start = date_start > sub.date_start
            end_before_related_end = (
                date_end is not None and sub.date_end is not None
                and date_end < sub.date_end
            )
            end_after_related_end = (
                date_end is not None and sub.date_end is not None
                and date_end > sub.date_end
            )
            end_after_related_start = date_end is not None and date_end > sub.date_start

            if (
                (start_before_related_end and start_after_related_start)
                or (start_after_related_start and related_has_no_end)
                or (end_after_related_start and end_before_related_end)
                or (end_after_related_start and related_has_no_end)
                or (start_before_related_start and end_after_related_end)
                or (start_before_related_end and current_has_no_end)
                or (current_has_no_end and related_has_no_end)
            ):
                raise SubscriptionAdjustmentError(
                    "The start date of %(start_date)s conflicts with the "
                    "subscription dates to %(related_sub)s." % {
                        'start_date': self.date_start.strftime(USER_DATE_FORMAT),
                        'related_sub': sub,
                    }
                )

    def update_subscription(self, date_start, date_end,
                            do_not_invoice=None,
                            no_invoice_reason=None, do_not_email_invoice=None,
                            do_not_email_reminder=None, salesforce_contract_id=None,
                            auto_generate_credits=None,
                            web_user=None, note=None, adjustment_method=None,
                            service_type=None, pro_bono_status=None, funding_source=None,
                            skip_invoicing_if_no_feature_charges=None, skip_auto_downgrade=None,
                            skip_auto_downgrade_reason=None):
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL

        self._update_dates(date_start, date_end)

        self._update_properties(
            do_not_invoice=do_not_invoice,
            no_invoice_reason=no_invoice_reason,
            skip_invoicing_if_no_feature_charges=skip_invoicing_if_no_feature_charges,
            do_not_email_invoice=do_not_email_invoice,
            do_not_email_reminder=do_not_email_reminder,
            auto_generate_credits=auto_generate_credits,
            salesforce_contract_id=salesforce_contract_id,
            service_type=service_type,
            pro_bono_status=pro_bono_status,
            funding_source=funding_source,
            skip_auto_downgrade=skip_auto_downgrade,
            skip_auto_downgrade_reason=skip_auto_downgrade_reason,
        )

        self.save()

        SubscriptionAdjustment.record_adjustment(
            self, method=adjustment_method, note=note, web_user=web_user,
            reason=SubscriptionAdjustmentReason.MODIFY
        )

    def _update_dates(self, date_start, date_end):
        if not date_start:
            raise SubscriptionAdjustmentError('Start date must be provided')
        if date_end is not None and date_start > date_end:
            raise SubscriptionAdjustmentError(
                "Can't have a subscription start after the end date."
            )
        self.raise_conflicting_dates(date_start, date_end)
        self.date_start = date_start
        self.date_end = date_end

        is_active_dates = is_active_subscription(self.date_start, self.date_end)
        if self.is_active != is_active_dates:
            if is_active_dates:
                self.is_active = True
                self.subscriber.activate_subscription(get_privileges(self.plan_version), self)
            else:
                raise SubscriptionAdjustmentError(
                    'Cannot deactivate a subscription here. Cancel subscription instead.'
                )

    def _update_properties(self, **kwargs):
        property_names = {
            'do_not_invoice',
            'no_invoice_reason',
            'skip_invoicing_if_no_feature_charges',
            'do_not_email_invoice',
            'do_not_email_reminder',
            'auto_generate_credits',
            'salesforce_contract_id',
            'service_type',
            'pro_bono_status',
            'funding_source',
            'skip_auto_downgrade',
            'skip_auto_downgrade_reason',
        }

        assert property_names >= set(kwargs.keys())

        for property_name, property_value in kwargs.items():
            if property_value is not None:
                setattr(self, property_name, property_value)

    @transaction.atomic
    def change_plan(self, new_plan_version, date_end=None,
                    note=None, web_user=None, adjustment_method=None,
                    service_type=None, pro_bono_status=None, funding_source=None,
                    transfer_credits=True, internal_change=False, account=None,
                    do_not_invoice=None, no_invoice_reason=None,
                    auto_generate_credits=False, is_trial=False):
        """
        Changing a plan TERMINATES the current subscription and
        creates a NEW SUBSCRIPTION where the old plan left off.
        This is not the same thing as simply updating the subscription.
        """
        from corehq.apps.analytics.tasks import track_workflow
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL

        today = datetime.date.today()
        assert self.is_active
        assert date_end is None or date_end >= today

        if new_plan_version.plan.at_max_domains() and self.plan_version.plan != new_plan_version.plan:
            raise SubscriptionAdjustmentError(
                'The maximum number of project spaces has been reached for %(new_plan_version)s. ' % {
                    'new_plan_version': new_plan_version,
                }
            )

        self.date_end = today
        self.is_active = False
        self.save()

        new_subscription = Subscription(
            account=account if account else self.account,
            plan_version=new_plan_version,
            subscriber=self.subscriber,
            salesforce_contract_id=self.salesforce_contract_id,
            date_start=today,
            date_end=date_end,
            is_active=True,
            do_not_invoice=do_not_invoice if do_not_invoice is not None else self.do_not_invoice,
            no_invoice_reason=no_invoice_reason if no_invoice_reason is not None else self.no_invoice_reason,
            auto_generate_credits=auto_generate_credits,
            is_trial=is_trial,
            service_type=(service_type or SubscriptionType.NOT_SET),
            pro_bono_status=(pro_bono_status or ProBonoStatus.NO),
            funding_source=(funding_source or FundingSource.CLIENT),
            skip_auto_downgrade=False,
            skip_auto_downgrade_reason='',
        )

        new_subscription.save()
        new_subscription.raise_conflicting_dates(new_subscription.date_start, new_subscription.date_end)

        new_subscription.set_billing_account_entry_point()

        change_status_result = get_change_status(self.plan_version, new_plan_version)
        self.subscriber.change_subscription(
            downgraded_privileges=change_status_result.downgraded_privs,
            upgraded_privileges=change_status_result.upgraded_privs,
            new_plan_version=new_plan_version,
            old_subscription=self,
            new_subscription=new_subscription,
            internal_change=internal_change,
        )

        # transfer existing credit lines to the new subscription
        if transfer_credits:
            self.transfer_credits(new_subscription)

        # record transfer from old subscription
        SubscriptionAdjustment.record_adjustment(
            self, method=adjustment_method, note=note, web_user=web_user,
            reason=change_status_result.adjustment_reason, related_subscription=new_subscription
        )
        SubscriptionAdjustment.record_adjustment(
            new_subscription, method=adjustment_method, note=note, web_user=web_user,
            reason=SubscriptionAdjustmentReason.CREATE
        )

        upgrade_reasons = [SubscriptionAdjustmentReason.UPGRADE, SubscriptionAdjustmentReason.CREATE]
        if web_user and adjustment_method == SubscriptionAdjustmentMethod.USER:
            if change_status_result.adjustment_reason in upgrade_reasons:
                track_workflow(web_user, 'Changed Plan: Upgrade')
            if change_status_result.adjustment_reason == SubscriptionAdjustmentReason.DOWNGRADE:
                track_workflow(web_user, 'Changed Plan: Downgrade')

        return new_subscription

    def reactivate_subscription(self, date_end=None, note=None, web_user=None,
                                adjustment_method=None, **kwargs):
        """
        This assumes that a subscription was cancelled then recreated with the
        same date_start as the last subscription's date_end (with no other subscriptions
        created in between).
        """
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL
        self.date_end = date_end
        self.is_active = True
        for allowed_attr in self.allowed_attr_changes:
            if allowed_attr in kwargs:
                setattr(self, allowed_attr, kwargs[allowed_attr])
        self.save()
        self.subscriber.reactivate_subscription(
            new_plan_version=self.plan_version,
            subscription=self,
        )
        SubscriptionAdjustment.record_adjustment(
            self, reason=SubscriptionAdjustmentReason.REACTIVATE,
            method=adjustment_method, note=note, web_user=web_user,
        )

    def renew_subscription(self, note=None, web_user=None,
                           adjustment_method=None,
                           service_type=None, pro_bono_status=None,
                           funding_source=None, new_version=None):
        """
        This creates a new subscription with a date_start that is
        equivalent to the current subscription's date_end.
        - The date_end is left None.
        - The plan_version is the cheapest self-subscribable plan with the
          same set of privileges that the current plan has.
        """
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL

        if self.date_end is None:
            raise SubscriptionRenewalError(
                "Cannot renew a subscription with no date_end set."
            )

        if new_version is None:
            current_privileges = get_privileges(self.plan_version)
            new_version = DefaultProductPlan.get_lowest_edition(
                current_privileges, return_plan=True,
            )

        if new_version is None:
            # this should NEVER happen, but on the off-chance that it does...
            raise SubscriptionRenewalError(
                "There was an issue renewing your subscription. Someone "
                "from Dimagi will get back to you shortly."
            )
        renewed_subscription = Subscription(
            account=self.account,
            plan_version=new_version,
            subscriber=self.subscriber,
            salesforce_contract_id=self.salesforce_contract_id,
            date_start=self.date_end,
            date_end=None,
        )
        if service_type is not None:
            renewed_subscription.service_type = service_type
        if pro_bono_status is not None:
            renewed_subscription.pro_bono_status = pro_bono_status
        if funding_source is not None:
            renewed_subscription.funding_source = funding_source
        if datetime.date.today() == self.date_end:
            renewed_subscription.is_active = True
        renewed_subscription.save()

        # record renewal from old subscription
        SubscriptionAdjustment.record_adjustment(
            self, method=adjustment_method, note=note, web_user=web_user,
            reason=SubscriptionAdjustmentReason.RENEW,
        )

        return renewed_subscription

    def transfer_credits(self, subscription=None):
        """Transfers all credit balances related to an account or subscription
        (if specified).
        """
        if subscription is not None and self.account.pk != subscription.account.pk:
            raise CreditLineError(
                "Can only transfer subscription credits under the same "
                "Billing Account."
            )
        source_credits = CreditLine.objects.filter(
            account=self.account,
            subscription=self,
        ).all()
        for credit_line in source_credits:
            transferred_credit = CreditLine.add_credit(
                credit_line.balance,
                account=self.account,
                subscription=subscription,
                feature_type=credit_line.feature_type,
                is_product=credit_line.is_product,
                related_credit=credit_line
            )
            credit_line.is_active = False
            credit_line.adjust_credit_balance(
                credit_line.balance * Decimal('-1'),
                related_credit=transferred_credit,
            )

    def send_ending_reminder_email(self):
        """
        Sends a reminder email to the emails specified in the accounting
        contacts that the subscription will end on the specified end date.
        """
        if self.date_end is None:
            raise SubscriptionReminderError(
                "This subscription has no end date."
            )
        if self.plan_version.plan.edition == SoftwarePlanEdition.PAUSED:
            # never send a subscription ending email for Paused subscriptions...
            return

        today = datetime.date.today()
        num_days_left = (self.date_end - today).days

        domain_name = self.subscriber.domain
        context = self.ending_reminder_context
        subject = context['subject']

        template = self.ending_reminder_email_html
        template_plaintext = self.ending_reminder_email_text
        email_html = render_to_string(template, context)
        email_plaintext = render_to_string(template_plaintext, context)
        bcc = [settings.ACCOUNTS_EMAIL] if not self.is_trial else []
        if self.account.dimagi_contact is not None:
            bcc.append(self.account.dimagi_contact)
        for email in self._reminder_email_contacts(domain_name):
            send_html_email_async.delay(
                subject, email, email_html,
                text_content=email_plaintext,
                email_from=get_dimagi_from_email(),
                bcc=bcc,
            )
            log_accounting_info(
                "Sent %(days_left)s-day subscription reminder "
                "email for %(domain)s to %(email)s." % {
                    'days_left': num_days_left,
                    'domain': domain_name,
                    'email': email,
                }
            )

    @property
    def ending_reminder_email_html(self):
        if self.account.is_customer_billing_account:
            return 'accounting/email/customer_subscription_ending_reminder.html'
        elif self.is_trial:
            return 'accounting/email/trial_ending_reminder.html'
        else:
            return 'accounting/email/subscription_ending_reminder.html'

    @property
    def ending_reminder_email_text(self):
        if self.account.is_customer_billing_account:
            return 'accounting/email/customer_subscription_ending_reminder.txt'
        elif self.is_trial:
            return 'accounting/email/trial_ending_reminder.txt'
        else:
            return 'accounting/email/subscription_ending_reminder.txt'

    @property
    def ending_reminder_context(self):
        from corehq.apps.domain.views.accounting import DomainSubscriptionView

        today = datetime.date.today()
        num_days_left = (self.date_end - today).days
        if num_days_left == 1:
            ending_on = _("tomorrow!")
        else:
            ending_on = _("on %s." % self.date_end.strftime(USER_DATE_FORMAT))

        user_desc = self.plan_version.user_facing_description
        plan_name = user_desc['name']

        domain_name = self.subscriber.domain

        context = {
            'domain': domain_name,
            'plan_name': plan_name,
            'account': self.account.name,
            'ending_on': ending_on,
            'subscription_url': absolute_reverse(
                DomainSubscriptionView.urlname, args=[self.subscriber.domain]),
            'base_url': get_site_domain(),
            'invoicing_contact_email': settings.INVOICING_CONTACT_EMAIL,
            'sales_email': settings.SALES_EMAIL,
        }

        if self.account.is_customer_billing_account:
            subject = _(
                "CommCare Alert: %(account_name)s's subscription to "
                "%(plan_name)s ends %(ending_on)s"
            ) % {
                'account_name': self.account.name,
                'plan_name': plan_name,
                'ending_on': ending_on,
            }
        elif self.is_trial:
            subject = _("CommCare Alert: 30 day trial for '%(domain)s' "
                        "ends %(ending_on)s") % {
                'domain': domain_name,
                'ending_on': ending_on,
            }
        else:
            subject = _(
                "CommCare Alert: %(domain)s's subscription to "
                "%(plan_name)s ends %(ending_on)s"
            ) % {
                'plan_name': plan_name,
                'domain': domain_name,
                'ending_on': ending_on,
            }
        context.update({'subject': subject})
        return context

    def send_dimagi_ending_reminder_email(self):
        if self.date_end is None:
            raise SubscriptionReminderError(
                "This subscription has no end date."
            )
        if self.account.dimagi_contact is None:
            raise SubscriptionReminderError(
                "This subscription has no Dimagi contact."
            )

        subject = self.dimagi_ending_reminder_subject
        context = self.dimagi_ending_reminder_context
        email_html = render_to_string(self.dimagi_ending_reminder_email_html, context)
        email_plaintext = render_to_string(self.dimagi_ending_reminder_email_text, context)
        send_html_email_async.delay(
            subject, self.account.dimagi_contact, email_html,
            text_content=email_plaintext,
            email_from=settings.DEFAULT_FROM_EMAIL,
        )

    @property
    def dimagi_ending_reminder_email_html(self):
        if self.account.is_customer_billing_account:
            return 'accounting/email/customer_subscription_ending_reminder_dimagi.html'
        else:
            return 'accounting/email/subscription_ending_reminder_dimagi.html'

    @property
    def dimagi_ending_reminder_email_text(self):
        if self.account.is_customer_billing_account:
            return 'accounting/email/customer_subscription_ending_reminder_dimagi.txt'
        else:
            return 'accounting/email/subscription_ending_reminder_dimagi.txt'

    @property
    def dimagi_ending_reminder_subject(self):
        if self.account.is_customer_billing_account:
            return "Alert: {account}'s subscriptions are ending on {end_date}".format(
                account=self.account.name,
                end_date=self.date_end.strftime(USER_DATE_FORMAT))
        else:
            return "Alert: {domain}'s subscription is ending on {end_date}".format(
                domain=self.subscriber.domain,
                end_date=self.date_end.strftime(USER_DATE_FORMAT))

    @property
    def dimagi_ending_reminder_context(self):
        end_date = self.date_end.strftime(USER_DATE_FORMAT)
        email = self.account.dimagi_contact
        if self.account.is_customer_billing_account:
            account = self.account.name
            plan = self.plan_version.plan.edition
            context = {
                'account': account,
                'plan': plan,
                'end_date': end_date,
                'client_reminder_email_date': (self.date_end - datetime.timedelta(days=30)).strftime(
                    USER_DATE_FORMAT),
                'contacts': ', '.join(self._reminder_email_contacts(self.subscriber.domain)),
                'dimagi_contact': email,
                'accounts_email': settings.ACCOUNTS_EMAIL
            }
        else:
            domain = self.subscriber.domain
            context = {
                'domain': domain,
                'end_date': end_date,
                'client_reminder_email_date': (self.date_end - datetime.timedelta(days=30)).strftime(
                    USER_DATE_FORMAT),
                'contacts': ', '.join(self._reminder_email_contacts(domain)),
                'dimagi_contact': email,
            }
        return context

    def _reminder_email_contacts(self, domain_name):
        emails = {a.username for a in WebUser.get_admins_by_domain(domain_name)}
        emails |= {e for e in WebUser.get_dimagi_emails_by_domain(domain_name)}
        if not self.is_trial:
            billing_contact_emails = (
                self.account.billingcontactinfo.email_list
                if BillingContactInfo.objects.filter(account=self.account).exists() else []
            )
            if not billing_contact_emails:
                from corehq.apps.accounting.views import ManageBillingAccountView
                _soft_assert_contact_emails_missing(
                    False,
                    'Billing Account for project %s is missing client contact emails: %s' % (
                        domain_name,
                        absolute_reverse(ManageBillingAccountView.urlname, args=[self.account.id])
                    )
                )
            emails |= {billing_contact_email for billing_contact_email in billing_contact_emails}
        if self.account.is_customer_billing_account:
            enterprise_admin_emails = self.account.enterprise_admin_emails
            emails |= {enterprise_admin_email for enterprise_admin_email in enterprise_admin_emails}
        return emails

    def set_billing_account_entry_point(self):
        no_current_entry_point = self.account.entry_point == EntryPoint.NOT_SET
        self_serve = self.service_type == SubscriptionType.PRODUCT
        if no_current_entry_point and self_serve and not self.is_trial:
            self.account.entry_point = EntryPoint.SELF_STARTED
            self.account.save()

    @classmethod
    def get_active_subscription_by_domain(cls, domain_name_or_obj):
        if settings.ENTERPRISE_MODE:
            # Use the default plan, which is Enterprise when in ENTERPRISE_MODE
            return None
        if isinstance(domain_name_or_obj, Domain):
            return cls._get_active_subscription_by_domain(domain_name_or_obj.name)
        return cls._get_active_subscription_by_domain(domain_name_or_obj)

    @classmethod
    @quickcache(['domain_name'], timeout=60 * 60)
    def _get_active_subscription_by_domain(cls, domain_name):
        try:
            return cls.visible_objects.select_related(
                'plan_version__role'
            ).get(
                is_active=True,
                subscriber__domain=domain_name,
            )
        except cls.DoesNotExist:
            return None

    @classmethod
    def get_subscribed_plan_by_domain(cls, domain):
        """
        Returns SoftwarePlanVersion for the given domain.
        """
        domain_obj = ensure_domain_instance(domain)
        if domain_obj is None:
            try:
                return DefaultProductPlan.get_default_plan_version()
            except DefaultProductPlan.DoesNotExist:
                raise ProductPlanNotFoundError
        else:
            active_subscription = cls.get_active_subscription_by_domain(domain_obj.name)
            if active_subscription is not None:
                return active_subscription.plan_version
            else:
                return DefaultProductPlan.get_default_plan_version()

    @classmethod
    def new_domain_subscription(cls, account, domain, plan_version,
                                date_start=None, date_end=None, note=None,
                                web_user=None, adjustment_method=None, internal_change=False,
                                **kwargs):
        if plan_version.plan.at_max_domains():
            raise NewSubscriptionError(
                'The maximum number of project spaces has been reached for %(plan_version)s. ' % {
                    'plan_version': plan_version,
                }
            )

        if plan_version.plan.is_customer_software_plan != account.is_customer_billing_account:
            if plan_version.plan.is_customer_software_plan:
                raise NewSubscriptionError(
                    'You are trying to add a Customer Software Plan to a regular Billing Account. '
                    'Both or neither must be customer-level.'
                )
            else:
                raise NewSubscriptionError(
                    'You are trying to add a regular Software Plan to a Customer Billing Account. '
                    'Both or neither must be customer-level.'
                )

        subscriber = Subscriber.objects.get_or_create(domain=domain)[0]
        today = datetime.date.today()
        date_start = date_start or today

        # find subscriptions that end in the future / after this subscription
        available_subs = Subscription.visible_objects.filter(
            subscriber=subscriber,
        )

        future_subscription_no_end = available_subs.filter(
            date_end__exact=None,
        )
        if date_end is not None:
            future_subscription_no_end = future_subscription_no_end.filter(date_start__lt=date_end)
        if future_subscription_no_end.count() > 0:
            raise NewSubscriptionError(_(
                "There is already a subscription '%s' with no end date "
                "that conflicts with the start and end dates of this "
                "subscription.") %
                future_subscription_no_end.latest('date_created')
            )

        future_subscriptions = available_subs.filter(
            date_end__gt=date_start
        )
        if date_end is not None:
            future_subscriptions = future_subscriptions.filter(date_start__lt=date_end)
        if future_subscriptions.count() > 0:
            raise NewSubscriptionError(str(
                _(
                    "There is already a subscription '%(sub)s' that has an end date "
                    "that conflicts with the start and end dates of this "
                    "subscription %(start)s - %(end)s."
                ) % {
                    'sub': future_subscriptions.latest('date_created'),
                    'start': date_start,
                    'end': date_end
                }
            ))

        can_reactivate, last_subscription = cls.can_reactivate_domain_subscription(
            account, domain, plan_version, date_start=date_start
        )
        if can_reactivate:
            last_subscription.reactivate_subscription(
                date_end=date_end, note=note, web_user=web_user,
                adjustment_method=adjustment_method,
                **kwargs
            )
            return last_subscription

        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL
        subscription = Subscription.visible_objects.create(
            account=account,
            plan_version=plan_version,
            subscriber=subscriber,
            date_start=date_start,
            date_end=date_end,
            **kwargs
        )
        subscription.is_active = is_active_subscription(date_start, date_end)
        if subscription.is_active:
            subscriber.create_subscription(
                new_plan_version=plan_version,
                new_subscription=subscription,
                is_internal_change=internal_change,
            )
        SubscriptionAdjustment.record_adjustment(
            subscription, method=adjustment_method, note=note,
            web_user=web_user
        )
        subscription.save()

        subscription.set_billing_account_entry_point()

        return subscription

    @classmethod
    def can_reactivate_domain_subscription(cls, account, domain, plan_version,
                                           date_start=None):
        subscriber = Subscriber.objects.get_or_create(domain=domain)[0]
        date_start = date_start or datetime.date.today()
        last_subscription = Subscription.visible_objects.filter(
            subscriber=subscriber, date_end=date_start
        )
        if not last_subscription.exists():
            return False, None
        last_subscription = last_subscription.latest('date_created')
        return (
            last_subscription.account.pk == account.pk and
            last_subscription.plan_version.pk == plan_version.pk
        ), last_subscription

    @property
    def is_below_minimum_subscription(self):
        if self.is_trial:
            return False
        elif self.date_start < datetime.date(2018, 9, 5):
            # Only block upgrades for subscriptions created after the date we launched the 30-Day Minimum
            return False
        elif self.date_start + datetime.timedelta(days=MINIMUM_SUBSCRIPTION_LENGTH) >= datetime.date.today():
            return True
        else:
            return False

    def user_can_change_subscription(self, user):
        if user.is_superuser:
            return True
        elif self.account.is_customer_billing_account:
            return self.account.has_enterprise_admin(user.email)
        else:
            return True


class InvoiceBaseManager(models.Manager):

    def get_queryset(self):
        return super(InvoiceBaseManager, self).get_queryset().filter(is_hidden_to_ops=False)


class InvoiceBase(models.Model):
    date_created = models.DateTimeField(auto_now_add=True)
    is_hidden = models.BooleanField(default=False)
    tax_rate = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    balance = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    date_due = models.DateField(db_index=True, null=True)
    date_paid = models.DateField(blank=True, null=True)
    date_start = models.DateField()
    date_end = models.DateField()
    # If set to True invoice will not appear in invoice report. There is no UI to
    # control this filter
    is_hidden_to_ops = models.BooleanField(default=False)
    last_modified = models.DateTimeField(auto_now=True)

    objects = InvoiceBaseManager()
    api_objects = Manager()

    class Meta(object):
        abstract = True

    @property
    def is_customer_invoice(self):
        return False

    @property
    def invoice_number(self):
        ops_num = settings.INVOICE_STARTING_NUMBER + self.id
        return "%s%d" % (settings.INVOICE_PREFIX, ops_num)

    @property
    def is_wire(self):
        return False

    def get_domain(self):
        raise NotImplementedError()

    @property
    def account(self):
        raise NotImplementedError()

    @property
    def is_paid(self):
        return bool(self.date_paid)

    @property
    def email_recipients(self):
        raise NotImplementedError


class WireInvoice(InvoiceBase):
    # WireInvoice is tied to a domain, rather than a subscription
    domain = models.CharField(max_length=100)

    class Meta(object):
        app_label = 'accounting'

    @property
    @memoized
    def account(self):
        return BillingAccount.get_account_by_domain(self.domain)

    @property
    def subtotal(self):
        return self.balance

    @property
    def is_wire(self):
        return True

    @property
    def is_prepayment(self):
        return False

    def get_domain(self):
        return self.domain

    def get_total(self):
        return self.balance

    @property
    def email_recipients(self):
        try:
            original_record = WireBillingRecord.objects.filter(invoice=self).order_by('-date_created')[0]
            return original_record.emailed_to_list
        except IndexError:
            log_accounting_error(
                "Strange that WireInvoice %d has no associated WireBillingRecord. "
                "Should investigate."
                % self.id
            )
            return []


class WirePrepaymentInvoice(WireInvoice):

    class Meta(object):
        app_label = 'accounting'
        proxy = True

    items = []

    @property
    def is_prepayment(self):
        return True


class Invoice(InvoiceBase):
    """
    This is what we'll use to calculate the balance on the accounts based on the current balance
    held by the Invoice. Balance updates will be tied to CreditAdjustmentTriggers which are tied
    to CreditAdjustments.
    """
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT)

    class Meta(object):
        app_label = 'accounting'

    def save(self, *args, **kwargs):
        from corehq.apps.accounting.mixins import get_overdue_invoice

        super(Invoice, self).save(*args, **kwargs)
        get_overdue_invoice.clear(self.subscription.subscriber.domain)

    @property
    def email_recipients(self):
        if self.subscription.service_type == SubscriptionType.IMPLEMENTATION:
            return [settings.ACCOUNTS_EMAIL]
        else:
            return self.get_contact_emails()

    def get_contact_emails(self, include_domain_admins=False, filter_out_dimagi=False):
        try:
            billing_contact_info = BillingContactInfo.objects.get(account=self.account)
            contact_emails = billing_contact_info.email_list
        except BillingContactInfo.DoesNotExist:
            contact_emails = []

        if include_domain_admins or not contact_emails:
            from corehq.apps.accounting.views import ManageBillingAccountView
            admins = WebUser.get_admins_by_domain(self.get_domain())
            contact_emails.extend([admin.email if admin.email else admin.username for admin in admins])
            if not settings.UNIT_TESTING:
                _soft_assert_contact_emails_missing(
                    False,
                    "Could not find an email to send the invoice "
                    "email to for the domain %s. Sending to domain admins instead: %s."
                    " Add client contact emails here: %s" % (
                        self.get_domain(),
                        ', '.join(contact_emails),
                        absolute_reverse(ManageBillingAccountView.urlname, args=[self.account.id]),
                    )
                )
        if filter_out_dimagi:
            contact_emails = [e for e in contact_emails if not e.endswith('@dimagi.com')]
        return contact_emails

    @property
    def subtotal(self):
        """
        This will be inserted in the subtotal field on the printed invoice.
        """
        if self.lineitem_set.count() == 0:
            return Decimal('0.0000')
        return sum([line_item.total for line_item in self.lineitem_set.all()])

    @property
    def applied_tax(self):
        return Decimal('%.4f' % round(self.tax_rate * self.subtotal, 4))

    @property
    @memoized
    def account(self):
        return self.subscription.account

    @property
    def applied_credit(self):
        if self.creditadjustment_set.count() == 0:
            return Decimal('0.0000')
        return sum([credit.amount for credit in self.creditadjustment_set.all()])

    def get_total(self):
        """
        This will be inserted in the total field on the printed invoice.
        """
        return self.subtotal + self.applied_tax + self.applied_credit

    def update_balance(self):
        self.balance = self.get_total()
        if self.balance <= 0:
            self.date_paid = datetime.date.today()
        else:
            self.date_paid = None

    def calculate_credit_adjustments(self):
        """
        This goes through all credit lines that:
        - do not have feature/product rates, but specify the related subscription and billing account
        - do not have feature/product rates or a subscription, but specify the related billing account
        """
        # first apply credits to all the line items
        for line_item in self.lineitem_set.all():
            line_item.calculate_credit_adjustments()

        # finally, apply credits to the leftover invoice balance
        current_total = self.get_total()
        credit_lines = CreditLine.get_credits_for_invoice(self)
        CreditLine.apply_credits_toward_balance(credit_lines, current_total, invoice=self)

    @classmethod
    def exists_for_domain(cls, domain):
        return cls.objects.filter(
            subscription__subscriber__domain=domain, is_hidden=False
        ).count() > 0

    def get_domain(self):
        return self.subscription.subscriber.domain

    @classmethod
    def autopayable_invoices(cls, date_due):
        """ Invoices that can be auto paid on date_due """
        invoices = cls.objects.select_related('subscription__account').filter(
            date_due=date_due,
            is_hidden=False,
            subscription__account__auto_pay_user__isnull=False,
        )
        return invoices

    def pay_invoice(self, payment_record):
        CreditLine.make_payment_towards_invoice(
            invoice=self,
            payment_record=payment_record,
        )

        self.update_balance()
        self.save()


class CustomerInvoice(InvoiceBase):
    # CustomerInvoice is tied to a customer level account, instead of a subscription
    account = models.ForeignKey(BillingAccount, on_delete=models.PROTECT)
    subscriptions = models.ManyToManyField(Subscription, default=list, blank=True)

    class Meta(object):
        app_label = 'accounting'

    @property
    def is_customer_invoice(self):
        return True

    def get_domain(self):
        return None

    @property
    def email_recipients(self):
        try:
            billing_contact_info = BillingContactInfo.objects.get(account=self.account)
            contact_emails = billing_contact_info.email_list
        except BillingContactInfo.DoesNotExist:
            contact_emails = []
        return contact_emails

    @property
    def contact_emails(self):
        return self.account.enterprise_admin_emails

    def get_contact_emails(self, include_domain_admins=False, filter_out_dimagi=False):
        # mimic the behavior of the regular Invoice for notification purposes
        return self.contact_emails

    @property
    def subtotal(self):
        """
        This will be inserted in the subtotal field on the printed invoice.
        """
        if self.lineitem_set.count() == 0:
            return Decimal('0.0000')
        return sum([line_item.total for line_item in self.lineitem_set.all()])

    @property
    def applied_tax(self):
        return Decimal('%.4f' % round(self.tax_rate * self.subtotal, 4))

    @property
    def applied_credit(self):
        if self.creditadjustment_set.count() == 0:
            return Decimal('0.0000')
        return sum([credit.amount for credit in self.creditadjustment_set.all()])

    def get_total(self):
        """
        This will be inserted in the total field on the printed invoice.
        """
        return self.subtotal + self.applied_tax + self.applied_credit

    def update_balance(self):
        self.balance = self.get_total()
        if self.balance <= 0:
            self.date_paid = datetime.date.today()
        else:
            self.date_paid = None

    def calculate_credit_adjustments(self):
        for line_item in self.lineitem_set.all():
            line_item.calculate_credit_adjustments()
        current_total = self.get_total()
        credit_lines = CreditLine.get_credits_for_customer_invoice(self)
        CreditLine.apply_credits_toward_balance(credit_lines, current_total, customer_invoice=self)

    def pay_invoice(self, payment_record):
        CreditLine.make_payment_towards_invoice(
            invoice=self,
            payment_record=payment_record,
        )

        self.update_balance()
        self.save()

    @classmethod
    def exists_for_domain(cls, domain):
        invoices = cls.objects.filter(is_hidden=False)
        for subscription in invoices.subscriptions.filter(is_hidden=False):
            if subscription.subscriber.domain == domain:
                return True
        return False

    @classmethod
    def autopayable_invoices(cls, date_due):
        """ Invoices that can be auto paid on date_due """
        invoices = cls.objects.select_related('account').filter(
            date_due=date_due,
            is_hidden=False,
            account__auto_pay_user__isnull=False
        )
        return invoices


class SubscriptionAdjustment(models.Model):
    """
    A record of any adjustments made to a subscription, so we always have a paper trail.
    Things that cannot be modified after a subscription is created:
    - account
    - plan
    - subscriber
    Things that have limited modification abilities:
    - dates if the current date is today or earlier
    All other modifications require cancelling the current subscription and creating a new one.

    Note: related_subscription is the subscription to be filled in when the subscription is upgraded / downgraded.
    """
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT)
    reason = models.CharField(max_length=50, default=SubscriptionAdjustmentReason.CREATE,
                              choices=SubscriptionAdjustmentReason.CHOICES)
    method = models.CharField(max_length=50, default=SubscriptionAdjustmentMethod.INTERNAL,
                              choices=SubscriptionAdjustmentMethod.CHOICES)
    note = models.TextField(null=True)
    web_user = models.CharField(max_length=80, null=True)
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True)
    related_subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT, null=True,
                                             related_name='subscriptionadjustment_related')
    date_created = models.DateTimeField(auto_now_add=True)
    new_date_start = models.DateField()
    new_date_end = models.DateField(blank=True, null=True)
    new_date_delay_invoicing = models.DateField(blank=True, null=True)
    new_salesforce_contract_id = models.CharField(blank=True, null=True, max_length=80)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    @classmethod
    def record_adjustment(cls, subscription, **kwargs):
        adjustment = SubscriptionAdjustment(
            subscription=subscription,
            new_date_start=subscription.date_start,
            new_date_end=subscription.date_end,
            new_salesforce_contract_id=subscription.salesforce_contract_id,
            **kwargs
        )
        adjustment.save()
        return adjustment


class BillingRecordBase(models.Model):
    """
    This stores any interaction we have with the client in sending a physical / pdf invoice to their contact email.
    """
    date_created = models.DateTimeField(auto_now_add=True, db_index=True)
    emailed_to_list = ArrayField(models.EmailField(), default=list)
    skipped_email = models.BooleanField(default=False)
    pdf_data_id = models.CharField(max_length=48)
    last_modified = models.DateTimeField(auto_now=True)

    INVOICE_HTML_TEMPLATE = 'accounting/email/invoice.html'
    INVOICE_TEXT_TEMPLATE = 'accounting/email/invoice.txt'

    class Meta(object):
        abstract = True

    _pdf = None

    @property
    def pdf(self):
        if self._pdf is None:
            return InvoicePdf.get(self.pdf_data_id)
        return self._pdf

    @property
    def html_template(self):
        return self.INVOICE_HTML_TEMPLATE

    @property
    def text_template(self):
        return self.INVOICE_TEXT_TEMPLATE

    @property
    def should_send_email(self):
        raise NotImplementedError("should_send_email is required")

    @classmethod
    def generate_record(cls, invoice):
        record = cls(invoice=invoice)
        invoice_pdf = InvoicePdf()
        invoice_pdf.generate_pdf(record.invoice)
        record.pdf_data_id = invoice_pdf._id
        record._pdf = invoice_pdf
        record.save()
        return record

    def handle_throttled_email(self, contact_emails):
        self.skipped_email = True
        month_name = self.invoice.date_start.strftime("%B")
        self.save()
        log_accounting_info(
            "Throttled billing statements for domain %(domain)s "
            "to %(emails)s." % {
                'domain': self.invoice.get_domain(),
                'emails': ', '.join(contact_emails),
            }
        )
        raise InvoiceEmailThrottledError(
            "Invoice communications exceeded the maximum limit of "
            "%(max_limit)d for domain %(domain)s for the month of "
            "%(month_name)s." % {
                'max_limit': MAX_INVOICE_COMMUNICATIONS,
                'domain': self.invoice.get_domain(),
                'month_name': month_name,
            })

    def email_context(self):
        from corehq.apps.domain.views.accounting import DomainBillingStatementsView
        from corehq.apps.domain.views.settings import DefaultProjectSettingsView

        month_name = self.invoice.date_start.strftime("%B")
        domain = self.invoice.get_domain()
        context = {
            'month_name': month_name,
            'domain': domain,
            'domain_url': absolute_reverse(DefaultProjectSettingsView.urlname,
                                           args=[domain]),
            'statement_number': self.invoice.invoice_number,
            'payment_status': (_("Paid") if self.invoice.is_paid
                               else _("Payment Required")),
            'amount_due': fmt_dollar_amount(self.invoice.balance),
            'statements_url': absolute_reverse(
                DomainBillingStatementsView.urlname, args=[domain]),
            'invoicing_contact_email': settings.INVOICING_CONTACT_EMAIL,
            'accounts_email': settings.ACCOUNTS_EMAIL,
        }
        return context

    def email_subject(self):
        raise NotImplementedError()

    def can_view_statement(self, web_user):
        raise NotImplementedError()

    def send_email(self, contact_email=None, cc_emails=None):
        pdf_attachment = {
            'title': self.pdf.get_filename(self.invoice),
            'file_obj': BytesIO(self.pdf.get_data(self.invoice)),
            'mimetype': 'application/pdf',
        }
        domain = self.invoice.get_domain()
        subject = self.email_subject()
        context = self.email_context()
        email_from = self.email_from()

        greeting = _("Hello,")
        can_view_statement = False
        web_user = WebUser.get_by_username(contact_email)
        if web_user is not None:
            if web_user.first_name:
                greeting = _("Dear %s,") % web_user.first_name
            can_view_statement = self.can_view_statement(web_user)
        context['greeting'] = greeting
        context['can_view_statement'] = can_view_statement
        email_html = render_to_string(self.html_template, context)
        email_plaintext = render_to_string(self.text_template, context)
        send_html_email_async.delay(
            subject, contact_email, email_html,
            text_content=email_plaintext,
            email_from=email_from,
            file_attachments=[pdf_attachment],
            cc=cc_emails
        )
        self.emailed_to_list.extend([contact_email])
        if cc_emails:
            self.emailed_to_list.extend(cc_emails)
        self.save()
        if self.invoice.is_customer_invoice:
            log_message = "Sent billing statements for account %(account)s to %(emails)s." % {
                'account': self.invoice.account,
                'emails': contact_email,
            }
        else:
            log_message = "Sent billing statements for domain %(domain)s to %(emails)s." % {
                'domain': domain,
                'emails': contact_email,
            }
        log_accounting_info(log_message)


class WireBillingRecord(BillingRecordBase):
    invoice = models.ForeignKey(WireInvoice, on_delete=models.PROTECT)

    INVOICE_HTML_TEMPLATE = 'accounting/email/wire_invoice.html'
    INVOICE_TEXT_TEMPLATE = 'accounting/email/wire_invoice.txt'

    class Meta(object):
        app_label = 'accounting'

    @property
    def should_send_email(self):
        hidden = self.invoice.is_hidden
        return not hidden

    @staticmethod
    def is_email_throttled():
        return False

    def email_subject(self):
        month_name = self.invoice.date_start.strftime("%B")
        return "Your %(month)s Bulk Billing Statement for Project Space %(domain)s" % {
            'month': month_name,
            'domain': self.invoice.get_domain(),
        }

    @staticmethod
    def email_from():
        return "Dimagi Accounting <{email}>".format(email=settings.INVOICING_CONTACT_EMAIL)

    def can_view_statement(self, web_user):
        return web_user.is_domain_admin(self.invoice.get_domain())


class WirePrepaymentBillingRecord(WireBillingRecord):

    class Meta(object):
        app_label = 'accounting'
        proxy = True

    def email_subject(self):
        return _("Your prepayment invoice")

    def can_view_statement(self, web_user):
        return web_user.is_domain_admin(self.invoice.get_domain())


class BillingRecord(BillingRecordBase):
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT)
    INVOICE_CONTRACTED_HTML_TEMPLATE = 'accounting/email/invoice_contracted.html'
    INVOICE_CONTRACTED_TEXT_TEMPLATE = 'accounting/email/invoice_contracted.txt'

    INVOICE_AUTOPAY_HTML_TEMPLATE = 'accounting/email/invoice_autopayment.html'
    INVOICE_AUTOPAY_TEXT_TEMPLATE = 'accounting/email/invoice_autopayment.txt'

    class Meta(object):
        app_label = 'accounting'

    @property
    def html_template(self):
        if self.invoice.subscription.service_type == SubscriptionType.IMPLEMENTATION:
            return self.INVOICE_CONTRACTED_HTML_TEMPLATE

        if self.invoice.subscription.account.auto_pay_enabled:
            return self.INVOICE_AUTOPAY_HTML_TEMPLATE

        return self.INVOICE_HTML_TEMPLATE

    @property
    def text_template(self):
        if self.invoice.subscription.service_type == SubscriptionType.IMPLEMENTATION:
            return self.INVOICE_CONTRACTED_TEXT_TEMPLATE

        if self.invoice.subscription.account.auto_pay_enabled:
            return self.INVOICE_AUTOPAY_TEXT_TEMPLATE

        return self.INVOICE_TEXT_TEMPLATE

    @property
    def should_send_email(self):
        subscription = self.invoice.subscription
        autogenerate = (subscription.auto_generate_credits and not self.invoice.balance)
        small_contracted = (self.invoice.balance <= SMALL_INVOICE_THRESHOLD and
                            subscription.service_type == SubscriptionType.IMPLEMENTATION)
        hidden = self.invoice.is_hidden
        do_not_email_invoice = self.invoice.subscription.do_not_email_invoice
        return not (autogenerate or small_contracted or hidden or do_not_email_invoice)

    def is_email_throttled(self):
        month = self.invoice.date_start.month
        year = self.invoice.date_start.year
        date_start, date_end = get_first_last_days(year, month)
        return self.__class__.objects.filter(
            invoice__date_start__lte=date_end, invoice__date_end__gte=date_start,
            invoice__subscription__subscriber=self.invoice.subscription.subscriber,
            invoice__is_hidden_to_ops=False,
        ).count() > MAX_INVOICE_COMMUNICATIONS

    def email_context(self):
        context = super(BillingRecord, self).email_context()
        total_balance = sum(invoice.balance for invoice in Invoice.objects.filter(
            is_hidden=False,
            subscription__subscriber__domain=self.invoice.get_domain(),
        ))
        is_small_invoice = self.invoice.balance < SMALL_INVOICE_THRESHOLD
        payment_status = (_("Paid")
                          if self.invoice.is_paid or total_balance == 0
                          else _("Payment Required"))
        context.update({
            'plan_name': self.invoice.subscription.plan_version.plan.name,
            'date_due': self.invoice.date_due,
            'is_small_invoice': is_small_invoice,
            'total_balance': total_balance,
            'is_total_balance_due': total_balance >= SMALL_INVOICE_THRESHOLD,
            'payment_status': payment_status,
        })
        if self.invoice.subscription.service_type == SubscriptionType.IMPLEMENTATION:
            from corehq.apps.accounting.dispatcher import AccountingAdminInterfaceDispatcher
            context.update({
                'salesforce_contract_id': self.invoice.subscription.salesforce_contract_id,
                'billing_account': self.invoice.subscription.account.name,
                'billing_contacts': self.invoice.get_contact_emails(),
                'admin_invoices_url': "{url}?subscriber={domain}".format(
                    url=absolute_reverse(AccountingAdminInterfaceDispatcher.name(), args=['invoices']),
                    domain=self.invoice.get_domain()
                )
            })

        if self.invoice.subscription.account.auto_pay_enabled:
            try:
                last_4 = getattr(self.invoice.subscription.account.autopay_card, 'last4', None)
            except StripePaymentMethod.DoesNotExist:
                last_4 = None
            context.update({
                'auto_pay_user': self.invoice.subscription.account.auto_pay_user,
                'last_4': last_4,
            })

        context.update({
            'credits': self.credits,
        })

        return context

    def credits(self):
        credits = {
            'account': {},
            'subscription': {},
        }
        self._add_product_credits(credits)
        self._add_user_credits(credits)
        self._add_sms_credits(credits)
        self._add_general_credits(credits)
        return credits

    def _add_product_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            invoice=self.invoice,
            line_item__product_rate__isnull=False,
        )

        subscription_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_by_subscription_and_features(
                self.invoice.subscription,
                is_product=True,
            )
        )
        if subscription_credits or credit_adjustments.filter(
            credit_line__subscription=self.invoice.subscription,
        ):
            credits['subscription'].update({
                'product': {
                    'amount': quantize_accounting_decimal(subscription_credits),
                }
            })

        account_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.subscription.account,
                is_product=True,
            )
        )
        if account_credits or credit_adjustments.filter(
            credit_line__subscription=None,
        ):
            credits['account'].update({
                'product': {
                    'amount': quantize_accounting_decimal(account_credits),
                }
            })

        return credits

    def _add_user_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            invoice=self.invoice,
            line_item__feature_rate__feature__feature_type=FeatureType.USER,
        )

        subscription_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_by_subscription_and_features(
                self.invoice.subscription,
                feature_type=FeatureType.USER,
            )
        )
        if subscription_credits or credit_adjustments.filter(
            credit_line__subscription=self.invoice.subscription,
        ):
            credits['subscription'].update({
                'user': {
                    'amount': quantize_accounting_decimal(subscription_credits),
                }
            })

        account_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.subscription.account,
                feature_type=FeatureType.USER,
            )
        )
        if account_credits or credit_adjustments.filter(
            credit_line__subscription=None,
        ):
            credits['account'].update({
                'user': {
                    'amount': quantize_accounting_decimal(account_credits),
                }
            })

        return credits

    def _add_sms_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            invoice=self.invoice,
            line_item__feature_rate__feature__feature_type=FeatureType.SMS,
        )

        subscription_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_by_subscription_and_features(
                self.invoice.subscription,
                feature_type=FeatureType.SMS,
            )
        )
        if subscription_credits or credit_adjustments.filter(
            credit_line__subscription=self.invoice.subscription,
        ):
            credits['subscription'].update({
                'sms': {
                    'amount': quantize_accounting_decimal(subscription_credits),
                }
            })

        account_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.subscription.account,
                feature_type=FeatureType.SMS,
            )
        )
        if account_credits or credit_adjustments.filter(
            credit_line__subscription=None,
        ):
            credits['account'].update({
                'sms': {
                    'amount': quantize_accounting_decimal(account_credits),
                }
            })

        return credits

    def _add_general_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            invoice=self.invoice,
            line_item__feature_rate=None,
            line_item__product_rate=None,
        )

        subscription_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_by_subscription_and_features(
                self.invoice.subscription,
            )
        )
        if subscription_credits or credit_adjustments.filter(
            credit_line__subscription=self.invoice.subscription,
        ):
            credits['subscription'].update({
                'general': {
                    'amount': quantize_accounting_decimal(subscription_credits),
                }
            })

        account_credits = BillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.subscription.account,
            )
        )
        if account_credits or credit_adjustments.filter(
            credit_line__subscription=None,
        ):
            credits['account'].update({
                'general': {
                    'amount': quantize_accounting_decimal(account_credits),
                }
            })

        return credits

    def email_subject(self):
        month_name = self.invoice.date_start.strftime("%B")
        return "Your %(month)s CommCare Billing Statement for Project Space %(domain)s" % {
            'month': month_name,
            'domain': self.invoice.subscription.subscriber.domain,
        }

    def email_from(self):
        return get_dimagi_from_email()

    @staticmethod
    def _get_total_balance(credit_lines):
        return (
            sum([credit_line.balance for credit_line in credit_lines])
            if credit_lines else Decimal('0.0')
        )

    def can_view_statement(self, web_user):
        return web_user.is_domain_admin(self.invoice.get_domain())


class CustomerBillingRecord(BillingRecordBase):
    invoice = models.ForeignKey(CustomerInvoice, on_delete=models.PROTECT)
    INVOICE_AUTOPAY_HTML_TEMPLATE = 'accounting/email/invoice_autopayment.html'
    INVOICE_AUTOPAY_TEXT_TEMPLATE = 'accounting/email/invoice_autopayment.txt'

    INVOICE_HTML_TEMPLATE = 'accounting/email/customer_invoice.html'
    INVOICE_TEXT_TEMPLATE = 'accounting/email/customer_invoice.txt'

    class Meta(object):
        app_label = 'accounting'

    @property
    def html_template(self):
        if self.invoice.account.auto_pay_enabled:
            return self.INVOICE_AUTOPAY_HTML_TEMPLATE

        return self.INVOICE_HTML_TEMPLATE

    @property
    def text_template(self):
        if self.invoice.account.auto_pay_enabled:
            return self.INVOICE_AUTOPAY_TEXT_TEMPLATE
        return self.INVOICE_TEXT_TEMPLATE

    @property
    def should_send_email(self):
        return not self.invoice.is_hidden

    def email_context(self):
        from corehq.apps.accounting.views import EnterpriseBillingStatementsView
        context = super(CustomerBillingRecord, self).email_context()
        is_small_invoice = self.invoice.balance < SMALL_INVOICE_THRESHOLD
        payment_status = (_("Paid")
                          if self.invoice.is_paid or self.invoice.balance == 0
                          else _("Payment Required"))
        # Random domain, because all subscriptions on a customer account link to the same Enterprise Dashboard
        domain = self.invoice.subscriptions.first().subscriber.domain
        context.update({
            'account_name': self.invoice.account.name,
            'date_due': self.invoice.date_due,
            'is_small_invoice': is_small_invoice,
            'total_balance': '{:.2f}'.format(self.invoice.balance),
            'is_total_balance_due': self.invoice.balance >= SMALL_INVOICE_THRESHOLD,
            'payment_status': payment_status,
            'statements_url': absolute_reverse(
                EnterpriseBillingStatementsView.urlname, args=[domain]),
        })
        if self.invoice.account.auto_pay_enabled:
            try:
                last_4 = getattr(self.invoice.account.autopay_card, 'last4', None)
            except StripePaymentMethod.DoesNotExist:
                last_4 = None
            context.update({
                'auto_pay_user': self.invoice.account.auto_pay_user,
                'last_4': last_4,
            })

        context.update({
            'credits': self.credits,
        })

        return context

    def credits(self):
        credits = {
            'account': {},
            'subscription': {},
        }
        self._add_product_credits(credits)
        self._add_user_credits(credits)
        self._add_sms_credits(credits)
        self._add_general_credits(credits)
        return credits

    def _add_product_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            customer_invoice=self.invoice,
            line_item__product_rate__isnull=False
        )
        subscription_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_subscriptions(
                self.invoice.subscriptions,
                is_product=True
            )
        )
        if subscription_credits or self._subscriptions_in_credit_adjustments(credit_adjustments):
            credit_adjustments['subscription'].update({
                'product': {
                    'amount': quantize_accounting_decimal(subscription_credits)
                }
            })

        account_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.account,
                is_product=True
            )
        )
        if account_credits or credit_adjustments.filter(credit_line__subscription=None):
            credits['account'].update({
                'product': {
                    'amount': quantize_accounting_decimal(account_credits)
                }
            })
        return credits

    def _add_user_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            customer_invoice=self.invoice,
            line_item__feature_rate__feature__feature_type=FeatureType.USER
        )
        subscription_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_subscriptions(
                self.invoice.subscriptions,
                feature_type=FeatureType.USER
            )
        )
        if subscription_credits or self._subscriptions_in_credit_adjustments(credit_adjustments):
            credits['subscription'].update({
                'user': {
                    'amount': quantize_accounting_decimal(subscription_credits)
                }
            })

        account_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.account,
                feature_type=FeatureType.USER
            )
        )
        if account_credits or credit_adjustments.filter(credit_line__subscription=None):
            credits['account'].update({
                'user': {
                    'amount': quantize_accounting_decimal(account_credits)
                }
            })
        return credits

    def _add_sms_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            customer_invoice=self.invoice,
            line_item__feature_rate__feature__feature_type=FeatureType.SMS
        )
        subscription_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_subscriptions(
                self.invoice.subscriptions,
                feature_type=FeatureType.SMS
            )
        )
        if subscription_credits or self._subscriptions_in_credit_adjustments(credit_adjustments):
            credits['subscription'].update({
                'sms': {
                    'amount': quantize_accounting_decimal(subscription_credits)
                }
            })

        account_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.account,
                feature_type=FeatureType.SMS
            )
        )
        if account_credits or credit_adjustments.filter(credit_line__subscription=None):
            credits['account'].update({
                'sms': {
                    'amount': quantize_accounting_decimal(account_credits)
                }
            })
        return credits

    def _add_general_credits(self, credits):
        credit_adjustments = CreditAdjustment.objects.filter(
            customer_invoice=self.invoice,
            line_item__feature_rate=None,
            line_item__product_rate=None
        )
        subscription_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_subscriptions(
                self.invoice.subscriptions
            )
        )
        if subscription_credits or self._subscriptions_in_credit_adjustments(credit_adjustments):
            credits['subscription'].update({
                'general': {
                    'amount': quantize_accounting_decimal(subscription_credits)
                }
            })

        account_credits = CustomerBillingRecord._get_total_balance(
            CreditLine.get_credits_for_account(
                self.invoice.account
            )
        )
        if account_credits or credit_adjustments.filter(credit_line__subscription=None):
            credits['account'].update({
                'general': {
                    'amount': quantize_accounting_decimal(account_credits)
                }
            })
        return credits

    def _subscriptions_in_credit_adjustments(self, credit_adjustments):
        for subscription in self.invoice.subscriptions.all():
            if credit_adjustments.filter(
                    credit_line__subscription=subscription
            ):
                return True
        return False

    def email_subject(self):
        month_name = self.invoice.date_start.strftime("%B")
        return "Your %(month)s CommCare Billing Statement for Customer Account %(account_name)s" % {
            'month': month_name,
            'account_name': self.invoice.account.name,
        }

    def email_from(self):
        return get_dimagi_from_email()

    @staticmethod
    def _get_total_balance(credit_lines):
        return (
            sum([credit_line.balance for credit_line in credit_lines])
            if credit_lines else Decimal('0.0')
        )

    def can_view_statement(self, web_user):
        for subscription in self.invoice.subscriptions.all():
            if web_user.is_domain_admin(subscription.subscriber.domain):
                return True
        return False


class InvoicePdf(BlobMixin, SafeSaveDocument):
    invoice_id = StringProperty()
    date_created = DateTimeProperty()
    is_wire = BooleanProperty(default=False)
    is_customer = BooleanProperty(default=False)
    _blobdb_type_code = CODES.invoice

    def generate_pdf(self, invoice):
        self.save()
        domain = invoice.get_domain()
        pdf_data = NamedTemporaryFile()
        account_name = ''
        if invoice.is_customer_invoice:
            account_name = invoice.account.name
        template = InvoiceTemplate(
            pdf_data.name,
            invoice_number=invoice.invoice_number,
            to_address=get_address_from_invoice(invoice),
            project_name=domain,
            invoice_date=invoice.date_created.date(),
            due_date=invoice.date_due,
            date_start=invoice.date_start,
            date_end=invoice.date_end,
            subtotal=invoice.subtotal,
            tax_rate=invoice.tax_rate,
            applied_tax=getattr(invoice, 'applied_tax', Decimal('0.000')),
            applied_credit=getattr(invoice, 'applied_credit', Decimal('0.000')),
            total=invoice.get_total(),
            is_wire=invoice.is_wire,
            is_customer=invoice.is_customer_invoice,
            is_prepayment=invoice.is_wire and invoice.is_prepayment,
            account_name=account_name
        )

        if not invoice.is_wire:
            if invoice.is_customer_invoice:
                line_items = LineItem.objects.filter(customer_invoice=invoice)
            else:
                line_items = LineItem.objects.filter(subscription_invoice=invoice)
            for line_item in line_items:
                is_unit = line_item.unit_description is not None
                is_quarterly = line_item.invoice.is_customer_invoice and \
                    line_item.invoice.account.invoicing_plan != InvoicingPlan.MONTHLY
                unit_cost = line_item.subtotal
                if is_unit:
                    unit_cost = line_item.unit_cost
                if is_quarterly and line_item.base_description is not None:
                    unit_cost = line_item.product_rate.monthly_fee
                description = line_item.base_description or line_item.unit_description
                if line_item.quantity > 0:
                    template.add_item(
                        description,
                        line_item.quantity if is_unit or is_quarterly else 1,
                        unit_cost,
                        line_item.subtotal,
                        line_item.applied_credit,
                        line_item.total
                    )

        if invoice.is_wire and invoice.is_prepayment:
            unit_cost = 1
            applied_credit = 0
            for item in invoice.items:
                template.add_item(item['type'],
                                  item['amount'],
                                  unit_cost,
                                  item['amount'],
                                  applied_credit,
                                  item['amount'])

        template.get_pdf()
        filename = self.get_filename(invoice)
        blob_domain = domain or UNKNOWN_DOMAIN
        # this is slow and not unit tested
        # best to just skip during unit tests for speed
        if not settings.UNIT_TESTING:
            self.put_attachment(pdf_data, filename, 'application/pdf', domain=blob_domain)
        else:
            self.put_attachment('', filename, 'application/pdf', domain=blob_domain)
        pdf_data.close()

        self.invoice_id = str(invoice.id)
        self.date_created = datetime.datetime.utcnow()
        self.is_wire = invoice.is_wire
        self.is_customer = invoice.is_customer_invoice
        self.save()

    @staticmethod
    def get_filename(invoice):
        return "statement_%(year)d_%(month)d.pdf" % {
            'year': invoice.date_start.year,
            'month': invoice.date_start.month,
        }

    def get_data(self, invoice):
        with self.fetch_attachment(self.get_filename(invoice), stream=True) as fh:
            return fh.read()


class LineItemManager(models.Manager):

    def get_products(self):
        return self.get_queryset().filter(feature_rate__exact=None)

    def get_features(self):
        return self.get_queryset().filter(product_rate__exact=None)

    def get_feature_by_type(self, feature_type):
        return self.get_queryset().filter(feature_rate__feature__feature_type=feature_type)


class LineItem(models.Model):
    subscription_invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True)
    customer_invoice = models.ForeignKey(CustomerInvoice, on_delete=models.PROTECT, null=True)
    feature_rate = models.ForeignKey(FeatureRate, on_delete=models.PROTECT, null=True)
    product_rate = models.ForeignKey(SoftwareProductRate, on_delete=models.PROTECT, null=True)
    base_description = models.TextField(blank=True, null=True)
    base_cost = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    unit_description = models.TextField(blank=True, null=True)
    unit_cost = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    quantity = models.IntegerField(default=1, validators=integer_field_validators)
    last_modified = models.DateTimeField(auto_now=True)

    objects = LineItemManager()

    class Meta(object):
        app_label = 'accounting'

    @property
    def invoice(self):
        if self.subscription_invoice:
            return self.subscription_invoice
        else:
            return self.customer_invoice

    @invoice.setter
    def invoice(self, invoice):
        if invoice.is_customer_invoice:
            self.customer_invoice = invoice
        else:
            self.subscription_invoice = invoice

    @property
    def subtotal(self):
        if self.customer_invoice and self.customer_invoice.account.invoicing_plan != InvoicingPlan.MONTHLY:
            return self.base_cost * self.quantity + self.unit_cost * self.quantity

        return self.base_cost + self.unit_cost * self.quantity

    @property
    def applied_credit(self):
        """
        The total amount of credit applied specifically to this LineItem.
        """
        if self.creditadjustment_set.count() == 0:
            return Decimal('0.0000')
        return sum([credit.amount for credit in self.creditadjustment_set.all()])

    @property
    def total(self):
        return self.subtotal + self.applied_credit

    def calculate_credit_adjustments(self):
        """
        This goes through all credit lines that:
        - specify the related feature or product rate that generated this line item
        """
        current_total = self.total
        credit_lines = CreditLine.get_credits_for_line_item(self)
        CreditLine.apply_credits_toward_balance(credit_lines, current_total, line_item=self)


class CreditLine(models.Model):
    """
    The amount of money in USD that exists that can be applied toward a specific account,
    a specific subscription, or specific rates in that subscription.
    """
    account = models.ForeignKey(BillingAccount, on_delete=models.PROTECT)
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT, null=True, blank=True)
    is_product = models.BooleanField(default=False)
    feature_type = models.CharField(max_length=10, null=True, blank=True,
                                    choices=FeatureType.CHOICES)
    date_created = models.DateTimeField(auto_now_add=True)
    balance = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    is_active = models.BooleanField(default=True)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    def __str__(self):
        credit_level = ("Account-Level" if self.subscription is None
                        else "Subscription-Level")
        return ("%(level)s credit [Account %(account_id)d]%(feature)s"
                "%(product)s, balance %(balance)s" % {
                    'level': credit_level,
                    'account_id': self.account.id,
                    'feature': (' for Feature %s' % self.feature_type
                                if self.feature_type is not None else ""),
                    'product': (' for Product'
                                if self.is_product else ""),
                    'balance': self.balance,
                })

    def save(self, *args, **kwargs):
        from corehq.apps.accounting.mixins import (
            get_credits_available_for_product_in_account,
            get_credits_available_for_product_in_subscription,
        )

        super(CreditLine, self).save(*args, **kwargs)
        if self.account:
            get_credits_available_for_product_in_account.clear(self.account)
        if self.subscription:
            get_credits_available_for_product_in_subscription.clear(self.subscription)

    def adjust_credit_balance(self, amount, is_new=False, note=None,
                              line_item=None, invoice=None, customer_invoice=None,
                              payment_record=None, related_credit=None,
                              reason=None, web_user=None):
        note = note or ""
        if line_item is not None and (invoice is not None or customer_invoice is not None):
            raise CreditLineError("You may only have an invoice OR a line item making this adjustment.")
        if reason is None:
            reason = CreditAdjustmentReason.MANUAL
            if payment_record is not None:
                reason = CreditAdjustmentReason.DIRECT_PAYMENT
            elif related_credit is not None:
                reason = CreditAdjustmentReason.TRANSFER
            elif invoice is not None:
                reason = CreditAdjustmentReason.INVOICE
            elif customer_invoice is not None:
                reason = CreditAdjustmentReason.INVOICE
            elif line_item is not None:
                reason = CreditAdjustmentReason.LINE_ITEM
        if is_new:
            note = "Initialization of credit line. %s" % note
        credit_adjustment = CreditAdjustment(
            credit_line=self,
            note=note,
            amount=amount,
            reason=reason,
            payment_record=payment_record,
            line_item=line_item,
            invoice=invoice,
            customer_invoice=customer_invoice,
            related_credit=related_credit,
            web_user=web_user,
        )
        credit_adjustment.save()
        self.balance = F('balance') + amount
        self.save()
        self.refresh_from_db()

    @classmethod
    def get_credits_for_line_item(cls, line_item):
        is_product = line_item.product_rate is not None
        feature_type = (
            line_item.feature_rate.feature.feature_type
            if line_item.feature_rate is not None else None
        )

        assert is_product or feature_type
        assert not (is_product and feature_type)

        if line_item.invoice.is_customer_invoice:
            return cls.get_credits_for_line_item_in_customer_invoice(line_item, feature_type, is_product)
        else:
            return cls.get_credits_for_line_item_in_invoice(line_item, feature_type, is_product)

    @classmethod
    def get_credits_for_line_item_in_invoice(cls, line_item, feature_type, is_product):
        if feature_type:
            return itertools.chain(
                cls.get_credits_by_subscription_and_features(
                    line_item.invoice.subscription,
                    feature_type=feature_type,
                ),
                cls.get_credits_for_account(
                    line_item.invoice.subscription.account,
                    feature_type=feature_type,
                )
            )
        if is_product:
            return itertools.chain(
                cls.get_credits_by_subscription_and_features(
                    line_item.invoice.subscription,
                    is_product=True,
                ),
                cls.get_credits_for_account(
                    line_item.invoice.subscription.account,
                    is_product=True,
                )
            )

    @classmethod
    def get_credits_for_line_item_in_customer_invoice(cls, line_item, feature_type, is_product):
        if feature_type:
            return itertools.chain(
                cls.get_credits_for_subscriptions(
                    subscriptions=line_item.invoice.subscriptions.all(),
                    feature_type=feature_type
                ),
                cls.get_credits_for_account(
                    account=line_item.invoice.account,
                    feature_type=feature_type
                )
            )
        if is_product:
            return itertools.chain(
                cls.get_credits_for_subscriptions(
                    subscriptions=line_item.invoice.subscriptions.all(),
                    is_product=is_product
                ),
                cls.get_credits_for_account(
                    account=line_item.invoice.account,
                    is_product=is_product
                )
            )

    @classmethod
    def get_credits_for_invoice(cls, invoice):
        relevant_credits = [
            cls.get_credits_by_subscription_and_features(invoice.subscription),
            cls.get_credits_for_account(invoice.subscription.account)
        ]
        if invoice.subscription.next_subscription:
            # check for a transfer of subscription credits due to upgrades by
            # looking first at the active subscription or the "next" subscription
            # if the accounts don't match with the active subscription.
            active_sub = Subscription.get_active_subscription_by_domain(
                invoice.subscription.subscriber.domain
            )
            if active_sub.account == invoice.subscription.account:
                relevant_credits.append(
                    cls.get_credits_by_subscription_and_features(active_sub)
                )
            elif (invoice.subscription.next_subscription.account
                  == invoice.subscription.account):
                relevant_credits.append(
                    cls.get_credits_by_subscription_and_features(
                        invoice.subscription.next_subscription
                    )
                )
        return itertools.chain(*relevant_credits)

    @classmethod
    def get_credits_for_customer_invoice(cls, invoice):
        return itertools.chain(
            cls.get_credits_for_subscriptions(invoice.subscriptions.all()),
            cls.get_credits_for_account(invoice.account)
        )

    @classmethod
    def get_credits_for_subscriptions(cls, subscriptions, feature_type=None, is_product=False):
        credit_list = cls.objects.none()
        for subscription in subscriptions.all():
            credit_list = credit_list.union(cls.get_credits_by_subscription_and_features(
                subscription,
                feature_type=feature_type,
                is_product=is_product
            ))
        return credit_list

    @classmethod
    def get_credits_for_account(cls, account, feature_type=None, is_product=False):
        assert not (feature_type and is_product)
        return cls.objects.filter(
            account=account, subscription__exact=None, is_active=True
        ).filter(
            is_product=is_product, feature_type__exact=feature_type
        ).all()

    @classmethod
    def get_credits_by_subscription_and_features(cls, subscription,
                                                 feature_type=None,
                                                 is_product=False):
        assert not (feature_type and is_product)
        return cls.objects.filter(
            subscription=subscription,
            feature_type__exact=feature_type,
            is_product=is_product,
            is_active=True
        ).all()

    @classmethod
    def get_non_general_credits_by_subscription(cls, subscription):
        return cls.objects.filter(subscription=subscription, is_active=True).filter(
            Q(is_product=True) |
            Q(feature_type__in=[f[0] for f in FeatureType.CHOICES])
        ).all()

    @classmethod
    def add_credit(cls, amount, account=None, subscription=None,
                   is_product=False, feature_type=None, payment_record=None,
                   invoice=None, customer_invoice=None, line_item=None, related_credit=None,
                   note=None, reason=None, web_user=None, permit_inactive=False):
        if account is None and subscription is None:
            raise CreditLineError(
                "You must specify either a subscription "
                "or account to add this credit to."
            )
        if feature_type is not None and is_product:
            raise CreditLineError(
                "Can only add credit for a product OR a feature, but not both."
            )
        account = account or subscription.account
        try:
            credit_line = cls.objects.get(
                account__exact=account,
                subscription__exact=subscription,
                is_product=is_product,
                feature_type__exact=feature_type,
                is_active=True
            )
            if not permit_inactive and not credit_line.is_active and not invoice:
                raise CreditLineError(
                    "Could not add credit to CreditLine %s because it is "
                    "inactive." % str(credit_line)
                )
            is_new = False
        except cls.MultipleObjectsReturned as e:
            raise CreditLineError(
                "Could not find a unique credit line for %(account)s"
                "%(subscription)s%(feature)s%(product)s. %(error)s"
                "instead." % {
                    'account': "Account ID %d" % account.id,
                    'subscription': (" | Subscription ID %d" % subscription.id
                                     if subscription is not None else ""),
                    'feature': (" | Feature %s" % feature_type
                                if feature_type is not None else ""),
                    'product': (" | Product" if is_product else ""),
                    'error': str(e),
                }
            )
        except cls.DoesNotExist:
            credit_line = cls.objects.create(
                account=account,
                subscription=subscription,
                is_product=is_product,
                feature_type=feature_type,
            )
            is_new = True
        credit_line.adjust_credit_balance(amount, is_new=is_new, note=note,
                                          payment_record=payment_record,
                                          invoice=invoice, customer_invoice=customer_invoice, line_item=line_item,
                                          related_credit=related_credit,
                                          reason=reason, web_user=web_user)
        return credit_line

    @classmethod
    def apply_credits_toward_balance(cls, credit_lines, balance, **kwargs):
        for credit_line in credit_lines:
            if balance == Decimal('0.0000'):
                return
            if balance <= Decimal('0.0000'):
                raise CreditLineError(
                    "A balance went below zero dollars when applying credits "
                    "to credit line %d." % credit_line.pk
                )
            adjustment_amount = min(credit_line.balance, balance)
            if adjustment_amount > Decimal('0.0000'):
                credit_line.adjust_credit_balance(-adjustment_amount, **kwargs)
                balance -= adjustment_amount

    @classmethod
    def make_payment_towards_invoice(cls, invoice, payment_record):
        """ Make a payment for a billing account towards an invoice """
        if invoice.is_customer_invoice:
            billing_account = invoice.account
        else:
            billing_account = invoice.subscription.account
        cls.add_credit(
            payment_record.amount,
            account=billing_account,
            payment_record=payment_record,
        )
        cls.add_credit(
            -payment_record.amount,
            account=billing_account,
            invoice=invoice,
        )


class PaymentMethod(models.Model):
    """A link to a particular payment method for an account.
    Right now the only payment methods are via Stripe, but leaving that
    open for future changes.

    :customer_id: is used by the API of the payment method we're using that
    uniquely identifies the payer on their end.
    """
    web_user = models.CharField(max_length=80, db_index=True)
    method_type = models.CharField(max_length=50,
                                   default=PaymentMethodType.STRIPE,
                                   choices=PaymentMethodType.CHOICES,
                                   db_index=True)
    customer_id = models.CharField(max_length=255, null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'
        unique_together = ('web_user', 'method_type')


class StripePaymentMethod(PaymentMethod):
    """ Do stuff with Stripe  """
    class Meta(object):
        proxy = True
        app_label = 'accounting'

    STRIPE_GENERIC_ERROR = (stripe.error.AuthenticationError,
                            stripe.error.InvalidRequestError,
                            stripe.error.APIConnectionError,
                            stripe.error.StripeError,)

    @property
    def customer(self):
        return self._get_or_create_stripe_customer()

    def _get_or_create_stripe_customer(self):
        customer = None
        if self.customer_id is not None:
            try:
                customer = self._get_stripe_customer()
            except stripe.InvalidRequestError:
                pass
        if customer is None:
            customer = self._create_stripe_customer()
        return customer

    def _create_stripe_customer(self):
        customer = stripe.Customer.create(
            description="{}'s cards".format(self.web_user),
            email=self.web_user,
        )
        self.customer_id = customer.id
        self.save()
        return customer

    def _get_stripe_customer(self):
        return stripe.Customer.retrieve(self.customer_id)

    @property
    def all_cards(self):
        try:
            return [card for card in self.customer.cards.data if card is not None]
        except stripe.error.AuthenticationError:
            if not settings.STRIPE_PRIVATE_KEY:
                log_accounting_info("Private key is not defined in settings")
                return []
            else:
                raise

    def all_cards_serialized(self, billing_account):
        return [{
            'brand': card.brand,
            'last4': card.last4,
            'exp_month': card.exp_month,
            'exp_year': card.exp_year,
            'token': card.id,
            'is_autopay': self._is_autopay(card, billing_account),
        } for card in self.all_cards]

    def get_card(self, card_token):
        return self.customer.cards.retrieve(card_token)

    def get_autopay_card(self, billing_account):
        return next((
            card for card in self.all_cards
            if self._is_autopay(card, billing_account)
        ), None)

    def remove_card(self, card_token):
        card = self.get_card(card_token)
        self._remove_card_from_all_accounts(card)
        card.delete()

    def _remove_card_from_all_accounts(self, card):
        accounts = BillingAccount.objects.filter(auto_pay_user=self.web_user)
        for account in accounts:
            if account.autopay_card == card:
                account.remove_autopay_user()

    def create_card(self, stripe_token, billing_account, domain, autopay=False):
        customer = self.customer
        card = customer.cards.create(card=stripe_token)
        self.set_default_card(card)
        if autopay:
            self.set_autopay(card, billing_account, domain)
        return card

    def set_default_card(self, card):
        self.customer.default_card = card
        self.customer.save()
        return card

    def set_autopay(self, card, billing_account, domain):
        """
        Sets the auto_pay status on the card for a billing account

        If there are other cards that auto_pay for that billing account, remove them
        """
        if billing_account.auto_pay_enabled:
            self._remove_other_auto_pay_cards(billing_account)

        self._update_autopay_status(card, billing_account, autopay=True)
        billing_account.update_autopay_user(self.web_user, domain)

    def unset_autopay(self, card, billing_account):
        """
        Unsets the auto_pay status for this card, and removes it from the billing account
        """
        if self._is_autopay(card, billing_account):
            self._update_autopay_status(card, billing_account, autopay=False)
            billing_account.remove_autopay_user()

    def _update_autopay_status(self, card, billing_account, autopay):
        metadata = card.metadata.copy()
        metadata.update({self._auto_pay_card_metadata_key(billing_account): autopay})
        card.metadata = metadata
        card.save()

    def _remove_autopay_card(self, billing_account):
        autopay_card = self.get_autopay_card(billing_account)
        if autopay_card is not None:
            self._update_autopay_status(autopay_card, billing_account, autopay=False)

    @staticmethod
    def _remove_other_auto_pay_cards(billing_account):
        user = billing_account.auto_pay_user
        try:
            other_payment_method = StripePaymentMethod.objects.get(web_user=user)
            other_payment_method._remove_autopay_card(billing_account)
        except StripePaymentMethod.DoesNotExist:
            pass

    @staticmethod
    def _is_autopay(card, billing_account):
        return card.metadata.get(StripePaymentMethod._auto_pay_card_metadata_key(billing_account)) == 'True'

    @staticmethod
    def _auto_pay_card_metadata_key(billing_account):
        """
        Returns the autopay key for the billing account

        Cards can be used to autopay for multiple billing accounts. This is stored in the `metadata` property
        on the card: {metadata: {auto_pay_{billing_account_id_1}: True, auto_pay_{billing_account_id_2}: False}}
        """
        return 'auto_pay_{billing_account_id}'.format(billing_account_id=billing_account.id)

    def create_charge(self, card, amount_in_dollars, description):
        """ Charges a stripe card and returns a transaction id """
        amount_in_cents = int((amount_in_dollars * Decimal('100')).quantize(Decimal(10)))
        transaction_record = stripe.Charge.create(
            card=card,
            customer=self.customer,
            amount=amount_in_cents,
            currency=settings.DEFAULT_CURRENCY,
            description=description,
        )
        return transaction_record.id


class PaymentRecord(models.Model):
    """Records the transaction with external payment APIs.
    """
    payment_method = models.ForeignKey(PaymentMethod, on_delete=models.PROTECT,
                                       db_index=True)
    date_created = models.DateTimeField(auto_now_add=True)
    transaction_id = models.CharField(max_length=255, unique=True)
    amount = models.DecimalField(default=Decimal('0.0000'),
                                 max_digits=10, decimal_places=4)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    @property
    def public_transaction_id(self):
        ops_num = settings.INVOICE_STARTING_NUMBER + self.id
        return "%sP-%d" % (settings.INVOICE_PREFIX, ops_num)

    @classmethod
    def create_record(cls, payment_method, transaction_id, amount):
        return cls.objects.create(
            payment_method=payment_method,
            transaction_id=transaction_id,
            amount=amount,
        )


class CreditAdjustment(ValidateModelMixin, models.Model):
    """
    A record of any additions (positive amounts) or deductions (negative amounts) that contributed to the
    current balance of the associated CreditLine.
    """
    credit_line = models.ForeignKey(CreditLine, on_delete=models.PROTECT)
    reason = models.CharField(max_length=25, default=CreditAdjustmentReason.MANUAL,
                              choices=CreditAdjustmentReason.CHOICES)
    note = models.TextField(blank=True)
    amount = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    line_item = models.ForeignKey(LineItem, on_delete=models.PROTECT, null=True, blank=True)
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True, blank=True)
    customer_invoice = models.ForeignKey(CustomerInvoice, on_delete=models.PROTECT, null=True, blank=True)
    payment_record = models.ForeignKey(PaymentRecord,
                                       on_delete=models.PROTECT, null=True, blank=True)
    related_credit = models.ForeignKey(CreditLine, on_delete=models.PROTECT,
                                       null=True, blank=True, related_name='creditadjustment_related')
    date_created = models.DateTimeField(auto_now_add=True)
    web_user = models.CharField(max_length=80, null=True, blank=True)
    last_modified = models.DateTimeField(auto_now=True)

    class Meta(object):
        app_label = 'accounting'

    def clean(self):
        """
        Only one of either a line item or invoice may be specified as the adjuster.
        """
        if self.line_item and self.invoice:
            raise ValidationError(_("You can't specify both an invoice and a line item."))


class DomainUserHistory(models.Model):
    """
    A record of the number of users in a domain at the record_date.
    Created by task calculate_users_and_sms_in_all_domains on the first of every month.
    Used to bill clients for the appropriate number of users
    """
    domain = models.CharField(max_length=256)
    record_date = models.DateField()
    num_users = models.IntegerField(default=0)

    class Meta:
        unique_together = ('domain', 'record_date')


class CommunicationHistoryBase(models.Model):
    """
    A record of any serious correspondence we initiate with admins / billing
    contacts due to things like downgrade warnings or
    overdue notices.
    """
    date_created = models.DateField(auto_now_add=True)
    communication_type = models.CharField(
        max_length=25,
        default=CommunicationType.OTHER,
        choices=CommunicationType.CHOICES,
    )

    class Meta(object):
        abstract = True


class InvoiceCommunicationHistory(CommunicationHistoryBase):
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT)


class CustomerInvoiceCommunicationHistory(CommunicationHistoryBase):
    invoice = models.ForeignKey(CustomerInvoice, on_delete=models.PROTECT)
