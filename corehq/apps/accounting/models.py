import datetime
from decimal import Decimal
import logging
from couchdbkit.ext.django.schema import DateTimeProperty, StringProperty

from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist, ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models
from django.utils.translation import ugettext_lazy as _
from corehq import toggles
from corehq.apps.accounting.utils import is_active_subscription, get_privileges
from corehq.apps.accounting.subscription_changes import (
    DomainDowngradeActionHandler, DomainUpgradeActionHandler,
)
from corehq.apps.users.models import WebUser
from dimagi.utils.decorators.memoized import memoized

from django_prbac.models import Role
from dimagi.utils.couch.database import SafeSaveDocument

from corehq.apps.accounting.exceptions import (CreditLineError, AccountingError, SubscriptionAdjustmentError,
                                               SubscriptionChangeError, NewSubscriptionError)
from corehq.apps.accounting.utils import EXCHANGE_RATE_DECIMAL_PLACES, assure_domain_instance, get_change_status

global_logger = logging.getLogger(__name__)
integer_field_validators = [MaxValueValidator(2147483647), MinValueValidator(-2147483648)]


class BillingAccountType(object):
    CONTRACT = "CONTRACT"
    USER_CREATED = "USER_CREATED"
    INVOICE_GENERATED = "INVOICE_GENERATED"
    CHOICES = (
        (CONTRACT, "Created by contract"),
        (USER_CREATED, "Created by user"),
        (INVOICE_GENERATED, "Generated by an invoice"),
    )


class FeatureType(object):
    USER = "User"
    SMS = "SMS"
    API = "API"
    CHOICES = (
        (USER, USER),
        (SMS, SMS),
    )


class SoftwareProductType(object):
    COMMCARE = "CommCare"
    COMMTRACK = "CommTrack"
    COMMCONNECT = "CommConnect"
    CHOICES = (
        (COMMCARE, COMMCARE),
        (COMMTRACK, COMMTRACK),
        (COMMCONNECT, COMMCONNECT),
    )

    @classmethod
    def get_type_by_domain(cls, domain):
        if domain.commtrack_enabled:
            return cls.COMMTRACK
        if domain.commconnect_enabled:
            return cls.COMMCONNECT
        return cls.COMMCARE


class SoftwarePlanEdition(object):
    COMMUNITY = "Community"
    STANDARD = "Standard"
    PRO = "Pro"
    ADVANCED = "Advanced"
    ENTERPRISE = "Enterprise"
    CHOICES = (
        (COMMUNITY, COMMUNITY),
        (STANDARD, STANDARD),
        (PRO, PRO),
        (ADVANCED, ADVANCED),
        (ENTERPRISE, ENTERPRISE),
    )


class SoftwarePlanVisibility(object):
    PUBLIC = "PUBLIC"
    INTERNAL = "INTERNAL"
    CHOICES = (
        (PUBLIC, "Anyone can subscribe"),
        (INTERNAL, "Dimagi must create subscription"),
    )


class CreditAdjustmentReason(object):
    DIRECT_PAYMENT = "DIRECT_PAYMENT"
    SALESFORCE = "SALESFORCE"
    INVOICE = "INVOICE"
    LINE_ITEM = "LINE_ITEM"
    TRANSFER = "TRANSFER"
    MANUAL = "MANUAL"
    CHOICES = (
        (MANUAL, "manual"),
        (SALESFORCE, "via Salesforce"),
        (INVOICE, "invoice generated"),
        (LINE_ITEM, "line item generated"),
        (TRANSFER, "transfer from another credit line"),
        (DIRECT_PAYMENT, "payment from client received"),
    )


class SubscriptionAdjustmentReason(object):
    CREATE = "CREATE"
    MODIFY = "MODIFY"
    CANCEL = "CANCEL"
    UPGRADE = "UPGRADE"
    DOWNGRADE = "DOWNGRADE"
    SWITCH = "SWITCH"
    CHOICES = (
        (CREATE, "A new subscription created from scratch."),
        (MODIFY, "Some part of the subscription was modified...likely a date."),
        (CANCEL, "The subscription was cancelled with no followup subscription."),
        (UPGRADE, "The subscription was upgraded to the related subscription."),
        (DOWNGRADE, "The subscription was downgraded to the related subscription."),
        (SWITCH, "The plan was changed to the related subscription and was neither an upgrade or downgrade.")
    )


class SubscriptionAdjustmentMethod(object):
    USER = "USER"
    INTERNAL = "INTERNAL"
    TASK = "TASK"
    CHOICES = (
        (USER, "This modification was made through a public UI."),
        (INTERNAL, "This modification was made through an internal UI."),
        (TASK, "The subscription was modified by a task (like an invoice)."),
    )


class Currency(models.Model):
    """
    Keeps track of the current conversion rates so that we don't have to poll the free, but rate limited API
    from Open Exchange Rates. Necessary for billing things like MACH SMS.
    """
    code = models.CharField(max_length=3, unique=True)
    name = models.CharField(max_length=25, db_index=True)
    symbol = models.CharField(max_length=10)
    rate_to_default = models.DecimalField(
        default=Decimal('1.0'), max_digits=20,
        decimal_places=EXCHANGE_RATE_DECIMAL_PLACES,
    )
    date_updated = models.DateField(auto_now=True)

    @classmethod
    def get_default(cls):
        default, _ = cls.objects.get_or_create(code=settings.DEFAULT_CURRENCY)
        return default


class BillingAccountAdmin(models.Model):
    web_user = models.CharField(max_length=80, unique=True, db_index=True)

    @classmethod
    def get_admin_status_and_account(cls, web_user, domain):
        if not isinstance(web_user, WebUser):
            return False, None
        account = BillingAccount.get_account_by_domain(domain)
        if account is None:
            return web_user.is_domain_admin(domain), None
        admin = account.billing_admins.filter(web_user=web_user.username)
        return admin.count() > 0, account


class BillingAccount(models.Model):
    """
    The key model that links a Subscription to its financial source and methods of payment.
    """
    name = models.CharField(max_length=200, db_index=True)
    salesforce_account_id = models.CharField(
        db_index=True,
        max_length=80,
        blank=True,
        null=True,
        help_text="This is how we link to the salesforce account",
    )
    created_by = models.CharField(max_length=80)
    created_by_domain = models.CharField(max_length=25, null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    billing_admins = models.ManyToManyField(BillingAccountAdmin, null=True)
    currency = models.ForeignKey(Currency, on_delete=models.PROTECT)
    is_auto_invoiceable = models.BooleanField(default=False)
    date_confirmed_extra_charges = models.DateTimeField(null=True, blank=True)
    account_type = models.CharField(
        max_length=25,
        default=BillingAccountType.CONTRACT,
        choices=BillingAccountType.CHOICES,
    )

    @property
    def balance(self):
        # todo compute
        return 0.0

    @classmethod
    def get_or_create_account_by_domain(cls, domain, created_by=None, account_type=None):
        """
        First try to grab the account used for the last subscription.
        If an account is not found, create it.
        """
        is_new = False
        account = cls.get_account_by_domain(domain)
        if account is None:
            is_new = True
            account_type = account_type or BillingAccountType.INVOICE_GENERATED
            account = BillingAccount(
                name="Account for Project %s" % domain,
                created_by=created_by,
                created_by_domain=domain,
                currency=Currency.get_default(),
                account_type=account_type,
            )
            account.save()
            billing_admin = BillingAccountAdmin.objects.get_or_create(web_user=created_by)[0]
            account.billing_admins.add(billing_admin)
            account.save()
        return account, is_new

    @classmethod
    def get_account_by_domain(cls, domain):
        try:
            last_subscription = Subscription.objects.filter(subscriber__domain=domain).latest('date_end')
            return last_subscription.account
        except ObjectDoesNotExist:
            pass
        try:
            return cls.objects.get(created_by_domain=domain)
        except cls.DoesNotExist:
            pass
        except cls.MultipleObjectsReturned:
            global_logger.error("Multiple billing accounts showed up for the domain '%s'. The "
                                "latest one was served, but you should reconcile very soon." % domain)
            return cls.objects.filter(created_by_domain=domain).latest('date_created')


class BillingContactInfo(models.Model):
    account = models.OneToOneField(BillingAccount, primary_key=True, null=False)
    first_name = models.CharField(
        max_length=50, null=True, blank=True, verbose_name=_("First Name")
    )
    last_name = models.CharField(
        max_length=50, null=True, blank=True, verbose_name=_("Last Name")
    )
    emails = models.CharField(
        max_length=200, null=True, blank=True, verbose_name=_("Additional Contact Emails"),
        help_text=_("We will email communications to the emails specified here and the emails "
                    "of the Billing Administrators.")
    )
    phone_number = models.CharField(max_length=20, null=True, blank=True, verbose_name=_("Phone Number"))
    company_name = models.CharField(max_length=50, null=True, blank=True, verbose_name=_("Company / Organization"))
    first_line = models.CharField(max_length=50, null=False, verbose_name=_("Address First Line"))
    second_line = models.CharField(max_length=50, null=True, blank=True, verbose_name=_("Address Second Line"))
    city = models.CharField(max_length=50, null=False, verbose_name=_("City"))
    state_province_region = models.CharField(max_length=50, null=False, verbose_name=_("State / Province / Region"))
    postal_code = models.CharField(max_length=20, null=False, verbose_name=_("Postal Code"))
    country = models.CharField(max_length=50, null=False, verbose_name=_("Country"))


class SoftwareProduct(models.Model):
    """
    Specifies a product name that can be included in a subscription. e.g. CommTrack Pro, CommCare Community, etc.
    """
    name = models.CharField(max_length=40, unique=True)
    product_type = models.CharField(max_length=25, db_index=True, choices=SoftwareProductType.CHOICES)

    def __str__(self):
        return "Software Product '%s' of type '%s'" % (self.name, self.product_type)

    def get_rate(self, default_instance=True):
        try:
            return self.softwareproductrate_set.filter(is_active=True).latest('date_created')
        except SoftwareProductRate.DoesNotExist:
            return SoftwareProductRate() if default_instance else None  # the defaults


class SoftwareProductRate(models.Model):
    """
    Links a SoftwareProduct to a monthly fee.
    Once created, ProductRates cannot be modified. Instead, a new ProductRate must be created.
    """
    product = models.ForeignKey(SoftwareProduct, on_delete=models.PROTECT)
    monthly_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return '%s @ $%s /month' % (self.product.name, self.monthly_fee)

    def __eq__(self, other):
        if not isinstance(other, self.__class__) or not self.product.pk == other.product.pk:
            return False
        for field in ['monthly_fee', 'is_active']:
            if not getattr(self, field) == getattr(other, field):
                return False
        return True

    @classmethod
    def new_rate(cls, product_name, monthly_fee, save=True):
        product, _ = SoftwareProduct.objects.get_or_create(name=product_name)
        rate = SoftwareProductRate(product=product, monthly_fee=monthly_fee)
        if save:
            rate.save()
        return rate


class Feature(models.Model):
    """
    This is what will link a feature type (USER, API, etc.) to a name (Users Pro, API Standard, etc.) and will be what
    the FeatureRate references to provide a monthly fee, limit and per-excess fee.
    """
    name = models.CharField(max_length=40, unique=True)
    feature_type = models.CharField(max_length=10, db_index=True, choices=FeatureType.CHOICES)

    def __str__(self):
        return "Feature '%s' of type '%s'" % (self.name, self.feature_type)

    def get_rate(self, default_instance=True):
        try:
            return self.featurerate_set.filter(is_active=True).latest('date_created')
        except FeatureRate.DoesNotExist:
            return FeatureRate() if default_instance else None  # the defaults


class FeatureRate(models.Model):
    """
    Links a feature to a monthly fee, monthly limit, and a per-excess fee for exceeding the monthly limit.
    Once created, Feature Rates cannot be modified. Instead, a new Feature Rate must be created.
    """
    feature = models.ForeignKey(Feature, on_delete=models.PROTECT)
    monthly_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2,
                                      verbose_name="Monthly Fee")
    monthly_limit = models.IntegerField(default=0,
                                        verbose_name="Monthly Included Limit",
                                        validators=integer_field_validators)
    per_excess_fee = models.DecimalField(default=Decimal('0.00'), max_digits=10, decimal_places=2,
                                         verbose_name="Fee Per Excess of Limit")
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return '%s @ $%s /month, $%s /excess, limit: %d' % (
            self.feature.name, self.monthly_fee, self.per_excess_fee, self.monthly_limit
        )

    def __eq__(self, other):
        if not isinstance(other, self.__class__) or not self.feature.pk == other.feature.pk:
            return False
        for field in ['monthly_fee', 'monthly_limit', 'per_excess_fee', 'is_active']:
            if not getattr(self, field) == getattr(other, field):
                return False
        return True

    @classmethod
    def new_rate(cls, feature_name, feature_type,
                 monthly_fee=None, monthly_limit=None, per_excess_fee=None, save=True):
        feature, _ = Feature.objects.get_or_create(name=feature_name, feature_type=feature_type)
        rate = FeatureRate(feature=feature)

        if monthly_fee is not None:
            rate.monthly_fee = monthly_fee
        if monthly_limit is not None:
            rate.monthly_limit = monthly_limit
        if per_excess_fee is not None:
            rate.per_excess_fee = per_excess_fee

        if save:
            rate.save()
        return rate


class SoftwarePlan(models.Model):
    """
    Subscriptions are created for Software Plans. Software Plans can have many Software Plan Versions, which
    link the Software Plan to a set of permissions roles.
    """
    name = models.CharField(max_length=80, unique=True)
    description = models.TextField(blank=True,
                                   help_text="If the visibility is INTERNAL, this description field will be used.")
    edition = models.CharField(
        max_length=25,
        default=SoftwarePlanEdition.ENTERPRISE,
        choices=SoftwarePlanEdition.CHOICES,
    )
    visibility = models.CharField(
        max_length=10,
        default=SoftwarePlanVisibility.INTERNAL,
        choices=SoftwarePlanVisibility.CHOICES,
    )

    def get_version(self):
        try:
            return self.softwareplanversion_set.filter(is_active=True).latest('date_created')
        except SoftwarePlanVersion.DoesNotExist:
            return None


class DefaultProductPlan(models.Model):
    """
    This links a product type to its default SoftwarePlan (i.e. the Community Plan).
    The latest SoftwarePlanVersion that's linked to this plan will be the one used to create a new subscription if
    nothing is found for that domain.
    """
    product_type = models.CharField(max_length=25, choices=SoftwareProductType.CHOICES)
    edition = models.CharField(
        default=SoftwarePlanEdition.COMMUNITY,
        choices=SoftwarePlanEdition.CHOICES,
        max_length=25,
    )
    plan = models.ForeignKey(SoftwarePlan, on_delete=models.PROTECT)

    @classmethod
    def get_default_plan_by_domain(cls, domain, edition=None):
        domain = assure_domain_instance(domain)
        edition = edition or SoftwarePlanEdition.COMMUNITY
        product_type = SoftwareProductType.get_type_by_domain(domain)
        try:
            default_product_plan = DefaultProductPlan.objects.get(product_type=product_type,
                                                                  edition=edition)
            return default_product_plan.plan.get_version()
        except DefaultProductPlan.DoesNotExist:
            raise AccountingError("No default product plan was set up, did you forget to bootstrap plans?")

    @classmethod
    def get_lowest_edition_for_privilege_by_domain(cls, domain, privilege_slug):
        edition_order = [
            SoftwarePlanEdition.COMMUNITY,
            SoftwarePlanEdition.STANDARD,
            SoftwarePlanEdition.PRO,
            SoftwarePlanEdition.ADVANCED,
            SoftwarePlanEdition.ENTERPRISE,
        ]
        for edition in edition_order:
            plan_version = cls.get_default_plan_by_domain(
                domain, edition=edition
            )
            privileges = get_privileges(plan_version)
            if privilege_slug in privileges:
                return plan_version.plan.edition
        return SoftwarePlanEdition.ENTERPRISE


class SoftwarePlanVersion(models.Model):
    """
    Links a plan to its rates and provides versioning information.
    Once a new SoftwarePlanVersion is created, it cannot be modified. Instead, a new SofwarePlanVersion
    must be created.
    """
    plan = models.ForeignKey(SoftwarePlan, on_delete=models.PROTECT)
    product_rates = models.ManyToManyField(SoftwareProductRate, blank=True)
    feature_rates = models.ManyToManyField(FeatureRate, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    role = models.ForeignKey(Role)

    def __str__(self):
        return "Software Plan Version For Plan '%s' with Role '%s'" % (self.plan.name, self.role.slug)

    @property
    def user_facing_description(self):
        from corehq.apps.accounting.user_text import DESC_BY_EDITION, FEATURE_TYPE_TO_NAME
        product = self.product_rates.get()
        desc = {
            'name': self.plan.name,
            'description': self.plan.description,
        }
        if self.plan.visibility == SoftwarePlanVisibility.PUBLIC:
            try:
                desc = DESC_BY_EDITION[self.plan.edition]
            except KeyError:
                pass
        desc.update({
            'monthly_fee': 'USD %s' % product.monthly_fee,
            'rates': [{'name': FEATURE_TYPE_TO_NAME[r.feature.feature_type],
                       'included': 'Infinite' if r.monthly_limit == -1 else r.monthly_limit}
                      for r in self.feature_rates.all()],
            'edition': self.plan.edition,
        })
        return desc

    @property
    @memoized
    def user_feature(self):
        user_features = self.feature_rates.filter(feature__feature_type=FeatureType.USER)
        try:
            user_feature = user_features.order_by('monthly_limit')[0]
            if not user_feature.monthly_limit == -1:
                user_feature = user_features.order_by('-monthly_limit')[0]
            return user_feature
        except IndexError:
            pass


    @property
    def user_limit(self):
        if self.user_feature is not None:
            return self.user_feature.monthly_limit
        return -1

    @property
    def user_fee(self):
        if self.user_feature is not None:
            return "USD %d" % self.user_feature.per_excess_fee


class SubscriberManager(models.Manager):

    def safe_get(self, *args, **kwargs):
        try:
            return self.get(*args, **kwargs)
        except Subscriber.DoesNotExist:
            return None


class Subscriber(models.Model):
    """
    The objects that can be subscribed to a Subscription.
    """
    domain = models.CharField(max_length=25, null=True, db_index=True)
    organization = models.CharField(max_length=25, null=True, db_index=True)

    objects = SubscriberManager()

    def __str__(self):
        if self.organization:
            return "ORGANIZATION %s" % self.organization
        return "DOMAIN %s" % self.domain

    def apply_upgrades_and_downgrades(self, downgraded_privileges=None,
                                      upgraded_privileges=None,
                                      new_plan_version=None,
                                      verbose=False):

        if self.organization is not None:
            raise SubscriptionChangeError("Only domain upgrades and downgrades are possible.")

        if new_plan_version is None:
            new_plan_version = DefaultProductPlan.get_default_plan_by_domain(self.domain)

        if downgraded_privileges is None or upgraded_privileges is None:
            dp, up = get_change_status(None, new_plan_version)[1:]
            downgraded_privileges = downgraded_privileges or dp
            upgraded_privileges = upgraded_privileges or up

        if downgraded_privileges:
            downgrade_handler = DomainDowngradeActionHandler(
                self.domain, new_plan_version, downgraded_privileges,
                verbose=verbose,
            )
            if not downgrade_handler.get_response():
                raise SubscriptionChangeError("The downgrade was not successful.")

        if upgraded_privileges:
            upgrade_handler = DomainUpgradeActionHandler(
                self.domain, new_plan_version, upgraded_privileges,
                verbose=verbose,
            )
            if not upgrade_handler.get_response():
                raise SubscriptionChangeError("The upgrade was not successful.")


class Subscription(models.Model):
    """
    Links a Subscriber to a SoftwarePlan and BillingAccount, necessary for invoicing.
    """
    account = models.ForeignKey(BillingAccount, on_delete=models.PROTECT)
    plan_version = models.ForeignKey(SoftwarePlanVersion, on_delete=models.PROTECT)
    subscriber = models.ForeignKey(Subscriber, on_delete=models.PROTECT)
    salesforce_contract_id = models.CharField(blank=True, null=True, max_length=80)
    date_start = models.DateField()
    date_end = models.DateField(blank=True, null=True)
    date_delay_invoicing = models.DateField(blank=True, null=True)
    date_created = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=False)
    do_not_invoice = models.BooleanField(default=False)

    def cancel_subscription(self, adjustment_method=None, web_user=None, note=None):
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL
        today = datetime.date.today()
        if self.date_end is not None and today > self.date_end:
            raise SubscriptionAdjustmentError("The end date for this subscription already passed.")
        self.subscriber.apply_upgrades_and_downgrades()
        self.date_end = today
        self.is_active = False
        self.save()
        SubscriptionAdjustment.record_adjustment(
            self, reason=SubscriptionAdjustmentReason.CANCEL, method=adjustment_method, note=note, web_user=web_user,
        )

    def change_plan(self, new_plan_version, date_start=None, date_end=None, date_delay_invoicing=None,
                    salesforce_contract_id=None, do_not_invoice=False,
                    note=None, web_user=None, adjustment_method=None):
        """
        Changing a plan terminates the current subscription and creates a new subscription where the old plan
        left off.
        """
        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL

        adjustment_reason, downgrades, upgrades = get_change_status(self.plan_version, new_plan_version)
        self.subscriber.apply_upgrades_and_downgrades(
            downgraded_privileges=downgrades, upgraded_privileges=upgrades,
            new_plan_version=new_plan_version)

        today = datetime.date.today()
        new_start_date = today if self.date_start <= today else (date_start or self.date_start)

        new_is_active = is_active_subscription(new_start_date, date_end)
        new_salesforce_contract_id = (
            salesforce_contract_id if salesforce_contract_id is not None
            else self.salesforce_contract_id)

        if self.date_start > today:
            self.date_start = today
        if self.date_end is None or self.date_end > today:
            self.date_end = today
        if self.date_delay_invoicing is not None and self.date_delay_invoicing > today:
            self.date_delay_invoicing = today
        self.is_active = False
        self.save()

        new_subscription = Subscription.new_domain_subscription(
            self.account, self.subscriber.domain, new_plan_version,
            date_start=new_start_date,
            date_end=date_end,
            date_delay_invoicing=date_delay_invoicing,
            salesforce_contract_id=new_salesforce_contract_id,
            is_active=new_is_active,
            do_not_invoice=do_not_invoice,
            adjustment_method=adjustment_method,
            note=note,
            web_user=web_user
         )

        # record transfer from old subscription
        SubscriptionAdjustment.record_adjustment(self, method=adjustment_method, note=note, web_user=web_user,
                                                 reason=adjustment_reason, related_subscription=new_subscription)

        return new_subscription

    @classmethod
    def _get_plan_by_subscriber(cls, subscriber):
        try:
            active_subscriptions = cls.objects.filter(subscriber=subscriber, is_active=True)
            if active_subscriptions.count() > 1:
                global_logger.error("There seem to be multiple ACTIVE subscriptions for the subscriber %s. "
                                    "Odd, right? The latest one by date_created was used, but consider this an "
                                    "issue." % subscriber)
            current_subscription = active_subscriptions.latest('date_created')
            return current_subscription.plan_version, current_subscription
        except Subscription.DoesNotExist:
            pass
        return None, None

    @classmethod
    def get_subscribed_plan_by_organization(cls, organization):
        """
        Returns SoftwarePlanVersion, Subscription for the given organization.
        """
        subscriber = Subscriber.objects.safe_get(organization=organization, domain=None)
        return cls._get_plan_by_subscriber(subscriber) if subscriber else None, None

    @classmethod
    def get_subscribed_plan_by_domain(cls, domain):
        """
        Returns SoftwarePlanVersion, Subscription for the given domain.
        """
        domain_obj = assure_domain_instance(domain)
        if domain_obj is None:
            # need more info to troubleshoot this further
            logging.error("Tried to fetch a subscription for a domain that was not properly located. "
                          "Domain name is %s." % domain)
            plan_version = DefaultProductPlan.objects.get(edition=SoftwarePlanEdition.COMMUNITY,
                                                          product_type=SoftwareProductType.COMMCARE).plan.get_version()
            return plan_version, None
        domain = domain_obj
        subscriber = Subscriber.objects.safe_get(domain=domain.name, organization=None)
        plan_version, subscription = (cls._get_plan_by_subscriber(subscriber) if subscriber
                                      else cls.get_subscribed_plan_by_organization(domain.organization))
        if plan_version is None:
            plan_version = DefaultProductPlan.get_default_plan_by_domain(domain)
        return plan_version, subscription
    
    @classmethod
    def new_domain_subscription(cls, account, domain, plan_version, date_start=None, adjustment_method=None,
                                note=None, web_user=None, **kwargs):
        subscriber = Subscriber.objects.get_or_create(domain=domain, organization=None)[0]
        today = datetime.date.today()
        future_subscriptions = Subscription.objects.filter(
            models.Q(subscriber=subscriber, date_end__gt=today) | models.Q(subscriber=subscriber, date_end__exact=None)
        )
        if future_subscriptions.filter(is_active=True).count() > 0:
            raise NewSubscriptionError(_("Project '%s' currently has an active subscription. "
                                         "Please cancel the current subscription.") % domain)
        try:
            next_subscription = future_subscriptions.filter(date_start__gt=today).order_by('date_start')[0]
            date_end = kwargs.get('date_end')
            if date_end is None or date_end > next_subscription.date_start:
                raise NewSubscriptionError(_("The end date for this subscription overlaps with the start date "
                                             "of the next subscription on %s. Please cancel this subscription first.")
                                           % next_subscription.date_start)
        except (Subscription.DoesNotExist, IndexError):
            pass

        adjustment_method = adjustment_method or SubscriptionAdjustmentMethod.INTERNAL
        subscription = Subscription(
            account=account,
            plan_version=plan_version,
            subscriber=subscriber,
            date_start=date_start or datetime.date.today(),
            **kwargs
        )
        subscription.save()
        subscriber.apply_upgrades_and_downgrades(new_plan_version=plan_version)
        SubscriptionAdjustment.record_adjustment(subscription, method=adjustment_method, note=note, web_user=web_user)
        return subscription


class Invoice(models.Model):
    """
    This is what we'll use to calculate the balance on the accounts based on the current balance
    held by the Invoice. Balance updates will be tied to CreditAdjustmentTriggers which are tied
    to CreditAdjustments.
    """
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT)
    tax_rate = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    balance = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    date_due = models.DateField(db_index=True)
    date_paid = models.DateField(blank=True, null=True)
    date_created = models.DateTimeField(auto_now_add=True)
    date_received = models.DateField(blank=True, db_index=True, null=True)
    date_start = models.DateField()
    date_end = models.DateField()

    @property
    def subtotal(self):
        """
        This will be inserted in the subtotal field on the printed invoice.
        """
        if self.lineitem_set.count() == 0:
            return Decimal('0.0000')
        return sum([line_item.total for line_item in self.lineitem_set.all()])

    @property
    def applied_tax(self):
        return self.tax_rate * self.subtotal

    @property
    def applied_credit(self):
        if self.creditadjustment_set.count() == 0:
            return Decimal('0.0000')
        return sum([credit.amount for credit in self.creditadjustment_set.all()])

    def get_total(self):
        """
        This will be inserted in the total field on the printed invoice.
        """
        return self.subtotal + self.applied_tax + self.applied_credit

    def update_balance(self):
        self.balance = self.get_total()

    def calculate_credit_adjustments(self):
        """
        This goes through all credit lines that:
        - do not have feature/product rates, but specify the related subscription and billing account
        - do not have feature/product rates or a subscription, but specify the related billing account
        """
        # first apply credits to all the line items
        for line_item in self.lineitem_set.all():
            line_item.calculate_credit_adjustments()

        # finally, apply credits to the leftover invoice balance
        current_total = self.get_total()
        credit_lines = CreditLine.get_credits_for_invoice(self)
        CreditLine.apply_credits_toward_balance(credit_lines, current_total, dict(invoice=self))


class SubscriptionAdjustment(models.Model):
    """
    A record of any adjustments made to a subscription, so we always have a paper trail.
    Things that cannot be modified after a subscription is created:
    - account
    - plan
    - subscriber
    Things that have limited modification abilities:
    - dates if the current date is today or earlier
    All other modifications require cancelling the current subscription and creating a new one.

    Note: related_subscription is the subscription to be filled in when the subscription is upgraded / downgraded.
    """
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT)
    reason = models.CharField(max_length=50, default=SubscriptionAdjustmentReason.CREATE,
                              choices=SubscriptionAdjustmentReason.CHOICES)
    method = models.CharField(max_length=50, default=SubscriptionAdjustmentMethod.INTERNAL,
                              choices=SubscriptionAdjustmentMethod.CHOICES)
    note = models.TextField(null=True)
    web_user = models.CharField(max_length=80, null=True)
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True)
    related_subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT, null=True,
                                             related_name='subscriptionadjustment_related')
    date_created = models.DateField(auto_now_add=True)
    new_date_start = models.DateField()
    new_date_end = models.DateField(blank=True, null=True)
    new_date_delay_invoicing = models.DateField(blank=True, null=True)
    new_salesforce_contract_id = models.CharField(blank=True, null=True, max_length=80)

    @classmethod
    def record_adjustment(cls, subscription, **kwargs):
        adjustment = SubscriptionAdjustment(
            subscription=subscription,
            new_date_start=subscription.date_start,
            new_date_end=subscription.date_end,
            new_date_delay_invoicing=subscription.date_delay_invoicing,
            new_salesforce_contract_id=subscription.salesforce_contract_id,
            **kwargs
        )
        adjustment.save()
        return adjustment


class BillingRecord(models.Model):
    """
    This stores any interaction we have with the client in sending a physical / pdf invoice to their contact email.
    """
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT)
    date_emailed = models.DateField(auto_now_add=True, db_index=True)
    emailed_to = models.CharField(max_length=254, db_index=True)
    pdf_data_id = models.CharField(max_length=48)

    @property
    def pdf(self):
        return InvoicePdf.get(self.pdf_data_id)


class InvoicePdf(SafeSaveDocument):
    invoice_id = StringProperty()
    date_created = DateTimeProperty()

    def generate_pdf(self, invoice):
        # todo generate pdf
        invoice.pdf_data_id = self._id
        # self.put_attachment(pdf_data)
        self.invoice_id = invoice.id
        self.date_created = datetime.datetime.now()


class LineItemManager(models.Manager):
    def get_products(self):
        return self.get_query_set().filter(feature_rate__exact=None)

    def get_features(self):
        return self.get_query_set().filter(product_rate__exact=None)

    def get_feature_by_type(self, feature_type):
        return self.get_query_set().filter(feature_rate__feature__feature_type=feature_type)


class LineItem(models.Model):
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT)
    feature_rate = models.ForeignKey(FeatureRate, on_delete=models.PROTECT, null=True)
    product_rate = models.ForeignKey(SoftwareProductRate, on_delete=models.PROTECT, null=True)
    base_description = models.TextField(blank=True, null=True)
    base_cost = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    unit_description = models.TextField(blank=True, null=True)
    unit_cost = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    quantity = models.IntegerField(default=1)

    objects = LineItemManager()

    @property
    def subtotal(self):
        return self.base_cost + self.unit_cost * self.quantity

    @property
    def applied_credit(self):
        """
        The total amount of credit applied specifically to this LineItem.
        """
        if self.creditadjustment_set.count() == 0:
            return Decimal('0.0000')
        return sum([credit.amount for credit in self.creditadjustment_set.all()])

    @property
    def total(self):
        return self.subtotal + self.applied_credit

    def calculate_credit_adjustments(self):
        """
        This goes through all credit lines that:
        - specify the related feature or product rate that generated this line item
        """
        current_total = self.total
        credit_lines = CreditLine.get_credits_for_line_item(self)
        CreditLine.apply_credits_toward_balance(credit_lines, current_total, dict(line_item=self))


class CreditLine(models.Model):
    """
    The amount of money in USD that exists can can be applied toward a specific account,
    a specific subscription, or specific rates in that subscription.
    """
    account = models.ForeignKey(BillingAccount, on_delete=models.PROTECT)
    subscription = models.ForeignKey(Subscription, on_delete=models.PROTECT, null=True, blank=True)
    product_rate = models.ForeignKey(SoftwareProductRate, on_delete=models.PROTECT, null=True, blank=True)
    feature_rate = models.ForeignKey(FeatureRate, on_delete=models.PROTECT, null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    balance = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)

    def adjust_credit_balance(self, amount, is_new=False, note=None, line_item=None, invoice=None):
        reason = CreditAdjustmentReason.MANUAL
        note = note or ""
        if line_item is not None and invoice is not None:
            raise CreditLineError("You may only have an invoice OR a line item making this adjustment.")
        if line_item is not None:
            reason = CreditAdjustmentReason.LINE_ITEM
        if invoice is not None:
            reason = CreditAdjustmentReason.INVOICE
        if is_new:
            note = "Initialization of credit line. %s" % note
        credit_adjustment = CreditAdjustment(
            credit_line=self,
            note=note,
            amount=amount,
            reason=reason,
            line_item=line_item,
            invoice=invoice,
        )
        credit_adjustment.save()
        self.balance += amount
        self.save()

    @classmethod
    def get_credits_for_line_item(cls, line_item):
        return cls.get_credits_by_subscription_and_features(
            line_item.invoice.subscription,
            product_rate=line_item.product_rate,
            feature_rate=line_item.feature_rate
        )

    @classmethod
    def get_credits_for_invoice(cls, invoice):
        return cls.get_credits_by_subscription_and_features(invoice.subscription)

    @classmethod
    def get_credits_by_subscription_and_features(cls, subscription, feature_rate=None, product_rate=None):
        return cls.objects.filter(
            models.Q(subscription=subscription) |
            models.Q(account=subscription.account, subscription__exact=None)
        ).filter(
            product_rate__exact=product_rate, feature_rate__exact=feature_rate
        ).all()

    @classmethod
    def add_account_credit(cls, amount, account, note=None):
        cls._validate_add_amount(amount)
        credit_line, is_created = cls.objects.get_or_create(
            account=account,
            subscription__exact=None,
            product_rate__exact=None,
            feature_rate__exact=None,
        )
        credit_line.adjust_credit_balance(amount, is_new=is_created, note=note)
        return credit_line

    @classmethod
    def add_subscription_credit(cls, amount, subscription, note=None):
        cls._validate_add_amount(amount)
        credit_line, is_created = cls.objects.get_or_create(
            account=subscription.account,
            subscription=subscription,
            product_rate__exact=None,
            feature_rate__exact=None,
        )
        credit_line.adjust_credit_balance(amount, is_new=is_created, note=note)
        return credit_line

    @classmethod
    def add_rate_credit(cls, amount, account, product_rate=None, feature_rate=None, subscription=None, note=None):
        if (feature_rate is None and product_rate is None) or (feature_rate is not None and product_rate is not None):
            raise ValueError("You must specify a product rate OR a feature rate")
        cls._validate_add_amount(amount)
        credit_line, is_created = cls.objects.get_or_create(
            account=account, subscription=subscription, product_rate=product_rate, feature_rate=feature_rate,
        )
        credit_line.adjust_credit_balance(amount, is_new=is_created, note=note)
        return credit_line

    @classmethod
    def apply_credits_toward_balance(cls, credit_lines, balance, adjust_balance_kwarg):
        for credit_line in credit_lines:
            if balance == Decimal('0.0000'):
                return
            if balance <= Decimal('0.0000'):
                raise CreditLineError("A balance went below zero dollars when applying credits.")
            adjustment_amount = min(credit_line.balance, balance)
            if adjustment_amount > Decimal('0.0000'):
                credit_line.adjust_credit_balance(-adjustment_amount, **adjust_balance_kwarg)
                balance -= adjustment_amount
        return balance

    @staticmethod
    def _validate_add_amount(amount):
        if not isinstance(amount, Decimal):
            raise ValueError("Amount must be a Decimal.")


class CreditAdjustment(models.Model):
    """
    A record of any addition (positive amounts) s or deductions (negative amounts) that contributed to the
    current balance of the associated CreditLine.
    """
    credit_line = models.ForeignKey(CreditLine, on_delete=models.PROTECT)
    reason = models.CharField(max_length=25, default=CreditAdjustmentReason.MANUAL,
                              choices=CreditAdjustmentReason.CHOICES)
    note = models.TextField()
    amount = models.DecimalField(default=Decimal('0.0000'), max_digits=10, decimal_places=4)
    line_item = models.ForeignKey(LineItem, on_delete=models.PROTECT, null=True)
    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True)
    # todo payment_method = models.ForeignKey(PaymentMethod)
    date_created = models.DateTimeField(auto_now_add=True)
    web_user = models.CharField(max_length=80, null=True)

    def clean(self):
        """
        Only one of either a line item or invoice may be specified as the adjuster.
        """
        if self.line_item and self.invoice is not None:
            raise ValidationError("You can't specify both an invoice and a line item.")
