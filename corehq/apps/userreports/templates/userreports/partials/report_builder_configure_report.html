{% extends "userreports/base_report_builder.html" %}
{% load i18n %}
{% load hq_shared_tags %}

{% block js %}{{ block.super }}
    <script src="{% new_static 'style/js/bootstrap3/main.js' %}"></script>
    <script src="{% new_static 'app_manager/js/case-knockout-bindings.js' %}"></script>
{% endblock %}

{% block page_title %}{% trans "Step 2 of 2 - Configure Report Settings" %}{% endblock page_title %}

{% block js-inline %}{{ block.super }}
    <script type="text/javascript">

        var defaultCalculationOptions = ["Count per Choice", "Sum", "Average"];
        var nonNumericPropertyCalculationOptions = ["Count per Choice"];
        var propertyOptions = {{ property_options|JSON }};
        var isNonNumericMap = propertyOptions.reduce(function(map, option) {
            map[option.id] = option.is_non_numeric;
            return map;
        }, {});
        var optionsContainQuestions = _.any(propertyOptions, function (o) {
            return o.type == 'question';
        });
        if (optionsContainQuestions) {
            // Munge the property_options into the form expected by the questionsSelect binding.
            propertyOptions = _.compact(_.map(propertyOptions, function (o) {
                if (o.type === 'question') {
                    return o.source;
                } else if (o.type == 'meta') {
                    return {
                        value: o.source[0],
                        label: o.text,
                        type: o.type
                    }
                }
            }));
        }

        /**
         * Knockout view model representing a row in the filter property list
         * @constructor
         */
        var PropertyListItem = function() {
            var self = this;

            this.property = ko.observable("");

            // True if the selected property is known to contain non numeric
            // data. This would be true for numeric form questions, false
            // for text questions and hidden value questions, and false for case
            // properties (because we don't know what type of data they might
            // contain)
            this.propertyIsNonNumeric = ko.pureComputed(function(){
                return isNonNumericMap[self.property()];
            });

            // True if the property exists in the current version of the app
            this.existsInCurrentVersion = ko.observable(true);

            // The header for the column in the report
            this.displayText = ko.observable("");

            // True if the display text has been modified by the user at least once
            this.displayTextModifiedByUser = ko.observable(false);

            // True if the display text should be updated when the property changes
            this.inheritDisplayText = ko.observable(!Boolean(this.displayText()));
            this.property.subscribe(function(newValue) {
                if (self.inheritDisplayText()){
                    self.displayText(newValue);
                }
            });
            this.displayText.subscribe(function(value){
                if (!value) {
                    self.inheritDisplayText(true);
                }
            });

            // A proxy for displayText that will let us know when displayText
            // has been modified by the user (by updating inheritDisplayText)
            this.inputBoundDisplayText = ko.computed({
                read: function() {
                    return self.displayText();
                },
                write: function(value) {
                    // User has made changes to display text
                    self.inheritDisplayText(false);
                    self.displayTextModifiedByUser(true);
                    self.displayText(value);
                },
                owner: this
            });

            this.displayTextIsValid = ko.pureComputed(function(){
                // Blank display text is not allowed
                return Boolean(self.displayText());
            });
            this.showDisplayTextError = ko.pureComputed(function(){
                // This should also return true if the user has tried to submit the form
                return !self.displayTextIsValid() && (self.displayTextModifiedByUser() || self.showWarnings());
            });


            this.format = ko.observable("");
            this.calculation = ko.observable("Count per Choice");
            this.calculationOptions = ko.pureComputed(function(){
                if (self.propertyIsNonNumeric()) {
                    return nonNumericPropertyCalculationOptions;
                }
                return defaultCalculationOptions;
            });
            this.dataSourceField = ko.observable("");
            this.isEditable = ko.pureComputed(function(){
                return !self.existsInCurrentVersion();
            });

            /**
             * Return a "plain" javascript object representing this view model
             * suitable for sending to the server.
             */
            this.toJS = function(){
                return {
                    property: this.property(),
                    display_text: this.displayText(),
                    format: this.format(),
                    calculation: this.calculation()
                };
            };

            // True if validation messages should be shown on any and all fields
            this.showWarnings = ko.observable(false);
            this.isValid = ko.computed(function(){
                return Boolean(self.property() && self.existsInCurrentVersion() && self.displayText());
            });
            this.validate = function() {
                self.showWarnings(true);
                return self.isValid();
            };
        };
        PropertyListItem.wrap = function(o){
            var i = new PropertyListItem();
            i.existsInCurrentVersion(o.exists_in_current_version);
            i.property(o.property !== undefined ? o.property : "");
            i.dataSourceField(o.data_source_field !== undefined ? o.data_source_field : null);
            i.displayText(o.display_text);
            i.calculation(o.calculation);
            i.format(o.format);
            return i;
        };

        /**
         * Knockout view model controlling the filter property list.
         */
        var propertyList = function(options) {
            var that = this;
            options = options || {};

            this.buttonText = options.buttonText !== undefined ? options.buttonText : "Add property";
            // True if at least one column is required.
            this.requireColumns = options.requireColumns !== undefined ? options.requireColumns : false;
            this.requireColumnsText = options.requireColumnsText !== undefined ? options.requireColumnsText: "Please select at least one property";
            // This function will be called if a user tries to submit the form with no columns.
            this.noColumnsValidationCallback = options.noColumnsValidationCallback !== undefined ? options.noColumnsValidationCallback : null;
            this.propertyHelpText = options.propertyHelpText !== undefined ? options.propertyHelpText : null;
            this.displayHelpText = options.displayHelpText !== undefined ? options.displayHelpText : null;
            this.formatHelpText = options.formatHelpText !== undefined ? options.formatHelpText : null;
            this.calcHelpText = options.calcHelpText !== undefined ? options.calcHelpText : null;
            this.analyticsAction = options.analyticsAction !== undefined ? options.analyticsAction : null;
            this.analyticsLabel = options.analyticsLabel !== undefined ? options.analyticsLabel : '{{ report_type }}';

            this.hasFormatCol = ko.observable(options.hasFormatCol !== undefined ? options.hasFormatCol : true);
            this.hasCalculationCol = ko.observable(options.hasCalculationCol !== undefined ? options.hasCalculationCol : false);
            this.formatOptions = ko.observableArray(["Choice", "Date"]);

            this.columns = ko.observableArray(options.initialCols !== undefined ? options.initialCols : []);
            this.serializedProperties = ko.computed(function(){
                return JSON.stringify(
                    _.map(that.columns(), function(c){return c.toJS()})
                );
            });
            this.showWarnings = ko.observable(false);
            this.validate = function(){
                that.showWarnings(true);
                var columnsValid = !_.contains(
                    _.map(
                        that.columns(),
                        function(c){return c.validate()}
                    ),
                    false
                );
                var columnLengthValid = !(that.requireColumns && !that.columns().length);
                if (that.noColumnsValidationCallback && !columnLengthValid){
                    that.noColumnsValidationCallback();
                }
                return columnsValid && columnLengthValid;
            };
            this.buttonHandler = function(){
                this.columns.push(new PropertyListItem());
                if (!_.isEmpty(this.analyticsAction) && !_.isEmpty(this.analyticsLabel)){
                    window.analytics.usage("Report Builder", this.analyticsAction, this.analyticsLabel);
                    window.analytics.workflow("Clicked " + this.analyticsAction + " in Report Builder");
                }
            }
        };

        var configForm = function(){
            var self = this;
            var initialFilters = _.map({{ initial_filters|JSON }}, function(i){
                return PropertyListItem.wrap(i);
            });
            var initialColumns = _.map({{ initial_columns|JSON }}, function(i){
                return PropertyListItem.wrap(i);
            });
            // TODO: Pass help texts from template so that they can be translated.
            this.filtersList = new propertyList({
                hasFormatCol: {% if form.source_type == "case" %}true{% else %}false{% endif %},
                hasCalculationCol: false,
                initialCols: initialFilters,
                buttonText: 'Add Filter',
                analyticsAction: 'Add Filter',
                propertyHelpText: '{{ filter_property_help_text|escapejs}}',
                displayHelpText: '{{ filter_display_help_text|escapejs }}',
                formatHelpText: '{{ filter_format_help_text|escapejs }}'
            });
            this.columnsList = new propertyList({
                hasFormatCol: false,
                hasCalculationCol: {% if report_type == "table" or report_type == "worker" %}true{% else %}false{% endif %},
                initialCols: initialColumns,
                buttonText: 'Add Column',
                analyticsAction: 'Add Column',
                calcHelpText: '{{ calculation_help_text|escapejs }}',
                requireColumns: {% if report_type != "chart"%}true{% else %}false{% endif %},
                requireColumnsText: "At least one column is required",
                noColumnsValidationCallback: function(){
                    window.analytics.usage(
                        'Report Builder',
                        'Click On Done (No Columns)',
                        '{{ report_type }}'
                    );
                }
            });
            this.submitHandler = function(formElement){
                var isValid = true;
                isValid = self.filtersList.validate() && isValid;
                isValid = self.columnsList.validate() && isValid;
                if (!isValid){
                    alert('Invalid report configuration. Please fix the issues and try again.');
                    // The event handler that disables the button is triggered
                    // after this handler is invoked. Therefore, we use _.defer()
                    // to re-enable it immediately after the call stack clears.
                    _.defer(function(el){
                        $(el).find('.disable-on-submit').enableButton();
                    }, formElement);
                }
                return isValid;
            };
        };

        $("#report-config-form").koApplyBindings(new configForm());

        $(function () {
            {% for event in report_builder_events %}
                {# Track a usage events that were produced on the server #}
                window.analytics.usage.apply(this, {{event|JSON}});
            {% endfor %}
            window.analytics.trackUsageLink(
                "#delete-report-button", "Report Builder", "Delete a Repot", '{{ report_type }}'
            );
        });

    </script>
{% endblock %}
