"""
EntriesContributor
------------------

This is the largest and most complex of the suite sections, responsible for generating an ``<entry>``
element for each form, including the datums required for form entry. The ``EntriesHelper``, which does all of the
heavy lifting here, is imported into other places in HQ that need to know what datums a form requires,
such as the session schema generator for form builder and the UI for form linking.

When forms work with multiple datums, they need to be named in a way that is predictable for app builders, who
reference them inside forms. This is most relevant to the "select parent first" feature and to parent/child
modules.  See ``update_refs`` and ``rename_other_id``, both inner functions in ``add_parent_datums``, plus
`this comment`_ on matching parent and child datums.


.. _this comment: https://github.com/dimagi/commcare-hq/blob/c9fa01d1ccbb73d8f07fefbe56a0bbe1dbe231f8/corehq/apps/app_manager/suite_xml/sections/entries.py#L966-L971
"""  # noqa
from collections import defaultdict

from django.utils.translation import gettext as _

import attr
from memoized import memoized

from corehq.apps.app_manager import id_strings
from corehq.apps.app_manager.const import USERCASE_ID, USERCASE_TYPE
from corehq.apps.app_manager.exceptions import (
    FormNotFoundException,
    ParentModuleReferenceError,
    SuiteValidationError,
)
from corehq.apps.app_manager.util import (
    actions_use_usercase,
    module_loads_registry_case,
    module_offers_search,
    module_uses_inline_search,
)
from corehq.apps.app_manager.xform import (
    autoset_owner_id_for_advanced_action,
    autoset_owner_id_for_open_case,
    autoset_owner_id_for_subcase,
)
from corehq.apps.app_manager.xpath import (
    CaseIDXPath,
    ItemListFixtureXpath,
    ProductInstanceXpath,
    UsercaseXPath,
    XPath,
    interpolate_xpath,
    session_var,
)
from corehq.apps.case_search.const import EXCLUDE_RELATED_CASES_FILTER
from corehq.apps.case_search.models import (
    CASE_SEARCH_REGISTRY_ID_KEY,
    case_search_sync_cases_on_form_entry_enabled_for_domain,
)
from corehq.toggles import USH_SEARCH_FILTER
from corehq.util.timer import time_method
from corehq.util.view_utils import absolute_reverse

from ..contributors import SuiteContributorByModule
from ..utils import (
    get_form_locale_id,
    get_ordered_case_types,
    get_select_chain_meta,
)
from ..xml_models import (
    Assertion,
    Command,
    Entry,
    InstanceDatum,
    LocaleArgument,
    LocalizedCommand,
    QueryData,
    RemoteRequestQuery,
    SessionDatum,
    Text,
)


@attr.s(repr=False)
class FormDatumMeta:
    """
    :param datum: The actual SessionDatum object
    :param case_type: The case type this datum represents
    :param requires_selection: True if this datum requires the user to make a selection
    :param action: The action that produced this datum
    :param from_parent: True if this datum is a placeholder necessary to match the parent module's session.
    :param module_id: The ID of the module where this datum comes from.
    """
    datum = attr.ib()
    case_type = attr.ib()
    requires_selection = attr.ib()
    action = attr.ib()
    from_parent = attr.ib(default=False)
    module_id = attr.ib(default=None)

    @property
    def id(self):
        return self.datum.id

    @property
    def is_new_case_id(self):
        return self.datum.function == 'uuid()'

    def __repr__(self):
        if isinstance(self.datum, RemoteRequestQuery):
            datum = f"<RemoteRequestQuery(id={self.datum.url})>"
        elif isinstance(self.datum, InstanceDatum):
            datum = f"<InstanceDatum(id={self.id})>"
        else:
            datum = f"<SessionDatum(id={self.id})>"
        return 'FormDatumMeta(datum={}, case_type={}, requires_selection={}, action={})'.format(
            datum, self.case_type, self.requires_selection, self.action
        )


class EntriesContributor(SuiteContributorByModule):
    @time_method()
    def get_module_contributions(self, module):
        return self.entries_helper.entry_for_module(module)


class EntriesHelper(object):

    def __init__(self, app, modules=None, build_profile_id=None):
        from ..sections.details import DetailsHelper
        self.app = app
        self.modules = modules or list(app.get_modules())
        self.build_profile_id = build_profile_id
        self.details_helper = DetailsHelper(self.app, self.modules)

    def get_case_session_var_for_form(self, form):
        """Returns the datum ID of the case that was selected last.
        Will not include autogenerated datums.

        :returns: The datum ID (session variable name) or None"""
        case_datums = self.get_case_datums_meta_for_form(form)
        try:
            return next(meta.id for meta in reversed(case_datums))
        except StopIteration:
            return None

    def get_case_datums_meta_for_form(self, form, include_autogenerated=False):
        """Get all datum meta for the form that represent a case ID

        :param: include_autogenerated - Set to True to include case IDs that are autogenerated
                                      i.e. don't require selection
        """
        return [
            datum for datum in self.get_datums_meta_for_form_generic(form)
            if datum.case_type and (include_autogenerated or datum.requires_selection)
        ]

    def get_datums_meta_for_form_generic(self, form, module=None):
        """Pass module if it is different from the form's own module e.g. a shadow module"""
        module = module or form.get_module()

        if form.form_type == 'module_form':
            datums_meta = self.get_case_datums_basic_module(module, form)
        elif form.form_type == 'advanced_form' or form.form_type == "shadow_form":
            datums_meta, _ = self.get_datum_meta_assertions_advanced(module, form)
            datums_meta.extend(EntriesHelper.get_new_case_id_datums_meta(form))
        else:
            raise SuiteValidationError("Unexpected form type '{}' with a case list form: {}".format(
                form.form_type, form.unique_id
            ))
        return datums_meta

    @staticmethod
    def get_filter_xpath(module):
        filter = module.case_details.short.filter
        if filter:
            xpath = '[%s]' % interpolate_xpath(filter)
        else:
            xpath = ''
        return xpath

    @staticmethod
    def get_nodeset_xpath(case_type, filter_xpath='', additional_types=None):
        return EntriesHelper._get_nodeset_xpath(
            'casedb', 'casedb', case_type, filter_xpath, additional_types
        )

    @staticmethod
    def get_registry_nodeset_xpath(case_type, filter_xpath='', additional_types=None):
        return EntriesHelper._get_nodeset_xpath(
            'results', 'results', case_type, filter_xpath, additional_types
        )

    @staticmethod
    def _get_nodeset_xpath(instance_name, root_element, case_type, filter_xpath='', additional_types=None):
        case_type_filter = " or ".join([
            "@case_type='{case_type}'".format(case_type=case_type)
            for case_type in get_ordered_case_types(case_type, additional_types)
        ])
        return f"instance('{instance_name}')/{root_element}/case[{case_type_filter}][@status='open']{filter_xpath}"

    @staticmethod
    def get_parent_filter(relationship, parent_id):
        if relationship is None:
            return ""
        else:
            return "[index/{relationship}=instance('commcaresession')/session/data/{parent_id}]".format(
                relationship=relationship,
                parent_id=parent_id,
            )

    @staticmethod
    def get_userdata_autoselect(key, session_id, mode):
        base_xpath = session_var('data', path='user')
        xpath = session_var(key, path='user/data')
        protected_xpath = XPath.if_(
            XPath.and_(base_xpath.count().eq(1), xpath.count().eq(1)),
            xpath,
            XPath.empty_string(),
        )
        datum = SessionDatum(id=session_id, function=protected_xpath)
        assertions = [
            EntriesHelper.get_assertion(
                XPath.and_(base_xpath.count().eq(1),
                           xpath.count().eq(1)),
                'case_autoload.{0}.property_missing'.format(mode),
                [key],
            ),
            EntriesHelper.get_assertion(
                CaseIDXPath(xpath).case().count().eq(1),
                'case_autoload.{0}.case_missing'.format(mode),
            )
        ]
        return datum, assertions

    @memoized
    def include_post_in_entry(self, module_id):
        module = self.app.get_module_by_unique_id(module_id)
        loads_registry_case = module_loads_registry_case(module)
        using_inline_search = module_uses_inline_search(module)
        sync_on_form_entry = (
            module_offers_search(module)
            and case_search_sync_cases_on_form_entry_enabled_for_domain(self.app.domain)
        )
        return (using_inline_search or sync_on_form_entry) and not loads_registry_case

    def entry_for_module(self, module):
        # avoid circular dependency
        from corehq.apps.app_manager.models import AdvancedModule, Module
        results = []
        for form in module.get_suite_forms():
            e = Entry()
            e.form = form.xmlns

            if module.report_context_tile:
                from ..features.mobile_ucr import get_report_context_tile_datum
                e.datums.append(get_report_context_tile_datum())
            if form.requires_case() and self.include_post_in_entry(module.get_or_create_unique_id()):
                case_session_var = self.get_case_session_var_for_form(form)
                from ..post_process.remote_requests import (
                    RESULTS_INSTANCE_INLINE,
                    RemoteRequestFactory,
                )
                storage_instance = RESULTS_INSTANCE_INLINE if module_uses_inline_search(module) \
                    else 'casedb'
                remote_request_factory = RemoteRequestFactory(
                    None, module, [], case_session_var=case_session_var, storage_instance=storage_instance,
                    exclude_relevant=case_search_sync_cases_on_form_entry_enabled_for_domain(self.app.domain))
                e.post = remote_request_factory.build_remote_request_post()

            # Ideally all of this version check should happen in Command/Display class
            if self.app.enable_localized_menu_media:
                form_custom_icon = form.custom_icon
                e.command = LocalizedCommand(
                    id=id_strings.form_command(form, module),
                    menu_locale_id=get_form_locale_id(form),
                    media_image=form.uses_image(build_profile_id=self.build_profile_id),
                    media_audio=form.uses_audio(build_profile_id=self.build_profile_id),
                    image_locale_id=id_strings.form_icon_locale(form),
                    audio_locale_id=id_strings.form_audio_locale(form),
                    custom_icon_locale_id=(id_strings.form_custom_icon_locale(form, form_custom_icon.form)
                                           if form_custom_icon and not form_custom_icon.xpath else None),
                    custom_icon_form=(form_custom_icon.form if form_custom_icon else None),
                    custom_icon_xpath=(form_custom_icon.xpath
                                       if form_custom_icon and form_custom_icon.xpath else None),
                )
            else:
                e.command = Command(
                    id=id_strings.form_command(form, module),
                    locale_id=get_form_locale_id(form),
                    media_image=form.default_media_image,
                    media_audio=form.default_media_audio,
                )
            config_entry = {
                'module_form': self.configure_entry_module_form,
                'advanced_form': self.configure_entry_advanced_form,
                'shadow_form': self.configure_entry_advanced_form,
            }[form.form_type]
            config_entry(module, e, form)

            EntriesHelper.add_custom_assertions(e, form)

            if (
                self.app.commtrack_enabled
                and session_var('supply_point_id') in getattr(form, 'source', "")
            ):
                from corehq.apps.app_manager.const import AUTO_SELECT_LOCATION
                datum, assertions = EntriesHelper.get_userdata_autoselect(
                    'commtrack-supply-point',
                    'supply_point_id',
                    AUTO_SELECT_LOCATION,
                )
                e.datums.append(datum)
                e.assertions.extend(assertions)

            results.append(e)

        if hasattr(module, 'case_list') and module.case_list.show:
            e = Entry()
            if self.app.enable_localized_menu_media:
                e.command = LocalizedCommand(
                    id=id_strings.case_list_command(module),
                    menu_locale_id=id_strings.case_list_locale(module),
                    media_image=module.case_list.uses_image(build_profile_id=self.build_profile_id),
                    media_audio=module.case_list.uses_audio(build_profile_id=self.build_profile_id),
                    image_locale_id=id_strings.case_list_icon_locale(module),
                    audio_locale_id=id_strings.case_list_audio_locale(module),
                )
            else:
                e.command = Command(
                    id=id_strings.case_list_command(module),
                    locale_id=id_strings.case_list_locale(module),
                    media_image=module.case_list.default_media_image,
                    media_audio=module.case_list.default_media_audio,
                )
            if isinstance(module, Module):
                self.configure_entry_module_form(module, e)
            elif isinstance(module, AdvancedModule):
                detail_inline = self.get_detail_inline_attr(module, "case_short")
                detail_confirm = None
                if not detail_inline:
                    detail_confirm = self.details_helper.get_detail_id_safe(module, 'case_long')
                datum_cls = InstanceDatum if module.is_multi_select() else SessionDatum
                e.datums.append(datum_cls(
                    id='case_id_case_%s' % module.case_type,
                    nodeset=(EntriesHelper.get_nodeset_xpath(module.case_type)),
                    value="./@case_id",
                    detail_select=self.details_helper.get_detail_id_safe(module, 'case_short'),
                    detail_confirm=detail_confirm,
                    detail_persistent=self.get_detail_persistent_attr(module, "case_short"),
                    detail_inline=detail_inline,
                    autoselect=module.is_auto_select(),
                    max_select_value=module.max_select_value,
                ))
                if self.app.commtrack_enabled:
                    e.datums.append(SessionDatum(
                        id='product_id',
                        nodeset=ProductInstanceXpath().instance(),
                        value="./@id",
                        detail_select=self.details_helper.get_detail_id_safe(module, 'product_short')
                    ))
            results.append(e)

        for entry in module.get_custom_entries():
            results.append(entry)

        return results

    @staticmethod
    def get_assertion(test, locale_id, locale_arguments=None):
        assertion = Assertion(test=test)
        text = Text(locale_id=locale_id)
        if locale_arguments:
            locale = text.locale
            for arg in locale_arguments:
                locale.arguments.append(LocaleArgument(value=arg))
        assertion.text.append(text)
        return assertion

    @staticmethod
    def add_case_sharing_assertion(entry):
        assertion = EntriesHelper.get_assertion("count(instance('groups')/groups/group) = 1",
                           'case_sharing.exactly_one_group')
        entry.assertions.append(assertion)

    @staticmethod
    def get_auto_select_assertions(case_id_xpath, mode, locale_arguments=None):
        case_count = CaseIDXPath(case_id_xpath).case().count()
        return [
            EntriesHelper.get_assertion(
                "{0} = 1".format(case_id_xpath.count()),
                'case_autoload.{0}.property_missing'.format(mode),
                locale_arguments
            ),
            EntriesHelper.get_assertion(
                "{0} = 1".format(case_count),
                'case_autoload.{0}.case_missing'.format(mode),
            )
        ]

    @staticmethod
    def add_custom_assertions(entry, form):
        for id, assertion in enumerate(form.custom_assertions):
            locale_id = id_strings.custom_assertion_locale(id, form.get_module(), form)
            entry.assertions.append(EntriesHelper.get_assertion(assertion.test, locale_id))

    @staticmethod
    def add_usercase_id_assertion(entry):
        assertion = EntriesHelper.get_assertion("count(instance('casedb')/casedb/case[@case_type='commcare-user']"
                                                "[hq_user_id=instance('commcaresession')/session/context/userid])"
                                                " = 1", "case_autoload.usercase.case_missing")
        entry.assertions.append(assertion)

    @staticmethod
    def get_extra_case_id_datums(form, case_datum=None):
        datums = []
        actions = form.active_actions()
        if form.form_type == 'module_form' and actions_use_usercase(actions):
            case = UsercaseXPath().case()
            datums.append(FormDatumMeta(
                datum=SessionDatum(id=USERCASE_ID, function=('%s/@case_id' % case)),
                case_type=USERCASE_TYPE,
                requires_selection=False,
                action=None  # Unused (and could be actions['usercase_update'] or actions['usercase_preload'])
            ))
        if case_datum and form.get_module().has_grouped_tiles():
            # add a datum for the parent case ids
            case_datum_id = case_datum.datum.id
            index_identifier = form.get_module().case_details.short.case_tile_group.index_identifier
            if isinstance(case_datum.datum, InstanceDatum):
                # distinct-values(instance('casedb')/casedb/case[selected(
                #     join(' ', instance('selected_cases')/results/value),
                #     @case_id
                # )]/index/parent)
                predicate = f"selected(join(' ', instance('{case_datum_id}')/results/value), @case_id)"
            else:
                predicate = f"@case_id = instance('commcaresession')/session/data/{case_datum_id}"
            func = (
                "join(' ', distinct-values(instance('casedb')/casedb/case["
                f"{predicate}"
                f"]/index/{index_identifier}))"
            )
            datums.append(FormDatumMeta(
                datum=SessionDatum(id=f"{case_datum_id}_parent_ids", function=func),
                case_type=None,
                requires_selection=False,
                action=None
            ))
        return datums

    @staticmethod
    def any_usercase_datums(datums):
        return any(d.case_type == USERCASE_TYPE for d in datums)

    @staticmethod
    def get_new_case_id_datums_meta(form):
        if not form:
            return []

        datums = []
        if form.form_type == 'module_form':
            actions = form.active_actions()
            if 'open_case' in actions:
                datums.append(FormDatumMeta(
                    datum=SessionDatum(id=form.session_var_for_action('open_case'), function='uuid()'),
                    case_type=form.get_module().case_type,
                    requires_selection=False,
                    action=actions['open_case']
                ))

            if 'subcases' in actions:
                for subcase in actions['subcases']:
                    # don't put this in the loop to be consistent with the form's indexing
                    # see XForm._create_casexml
                    if not subcase.repeat_context:
                        datums.append(FormDatumMeta(
                            datum=SessionDatum(
                                id=form.session_var_for_action(subcase), function='uuid()'
                            ),
                            case_type=subcase.case_type,
                            requires_selection=False,
                            action=subcase
                        ))
        elif form.form_type == 'advanced_form' or form.form_type == "shadow_form":
            for action in form.actions.get_open_actions():
                if not action.repeat_context:
                    datums.append(FormDatumMeta(
                        datum=SessionDatum(id=action.case_session_var, function='uuid()'),
                        case_type=action.case_type,
                        requires_selection=False,
                        action=action
                    ))

        return datums

    def get_case_datums_basic_module(self, module, form=None):
        datums = []
        if not form or form.requires_case():
            datums.extend(self.get_datum_meta_module(module, use_filter=True))

        case_datum = datums[-1] if datums else None
        if form:
            datums.extend(EntriesHelper.get_new_case_id_datums_meta(form))
            datums.extend(EntriesHelper.get_extra_case_id_datums(form, case_datum))

        return self.add_parent_datums(datums, module)

    def configure_entry_module_form(self, module, e, form=None, use_filter=True, **kwargs):
        def case_sharing_requires_assertion(form):
            actions = form.active_actions()
            if 'open_case' in actions and autoset_owner_id_for_open_case(actions):
                return True
            if 'subcases' in actions:
                for subcase in actions['subcases']:
                    if autoset_owner_id_for_subcase(subcase):
                        return True
            return False

        case_datums = self.get_case_datums_basic_module(module, form)
        all_datums = self.add_remote_query_datums(case_datums)
        for datum in all_datums:
            e.datums.append(datum.datum)

        if form and self.app.case_sharing and case_sharing_requires_assertion(form):
            EntriesHelper.add_case_sharing_assertion(e)

        if form and EntriesHelper.any_usercase_datums(all_datums):
            EntriesHelper.add_usercase_id_assertion(e)

    def add_remote_query_datums(self, datums):
        """Add in any `query` datums that are necessary.
        This only applies to datums that are loaded via inline search or from a data registry.
        """
        result = []
        for datum in datums:
            if datum.module_id and datum.case_type:
                module = self.app.get_module_by_unique_id(datum.module_id)
                loads_registry_case = module_loads_registry_case(module)
                uses_inline_search = module_uses_inline_search(module)
                if loads_registry_case or uses_inline_search:
                    result.append(self.get_query_datums(module, uses_inline_search))
                    result.append(datum)
                    if loads_registry_case:
                        result.append(self.get_data_registry_case_datums(datum, module))
                else:
                    result.append(datum)
            else:
                result.append(datum)
        return result

    def get_datum_meta_module(self, module, use_filter=False):
        datums = []
        is_shadow_module = module.module_type == 'shadow'
        source_module = module.source_module if is_shadow_module else module
        datums_meta = get_select_chain_meta(self.app, source_module)
        for i, datum in enumerate(datums_meta):
            # get the session var for the previous datum if there is one
            parent_id = datums_meta[i - 1]['session_var'] if i >= 1 else ''
            if parent_id:
                parent_filter = EntriesHelper.get_parent_filter(
                    datum['module'].parent_select.relationship, parent_id
                )
            else:
                parent_filter = ''

            # Figure out which module will supply the details (select, confirm, etc.)
            # for this datum. Normally this is the datum's own module.
            detail_module = datum['module']

            # Shadow modules are different because datums_meta is generated based on the source module,
            # but the various details should be supplied based on the shadow's own configuration.
            if is_shadow_module:
                if datum['module'].unique_id == module.source_module_id:
                    # We're looking at the datum that corresponds to the original module,
                    # so use that module for details
                    detail_module = module
                else:
                    # Check for case list parent child selection. If both shadow and source use parent case
                    # selection, datums_meta will contain a datum for the parent case, based on the SOURCE's
                    # parent select, and when we see that datum, we need to use the SHADOW's parent select
                    # to supply the details.
                    shadow_active = hasattr(module, 'parent_select') and module.parent_select.active
                    source_active = hasattr(source_module, 'parent_select') and source_module.parent_select.active
                    if shadow_active and source_active:
                        if datum['module'].unique_id == source_module.parent_select.module_id:
                            detail_module = self.app.get_module_by_unique_id(module.parent_select.module_id)

            detail_persistent = self.get_detail_persistent_attr(detail_module, "case_short")
            detail_inline = self.get_detail_inline_attr(detail_module, "case_short")

            fixture_select_filter = ''
            if datum['module'].fixture_select.active:
                datums.append(FormDatumMeta(
                    datum=SessionDatum(
                        id=id_strings.fixture_session_var(datum['module']),
                        nodeset=ItemListFixtureXpath(datum['module'].fixture_select.fixture_type).instance(),
                        value=datum['module'].fixture_select.variable_column,
                        detail_select=id_strings.fixture_detail(detail_module)
                    ),
                    case_type=None,
                    requires_selection=True,
                    action='fixture_select'
                ))
                filter_xpath_template = datum['module'].fixture_select.xpath
                fixture_value = session_var(id_strings.fixture_session_var(datum['module']))
                fixture_select_filter = "[{}]".format(
                    filter_xpath_template.replace('$fixture_value', fixture_value)
                )

            filter_xpath = EntriesHelper.get_filter_xpath(detail_module) if use_filter else ''

            instance_name, root_element = "casedb", "casedb"
            loads_registry_case = module_loads_registry_case(detail_module)
            uses_inline_search = module_uses_inline_search(detail_module)
            if loads_registry_case or uses_inline_search:
                if uses_inline_search:
                    instance_name, root_element = "results:inline", "results"
                elif loads_registry_case:
                    instance_name, root_element = "results", "results"
                if detail_module.search_config.search_filter and USH_SEARCH_FILTER.enabled(self.app.domain):
                    filter_xpath += f"[{interpolate_xpath(detail_module.search_config.search_filter)}]"
                filter_xpath += EXCLUDE_RELATED_CASES_FILTER

            nodeset = EntriesHelper._get_nodeset_xpath(
                instance_name, root_element,
                datum['case_type'],
                filter_xpath=filter_xpath,
                additional_types=datum['module'].additional_case_types
            )

            datum_cls = InstanceDatum if datum['module'].is_multi_select() else SessionDatum
            datums.append(FormDatumMeta(
                datum=datum_cls(
                    id=datum['session_var'],
                    nodeset=nodeset + parent_filter + fixture_select_filter,
                    value="./@case_id",
                    detail_select=self.details_helper.get_detail_id_safe(detail_module, 'case_short'),
                    detail_confirm=(
                        self.details_helper.get_detail_id_safe(detail_module, 'case_long')
                        if datum['index'] == 0 and not detail_inline else None
                    ),
                    detail_persistent=detail_persistent,
                    detail_inline=detail_inline,
                    autoselect=datum['module'].is_auto_select(),
                    max_select_value=datum['module'].max_select_value,
                ),
                case_type=datum['case_type'],
                requires_selection=True,
                action='update_case',
                module_id=detail_module.get_or_create_unique_id()
            ))

        return datums

    def get_query_datums(self, module, uses_inline_search):
        """When doing 'inline' search we skip the normal case search
        workflow and put the query directly in the entry.
        The case details is then populated with data from the results of the query.
        """
        from ..post_process.remote_requests import (
            RESULTS_INSTANCE,
            RESULTS_INSTANCE_INLINE,
            RemoteRequestFactory,
        )
        storage_instance = RESULTS_INSTANCE_INLINE if uses_inline_search else RESULTS_INSTANCE
        factory = RemoteRequestFactory(None, module, [], storage_instance=storage_instance)
        query = factory.build_remote_request_queries()[0]
        return FormDatumMeta(datum=query, case_type=None, requires_selection=False, action=None)

    def get_data_registry_case_datums(self, datum, module):
        """When a data registry is the source of the search results we can't assume that the case
        the user selected is in the user's casedb so we have to get the data directly from HQ before
        entering the form. This data is then available in the 'registry' instance (``instance('registry')``)
        """
        from ..post_process.remote_requests import REGISTRY_INSTANCE

        case_ids_expressions = {session_var(datum.id)} | set(module.search_config.additional_registry_cases)
        data = [
            QueryData(key=CASE_SEARCH_REGISTRY_ID_KEY, ref=f"'{module.search_config.data_registry}'")
        ]
        data.extend([
            QueryData(key='case_type', ref=f"'{case_type}'")
            for case_type in get_ordered_case_types(datum.case_type, module.additional_case_types)
        ])
        data.extend([
            QueryData(key='case_id', ref=case_id_xpath)
            for case_id_xpath in sorted(case_ids_expressions)
        ])

        return FormDatumMeta(
            datum=RemoteRequestQuery(
                url=absolute_reverse('case_fixture', args=[self.app.domain, self.app.get_id]),
                storage_instance=REGISTRY_INSTANCE,
                template='case',
                data=data,
                default_search='true',
            ),
            case_type=None,
            requires_selection=False,
            action=None
        )

    @staticmethod
    def get_auto_select_datums_and_assertions(action, auto_select, form):
        from corehq.apps.app_manager.const import (
            AUTO_SELECT_CASE,
            AUTO_SELECT_FIXTURE,
            AUTO_SELECT_RAW,
            AUTO_SELECT_USER,
            AUTO_SELECT_USERCASE,
        )
        if auto_select.mode == AUTO_SELECT_USER:
            return EntriesHelper.get_userdata_autoselect(
                auto_select.value_key,
                action.case_session_var,
                auto_select.mode,
            )
        elif auto_select.mode == AUTO_SELECT_CASE:
            try:
                ref = form.actions.actions_meta_by_tag[auto_select.value_source]['action']
                sess_var = ref.case_session_var
            except KeyError:
                raise ValueError("Case tag not found: %s" % auto_select.value_source)
            xpath = CaseIDXPath(session_var(sess_var)).case().index_id(auto_select.value_key)
            assertions = EntriesHelper.get_auto_select_assertions(xpath, auto_select.mode, [auto_select.value_key])
            return SessionDatum(
                id=action.case_session_var,
                function=xpath
            ), assertions
        elif auto_select.mode == AUTO_SELECT_FIXTURE:
            xpath_base = ItemListFixtureXpath(auto_select.value_source).instance()
            xpath = xpath_base.slash(auto_select.value_key)
            fixture_assertion = EntriesHelper.get_assertion(
                "{0} = 1".format(xpath_base.count()),
                'case_autoload.{0}.exactly_one_fixture'.format(auto_select.mode),
                [auto_select.value_source]
            )
            assertions = EntriesHelper.get_auto_select_assertions(xpath, auto_select.mode, [auto_select.value_key])
            return SessionDatum(
                id=action.case_session_var,
                function=xpath
            ), [fixture_assertion] + assertions
        elif auto_select.mode == AUTO_SELECT_RAW:
            case_id_xpath = auto_select.value_key
            case_count = CaseIDXPath(case_id_xpath).case().count()
            return SessionDatum(
                id=action.case_session_var,
                function=case_id_xpath
            ), [
                EntriesHelper.get_assertion(
                    "{0} = 1".format(case_count),
                    'case_autoload.{0}.case_missing'.format(auto_select.mode)
                )
            ]
        elif auto_select.mode == AUTO_SELECT_USERCASE:
            case = UsercaseXPath().case()
            return SessionDatum(
                id=action.case_session_var,
                function=case.slash('@case_id')
            ), [
                EntriesHelper.get_assertion(
                    "{0} = 1".format(case.count()),
                    'case_autoload.{0}.case_missing'.format(auto_select.mode)
                )
            ]

    def get_load_case_from_fixture_datums(self, action, target_module, form):
        datums = []
        load_case_from_fixture = action.load_case_from_fixture

        if (
            load_case_from_fixture.arbitrary_datum_id
            and load_case_from_fixture.arbitrary_datum_function
        ):
            datums.append(FormDatumMeta(
                SessionDatum(
                    id=load_case_from_fixture.arbitrary_datum_id,
                    function=load_case_from_fixture.arbitrary_datum_function,
                ),
                case_type=action.case_type,
                requires_selection=True,
                action=action,
            ))
        datums.append(FormDatumMeta(
            datum=SessionDatum(
                id=load_case_from_fixture.fixture_tag,
                nodeset=load_case_from_fixture.fixture_nodeset,
                value=load_case_from_fixture.fixture_variable,
                detail_select=self.details_helper.get_detail_id_safe(target_module, 'case_short'),
                detail_confirm=self.details_helper.get_detail_id_safe(target_module, 'case_long'),
                autoselect=load_case_from_fixture.auto_select_fixture,
            ),
            case_type=action.case_type,
            requires_selection=True,
            action=action,
        ))

        if action.case_tag:
            if action.case_index.tag:
                parent_action = form.actions.actions_meta_by_tag[action.case_index.tag]['action']
                parent_filter = EntriesHelper.get_parent_filter(
                    action.case_index.reference_id,
                    parent_action.case_session_var
                )
            else:
                parent_filter = ''
            session_var_for_fixture = session_var(load_case_from_fixture.fixture_tag)
            filter_for_casedb = '[{0}={1}]'.format(load_case_from_fixture.case_property, session_var_for_fixture)
            nodeset = EntriesHelper.get_nodeset_xpath(action.case_type, filter_xpath=filter_for_casedb)
            nodeset += parent_filter

            datums.append(FormDatumMeta(
                datum=SessionDatum(
                    id=action.case_tag,
                    nodeset=nodeset,
                    value="./@case_id",
                    autoselect=load_case_from_fixture.auto_select,
                ),
                case_type=action.case_type,
                requires_selection=False,
                action=action,
            ))

        return datums

    def configure_entry_advanced_form(self, module, e, form, **kwargs):
        def case_sharing_requires_assertion(form):
            actions = form.actions.open_cases
            for action in actions:
                if autoset_owner_id_for_advanced_action(action):
                    return True
            return False

        datums, assertions = self.get_datum_meta_assertions_advanced(module, form)
        datums.extend(EntriesHelper.get_new_case_id_datums_meta(form))

        for datum_meta in datums:
            e.datums.append(datum_meta.datum)

        # assertions come after session
        e.assertions.extend(assertions)

        if self.app.case_sharing and case_sharing_requires_assertion(form):
            EntriesHelper.add_case_sharing_assertion(e)

    def get_datum_meta_assertions_advanced(self, module, form):
        def get_target_module(case_type, module_id, with_product_details=False):
            if module_id:
                if module_id == module.unique_id:
                    return module

                from corehq.apps.app_manager.models import (
                    ModuleNotFoundException,
                )
                try:
                    target = module.get_app().get_module_by_unique_id(module_id,
                             error=_("Could not find target module used by form '{}'").format(form.default_name()))
                    if target.case_type != case_type:
                        raise ParentModuleReferenceError(
                            _(
                                "Form '%(form_name)s' in module '%(module_name)s' "
                                "references a module with an incorrect case type: "
                                "module '%(target_name)s' expected '%(expected_case_type)s', "
                                "found '%(target_case_type)s'"
                            ) % {
                                'form_name': form.default_name(),
                                'module_name': module.default_name(),
                                'target_name': target.default_name(),
                                'expected_case_type': case_type,
                                'target_case_type': target.case_type,
                            }
                        )
                    if with_product_details and not hasattr(target, 'product_details'):
                        raise ParentModuleReferenceError(
                            "Module with ID %s has no product details configuration" % module_id
                        )
                    return target
                except ModuleNotFoundException as e:
                    raise ParentModuleReferenceError(str(e))
            else:
                if case_type == module.case_type:
                    return module

                target_modules = [
                    mod for mod in module.get_app().modules
                    if mod.case_type == case_type and (not with_product_details or hasattr(mod, 'product_details'))
                ]
                try:
                    return target_modules[0]
                except IndexError:
                    raise ParentModuleReferenceError(
                        "Module with case type %s in app %s not found" % (case_type, self.app)
                    )

        def get_manual_datum(action_, parent_filter_=''):
            target_module_ = get_target_module(action_.case_type, action_.details_module)
            referenced_by = form.actions.actions_meta_by_parent_tag.get(action_.case_tag)
            filter_xpath = EntriesHelper.get_filter_xpath(target_module_)
            detail_inline = self.get_detail_inline_attr(target_module_, "case_short")

            return SessionDatum(
                id=action_.case_session_var,
                nodeset=(EntriesHelper.get_nodeset_xpath(action_.case_type, filter_xpath=filter_xpath)
                         + parent_filter_),
                value="./@case_id",
                detail_select=self.details_helper.get_detail_id_safe(target_module_, 'case_short'),
                detail_confirm=(
                    self.details_helper.get_detail_id_safe(target_module_, 'case_long')
                    if (not referenced_by or referenced_by['type'] != 'load') and not detail_inline else None
                ),
                detail_persistent=self.get_detail_persistent_attr(target_module_, "case_short"),
                detail_inline=detail_inline,
                autoselect=target_module_.auto_select_case,
            )

        datums = []
        assertions = []
        for action in form.actions.get_load_update_actions():
            auto_select = action.auto_select
            load_case_from_fixture = action.load_case_from_fixture
            if auto_select and auto_select.mode:
                datum, assertions_ = EntriesHelper.get_auto_select_datums_and_assertions(action, auto_select, form)
                assertions.extend(assertions_)
                datums.append(FormDatumMeta(
                    datum=datum,
                    case_type=None,
                    requires_selection=False,
                    action=action
                ))
            elif load_case_from_fixture:
                target_module = get_target_module(action.case_type, action.details_module)
                datums.extend(self.get_load_case_from_fixture_datums(action, target_module, form))
            else:
                if action.case_index.tag:
                    parent_action = form.actions.actions_meta_by_tag[action.case_index.tag]['action']
                    parent_filter = EntriesHelper.get_parent_filter(
                        action.case_index.reference_id,
                        parent_action.case_session_var
                    )
                else:
                    parent_filter = ''
                datums.append(FormDatumMeta(
                    datum=get_manual_datum(action, parent_filter),
                    case_type=action.case_type,
                    requires_selection=True,
                    action=action
                ))

        for datum in form.arbitrary_datums:
            datums.append(FormDatumMeta(
                SessionDatum(id=datum['datum_id'], function=datum['datum_function']), None, False, None)
            )

        if module.get_app().commtrack_enabled:
            try:
                last_action = list(form.actions.get_load_update_actions())[-1]
                if last_action.show_product_stock:
                    nodeset = ProductInstanceXpath().instance()
                    if last_action.product_program:
                        nodeset = nodeset.select('program_id', last_action.product_program)

                    target_module = get_target_module(last_action.case_type, last_action.details_module, True)

                    datums.append(FormDatumMeta(
                        datum=SessionDatum(
                            id='product_id',
                            nodeset=nodeset,
                            value="./@id",
                            detail_select=self.details_helper.get_detail_id_safe(target_module, 'product_short'),
                            detail_persistent=self.get_detail_persistent_attr(target_module, "product_short"),
                            detail_inline=self.get_detail_inline_attr(target_module, "product_short"),
                        ),
                        case_type=None,
                        requires_selection=True,
                        action=None
                    ))
            except IndexError:
                pass

        return self.add_parent_datums(datums, module), assertions

    def _get_first_forms_datums(self, module):
        """
        Return the datums of the first form in the given module
        """
        if not module:
            return []

        if module.module_type == 'shadow' and module.shadow_module_version > 1:
            module = module.source_module

        try:
            # assume that all forms in the module have the same case management
            form = module.get_form(0)
        except FormNotFoundException:
            return []
        return self.get_datums_meta_for_form_generic(form)

    def add_parent_datums(self, datums, module):
        parent_datums = self._get_first_forms_datums(module.root_module)
        if not parent_datums:
            return datums

        # we need to try and match the datums to the root module so that
        # the navigation on the phone works correctly
        # 1. Add in any datums that don't require user selection e.g. new case IDs
        # 2. Match the datum ID for datums that appear in the same position and
        #    will be loading the same case type
        # see advanced_app_features#child-modules in docs
        datum_ids = {d.id: d for d in datums}
        datums_by_case_tag = _get_datums_by_case_tag(datums)

        def set_id(datum_meta, new_id):
            case_tag = getattr(datum_meta.action, 'case_tag', 'basic')
            _update_refs(datums_by_case_tag[case_tag], datum_meta.datum.id, new_id)
            datum_meta.datum.id = new_id

        ret = []
        datums_remaining = list(datums)
        for parent_datum_meta in parent_datums:
            if parent_datum_meta.id in datum_ids:
                # We assume that a conflict is unwanted and rename. This may get undone below.
                datum = datum_ids[parent_datum_meta.id]
                set_id(datum, f'{datum.id}_{datum.case_type}')

            if not parent_datum_meta.requires_selection:
                ret.append(attr.evolve(parent_datum_meta, from_parent=True))
                continue

            if datums_remaining:
                this_datum_meta = datums_remaining[0]
                if _same_case(this_datum_meta, parent_datum_meta) and this_datum_meta.action:
                    if this_datum_meta.id != parent_datum_meta.id:
                        set_id(this_datum_meta, parent_datum_meta.id)
                    ret.append(datums_remaining.pop(0))

        return ret + datums_remaining

    def _get_module_for_persistent_context(self, module_unique_id):
        module_for_persistent_context = self.app.get_module_by_unique_id(module_unique_id)
        if (
            module_for_persistent_context and (
                module_for_persistent_context.case_details.short.case_tile_template
                or module_for_persistent_context.case_details.short.custom_xml
            )
        ):
            return module_for_persistent_context

    def get_detail_persistent_attr(self, module, detail_type="case_short"):
        detail, detail_enabled = self._get_detail_from_module(module, detail_type)
        if detail_enabled:
            # if configured to use persisted case tile context from another module which has case tiles
            # configured then get id_string for that module
            if detail.persistent_case_tile_from_module:
                module_for_persistent_context = self._get_module_for_persistent_context(
                    module_unique_id=detail.persistent_case_tile_from_module
                )
                if module_for_persistent_context:
                    return id_strings.detail(module_for_persistent_context, detail_type)
            if detail.has_persistent_tile():
                return id_strings.detail(module, detail_type)
            if detail.persist_case_context and detail_type == "case_short":
                # persistent_case_context will not work on product lists.
                return id_strings.persistent_case_context_detail(module)
        return None

    def _get_detail_inline_attr_from_module(self, module, module_unique_id):
        module_for_persistent_context = self._get_module_for_persistent_context(
            module_unique_id=module_unique_id
        )
        if module_for_persistent_context:
            return self.details_helper.get_detail_id_safe(module_for_persistent_context, "case_long")

    def get_detail_inline_attr(self, module, detail_type="case_short"):
        assert detail_type in ["case_short", "product_short"]
        detail, detail_enabled = self._get_detail_from_module(module, detail_type)
        if detail_enabled and detail.pull_down_tile:
            if detail_type == "case_short" and detail.persistent_case_tile_from_module:
                inline_attr = self._get_detail_inline_attr_from_module(
                    module, detail.persistent_case_tile_from_module)
                if inline_attr:
                    return inline_attr
            if detail.has_persistent_tile():
                list_type = "case_long" if detail_type == "case_short" else "product_long"
                return self.details_helper.get_detail_id_safe(module, list_type)
        return None

    def _get_detail_from_module(self, module, detail_type):
        """
        Return the Detail object of the given type from the given module
        """
        details = {d[0]: d for d in module.get_details()}
        _, detail, detail_enabled = details[detail_type]
        return detail, detail_enabled


def _update_refs(datums, old_id, new_id):
    """
    Update references in the nodeset of the given datum, if necessary

    e.g. instance('casedb')/casedb/case
             [@case_type='guppy']
             [@status='open']
             [index/parent=instance('commcaresession')/session/data/parent_id]

    is updated to
         instance('casedb')/casedb/case[@case_type='guppy']
             [@status='open']
             [index/parent=instance('commcaresession')/session/data/case_id]
                                                                    ^^^^^^^
    because the case referred to by "parent_id" in the child module has the ID
    "case_id" in the parent module.
    """
    old = session_var(old_id)
    new = session_var(new_id)

    for datum in datums:
        for prop in ['nodeset', 'function']:
            xpath = getattr(datum, prop, None)
            if xpath:
                setattr(datum, prop, xpath.replace(old, new))


def _get_datums_by_case_tag(datums):
    ret = defaultdict(list)
    for datum in datums:
        if datum.action:
            if hasattr(datum.action, 'case_indices'):
                # This is an advanced module
                for case_index in datum.action.case_indices:
                    ret[case_index.tag].append(datum.datum)
            else:
                ret['basic'].append(datum.datum)
    return ret


def _same_case(this_datum_meta, parent_datum_meta):
    return (this_datum_meta.case_type == parent_datum_meta.case_type
            and this_datum_meta.datum.ROOT_NAME == parent_datum_meta.datum.ROOT_NAME)
