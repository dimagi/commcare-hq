from __future__ import absolute_import
from __future__ import unicode_literals
from django.utils.translation import ugettext as _

from celery.task import task

from corehq.apps.app_manager.dbaccessors import get_app, get_latest_build_id, get_auto_generated_built_apps
from corehq.apps.app_manager.exceptions import SavedAppBuildException
from corehq.apps.users.models import CommCareUser
from corehq.util.decorators import serial_task


@task(serializer='pickle', queue='background_queue', ignore_result=True)
def create_user_cases(domain_name):
    from corehq.apps.callcenter.utils import sync_usercase
    for user in CommCareUser.by_domain(domain_name):
        sync_usercase(user)


@serial_task(serializer='pickle', '{app._id}-{app.version}', max_retries=0, timeout=60*60)
def make_async_build(app, username, release=False, comment=None):
    latest_build = app.get_latest_app(released_only=False)
    if latest_build and latest_build.version == app.version:
        return
    errors = app.validate_app()
    if not errors:
        if comment is None:
            comment = _('Auto-generated by a phone update. Will expire after next build if not marked released.')
        copy = app.make_build(
            previous_version=latest_build,
            comment=comment,
        )
        copy.is_auto_generated = True
        copy.is_released = release
        copy.save(increment_version=False)
        return copy


@task(serializer='pickle', queue='background_queue', ignore_result=True)
def create_build_files_for_all_app_profiles(domain, build_id):
    app = get_app(domain, build_id)
    build_profiles = app.build_profiles
    save_app = False
    for profile in build_profiles:
        if not app.has_attachment('files/{id}/profile.xml'.format(id=profile)):
            app.create_build_files(build_profile_id=profile)
            save_app = True
    if save_app:
        app.save()


@task(serializer='pickle', queue='background_queue')
def prune_auto_generated_builds(domain, app_id):
    last_build_id = get_latest_build_id(domain, app_id)
    saved_builds = get_auto_generated_built_apps(domain, app_id)

    for doc in saved_builds:
        app = get_app(domain, doc['_id'])
        if app.id == last_build_id or app.is_released:
            continue
        if not app.is_auto_generated or app.copy_of != app_id or app.id == last_build_id:
            raise SavedAppBuildException("Attempted to delete build that should not be deleted")
        app.delete()
