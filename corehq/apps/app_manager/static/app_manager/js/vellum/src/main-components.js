/**
 * @license text 2.0.16 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text/text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.16',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

define('text', ['text/text'], function (main) { return main; });

// RequireJS UnderscoreJS template plugin
// http://github.com/jfparadis/requirejs-tpl
//
// An alternative to http://github.com/ZeeAgency/requirejs-tpl
//
// Using UnderscoreJS micro-templates at http://underscorejs.org/#template
// Using and RequireJS text.js at http://requirejs.org/docs/api.html#text
// @author JF Paradis
// @version 0.0.5
//
// Released under the MIT license
//
// Usage:
//   require(['backbone', 'tpl!mytemplate'], function (Backbone, mytemplate) {
//     return Backbone.View.extend({
//       initialize: function(){
//         this.render();
//       },
//       render: function(){
//         this.$el.html(mytemplate({message: 'hello'}));
//     });
//   });
//
// Configuration: (optional)
//   require.config({
//     tpl: {
//       extension: '.tpl' // default = '.html'
//     }
//   });

/*jslint nomen: true */
/*global define: false */

define('tpl/tpl',['text', 'underscore'], function (text, _) {
    'use strict';

    var buildMap = {},
        buildTemplateSource = "define('{pluginName}!{moduleName}', ['underscore'], function (_) { return {source}; });\n";

    return {
        version: '0.0.5',

        load: function (moduleName, parentRequire, onload, config) {

            if (config.tpl && config.tpl.templateSettings) {
                _.templateSettings = config.tpl.templateSettings;
            }

            if (buildMap[moduleName]) {
                onload(buildMap[moduleName]);

            } else {
                var ext = config.tpl && !_.isUndefined(config.tpl.extension) ? config.tpl.extension : '.html';
                var path = (config.tpl && config.tpl.path) || '';
                text.load(path + moduleName + ext, parentRequire, function (source) {
                    buildMap[moduleName] = _.template(source);
                    onload(buildMap[moduleName]);
                }, config);
            }
        },

        write: function (pluginName, moduleName, write) {
            var build = buildMap[moduleName],
                source = build && build.source;
            if (source) {
                write.asModule(pluginName + '!' + moduleName,
                    buildTemplateSource
                    .replace('{pluginName}', pluginName)
                    .replace('{moduleName}', moduleName)
                    .replace('{source}', source));
            }
        }
    };
});

define('tpl', ['tpl/tpl'], function (main) { return main; });


define('tpl/tpl!vellum/templates/main', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-ui-container">\n    <div class="fd-content fd-content-left">\n        <div class="fd-tree">\n            <div class="fd-head">\n                <h2>\n                    <i class="fd-form-icon"></i>\n                    <span class="fd-head-text">'+
((__t=(gettext("Questions")))==null?'':_.escape(__t))+
'</span>\n                </h2>\n                <div class="fd-head-menu-container">\n                    <div class="dropdown">\n                        <a class="dropdown-toggle"\n                           data-toggle="dropdown">\n                            <i class="fa fa-reorder"></i>\n                            <i class="fa fa-caret-down"></i>\n                        </a>\n                        <ul class="dropdown-menu checklist fd-questions-menu fd-scrollable-minimal" role="menu">\n                            <li>\n                                <a class="fd-button-copy">\n                                    <i class="fa fa-copy"></i>\n                                    '+
((__t=(gettext("Copy")))==null?'':_.escape(__t))+
'<span class="hotkey">'+
((__t=(Ctrl))==null?'':_.escape(__t))+
'C</span>\n                                </a>\n                            </li>\n                            <li>\n                                <a class="fd-expand-all">\n                                    <i class="fa fa-angle-double-down"></i>\n                                    '+
((__t=(gettext("Expand All")))==null?'':_.escape(__t))+
'<span class="hotkey">'+
((__t=(Ctrl))==null?'':_.escape(__t))+
''+
((__t=(Alt))==null?'':_.escape(__t))+
'=</span>\n                                </a>\n                            </li>\n                            <li>\n                                <a class="fd-collapse-all">\n                                    <i class="fa fa-angle-double-right"></i>\n                                    '+
((__t=(gettext("Collapse All")))==null?'':_.escape(__t))+
'<span class="hotkey">'+
((__t=(Ctrl))==null?'':_.escape(__t))+
''+
((__t=(Alt))==null?'':_.escape(__t))+
'&ndash;</span>\n                                </a>\n                            </li>\n                            <li class="divider fd-bulk-update-menu"></li>\n                            <li class="dropdown-header fd-bulk-update-header">\n                              '+
((__t=(gettext("Bulk Update All Questions")))==null?'':_.escape(__t))+
'\n                            </li>\n                            <li class="divider fd-tools-menu"></li>\n                        </ul>\n                        <input type="hidden" class="fd-question-tree-display" />\n                    </div>\n                </div>\n            </div>\n            <div class="dropdown fd-add-question-dropdown">\n                <a class="fd-add-question dropdown-toggle btn btn-purple" data-toggle="dropdown">\n                    <i class="fa fa-plus"></i> '+
((__t=(gettext("Add Question")))==null?'':_.escape(__t))+
'\n                    <i class="fa fa-caret-down"></i>\n                </a>\n            </div>\n            <div class="fd-undo-container"> </div>\n            <div class="fd-scrollable fd-scrollable-tree">\n                <div class="fd-question-tree"></div>\n                <div class="hide fd-default-panel fd-default-qtree">\n                  <div class="helpbubble helpbubble-purple helpbubble-top-left">\n                    <p class="lead">\n                    ';

                        var msg = gettext("Click {btn} to start building your form."),
                            add = gettext("Add Question"),
                            btn = '<i class="fa fa-plus"></i> <strong>' + add + '</strong>';
                        print(format(msg, {btn: btn}));
                    
__p+='\n                    </p>\n                    <p class="fd-default-helptext"></p>\n                  </div>\n                </div>\n            </div>\n        </div>\n        <div class="fd-external-sources-divider fd-content-left-divider fd-content-horizontal-divider"></div>\n        <div class="fd-accessory-pane"></div>\n    </div>\n    <div class="fd-content fd-content-divider fd-content-vertical-divider"></div>\n    <div class="fd-content fd-content-right">\n        <div class="fd-form-actions btn-toolbar">\n            <div class="btn-group fd-save-button"></div>\n        </div>\n        <div class="fd-column fd-question-properties hide">\n            <div class="fd-head"><h2>'+
((__t=(gettext("Question Details")))==null?'':_.escape(__t))+
'</h2></div>\n            <div class="fd-props-toolbar"></div>\n            <div class="fd-scrollable fd-props-scrollable">\n                <form class="form form-horizontal fd-props-content"></form>\n            </div>\n        </div>\n        <div class="fd-xpath-editor fd-column hide">\n            <div class="fd-head"><h2>'+
((__t=(gettext("Expression Editor")))==null?'':_.escape(__t))+
'</h2></div>\n            <div class="fd-scrollable full">\n                <div class="fd-xpath-editor-content"></div>\n            </div>\n        </div>\n        <div class="fd-column hide fd-default-panel">\n        </div>\n    </div>\n\n    <div class="fd-messages"></div>\n</div>\n<!-- Begin modal divs -->\n<div class="fd-multimedia-modal-container"></div>\n<div class="fd-modal-generic-container"></div>\n<!-- end modal divs -->\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/add_question', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="dropdown-menu multi-level" role="menu">\n    ';
 _.each(groups, function(group) { 
__p+='\n        ';
 if (group.questions.length > 1) { 
__p+='\n            <li class="dropdown-submenu">\n                <a tabindex="-1" class="fd-question-type" data-qtype="'+
((__t=( group.defaultQuestion.slug ))==null?'':__t)+
'">\n                    <i class="'+
((__t=( group.defaultQuestion.icon ))==null?'':__t)+
'"></i>\n                    '+
((__t=( group.name ))==null?'':__t)+
'\n                </a>\n                <ul class="dropdown-menu">\n        ';
 } 
__p+='\n                    ';
 _.each(group.questions, function(question) { 
__p+='\n                        <li>\n                            <a tabindex="-1" class="fd-question-type" data-qtype="'+
((__t=( question.slug ))==null?'':__t)+
'">\n                                <i class="'+
((__t=( question.icon ))==null?'':__t)+
'"></i> '+
((__t=( question.name ))==null?'':__t)+
'\n                            </a>\n                        </li>\n                    ';
 }) 
__p+='\n        ';
 if (group.questions.length > 1) { 
__p+='\n                </ul>\n            </li>\n        ';
 } 
__p+='\n    ';
 }); 
__p+='\n</ul>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/edit_source', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-source-container">\n    <p>\n        '+
((__t=(description))==null?'':__t)+
'\n    </p>\n    <textarea class="form-control" rows="16"></textarea>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/confirm_overwrite', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-source-container">\n    <p>\n        '+
((__t=(description))==null?'':__t)+
'\n    </p>\n    <div id="form-differences">\n      <pre>\n          '+
((__t=(xmldiff))==null?'':__t)+
'\n      </pre>\n    </div>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/control_group_stdInput', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="form-group">\n    <label class="control-label col-sm-3">\n        '+
((__t=(label))==null?'':__t)+
'\n    </label>\n    <div class="col-sm-9">\n        <input type="'+
((__t=(type))==null?'':__t)+
'"';
 if (type === 'text') { 
__p+=' class="form-control"';
 } 
__p+=' />\n    </div>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/form_errors_template', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul>\n';
 _.each(errors, function (error) { 
__p+='\n    <li>\n        '+
((__t=( error.mug.getDisplayName(displayLanguage) ))==null?'':__t)+
'\n        <ul>\n        ';
 _.each(error.errors, function (error) { 
__p+='\n            <li>'+
((__t=( error.message ))==null?'':__t)+
'</li>\n        ';
 }); 
__p+='\n        </ul>\n    </li>\n';
 }); 
__p+='\n</ul>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/question_fieldset', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<fieldset class="fd-question-fieldset';
 if (isCollapsed) { 
__p+=' hide';
 } 
__p+='" data-slug="'+
((__t=( fieldsetSlug ))==null?'':__t)+
'">\n    <legend>\n        ';
 if (help) { 
__p+='\n        <div class="fd-help pull-right">\n            <a class="help" tabindex="-1"\n                data-title="'+
((__t=(help.title))==null?'':__t)+
'"\n                data-content="'+
((__t=(help.text))==null?'':__t)+
'<p><a target=\'_blank\' href=\''+
((__t=(help.link))==null?'':__t)+
'\'>See More</a></p>"\n                data-placement="left">\n            </a>\n        </div>\n        ';
 } 
__p+='\n        '+
((__t=(fieldsetTitle))==null?'':__t)+
'\n    </legend>\n    <!-- todo: don\'t require passing a unique ID to this template or an\n    interface that exposes it (i.e., allow passing a non-unique id and then\n    append it to a random one, or something -->\n    <div id="'+
((__t=(fieldsetClass))==null?'':__t)+
'">\n        <div class="fd-fieldset-content"></div>\n    </div>\n</fieldset>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/question_type_changer', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="btn-group question-type-changer">\n    <a class="btn btn-default dropdown-toggle current-question"\n        data-toggle="dropdown">\n        <i class="'+
((__t=(currentQuestionIcon))==null?'':__t)+
'"></i> \n        '+
((__t=( currentTypeName ))==null?'':__t)+
' <span class="caret"></span>\n    </a>\n    <ul class="dropdown-menu">\n        ';
 if (questions.length === 0) { 
__p+='\n            <li class="dropdown-header">'+
((__t=(gettext("Cannot Change Question Type")))==null?'':_.escape(__t))+
'</li>\n        ';
 } else { 
__p+='\n            <li class="dropdown-header">'+
((__t=(gettext("Change Question Type To")))==null?'':_.escape(__t))+
'</li>\n            ';
 _.each(questions, function(question) { 
__p+='\n            <li>\n                <a class="change-question" data-qtype="'+
((__t=(question.slug))==null?'':__t)+
'">\n                    <i class="'+
((__t=(question.icon))==null?'':__t)+
'"></i> '+
((__t=(question.name))==null?'':__t)+
'\n                </a>\n            </li>\n            ';
 }); 
__p+='\n        ';
 } 
__p+='\n\n    </ul>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/question_toolbar', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-question-toolbar-container clearfix">\n    ';
 if (isCopyable) { 
__p+='<div class="btn-toolbar pull-left"></div>';
 } 
__p+='\n    <div class="btn-toolbar pull-right">\n        ';
 if (isDeleteable) { 
__p+='\n            <button type="button" class="btn btn-danger fd-button-remove"  tabindex="-1">\n                <i class="fa-regular fa-trash-can"></i> '+
((__t=(gettext("Delete")))==null?'':_.escape(__t))+
'\n            </button>\n        ';
 } 
__p+='\n        ';
 if (sections.length) { 
__p+='\n            <div class="btn-group fd-section-changer">\n                <a class="btn btn-default dropdown-toggle" data-toggle="dropdown">\n                    <i class="fa fa-reorder"></i>\n                    <i class="fa fa-caret-down"></i>\n                </a>\n                <ul class="dropdown-menu dropdown-menu-right checklist">\n                    <li class="dropdown-header">'+
((__t=(gettext("Show")))==null?'':_.escape(__t))+
'</li>\n                    ';
 _.each(sections, function(section) { 
__p+='\n                    <li>\n                        <a data-slug="'+
((__t=( section.slug ))==null?'':__t)+
'" ';
 if (section.show) { 
__p+='class="selected"';
 } 
__p+='>\n                            <i class="fa fa-check"></i>'+
((__t=( section.displayName ))==null?'':__t)+
'\n                        </a>\n                    </li>\n                    ';
 }); 
__p+='\n                </ul>\n            </div>\n        ';
 } 
__p+='\n    </div>\n</div>\n<div class="alert alert-info fd-question-comment"\n';
 if (!comment) { 
__p+='\n  style="display: none"\n';
 } 
__p+='\n>'+
((__t=( comment ))==null?'':__t)+
'</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/alert_global', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="alert alert-block '+
((__t=(messageType.cssClass))==null?'':__t)+
'">\n    <button type="button" class="close" data-dismiss="alert">&times;</button>\n    <h4>';
 if (messageType.icon) { 
__p+='<i class="'+
((__t=(messageType.icon))==null?'':__t)+
'"></i> ';
 } 
__p+=''+
((__t=(messageType.title))==null?'':__t)+
'</h4>\n    <ul>\n        ';
 _.each(messages, function (message) { 
__p+='\n        <li>'+
((__t=(message))==null?'':_.escape(__t))+
'</li>\n        ';
 }); 
__p+='\n    </ul>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/modal_content', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="modal fade">\n    <div class="modal-dialog">\n        <div class="modal-content">\n            <div class="modal-header">\n                <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n                <h4 class="modal-title">\n                    ';
 if (headerIcon) { 
__p+='\n                        <i class="'+
((__t=(headerIcon))==null?'':__t)+
'"></i>\n                    ';
 } 
__p+='\n                    '+
((__t=(title))==null?'':__t)+
'\n                </h4>\n            </div>\n            <div class="modal-body form form-horizontal">\n            </div>\n            <div class="modal-footer">\n                ';
 if (closeButtonTitle) { 
__p+='\n                <button class="btn btn-default" data-dismiss="modal" aria-hidden="true">\n                    '+
((__t=(closeButtonTitle))==null?'':__t)+
'\n                </button>\n                ';
 } 
__p+='\n            </div>\n        </div>\n    </div>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/modal_button', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button class="btn '+
((__t=(cssClasses))==null?'':__t)+
'';
 if (defaultButton) { 
__p+=' btn-default';
 } 
__p+='">\n    '+
((__t=( title ))==null?'':__t)+
'\n</button>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/find_usages', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<table class="table table-hover">\n  <thead>\n    <th>'+
((__t=(gettext("Question")))==null?'':_.escape(__t))+
'</th>\n    <th>'+
((__t=(gettext("Used By")))==null?'':_.escape(__t))+
'</th>\n    <th>'+
((__t=(gettext("In Property")))==null?'':_.escape(__t))+
'</th>\n  </thead>\n  ';
 _.each(tableData, function(refs, question) { 
__p+='\n     <tr>\n       <td><a class="link-to-question">'+
((__t=( question ))==null?'':_.escape(__t))+
'</a></td>\n       <td></td>\n       <td></td>\n     </tr>\n     ';
 _.each(refs, function(propName, path) {
__p+='\n       <tr class="usage-row">\n         <td></td>\n         <td><a class="link-to-question">'+
((__t=( path ))==null?'':_.escape(__t))+
'</a></td>\n         <td>'+
((__t=( propName ))==null?'':_.escape(__t))+
'</td>\n       </tr>\n     ';
 }); 
__p+='\n   ';
 }); 
__p+='\n</table>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/find_usages_search', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-search">\n  <div class=\'form-inline\'>\n    <div>\n      <label class="control-label" for="findUsagesSearch">\n        <i class="fa fa-search"></i>\n      </label>\n      <div class="fd-search-control">\n        <input type="text"\n               class="form-control search-query"\n               id="findUsagesSearch"\n               placeholder="'+
((__t=(gettext("Search...")))==null?'':_.escape(__t))+
'"\n               style="width: calc(100% - 42px);"\n               autocomplete="off"/>\n      </div>\n    </div>\n  </div>\n</div>\n';
}
return __p;
}; });

/** @license
 * RequireJS plugin for loading JSON files
 * - depends on Text plugin and it was HEAVILY "inspired" by it as well.
 * Author: Miller Medeiros
 * Version: 0.3.2 (2013/08/17)
 * Released under the MIT license
 */
define('json/json',['text'], function(text){

    var CACHE_BUST_QUERY_PARAM = 'bust',
        CACHE_BUST_FLAG = '!bust',
        jsonParse = (typeof JSON !== 'undefined' && typeof JSON.parse === 'function')? JSON.parse : function(val){
            return eval('('+ val +')'); //quick and dirty
        },
        buildMap = {};

    function cacheBust(url){
        url = url.replace(CACHE_BUST_FLAG, '');
        url += (url.indexOf('?') < 0)? '?' : '&';
        return url + CACHE_BUST_QUERY_PARAM +'='+ Math.round(2147483647 * Math.random());
    }

    //API
    return {

        load : function(name, req, onLoad, config) {
            if ( config.isBuild && (config.inlineJSON === false || name.indexOf(CACHE_BUST_QUERY_PARAM +'=') !== -1) ) {
                //avoid inlining cache busted JSON or if inlineJSON:false
                onLoad(null);
            } else {
                text.get(req.toUrl(name), function(data){
                    if (config.isBuild) {
                        buildMap[name] = data;
                        onLoad(data);
                    } else {
                        onLoad(jsonParse(data));
                    }
                },
                    onLoad.error, {
                        accept: 'application/json'
                    }
                );
            }
        },

        normalize : function (name, normalize) {
            // used normalize to avoid caching references to a "cache busted" request
            if (name.indexOf(CACHE_BUST_FLAG) !== -1) {
                name = cacheBust(name);
            }
            // resolve any relative paths
            return normalize(name);
        },

        //write method based on RequireJS official text plugin by James Burke
        //https://github.com/jrburke/requirejs/blob/master/text.js
        write : function(pluginName, moduleName, write){
            if(moduleName in buildMap){
                var content = buildMap[moduleName];
                write('define("'+ pluginName +'!'+ moduleName +'", function(){ return '+ content +';});\n');
            }
        }

    };
});

define('json', ['json/json'], function (main) { return main; });


define("json/json!langCodes", function(){ return [
    {
        "names": ["Afar"],
        "two": "aa",
        "three": "aar"
    },
    {
        "names": ["Abkhazian"],
        "two": "ab",
        "three": "abk"
    },
    {
        "names": ["Achinese"],
        "two": "",
        "three": "ace"
    },
    {
        "names": ["Acoli"],
        "two": "",
        "three": "ach"
    },
    {
        "names": ["Adangme"],
        "two": "",
        "three": "ada"
    },
    {
        "names": ["Adyghe", "Adygei"],
        "two": "",
        "three": "ady"
    },
    {
        "names": ["Afro-Asiatic languages"],
        "two": "",
        "three": "afa"
    },
    {
        "names": ["Afrihili"],
        "two": "",
        "three": "afh"
    },
    {
        "names": ["Afrikaans"],
        "two": "af",
        "three": "afr"
    },
    {
        "names": ["Ainu"],
        "two": "",
        "three": "ain"
    },
    {
        "names": ["Akan"],
        "two": "ak",
        "three": "aka"
    },
    {
        "names": ["Akkadian"],
        "two": "",
        "three": "akk"
    },
    {
        "names": ["Albanian"],
        "two": "sq",
        "three": "sqi"
    },
    {
        "names": ["Aleut"],
        "two": "",
        "three": "ale"
    },
    {
        "names": ["Algonquian languages"],
        "two": "",
        "three": "alg"
    },
    {
        "names": ["Southern Altai"],
        "two": "",
        "three": "alt"
    },
    {
        "names": ["Amharic"],
        "two": "am",
        "three": "amh"
    },
    {
        "names": ["Angika"],
        "two": "",
        "three": "anp"
    },
    {
        "names": ["Anuak"],
        "two": "",
        "three": "anu"
    },
    {
        "names": ["Apache languages"],
        "two": "",
        "three": "apa"
    },
    {
        "names": ["Arabic"],
        "two": "ar",
        "three": "ara"
    },
    {
        "names": ["Official Aramaic (700-300 BCE)", "Imperial Aramaic (700-300 BCE)"],
        "two": "",
        "three": "arc"
    },
    {
        "names": ["Aragonese"],
        "two": "an",
        "three": "arg"
    },
    {
        "names": ["Armenian"],
        "two": "hy",
        "three": "hye"
    },
    {
        "names": ["Mapudungun", "Mapuche"],
        "two": "",
        "three": "arn"
    },
    {
        "names": ["Arapaho"],
        "two": "",
        "three": "arp"
    },
    {
        "names": ["Artificial languages"],
        "two": "",
        "three": "art"
    },
    {
        "names": ["Arawak"],
        "two": "",
        "three": "arw"
    },
    {
        "names": ["Assamese"],
        "two": "as",
        "three": "asm"
    },
    {
        "names": ["Asturian", "Bable", "Leonese", "Asturleonese"],
        "two": "",
        "three": "ast"
    },
    {
        "names": ["Athapascan languages"],
        "two": "",
        "three": "ath"
    },
    {
        "names": ["Australian languages"],
        "two": "",
        "three": "aus"
    },
    {
        "names": ["Avaric"],
        "two": "av",
        "three": "ava"
    },
    {
        "names": ["Avestan"],
        "two": "ae",
        "three": "ave"
    },
    {
        "names": ["Awadhi"],
        "two": "",
        "three": "awa"
    },
    {
        "names": ["Aymara"],
        "two": "ay",
        "three": "aym"
    },
    {
        "names": ["Azerbaijani"],
        "two": "az",
        "three": "aze"
    },
    {
        "names": ["Banda languages"],
        "two": "",
        "three": "bad"
    },
    {
        "names": ["Bamileke languages"],
        "two": "",
        "three": "bai"
    },
    {
        "names": ["Bashkir"],
        "two": "ba",
        "three": "bak"
    },
    {
        "names": ["Baluchi"],
        "two": "",
        "three": "bal"
    },
    {
        "names": ["Bambara"],
        "two": "bm",
        "three": "bam"
    },
    {
        "names": ["Balinese"],
        "two": "",
        "three": "ban"
    },
    {
        "names": ["Basque"],
        "two": "eu",
        "three": "eus"
    },
    {
        "names": ["Basa"],
        "two": "",
        "three": "bas"
    },
    {
        "names": ["Baltic languages"],
        "two": "",
        "three": "bat"
    },
    {
        "names": ["Beja", "Bedawiyet"],
        "two": "",
        "three": "bej"
    },
    {
        "names": ["Belarusian"],
        "two": "be",
        "three": "bel"
    },
    {
        "names": ["Bemba"],
        "two": "",
        "three": "bem"
    },
    {
        "names": ["Bengali"],
        "two": "bn",
        "three": "ben"
    },
    {
        "names": ["Berber languages"],
        "two": "",
        "three": "ber"
    },
    {
        "names": ["Bhojpuri"],
        "two": "",
        "three": "bho"
    },
    {
        "names": ["Bihari languages"],
        "two": "bh",
        "three": "bih"
    },
    {
        "names": ["Bikol"],
        "two": "",
        "three": "bik"
    },
    {
        "names": ["Bini", "Edo"],
        "two": "",
        "three": "bin"
    },
    {
        "names": ["Bislama"],
        "two": "bi",
        "three": "bis"
    },
    {
        "names": ["Siksika"],
        "two": "",
        "three": "bla"
    },
    {
        "names": ["Bantu (Other)"],
        "two": "",
        "three": "bnt"
    },
    {
        "names": ["Bosnian"],
        "two": "bs",
        "three": "bos"
    },
    {
        "names": ["Braj"],
        "two": "",
        "three": "bra"
    },
    {
        "names": ["Breton"],
        "two": "br",
        "three": "bre"
    },
    {
        "names": ["Batak languages"],
        "two": "",
        "three": "btk"
    },
    {
        "names": ["Buriat"],
        "two": "",
        "three": "bua"
    },
    {
        "names": ["Buginese"],
        "two": "",
        "three": "bug"
    },
    {
        "names": ["Bulgarian"],
        "two": "bg",
        "three": "bul"
    },
    {
        "names": ["Burmese"],
        "two": "my",
        "three": "mya"
    },
    {
        "names": ["Blin", "Bilin"],
        "two": "",
        "three": "byn"
    },
    {
        "names": ["Caddo"],
        "two": "",
        "three": "cad"
    },
    {
        "names": ["Central American Indian languages"],
        "two": "",
        "three": "cai"
    },
    {
        "names": ["Galibi Carib"],
        "two": "",
        "three": "car"
    },
    {
        "names": ["Catalan", "Valencian"],
        "two": "ca",
        "three": "cat"
    },
    {
        "names": ["Caucasian languages"],
        "two": "",
        "three": "cau"
    },
    {
        "names": ["Cebuano"],
        "two": "",
        "three": "ceb"
    },
    {
        "names": ["Celtic languages"],
        "two": "",
        "three": "cel"
    },
    {
        "names": ["Chamorro"],
        "two": "ch",
        "three": "cha"
    },
    {
        "names": ["Chibcha"],
        "two": "",
        "three": "chb"
    },
    {
        "names": ["Chechen"],
        "two": "ce",
        "three": "che"
    },
    {
        "names": ["Chagatai"],
        "two": "",
        "three": "chg"
    },
    {
        "names": ["Chinese"],
        "two": "zh",
        "three": "zho"
    },
    {
        "names": ["Chuukese"],
        "two": "",
        "three": "chk"
    },
    {
        "names": ["Mari"],
        "two": "",
        "three": "chm"
    },
    {
        "names": ["Chinook jargon"],
        "two": "",
        "three": "chn"
    },
    {
        "names": ["Choctaw"],
        "two": "",
        "three": "cho"
    },
    {
        "names": ["Chipewyan", "Dene Suline"],
        "two": "",
        "three": "chp"
    },
    {
        "names": ["Cherokee"],
        "two": "",
        "three": "chr"
    },
    {
        "names": ["Chuvash"],
        "two": "cv",
        "three": "chv"
    },
    {
        "names": ["Cheyenne"],
        "two": "",
        "three": "chy"
    },
    {
        "names": ["Chamic languages"],
        "two": "",
        "three": "cmc"
    },
    {
        "names": ["Coptic"],
        "two": "",
        "three": "cop"
    },
    {
        "names": ["Cornish"],
        "two": "kw",
        "three": "cor"
    },
    {
        "names": ["Corsican"],
        "two": "co",
        "three": "cos"
    },
    {
        "names": ["Creoles and pidgins, English based"],
        "two": "",
        "three": "cpe"
    },
    {
        "names": ["Creoles and pidgins, French-based"],
        "two": "",
        "three": "cpf"
    },
    {
        "names": ["Creoles and pidgins, Portuguese-based"],
        "two": "",
        "three": "cpp"
    },
    {
        "names": ["Cree"],
        "two": "cr",
        "three": "cre"
    },
    {
        "names": ["Crimean Tatar", "Crimean Turkish"],
        "two": "",
        "three": "crh"
    },
    {
        "names": ["Creoles and pidgins"],
        "two": "",
        "three": "crp"
    },
    {
        "names": ["Kashubian"],
        "two": "",
        "three": "csb"
    },
    {
        "names": ["Cushitic languages"],
        "two": "",
        "three": "cus"
    },
    {
        "names": ["Czech"],
        "two": "cs",
        "three": "ces"
    },
    {
        "names": ["Dagbani"],
        "two": "",
        "three": "dag"
    },
    {
        "names": ["Dakota"],
        "two": "",
        "three": "dak"
    },
    {
        "names": ["Danish"],
        "two": "da",
        "three": "dan"
    },
    {
        "names": ["Dargwa"],
        "two": "",
        "three": "dar"
    },
    {
        "names": ["Land Dayak languages"],
        "two": "",
        "three": "day"
    },
    {
        "names": ["Delaware"],
        "two": "",
        "three": "del"
    },
    {
        "names": ["Slave (Athapascan)"],
        "two": "",
        "three": "den"
    },
    {
        "names": ["Dogrib"],
        "two": "",
        "three": "dgr"
    },
    {
        "names": ["Diola"],
        "two": "",
        "three": "dyo"
    },
    {
        "names": ["Dinka"],
        "two": "",
        "three": "din"
    },
    {
        "names": ["Divehi", "Dhivehi", "Maldivian"],
        "two": "dv",
        "three": "div"
    },
    {
        "names": ["Dogri"],
        "two": "",
        "three": "doi"
    },
    {
        "names": ["Dravidian languages"],
        "two": "",
        "three": "dra"
    },
    {
        "names": ["Gedeo"],
        "two": "",
        "three": "drs"
    },
    {
        "names": ["Lower Sorbian"],
        "two": "",
        "three": "dsb"
    },
    {
        "names": ["Duala"],
        "two": "",
        "three": "dua"
    },
    {
        "names": ["Dutch, Middle (ca.1050-1350)"],
        "two": "",
        "three": "dum"
    },
    {
        "names": ["Dutch", "Flemish"],
        "two": "nl",
        "three": "nld"
    },
    {
        "names": ["Dyula"],
        "two": "",
        "three": "dyu"
    },
    {
        "names": ["Dzongkha"],
        "two": "dz",
        "three": "dzo"
    },
    {
        "names": ["Efik"],
        "two": "",
        "three": "efi"
    },
    {
        "names": ["Egyptian (Ancient)"],
        "two": "",
        "three": "egy"
    },
    {
        "names": ["Ekajuk"],
        "two": "",
        "three": "eka"
    },
    {
        "names": ["Elamite"],
        "two": "",
        "three": "elx"
    },
    {
        "names": ["English"],
        "two": "en",
        "three": "eng"
    },
    {
        "names": ["Esperanto"],
        "two": "eo",
        "three": "epo"
    },
    {
        "names": ["Estonian"],
        "two": "et",
        "three": "est"
    },
    {
        "names": ["Ewe"],
        "two": "ee",
        "three": "ewe"
    },
    {
        "names": ["Ewondo"],
        "two": "",
        "three": "ewo"
    },
    {
        "names": ["Fang"],
        "two": "",
        "three": "fan"
    },
    {
        "names": ["Faroese"],
        "two": "fo",
        "three": "fao"
    },
    {
        "names": ["Fanti"],
        "two": "",
        "three": "fat"
    },
    {
        "names": ["Fijian"],
        "two": "fj",
        "three": "fij"
    },
    {
        "names": ["Filipino", "Pilipino"],
        "two": "",
        "three": "fil"
    },
    {
        "names": ["Finnish"],
        "two": "fi",
        "three": "fin"
    },
    {
        "names": ["Finno-Ugrian languages"],
        "two": "",
        "three": "fiu"
    },
    {
        "names": ["Fon"],
        "two": "",
        "three": "fon"
    },
    {
        "names": ["French"],
        "two": "fr",
        "three": "fra"
    },
    {
        "names": ["French, Middle (ca.1400-1600)"],
        "two": "",
        "three": "frm"
    },
    {
        "names": ["Northern Frisian"],
        "two": "",
        "three": "frr"
    },
    {
        "names": ["Eastern Frisian"],
        "two": "",
        "three": "frs"
    },
    {
        "names": ["Western Frisian"],
        "two": "fy",
        "three": "fry"
    },
    {
        "names": ["Pulaar"],
        "two": "",
        "three": "fuc"
    },
    {
        "names": ["Fulah"],
        "two": "ff",
        "three": "ful"
    },
    {
        "names": ["Friulian"],
        "two": "",
        "three": "fur"
    },
    {
        "names": ["Ga"],
        "two": "",
        "three": "gaa"
    },
    {
        "names": ["Gayo"],
        "two": "",
        "three": "gay"
    },
    {
        "names": ["Gbaya"],
        "two": "",
        "three": "gba"
    },
    {
        "names": ["Germanic languages"],
        "two": "",
        "three": "gem"
    },
    {
        "names": ["Garo"],
        "two": "",
        "three": "grt"
    },
    {
        "names": ["Georgian"],
        "two": "ka",
        "three": "kat"
    },
    {
        "names": ["Koore", "Koorete"],
        "two": "",
        "three": "kqy"
    },
    {
        "names": ["German"],
        "two": "de",
        "three": "deu"
    },
    {
        "names": ["Geez"],
        "two": "",
        "three": "gez"
    },
    {
        "names": ["Gilbertese"],
        "two": "",
        "three": "gil"
    },
    {
        "names": ["Gaelic", "Scottish Gaelic"],
        "two": "gd",
        "three": "gla"
    },
    {
        "names": ["Irish"],
        "two": "ga",
        "three": "gle"
    },
    {
        "names": ["Galician"],
        "two": "gl",
        "three": "glg"
    },
    {
        "names": ["Manx"],
        "two": "gv",
        "three": "glv"
    },
    {
        "names": ["German, Middle High (ca.1050-1500)"],
        "two": "",
        "three": "gmh"
    },
    {
        "names": ["Gondi"],
        "two": "",
        "three": "gon"
    },
    {
        "names": ["Gorontalo"],
        "two": "",
        "three": "gor"
    },
    {
        "names": ["Gothic"],
        "two": "",
        "three": "got"
    },
    {
        "names": ["Grebo"],
        "two": "",
        "three": "grb"
    },
    {
        "names": ["Greek, Ancient (to 1453)"],
        "two": "",
        "three": "grc"
    },
    {
        "names": ["Greek, Modern (1453-)"],
        "two": "el",
        "three": "ell"
    },
    {
        "names": ["Guarani"],
        "two": "gn",
        "three": "grn"
    },
    {
        "names": ["Swiss German", "Alemannic", "Alsatian"],
        "two": "",
        "three": "gsw"
    },
    {
        "names": ["Gujarati"],
        "two": "gu",
        "three": "guj"
    },
    {
        "names": ["Gwich'in"],
        "two": "",
        "three": "gwi"
    },
    {
        "names": ["Haida"],
        "two": "",
        "three": "hai"
    },
    {
        "names": ["Haitian", "Haitian Creole"],
        "two": "ht",
        "three": "hat"
    },
    {
        "names": ["Hausa"],
        "two": "ha",
        "three": "hau"
    },
    {
        "names": ["Hawaiian"],
        "two": "",
        "three": "haw"
    },
    {
        "names": ["Hebrew"],
        "two": "he",
        "three": "heb"
    },
    {
        "names": ["Herero"],
        "two": "hz",
        "three": "her"
    },
    {
        "names": ["Hiligaynon"],
        "two": "",
        "three": "hil"
    },
    {
        "names": ["Himachali languages", "Western Pahari languages"],
        "two": "",
        "three": "him"
    },
    {
        "names": ["Hindi"],
        "two": "hi",
        "three": "hin"
    },
    {
        "names": ["Hittite"],
        "two": "",
        "three": "hit"
    },
    {
        "names": ["Hmong", "Mong"],
        "two": "",
        "three": "hmn"
    },
    {
        "names": ["Hiri Motu"],
        "two": "ho",
        "three": "hmo"
    },
    {
        "names": ["Croatian"],
        "two": "hr",
        "three": "hrv"
    },
    {
        "names": ["Upper Sorbian"],
        "two": "",
        "three": "hsb"
    },
    {
        "names": ["Hungarian"],
        "two": "hu",
        "three": "hun"
    },
    {
        "names": ["Hupa"],
        "two": "",
        "three": "hup"
    },
    {
        "names": ["Iban"],
        "two": "",
        "three": "iba"
    },
    {
        "names": ["Igbo"],
        "two": "ig",
        "three": "ibo"
    },
    {
        "names": ["Icelandic"],
        "two": "is",
        "three": "isl"
    },
    {
        "names": ["Ido"],
        "two": "io",
        "three": "ido"
    },
    {
        "names": ["Sichuan Yi", "Nuosu"],
        "two": "ii",
        "three": "iii"
    },
    {
        "names": ["Ijo languages"],
        "two": "",
        "three": "ijo"
    },
    {
        "names": ["Inuktitut"],
        "two": "iu",
        "three": "iku"
    },
    {
        "names": ["Ila - Zambia"],
        "two": "",
        "three": "ilb"
    },
    {
        "names": ["Interlingue", "Occidental"],
        "two": "ie",
        "three": "ile"
    },
    {
        "names": ["Iloko"],
        "two": "",
        "three": "ilo"
    },
    {
        "names": ["Interlingua (International Auxiliary Language Association)"],
        "two": "ia",
        "three": "ina"
    },
    {
        "names": ["Indic languages"],
        "two": "",
        "three": "inc"
    },
    {
        "names": ["Indonesian"],
        "two": "id",
        "three": "ind"
    },
    {
        "names": ["Indo-European languages"],
        "two": "",
        "three": "ine"
    },
    {
        "names": ["Ingush"],
        "two": "",
        "three": "inh"
    },
    {
        "names": ["Inupiaq"],
        "two": "ik",
        "three": "ipk"
    },
    {
        "names": ["Iranian languages"],
        "two": "",
        "three": "ira"
    },
    {
        "names": ["Iroquoian languages"],
        "two": "",
        "three": "iro"
    },
    {
        "names": ["Italian"],
        "two": "it",
        "three": "ita"
    },
    {
        "names": ["Javanese"],
        "two": "jv",
        "three": "jav"
    },
    {
        "names": ["Lojban"],
        "two": "",
        "three": "jbo"
    },
    {
        "names": ["Japanese"],
        "two": "ja",
        "three": "jpn"
    },
    {
        "names": ["Judeo-Persian"],
        "two": "",
        "three": "jpr"
    },
    {
        "names": ["Judeo-Arabic"],
        "two": "",
        "three": "jrb"
    },
    {
        "names": ["Kara-Kalpak"],
        "two": "",
        "three": "kaa"
    },
    {
        "names": ["Kabyle"],
        "two": "",
        "three": "kab"
    },
    {
        "names": ["Kachin", "Jingpho"],
        "two": "",
        "three": "kac"
    },
    {
        "names": ["Kalaallisut", "Greenlandic"],
        "two": "kl",
        "three": "kal"
    },
    {
        "names": ["Kamba"],
        "two": "",
        "three": "kam"
    },
    {
        "names": ["Kannada"],
        "two": "kn",
        "three": "kan"
    },
    {
        "names": ["Karen languages"],
        "two": "",
        "three": "kar"
    },
    {
        "names": ["Kashmiri"],
        "two": "ks",
        "three": "kas"
    },
    {
        "names": ["Kanuri"],
        "two": "kr",
        "three": "kau"
    },
    {
        "names": ["Kawi"],
        "two": "",
        "three": "kaw"
    },
    {
        "names": ["Kazakh"],
        "two": "kk",
        "three": "kaz"
    },
    {
        "names": ["Kabardian"],
        "two": "",
        "three": "kbd"
    },
    {
        "names": ["Khasi"],
        "two": "",
        "three": "kha"
    },
    {
        "names": ["Khoisan languages"],
        "two": "",
        "three": "khi"
    },
    {
        "names": ["Central Khmer"],
        "two": "km",
        "three": "khm"
    },
    {
        "names": ["Khotanese", "Sakan"],
        "two": "",
        "three": "kho"
    },
    {
        "names": ["Kikuyu", "Gikuyu"],
        "two": "ki",
        "three": "kik"
    },
    {
        "names": ["Kinyarwanda"],
        "two": "rw",
        "three": "kin"
    },
    {
        "names": ["Kirghiz", "Kyrgyz"],
        "two": "ky",
        "three": "kir"
    },
    {
        "names": ["Kimbundu"],
        "two": "",
        "three": "kmb"
    },
    {
        "names": ["Konkani"],
        "two": "",
        "three": "kok"
    },
    {
        "names": ["Komi"],
        "two": "kv",
        "three": "kom"
    },
    {
        "names": ["Kongo"],
        "two": "kg",
        "three": "kon"
    },
    {
        "names": ["Korean"],
        "two": "ko",
        "three": "kor"
    },
    {
        "names": ["Kosraean"],
        "two": "",
        "three": "kos"
    },
    {
        "names": ["Kpelle"],
        "two": "",
        "three": "kpe"
    },
    {
        "names": ["Karachay-Balkar"],
        "two": "",
        "three": "krc"
    },
    {
        "names": ["Krio"],
        "two": "",
        "three": "kri"
    },
    {
        "names": ["Karelian"],
        "two": "",
        "three": "krl"
    },
    {
        "names": ["Kru languages"],
        "two": "",
        "three": "kro"
    },
    {
        "names": ["Kurukh"],
        "two": "",
        "three": "kru"
    },
    {
        "names": ["Kuanyama", "Kwanyama"],
        "two": "kj",
        "three": "kua"
    },
    {
        "names": ["Kumyk"],
        "two": "",
        "three": "kum"
    },
    {
        "names": ["Kurdish"],
        "two": "ku",
        "three": "kur"
    },
    {
        "names": ["Kutenai"],
        "two": "",
        "three": "kut"
    },
    {
        "names": ["Ladino"],
        "two": "",
        "three": "lad"
    },
    {
        "names": ["Lahnda"],
        "two": "",
        "three": "lah"
    },
    {
        "names": ["Lamba"],
        "two": "",
        "three": "lam"
    },
    {
        "names": ["Lao"],
        "two": "lo",
        "three": "lao"
    },
    {
        "names": ["Latin"],
        "two": "la",
        "three": "lat"
    },
    {
        "names": ["Latvian"],
        "two": "lv",
        "three": "lav"
    },
    {
        "names": ["Lezghian"],
        "two": "",
        "three": "lez"
    },
    {
        "names": ["Limburgan", "Limburger", "Limburgish"],
        "two": "li",
        "three": "lim"
    },
    {
        "names": ["Lingala"],
        "two": "ln",
        "three": "lin"
    },
    {
        "names": ["Lithuanian"],
        "two": "lt",
        "three": "lit"
    },
    {
        "names": ["Mongo"],
        "two": "",
        "three": "lol"
    },
    {
        "names": ["Lozi"],
        "two": "",
        "three": "loz"
    },
    {
        "names": ["Luxembourgish", "Letzeburgesch"],
        "two": "lb",
        "three": "ltz"
    },
    {
        "names": ["Luba-Lulua"],
        "two": "",
        "three": "lua"
    },
    {
        "names": ["Luba-Katanga"],
        "two": "lu",
        "three": "lub"
    },
    {
        "names": ["Ganda"],
        "two": "lg",
        "three": "lug"
    },
    {
        "names": ["Luiseno"],
        "two": "",
        "three": "lui"
    },
    {
        "names": ["Lunda"],
        "two": "",
        "three": "lun"
    },
    {
        "names": ["Luo (Kenya and Tanzania)"],
        "two": "",
        "three": "luo"
    },
    {
        "names": ["Mizo"],
        "two": "",
        "three": "lus"
    },
    {
        "names": ["Lushai"],
        "two": "",
        "three": "lus"
    },
    {
        "names": ["Macedonian"],
        "two": "mk",
        "three": "mkd"
    },
    {
        "names": ["Madurese"],
        "two": "",
        "three": "mad"
    },
    {
        "names": ["Magahi"],
        "two": "",
        "three": "mag"
    },
    {
        "names": ["Marshallese"],
        "two": "mh",
        "three": "mah"
    },
    {
        "names": ["Maithili"],
        "two": "",
        "three": "mai"
    },
    {
        "names": ["Makasar"],
        "two": "",
        "three": "mak"
    },
    {
        "names": ["Malayalam"],
        "two": "ml",
        "three": "mal"
    },
    {
        "names": ["Mandingo"],
        "two": "",
        "three": "man"
    },
    {
        "names": ["Maori"],
        "two": "mi",
        "three": "mri"
    },
    {
        "names": ["Austronesian languages"],
        "two": "",
        "three": "map"
    },
    {
        "names": ["Marathi"],
        "two": "mr",
        "three": "mar"
    },
    {
        "names": ["Masai"],
        "two": "",
        "three": "mas"
    },
    {
        "names": ["Malay"],
        "two": "ms",
        "three": "msa"
    },
    {
        "names": ["Moksha"],
        "two": "",
        "three": "mdf"
    },
    {
        "names": ["Mandar"],
        "two": "",
        "three": "mdr"
    },
    {
        "names": ["Mende"],
        "two": "",
        "three": "men"
    },
    {
        "names": ["Irish, Middle (900-1200)"],
        "two": "",
        "three": "mga"
    },
    {
        "names": ["Mi'kmaq", "Micmac"],
        "two": "",
        "three": "mic"
    },
    {
        "names": ["Minangkabau"],
        "two": "",
        "three": "min"
    },
    {
        "names": ["Uncoded languages"],
        "two": "",
        "three": "mis"
    },
    {
        "names": ["Mon-Khmer languages"],
        "two": "",
        "three": "mkh"
    },
    {
        "names": ["Malagasy"],
        "two": "mg",
        "three": "mlg"
    },
    {
        "names": ["Maltese"],
        "two": "mt",
        "three": "mlt"
    },
    {
        "names": ["Manchu"],
        "two": "",
        "three": "mnc"
    },
    {
        "names": ["Manipuri"],
        "two": "",
        "three": "mni"
    },
    {
        "names": ["Manobo languages"],
        "two": "",
        "three": "mno"
    },
    {
        "names": ["Mohawk"],
        "two": "",
        "three": "moh"
    },
    {
        "names": ["Mongolian"],
        "two": "mn",
        "three": "mon"
    },
    {
        "names": ["Mossi"],
        "two": "",
        "three": "mos"
    },
    {
        "names": ["Multiple languages"],
        "two": "",
        "three": "mul"
    },
    {
        "names": ["Munda languages"],
        "two": "",
        "three": "mun"
    },
    {
        "names": ["Creek"],
        "two": "",
        "three": "mus"
    },
    {
        "names": ["Mirandese"],
        "two": "",
        "three": "mwl"
    },
    {
        "names": ["Marwari"],
        "two": "",
        "three": "mwr"
    },
    {
        "names": ["Mayan languages"],
        "two": "",
        "three": "myn"
    },
    {
        "names": ["Erzya"],
        "two": "",
        "three": "myv"
    },
    {
        "names": ["Nahuatl languages"],
        "two": "",
        "three": "nah"
    },
    {
        "names": ["North American Indian languages"],
        "two": "",
        "three": "nai"
    },
    {
        "names": ["Neapolitan"],
        "two": "",
        "three": "nap"
    },
    {
        "names": ["Nauru"],
        "two": "na",
        "three": "nau"
    },
    {
        "names": ["Navajo", "Navaho"],
        "two": "nv",
        "three": "nav"
    },
    {
        "names": ["Ndebele, South", "South Ndebele"],
        "two": "nr",
        "three": "nbl"
    },
    {
        "names": ["Ndebele, North", "North Ndebele"],
        "two": "nd",
        "three": "nde"
    },
    {
        "names": ["Ndonga"],
        "two": "ng",
        "three": "ndo"
    },
    {
        "names": ["Low German", "Low Saxon", "German, Low", "Saxon, Low"],
        "two": "",
        "three": "nds"
    },
    {
        "names": ["Nepali"],
        "two": "ne",
        "three": "nep"
    },
    {
        "names": ["Nepal Bhasa", "Newari"],
        "two": "",
        "three": "new"
    },
    {
        "names": ["Nias"],
        "two": "",
        "three": "nia"
    },
    {
        "names": ["Niger-Kordofanian languages"],
        "two": "",
        "three": "nic"
    },
    {
        "names": ["Niuean"],
        "two": "",
        "three": "niu"
    },
    {
        "names": ["Norwegian Nynorsk", "Nynorsk, Norwegian"],
        "two": "nn",
        "three": "nno"
    },
    {
        "names": ["Bokml, Norwegian", "Norwegian Bokml"],
        "two": "nb",
        "three": "nob"
    },
    {
        "names": ["Nogai"],
        "two": "",
        "three": "nog"
    },
    {
        "names": ["Norwegian"],
        "two": "no",
        "three": "nor"
    },
    {
        "names": ["N'Ko"],
        "two": "",
        "three": "nqo"
    },
    {
        "names": ["Pedi", "Sepedi", "Northern Sotho"],
        "two": "",
        "three": "nso"
    },
    {
        "names": ["Nubian languages"],
        "two": "",
        "three": "nub"
    },
    {
        "names": ["Nuer"],
        "two": "",
        "three": "nus"
    },
    {
        "names": ["Chichewa", "Chewa", "Nyanja"],
        "two": "ny",
        "three": "nya"
    },
    {
        "names": ["Nyamwezi"],
        "two": "",
        "three": "nym"
    },
    {
        "names": ["Nyankole"],
        "two": "",
        "three": "nyn"
    },
    {
        "names": ["Nyoro"],
        "two": "",
        "three": "nyo"
    },
    {
        "names": ["Nzima"],
        "two": "",
        "three": "nzi"
    },
    {
        "names": ["Occitan (post 1500)", "Provenal"],
        "two": "oc",
        "three": "oci"
    },
    {
        "names": ["Ojibwa"],
        "two": "oj",
        "three": "oji"
    },
    {
        "names": ["Oriya"],
        "two": "or",
        "three": "ori"
    },
    {
        "names": ["Oromo"],
        "two": "om",
        "three": "orm"
    },
    {
        "names": ["Osage"],
        "two": "",
        "three": "osa"
    },
    {
        "names": ["Ossetian", "Ossetic"],
        "two": "os",
        "three": "oss"
    },
    {
        "names": ["Turkish, Ottoman (1500-1928)"],
        "two": "",
        "three": "ota"
    },
    {
        "names": ["Otomian languages"],
        "two": "",
        "three": "oto"
    },
    {
        "names": ["Papuan languages"],
        "two": "",
        "three": "paa"
    },
    {
        "names": ["Pangasinan"],
        "two": "",
        "three": "pag"
    },
    {
        "names": ["Pahlavi"],
        "two": "",
        "three": "pal"
    },
    {
        "names": ["Pampanga", "Kapampangan"],
        "two": "",
        "three": "pam"
    },
    {
        "names": ["Panjabi", "Punjabi"],
        "two": "pa",
        "three": "pan"
    },
    {
        "names": ["Papiamento"],
        "two": "",
        "three": "pap"
    },
    {
        "names": ["Palauan"],
        "two": "",
        "three": "pau"
    },
    {
        "names": ["Persian"],
        "two": "fa",
        "three": "fas"
    },
    {
        "names": ["Philippine languages"],
        "two": "",
        "three": "phi"
    },
    {
        "names": ["Phoenician"],
        "two": "",
        "three": "phn"
    },
    {
        "names": ["Pali"],
        "two": "pi",
        "three": "pli"
    },
    {
        "names": ["Polish"],
        "two": "pl",
        "three": "pol"
    },
    {
        "names": ["Pohnpeian"],
        "two": "",
        "three": "pon"
    },
    {
        "names": ["Portuguese"],
        "two": "pt",
        "three": "por"
    },
    {
        "names": ["Prakrit languages"],
        "two": "",
        "three": "pra"
    },
    {
        "names": ["Pushto", "Pashto"],
        "two": "ps",
        "three": "pus"
    },
    {
        "names": ["Reserved for local use"],
        "two": "",
        "three": "qaa-qtz"
    },
    {
        "names": ["Quechua"],
        "two": "qu",
        "three": "que"
    },
    {
        "names": ["Rajasthani"],
        "two": "",
        "three": "raj"
    },
    {
        "names": ["Rapanui"],
        "two": "",
        "three": "rap"
    },
    {
        "names": ["Rarotongan", "Cook Islands Maori"],
        "two": "",
        "three": "rar"
    },
    {
        "names": ["Romance languages"],
        "two": "",
        "three": "roa"
    },
    {
        "names": ["Romansh"],
        "two": "rm",
        "three": "roh"
    },
    {
        "names": ["Romany"],
        "two": "",
        "three": "rom"
    },
    {
        "names": ["Romanian", "Moldavian", "Moldovan"],
        "two": "ro",
        "three": "ron"
    },
    {
        "names": ["Rundi"],
        "two": "rn",
        "three": "run"
    },
    {
        "names": ["Aromanian", "Arumanian", "Macedo-Romanian"],
        "two": "",
        "three": "rup"
    },
    {
        "names": ["Russian"],
        "two": "ru",
        "three": "rus"
    },
    {
        "names": ["Sandawe"],
        "two": "",
        "three": "sad"
    },
    {
        "names": ["Sango"],
        "two": "sg",
        "three": "sag"
    },
    {
        "names": ["Yakut"],
        "two": "",
        "three": "sah"
    },
    {
        "names": ["South American Indian (Other)"],
        "two": "",
        "three": "sai"
    },
    {
        "names": ["Salishan languages"],
        "two": "",
        "three": "sal"
    },
    {
        "names": ["Samaritan Aramaic"],
        "two": "",
        "three": "sam"
    },
    {
        "names": ["Sanskrit"],
        "two": "sa",
        "three": "san"
    },
    {
        "names": ["Sasak"],
        "two": "",
        "three": "sas"
    },
    {
        "names": ["Santali"],
        "two": "",
        "three": "sat"
    },
    {
        "names": ["Sicilian"],
        "two": "",
        "three": "scn"
    },
    {
        "names": ["Scots"],
        "two": "",
        "three": "sco"
    },
    {
        "names": ["Selkup"],
        "two": "",
        "three": "sel"
    },
    {
        "names": ["Semitic languages"],
        "two": "",
        "three": "sem"
    },
    {
        "names": ["Sign Languages"],
        "two": "",
        "three": "sgn"
    },
    {
        "names": ["Shan"],
        "two": "",
        "three": "shn"
    },
    {
        "names": ["Sidamo"],
        "two": "",
        "three": "sid"
    },
    {
        "names": ["Sinhala", "Sinhalese"],
        "two": "si",
        "three": "sin"
    },
    {
        "names": ["Siouan languages"],
        "two": "",
        "three": "sio"
    },
    {
        "names": ["Sino-Tibetan languages"],
        "two": "",
        "three": "sit"
    },
    {
        "names": ["Slavic languages"],
        "two": "",
        "three": "sla"
    },
    {
        "names": ["Slovak"],
        "two": "sk",
        "three": "slk"
    },
    {
        "names": ["Slovenian"],
        "two": "sl",
        "three": "slv"
    },
    {
        "names": ["Southern Sami"],
        "two": "",
        "three": "sma"
    },
    {
        "names": ["Northern Sami"],
        "two": "se",
        "three": "sme"
    },
    {
        "names": ["Sami languages"],
        "two": "",
        "three": "smi"
    },
    {
        "names": ["Lule Sami"],
        "two": "",
        "three": "smj"
    },
    {
        "names": ["Inari Sami"],
        "two": "",
        "three": "smn"
    },
    {
        "names": ["Samoan"],
        "two": "sm",
        "three": "smo"
    },
    {
        "names": ["Skolt Sami"],
        "two": "",
        "three": "sms"
    },
    {
        "names": ["Shona"],
        "two": "sn",
        "three": "sna"
    },
    {
        "names": ["Sindhi"],
        "two": "sd",
        "three": "snd"
    },
    {
        "names": ["Soninke"],
        "two": "",
        "three": "snk"
    },
    {
        "names": ["Sogdian"],
        "two": "",
        "three": "sog"
    },
    {
        "names": ["Somali"],
        "two": "so",
        "three": "som"
    },
    {
        "names": ["Songhai languages"],
        "two": "",
        "three": "son"
    },
    {
        "names": ["Sotho, Southern"],
        "two": "st",
        "three": "sot"
    },
    {
        "names": ["Spanish", "Castilian"],
        "two": "es",
        "three": "spa"
    },
    {
        "names": ["Sardinian"],
        "two": "sc",
        "three": "srd"
    },
    {
        "names": ["Sranan Tongo"],
        "two": "",
        "three": "srn"
    },
    {
        "names": ["Serbian"],
        "two": "sr",
        "three": "srp"
    },
    {
        "names": ["Serer"],
        "two": "",
        "three": "srr"
    },
    {
        "names": ["Nilo-Saharan languages"],
        "two": "",
        "three": "ssa"
    },
    {
        "names": ["Swati"],
        "two": "ss",
        "three": "ssw"
    },
    {
        "names": ["Sukuma"],
        "two": "",
        "three": "suk"
    },
    {
        "names": ["Sundanese"],
        "two": "su",
        "three": "sun"
    },
    {
        "names": ["Susu"],
        "two": "",
        "three": "sus"
    },
    {
        "names": ["Sumerian"],
        "two": "",
        "three": "sux"
    },
    {
        "names": ["Swahili"],
        "two": "sw",
        "three": "swa"
    },
    {
        "names": ["Swedish"],
        "two": "sv",
        "three": "swe"
    },
    {
        "names": ["Classical Syriac"],
        "two": "",
        "three": "syc"
    },
    {
        "names": ["Syriac"],
        "two": "",
        "three": "syr"
    },
    {
        "names": ["Tahitian"],
        "two": "ty",
        "three": "tah"
    },
    {
        "names": ["Tai languages"],
        "two": "",
        "three": "tai"
    },
    {
        "names": ["Tamil"],
        "two": "ta",
        "three": "tam"
    },
    {
        "names": ["Tatar"],
        "two": "tt",
        "three": "tat"
    },
    {
        "names": ["Tandroy-Mafahaly"],
        "two": "",
        "three": "tdx"
    },
    {
        "names": ["Telugu"],
        "two": "te",
        "three": "tel"
    },
    {
        "names": ["Timne"],
        "two": "",
        "three": "tem"
    },
    {
        "names": ["Tereno"],
        "two": "",
        "three": "ter"
    },
    {
        "names": ["Tetum"],
        "two": "",
        "three": "tet"
    },
    {
        "names": ["Tajik"],
        "two": "tg",
        "three": "tgk"
    },
    {
        "names": ["Tagalog"],
        "two": "tl",
        "three": "tgl"
    },
    {
        "names": ["Thai"],
        "two": "th",
        "three": "tha"
    },
    {
        "names": ["Tibetan"],
        "two": "bo",
        "three": "bod"
    },
    {
        "names": ["Tigre"],
        "two": "",
        "three": "tig"
    },
    {
        "names": ["Tigrinya"],
        "two": "ti",
        "three": "tir"
    },
    {
        "names": ["Tiv"],
        "two": "",
        "three": "tiv"
    },
    {
        "names": ["Tokelau"],
        "two": "",
        "three": "tkl"
    },
    {
        "names": ["Klingon", "tlhIngan-Hol"],
        "two": "",
        "three": "tlh"
    },
    {
        "names": ["Tlingit"],
        "two": "",
        "three": "tli"
    },
    {
        "names": ["Tamashek"],
        "two": "",
        "three": "tmh"
    },
    {
        "names": ["Tonga (Nyasa)"],
        "two": "",
        "three": "tog"
    },
    {
        "names": ["Tonga (Tonga Islands)"],
        "two": "to",
        "three": "ton"
    },
    {
        "names": ["Tok Pisin"],
        "two": "",
        "three": "tpi"
    },
    {
        "names": ["Tsimshian"],
        "two": "",
        "three": "tsi"
    },
    {
        "names": ["Tswana"],
        "two": "tn",
        "three": "tsn"
    },
    {
        "names": ["Tsonga"],
        "two": "ts",
        "three": "tso"
    },
    {
        "names": ["Turkmen"],
        "two": "tk",
        "three": "tuk"
    },
    {
        "names": ["Tumbuka"],
        "two": "",
        "three": "tum"
    },
    {
        "names": ["Tupi languages"],
        "two": "",
        "three": "tup"
    },
    {
        "names": ["Turkish"],
        "two": "tr",
        "three": "tur"
    },
    {
        "names": ["Altaic languages"],
        "two": "",
        "three": "tut"
    },
    {
        "names": ["Tuvalu"],
        "two": "",
        "three": "tvl"
    },
    {
        "names": ["Twi"],
        "two": "tw",
        "three": "twi"
    },
    {
        "names": ["Tuvinian"],
        "two": "",
        "three": "tyv"
    },
    {
        "names": ["Udmurt"],
        "two": "",
        "three": "udm"
    },
    {
        "names": ["Ugaritic"],
        "two": "",
        "three": "uga"
    },
    {
        "names": ["Uighur", "Uyghur"],
        "two": "ug",
        "three": "uig"
    },
    {
        "names": ["Ukrainian"],
        "two": "uk",
        "three": "ukr"
    },
    {
        "names": ["Umbundu"],
        "two": "",
        "three": "umb"
    },
    {
        "names": ["Undetermined"],
        "two": "",
        "three": "und"
    },
    {
        "names": ["Urdu"],
        "two": "ur",
        "three": "urd"
    },
    {
        "names": ["Uzbek"],
        "two": "uz",
        "three": "uzb"
    },
    {
        "names": ["Vai"],
        "two": "",
        "three": "vai"
    },
    {
        "names": ["Venda"],
        "two": "ve",
        "three": "ven"
    },
    {
        "names": ["Vietnamese"],
        "two": "vi",
        "three": "vie"
    },
    {
        "names": ["Volapk"],
        "two": "vo",
        "three": "vol"
    },
    {
        "names": ["Votic"],
        "two": "",
        "three": "vot"
    },
    {
        "names": ["Wakashan languages"],
        "two": "",
        "three": "wak"
    },
    {
        "names": ["Wolaytta"],
        "two": "",
        "three": "wal"
    },
    {
        "names": ["Waray"],
        "two": "",
        "three": "war"
    },
    {
        "names": ["Washo"],
        "two": "",
        "three": "was"
    },
    {
        "names": ["Welsh"],
        "two": "cy",
        "three": "cym"
    },
    {
        "names": ["Sorbian languages"],
        "two": "",
        "three": "wen"
    },
    {
        "names": ["Walloon"],
        "two": "wa",
        "three": "wln"
    },
    {
        "names": ["Wolof"],
        "two": "wo",
        "three": "wol"
    },
    {
        "names": ["Kalmyk", "Oirat"],
        "two": "",
        "three": "xal"
    },
    {
        "names": ["Xhosa"],
        "two": "xh",
        "three": "xho"
    },
    {
        "names": ["Yao"],
        "two": "",
        "three": "yao"
    },
    {
        "names": ["Yapese"],
        "two": "",
        "three": "yap"
    },
    {
        "names": ["Yiddish"],
        "two": "yi",
        "three": "yid"
    },
    {
        "names": ["Yoruba"],
        "two": "yo",
        "three": "yor"
    },
    {
        "names": ["Yupik languages"],
        "two": "",
        "three": "ypk"
    },
    {
        "names": ["Zapotec"],
        "two": "",
        "three": "zap"
    },
    {
        "names": ["Blissymbols", "Blissymbolics", "Bliss"],
        "two": "",
        "three": "zbl"
    },
    {
        "names": ["Zenaga"],
        "two": "",
        "three": "zen"
    },
    {
        "names": ["Zhuang", "Chuang"],
        "two": "za",
        "three": "zha"
    },
    {
        "names": ["Zande languages"],
        "two": "",
        "three": "znd"
    },
    {
        "names": ["Zulu"],
        "two": "zu",
        "three": "zul"
    },
    {
        "names": ["Zuni"],
        "two": "",
        "three": "zun"
    },
    {
        "names": ["No linguistic content", "Not applicable"],
        "two": "",
        "three": "zxx"
    },
    {
        "names": ["Zaza", "Dimili", "Dimli", "Kirdki", "Kirmanjki", "Zazaki"],
        "two": "",
        "three": "zza"
    }
]
;});

/*!

 diff v3.2.0

Software License Agreement (BSD License)

Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>

All rights reserved.

Redistribution and use of this software in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of Kevin Decker nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@license
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define('jsdiff',[], factory);
	else if(typeof exports === 'object')
		exports["JsDiff"] = factory();
	else
		root["JsDiff"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;
	/*istanbul ignore end*/
	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/
	var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_create = __webpack_require__(13) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_dmp = __webpack_require__(14) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_xml = __webpack_require__(15) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports. /*istanbul ignore end*/Diff = _base2['default'];
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize; /* See LICENSE file for terms of use */

	/*
	 * Text diff implementation.
	 *
	 * This library supports the following APIS:
	 * JsDiff.diffChars: Character by character diff
	 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
	 * JsDiff.diffLines: Line based diff
	 *
	 * JsDiff.diffCss: Diff targeted at CSS content
	 *
	 * These methods are based on the implementation proposed in
	 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
	 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
	 */
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQWdCQSxJLHlCQUFBLDhCLHdCQUFBOzs7Ozs7QUFDQSxJLHlCQUFBLHdDLHdCQUFBOztBQUNBLEkseUJBQUEsOEIsd0JBQUE7O0FBQ0EsSSx5QkFBQSw4Qix3QkFBQTs7QUFDQSxJLHlCQUFBLHNDLHdCQUFBOztBQUVBLEkseUJBQUEsNEIsd0JBQUE7O0FBQ0EsSSx5QkFBQSw4Qix3QkFBQTs7QUFFQSxJLHlCQUFBLGdDLHdCQUFBOztBQUVBLEkseUJBQUEsaUMsd0JBQUE7O0FBQ0EsSSx5QkFBQSxpQyx3QkFBQTs7QUFDQSxJLHlCQUFBLG1DLHdCQUFBOztBQUVBLEkseUJBQUEsK0Isd0JBQUE7O0FBQ0EsSSx5QkFBQSwrQix3QkFBQTs7Ozs7Z0NBR0UsSTt5REFFQSxTO3lEQUNBLFM7eURBQ0Esa0I7eURBQ0EsUzt5REFDQSxnQjt5REFDQSxhO3lEQUVBLE87eURBQ0EsUTt5REFFQSxVO3lEQUVBLGU7eURBQ0EsbUI7eURBQ0EsVzt5REFDQSxVO3lEQUNBLFk7eURBQ0EsVTt5REFDQSxtQjt5REFDQSxtQjt5REFDQSxZIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogU2VlIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMgb2YgdXNlICovXG5cbi8qXG4gKiBUZXh0IGRpZmYgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgQVBJUzpcbiAqIEpzRGlmZi5kaWZmQ2hhcnM6IENoYXJhY3RlciBieSBjaGFyYWN0ZXIgZGlmZlxuICogSnNEaWZmLmRpZmZXb3JkczogV29yZCAoYXMgZGVmaW5lZCBieSBcXGIgcmVnZXgpIGRpZmYgd2hpY2ggaWdub3JlcyB3aGl0ZXNwYWNlXG4gKiBKc0RpZmYuZGlmZkxpbmVzOiBMaW5lIGJhc2VkIGRpZmZcbiAqXG4gKiBKc0RpZmYuZGlmZkNzczogRGlmZiB0YXJnZXRlZCBhdCBDU1MgY29udGVudFxuICpcbiAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxuICogXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcIiAoTXllcnMsIDE5ODYpLlxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcbiAqL1xuaW1wb3J0IERpZmYgZnJvbSAnLi9kaWZmL2Jhc2UnO1xuaW1wb3J0IHtkaWZmQ2hhcnN9IGZyb20gJy4vZGlmZi9jaGFyYWN0ZXInO1xuaW1wb3J0IHtkaWZmV29yZHMsIGRpZmZXb3Jkc1dpdGhTcGFjZX0gZnJvbSAnLi9kaWZmL3dvcmQnO1xuaW1wb3J0IHtkaWZmTGluZXMsIGRpZmZUcmltbWVkTGluZXN9IGZyb20gJy4vZGlmZi9saW5lJztcbmltcG9ydCB7ZGlmZlNlbnRlbmNlc30gZnJvbSAnLi9kaWZmL3NlbnRlbmNlJztcblxuaW1wb3J0IHtkaWZmQ3NzfSBmcm9tICcuL2RpZmYvY3NzJztcbmltcG9ydCB7ZGlmZkpzb24sIGNhbm9uaWNhbGl6ZX0gZnJvbSAnLi9kaWZmL2pzb24nO1xuXG5pbXBvcnQge2RpZmZBcnJheXN9IGZyb20gJy4vZGlmZi9hcnJheSc7XG5cbmltcG9ydCB7YXBwbHlQYXRjaCwgYXBwbHlQYXRjaGVzfSBmcm9tICcuL3BhdGNoL2FwcGx5JztcbmltcG9ydCB7cGFyc2VQYXRjaH0gZnJvbSAnLi9wYXRjaC9wYXJzZSc7XG5pbXBvcnQge3N0cnVjdHVyZWRQYXRjaCwgY3JlYXRlVHdvRmlsZXNQYXRjaCwgY3JlYXRlUGF0Y2h9IGZyb20gJy4vcGF0Y2gvY3JlYXRlJztcblxuaW1wb3J0IHtjb252ZXJ0Q2hhbmdlc1RvRE1QfSBmcm9tICcuL2NvbnZlcnQvZG1wJztcbmltcG9ydCB7Y29udmVydENoYW5nZXNUb1hNTH0gZnJvbSAnLi9jb252ZXJ0L3htbCc7XG5cbmV4cG9ydCB7XG4gIERpZmYsXG5cbiAgZGlmZkNoYXJzLFxuICBkaWZmV29yZHMsXG4gIGRpZmZXb3Jkc1dpdGhTcGFjZSxcbiAgZGlmZkxpbmVzLFxuICBkaWZmVHJpbW1lZExpbmVzLFxuICBkaWZmU2VudGVuY2VzLFxuXG4gIGRpZmZDc3MsXG4gIGRpZmZKc29uLFxuXG4gIGRpZmZBcnJheXMsXG5cbiAgc3RydWN0dXJlZFBhdGNoLFxuICBjcmVhdGVUd29GaWxlc1BhdGNoLFxuICBjcmVhdGVQYXRjaCxcbiAgYXBwbHlQYXRjaCxcbiAgYXBwbHlQYXRjaGVzLFxuICBwYXJzZVBhdGNoLFxuICBjb252ZXJ0Q2hhbmdlc1RvRE1QLFxuICBjb252ZXJ0Q2hhbmdlc1RvWE1MLFxuICBjYW5vbmljYWxpemVcbn07XG4iXX0=


/***/ },
/* 1 */
/***/ function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports['default'] = /*istanbul ignore end*/Diff;
	function Diff() {}

	Diff.prototype = { /*istanbul ignore start*/
	  /*istanbul ignore end*/diff: function diff(oldString, newString) {
	    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	    var callback = options.callback;
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	    this.options = options;

	    var self = this;

	    function done(value) {
	      if (callback) {
	        setTimeout(function () {
	          callback(undefined, value);
	        }, 0);
	        return true;
	      } else {
	        return value;
	      }
	    }

	    // Allow subclasses to massage the input prior to running
	    oldString = this.castInput(oldString);
	    newString = this.castInput(newString);

	    oldString = this.removeEmpty(this.tokenize(oldString));
	    newString = this.removeEmpty(this.tokenize(newString));

	    var newLen = newString.length,
	        oldLen = oldString.length;
	    var editLength = 1;
	    var maxEditLength = newLen + oldLen;
	    var bestPath = [{ newPos: -1, components: [] }];

	    // Seed editLength = 0, i.e. the content starts with the same values
	    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
	    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	      // Identity per the equality and tokenizer
	      return done([{ value: this.join(newString), count: newString.length }]);
	    }

	    // Main worker method. checks all permutations of a given edit length for acceptance.
	    function execEditLength() {
	      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
	        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	        var addPath = bestPath[diagonalPath - 1],
	            removePath = bestPath[diagonalPath + 1],
	            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
	        if (addPath) {
	          // No one else is going to attempt to use this value, clear it
	          bestPath[diagonalPath - 1] = undefined;
	        }

	        var canAdd = addPath && addPath.newPos + 1 < newLen,
	            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
	        if (!canAdd && !canRemove) {
	          // If this path is a terminal then prune
	          bestPath[diagonalPath] = undefined;
	          continue;
	        }

	        // Select the diagonal that we want to branch from. We select the prior
	        // path whose position in the new string is the farthest from the origin
	        // and does not pass the bounds of the diff graph
	        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
	          basePath = clonePath(removePath);
	          self.pushComponent(basePath.components, undefined, true);
	        } else {
	          basePath = addPath; // No need to clone, we've pulled it from the list
	          basePath.newPos++;
	          self.pushComponent(basePath.components, true, undefined);
	        }

	        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

	        // If we have hit the end of both strings, then we are done
	        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
	          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
	        } else {
	          // Otherwise track this path as a potential candidate and continue.
	          bestPath[diagonalPath] = basePath;
	        }
	      }

	      editLength++;
	    }

	    // Performs the length of edit iteration. Is a bit fugly as this has to support the
	    // sync and async mode which is never fun. Loops over execEditLength until a value
	    // is produced.
	    if (callback) {
	      (function exec() {
	        setTimeout(function () {
	          // This should not happen, but we want to be safe.
	          /* istanbul ignore next */
	          if (editLength > maxEditLength) {
	            return callback();
	          }

	          if (!execEditLength()) {
	            exec();
	          }
	        }, 0);
	      })();
	    } else {
	      while (editLength <= maxEditLength) {
	        var ret = execEditLength();
	        if (ret) {
	          return ret;
	        }
	      }
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {
	    var last = components[components.length - 1];
	    if (last && last.added === added && last.removed === removed) {
	      // We need to clone here as the component clone operation is just
	      // as shallow array clone
	      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };
	    } else {
	      components.push({ count: 1, added: added, removed: removed });
	    }
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
	    var newLen = newString.length,
	        oldLen = oldString.length,
	        newPos = basePath.newPos,
	        oldPos = newPos - diagonalPath,
	        commonCount = 0;
	    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
	      newPos++;
	      oldPos++;
	      commonCount++;
	    }

	    if (commonCount) {
	      basePath.components.push({ count: commonCount });
	    }

	    basePath.newPos = newPos;
	    return oldPos;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {
	    return left === right;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {
	    var ret = [];
	    for (var i = 0; i < array.length; i++) {
	      if (array[i]) {
	        ret.push(array[i]);
	      }
	    }
	    return ret;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {
	    return value;
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {
	    return value.split('');
	  },
	  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {
	    return chars.join('');
	  }
	};

	function buildValues(diff, components, newString, oldString, useLongestToken) {
	  var componentPos = 0,
	      componentLen = components.length,
	      newPos = 0,
	      oldPos = 0;

	  for (; componentPos < componentLen; componentPos++) {
	    var component = components[componentPos];
	    if (!component.removed) {
	      if (!component.added && useLongestToken) {
	        var value = newString.slice(newPos, newPos + component.count);
	        value = value.map(function (value, i) {
	          var oldValue = oldString[oldPos + i];
	          return oldValue.length > value.length ? oldValue : value;
	        });

	        component.value = diff.join(value);
	      } else {
	        component.value = diff.join(newString.slice(newPos, newPos + component.count));
	      }
	      newPos += component.count;

	      // Common case
	      if (!component.added) {
	        oldPos += component.count;
	      }
	    } else {
	      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
	      oldPos += component.count;

	      // Reverse add and remove so removes are output first to match common convention
	      // The diffing algorithm is tied to add then remove output and this is the simplest
	      // route to get the desired output with minimal overhead.
	      if (componentPos && components[componentPos - 1].added) {
	        var tmp = components[componentPos - 1];
	        components[componentPos - 1] = components[componentPos];
	        components[componentPos] = tmp;
	      }
	    }
	  }

	  // Special case handle for when one terminal is ignored. For this case we merge the
	  // terminal into the prior string and drop the change.
	  var lastComponent = components[componentLen - 1];
	  if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
	    components[componentLen - 2].value += lastComponent.value;
	    components.pop();
	  }

	  return components;
	}

	function clonePath(path) {
	  return { newPos: path.newPos, components: path.components.slice(0) };
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Jhc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OzRDQUF3QixJO0FBQVQsU0FBUyxJQUFULEdBQWdCLENBQUU7O0FBRWpDLEtBQUssU0FBTCxHQUFpQixFO3lCQUNmLElBRGUsZ0JBQ1YsU0FEVSxFQUNDLFNBREQsRUFDMEI7NkJBQUEsSSx1QkFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQ3ZDLFFBQUksV0FBVyxRQUFRLFFBQXZCO0FBQ0EsUUFBSSxPQUFPLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakMsaUJBQVcsT0FBWDtBQUNBLGdCQUFVLEVBQVY7QUFDRDtBQUNELFNBQUssT0FBTCxHQUFlLE9BQWY7O0FBRUEsUUFBSSxPQUFPLElBQVg7O0FBRUEsYUFBUyxJQUFULENBQWMsS0FBZCxFQUFxQjtBQUNuQixVQUFJLFFBQUosRUFBYztBQUNaLG1CQUFXLFlBQVc7QUFBRSxtQkFBUyxTQUFULEVBQW9CLEtBQXBCO0FBQTZCLFNBQXJELEVBQXVELENBQXZEO0FBQ0EsZUFBTyxJQUFQO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsZUFBTyxLQUFQO0FBQ0Q7QUFDRjs7O0FBR0QsZ0JBQVksS0FBSyxTQUFMLENBQWUsU0FBZixDQUFaO0FBQ0EsZ0JBQVksS0FBSyxTQUFMLENBQWUsU0FBZixDQUFaOztBQUVBLGdCQUFZLEtBQUssV0FBTCxDQUFpQixLQUFLLFFBQUwsQ0FBYyxTQUFkLENBQWpCLENBQVo7QUFDQSxnQkFBWSxLQUFLLFdBQUwsQ0FBaUIsS0FBSyxRQUFMLENBQWMsU0FBZCxDQUFqQixDQUFaOztBQUVBLFFBQUksU0FBUyxVQUFVLE1BQXZCO0FBQUEsUUFBK0IsU0FBUyxVQUFVLE1BQWxEO0FBQ0EsUUFBSSxhQUFhLENBQWpCO0FBQ0EsUUFBSSxnQkFBZ0IsU0FBUyxNQUE3QjtBQUNBLFFBQUksV0FBVyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQVgsRUFBYyxZQUFZLEVBQTFCLEVBQUQsQ0FBZjs7O0FBR0EsUUFBSSxTQUFTLEtBQUssYUFBTCxDQUFtQixTQUFTLENBQVQsQ0FBbkIsRUFBZ0MsU0FBaEMsRUFBMkMsU0FBM0MsRUFBc0QsQ0FBdEQsQ0FBYjtBQUNBLFFBQUksU0FBUyxDQUFULEVBQVksTUFBWixHQUFxQixDQUFyQixJQUEwQixNQUExQixJQUFvQyxTQUFTLENBQVQsSUFBYyxNQUF0RCxFQUE4RDs7QUFFNUQsYUFBTyxLQUFLLENBQUMsRUFBQyxPQUFPLEtBQUssSUFBTCxDQUFVLFNBQVYsQ0FBUixFQUE4QixPQUFPLFVBQVUsTUFBL0MsRUFBRCxDQUFMLENBQVA7QUFDRDs7O0FBR0QsYUFBUyxjQUFULEdBQTBCO0FBQ3hCLFdBQUssSUFBSSxlQUFlLENBQUMsQ0FBRCxHQUFLLFVBQTdCLEVBQXlDLGdCQUFnQixVQUF6RCxFQUFxRSxnQkFBZ0IsQ0FBckYsRUFBd0Y7QUFDdEYsWUFBSSxXLHlCQUFBLE0sd0JBQUo7QUFDQSxZQUFJLFVBQVUsU0FBUyxlQUFlLENBQXhCLENBQWQ7QUFBQSxZQUNJLGFBQWEsU0FBUyxlQUFlLENBQXhCLENBRGpCO0FBQUEsWUFFSSxVQUFTLENBQUMsYUFBYSxXQUFXLE1BQXhCLEdBQWlDLENBQWxDLElBQXVDLFlBRnBEO0FBR0EsWUFBSSxPQUFKLEVBQWE7O0FBRVgsbUJBQVMsZUFBZSxDQUF4QixJQUE2QixTQUE3QjtBQUNEOztBQUVELFlBQUksU0FBUyxXQUFXLFFBQVEsTUFBUixHQUFpQixDQUFqQixHQUFxQixNQUE3QztBQUFBLFlBQ0ksWUFBWSxjQUFjLEtBQUssT0FBbkIsSUFBNkIsVUFBUyxNQUR0RDtBQUVBLFlBQUksQ0FBQyxNQUFELElBQVcsQ0FBQyxTQUFoQixFQUEyQjs7QUFFekIsbUJBQVMsWUFBVCxJQUF5QixTQUF6QjtBQUNBO0FBQ0Q7Ozs7O0FBS0QsWUFBSSxDQUFDLE1BQUQsSUFBWSxhQUFhLFFBQVEsTUFBUixHQUFpQixXQUFXLE1BQXpELEVBQWtFO0FBQ2hFLHFCQUFXLFVBQVUsVUFBVixDQUFYO0FBQ0EsZUFBSyxhQUFMLENBQW1CLFNBQVMsVUFBNUIsRUFBd0MsU0FBeEMsRUFBbUQsSUFBbkQ7QUFDRCxTQUhELE1BR087QUFDTCxxQkFBVyxPQUFYLEM7QUFDQSxtQkFBUyxNQUFUO0FBQ0EsZUFBSyxhQUFMLENBQW1CLFNBQVMsVUFBNUIsRUFBd0MsSUFBeEMsRUFBOEMsU0FBOUM7QUFDRDs7QUFFRCxrQkFBUyxLQUFLLGFBQUwsQ0FBbUIsUUFBbkIsRUFBNkIsU0FBN0IsRUFBd0MsU0FBeEMsRUFBbUQsWUFBbkQsQ0FBVDs7O0FBR0EsWUFBSSxTQUFTLE1BQVQsR0FBa0IsQ0FBbEIsSUFBdUIsTUFBdkIsSUFBaUMsVUFBUyxDQUFULElBQWMsTUFBbkQsRUFBMkQ7QUFDekQsaUJBQU8sS0FBSyxZQUFZLElBQVosRUFBa0IsU0FBUyxVQUEzQixFQUF1QyxTQUF2QyxFQUFrRCxTQUFsRCxFQUE2RCxLQUFLLGVBQWxFLENBQUwsQ0FBUDtBQUNELFNBRkQsTUFFTzs7QUFFTCxtQkFBUyxZQUFULElBQXlCLFFBQXpCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNEOzs7OztBQUtELFFBQUksUUFBSixFQUFjO0FBQ1gsZ0JBQVMsSUFBVCxHQUFnQjtBQUNmLG1CQUFXLFlBQVc7OztBQUdwQixjQUFJLGFBQWEsYUFBakIsRUFBZ0M7QUFDOUIsbUJBQU8sVUFBUDtBQUNEOztBQUVELGNBQUksQ0FBQyxnQkFBTCxFQUF1QjtBQUNyQjtBQUNEO0FBQ0YsU0FWRCxFQVVHLENBVkg7QUFXRCxPQVpBLEdBQUQ7QUFhRCxLQWRELE1BY087QUFDTCxhQUFPLGNBQWMsYUFBckIsRUFBb0M7QUFDbEMsWUFBSSxNQUFNLGdCQUFWO0FBQ0EsWUFBSSxHQUFKLEVBQVM7QUFDUCxpQkFBTyxHQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsR0E5R2M7bURBZ0hmLGFBaEhlLHlCQWdIRCxVQWhIQyxFQWdIVyxLQWhIWCxFQWdIa0IsT0FoSGxCLEVBZ0gyQjtBQUN4QyxRQUFJLE9BQU8sV0FBVyxXQUFXLE1BQVgsR0FBb0IsQ0FBL0IsQ0FBWDtBQUNBLFFBQUksUUFBUSxLQUFLLEtBQUwsS0FBZSxLQUF2QixJQUFnQyxLQUFLLE9BQUwsS0FBaUIsT0FBckQsRUFBOEQ7OztBQUc1RCxpQkFBVyxXQUFXLE1BQVgsR0FBb0IsQ0FBL0IsSUFBb0MsRUFBQyxPQUFPLEtBQUssS0FBTCxHQUFhLENBQXJCLEVBQXdCLE9BQU8sS0FBL0IsRUFBc0MsU0FBUyxPQUEvQyxFQUFwQztBQUNELEtBSkQsTUFJTztBQUNMLGlCQUFXLElBQVgsQ0FBZ0IsRUFBQyxPQUFPLENBQVIsRUFBVyxPQUFPLEtBQWxCLEVBQXlCLFNBQVMsT0FBbEMsRUFBaEI7QUFDRDtBQUNGLEdBekhjO21EQTBIZixhQTFIZSx5QkEwSEQsUUExSEMsRUEwSFMsU0ExSFQsRUEwSG9CLFNBMUhwQixFQTBIK0IsWUExSC9CLEVBMEg2QztBQUMxRCxRQUFJLFNBQVMsVUFBVSxNQUF2QjtBQUFBLFFBQ0ksU0FBUyxVQUFVLE1BRHZCO0FBQUEsUUFFSSxTQUFTLFNBQVMsTUFGdEI7QUFBQSxRQUdJLFNBQVMsU0FBUyxZQUh0QjtBQUFBLFFBS0ksY0FBYyxDQUxsQjtBQU1BLFdBQU8sU0FBUyxDQUFULEdBQWEsTUFBYixJQUF1QixTQUFTLENBQVQsR0FBYSxNQUFwQyxJQUE4QyxLQUFLLE1BQUwsQ0FBWSxVQUFVLFNBQVMsQ0FBbkIsQ0FBWixFQUFtQyxVQUFVLFNBQVMsQ0FBbkIsQ0FBbkMsQ0FBckQsRUFBZ0g7QUFDOUc7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsUUFBSSxXQUFKLEVBQWlCO0FBQ2YsZUFBUyxVQUFULENBQW9CLElBQXBCLENBQXlCLEVBQUMsT0FBTyxXQUFSLEVBQXpCO0FBQ0Q7O0FBRUQsYUFBUyxNQUFULEdBQWtCLE1BQWxCO0FBQ0EsV0FBTyxNQUFQO0FBQ0QsR0E3SWM7bURBK0lmLE1BL0llLGtCQStJUixJQS9JUSxFQStJRixLQS9JRSxFQStJSztBQUNsQixXQUFPLFNBQVMsS0FBaEI7QUFDRCxHQWpKYzttREFrSmYsV0FsSmUsdUJBa0pILEtBbEpHLEVBa0pJO0FBQ2pCLFFBQUksTUFBTSxFQUFWO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDckMsVUFBSSxNQUFNLENBQU4sQ0FBSixFQUFjO0FBQ1osWUFBSSxJQUFKLENBQVMsTUFBTSxDQUFOLENBQVQ7QUFDRDtBQUNGO0FBQ0QsV0FBTyxHQUFQO0FBQ0QsR0ExSmM7bURBMkpmLFNBM0plLHFCQTJKTCxLQTNKSyxFQTJKRTtBQUNmLFdBQU8sS0FBUDtBQUNELEdBN0pjO21EQThKZixRQTlKZSxvQkE4Sk4sS0E5Sk0sRUE4SkM7QUFDZCxXQUFPLE1BQU0sS0FBTixDQUFZLEVBQVosQ0FBUDtBQUNELEdBaEtjO21EQWlLZixJQWpLZSxnQkFpS1YsS0FqS1UsRUFpS0g7QUFDVixXQUFPLE1BQU0sSUFBTixDQUFXLEVBQVgsQ0FBUDtBQUNEO0FBbktjLENBQWpCOztBQXNLQSxTQUFTLFdBQVQsQ0FBcUIsSUFBckIsRUFBMkIsVUFBM0IsRUFBdUMsU0FBdkMsRUFBa0QsU0FBbEQsRUFBNkQsZUFBN0QsRUFBOEU7QUFDNUUsTUFBSSxlQUFlLENBQW5CO0FBQUEsTUFDSSxlQUFlLFdBQVcsTUFEOUI7QUFBQSxNQUVJLFNBQVMsQ0FGYjtBQUFBLE1BR0ksU0FBUyxDQUhiOztBQUtBLFNBQU8sZUFBZSxZQUF0QixFQUFvQyxjQUFwQyxFQUFvRDtBQUNsRCxRQUFJLFlBQVksV0FBVyxZQUFYLENBQWhCO0FBQ0EsUUFBSSxDQUFDLFVBQVUsT0FBZixFQUF3QjtBQUN0QixVQUFJLENBQUMsVUFBVSxLQUFYLElBQW9CLGVBQXhCLEVBQXlDO0FBQ3ZDLFlBQUksUUFBUSxVQUFVLEtBQVYsQ0FBZ0IsTUFBaEIsRUFBd0IsU0FBUyxVQUFVLEtBQTNDLENBQVo7QUFDQSxnQkFBUSxNQUFNLEdBQU4sQ0FBVSxVQUFTLEtBQVQsRUFBZ0IsQ0FBaEIsRUFBbUI7QUFDbkMsY0FBSSxXQUFXLFVBQVUsU0FBUyxDQUFuQixDQUFmO0FBQ0EsaUJBQU8sU0FBUyxNQUFULEdBQWtCLE1BQU0sTUFBeEIsR0FBaUMsUUFBakMsR0FBNEMsS0FBbkQ7QUFDRCxTQUhPLENBQVI7O0FBS0Esa0JBQVUsS0FBVixHQUFrQixLQUFLLElBQUwsQ0FBVSxLQUFWLENBQWxCO0FBQ0QsT0FSRCxNQVFPO0FBQ0wsa0JBQVUsS0FBVixHQUFrQixLQUFLLElBQUwsQ0FBVSxVQUFVLEtBQVYsQ0FBZ0IsTUFBaEIsRUFBd0IsU0FBUyxVQUFVLEtBQTNDLENBQVYsQ0FBbEI7QUFDRDtBQUNELGdCQUFVLFVBQVUsS0FBcEI7OztBQUdBLFVBQUksQ0FBQyxVQUFVLEtBQWYsRUFBc0I7QUFDcEIsa0JBQVUsVUFBVSxLQUFwQjtBQUNEO0FBQ0YsS0FsQkQsTUFrQk87QUFDTCxnQkFBVSxLQUFWLEdBQWtCLEtBQUssSUFBTCxDQUFVLFVBQVUsS0FBVixDQUFnQixNQUFoQixFQUF3QixTQUFTLFVBQVUsS0FBM0MsQ0FBVixDQUFsQjtBQUNBLGdCQUFVLFVBQVUsS0FBcEI7Ozs7O0FBS0EsVUFBSSxnQkFBZ0IsV0FBVyxlQUFlLENBQTFCLEVBQTZCLEtBQWpELEVBQXdEO0FBQ3RELFlBQUksTUFBTSxXQUFXLGVBQWUsQ0FBMUIsQ0FBVjtBQUNBLG1CQUFXLGVBQWUsQ0FBMUIsSUFBK0IsV0FBVyxZQUFYLENBQS9CO0FBQ0EsbUJBQVcsWUFBWCxJQUEyQixHQUEzQjtBQUNEO0FBQ0Y7QUFDRjs7OztBQUlELE1BQUksZ0JBQWdCLFdBQVcsZUFBZSxDQUExQixDQUFwQjtBQUNBLE1BQUksZUFBZSxDQUFmLEtBQ0ksY0FBYyxLQUFkLElBQXVCLGNBQWMsT0FEekMsS0FFRyxLQUFLLE1BQUwsQ0FBWSxFQUFaLEVBQWdCLGNBQWMsS0FBOUIsQ0FGUCxFQUU2QztBQUMzQyxlQUFXLGVBQWUsQ0FBMUIsRUFBNkIsS0FBN0IsSUFBc0MsY0FBYyxLQUFwRDtBQUNBLGVBQVcsR0FBWDtBQUNEOztBQUVELFNBQU8sVUFBUDtBQUNEOztBQUVELFNBQVMsU0FBVCxDQUFtQixJQUFuQixFQUF5QjtBQUN2QixTQUFPLEVBQUUsUUFBUSxLQUFLLE1BQWYsRUFBdUIsWUFBWSxLQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBc0IsQ0FBdEIsQ0FBbkMsRUFBUDtBQUNEIiwiZmlsZSI6ImJhc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaWZmKCkge31cblxuRGlmZi5wcm90b3R5cGUgPSB7XG4gIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBsZXQgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sodW5kZWZpbmVkLCB2YWx1ZSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcbiAgICBvbGRTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChvbGRTdHJpbmcpO1xuICAgIG5ld1N0cmluZyA9IHRoaXMuY2FzdElucHV0KG5ld1N0cmluZyk7XG5cbiAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XG4gICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xuXG4gICAgbGV0IG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XG4gICAgbGV0IGVkaXRMZW5ndGggPSAxO1xuICAgIGxldCBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgIGxldCBiZXN0UGF0aCA9IFt7IG5ld1BvczogLTEsIGNvbXBvbmVudHM6IFtdIH1dO1xuXG4gICAgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcbiAgICBsZXQgb2xkUG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgMCk7XG4gICAgaWYgKGJlc3RQYXRoWzBdLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcbiAgICAgIHJldHVybiBkb25lKFt7dmFsdWU6IHRoaXMuam9pbihuZXdTdHJpbmcpLCBjb3VudDogbmV3U3RyaW5nLmxlbmd0aH1dKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICBmb3IgKGxldCBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICBsZXQgYmFzZVBhdGg7XG4gICAgICAgIGxldCBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXG4gICAgICAgICAgICBvbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XG4gICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcbiAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBvbGRQb3MgJiYgb2xkUG9zIDwgb2xkTGVuO1xuICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBuZXcgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxuICAgICAgICBpZiAoIWNhbkFkZCB8fCAoY2FuUmVtb3ZlICYmIGFkZFBhdGgubmV3UG9zIDwgcmVtb3ZlUGF0aC5uZXdQb3MpKSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAgIC8vIE5vIG5lZWQgdG8gY2xvbmUsIHdlJ3ZlIHB1bGxlZCBpdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXG4gICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgIC8vIGlzIHByb2R1Y2VkLlxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgbGV0IHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICBsZXQgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgaGVyZSBhcyB0aGUgY29tcG9uZW50IGNsb25lIG9wZXJhdGlvbiBpcyBqdXN0XG4gICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPSB7Y291bnQ6IGxhc3QuY291bnQgKyAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5wdXNoKHtjb3VudDogMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH0pO1xuICAgIH1cbiAgfSxcbiAgZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xuICAgIGxldCBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxuICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXG4gICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcblxuICAgICAgICBjb21tb25Db3VudCA9IDA7XG4gICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcbiAgICAgIG5ld1BvcysrO1xuICAgICAgb2xkUG9zKys7XG4gICAgICBjb21tb25Db3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb21tb25Db3VudCkge1xuICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHtjb3VudDogY29tbW9uQ291bnR9KTtcbiAgICB9XG5cbiAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XG4gICAgcmV0dXJuIG9sZFBvcztcbiAgfSxcblxuICBlcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH0sXG4gIHJlbW92ZUVtcHR5KGFycmF5KSB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSkge1xuICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGNhc3RJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgdG9rZW5pemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xuICB9LFxuICBqb2luKGNoYXJzKSB7XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XG4gIGxldCBjb21wb25lbnRQb3MgPSAwLFxuICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICBuZXdQb3MgPSAwLFxuICAgICAgb2xkUG9zID0gMDtcblxuICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICAgICAgbGV0IG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4odmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgfVxuICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDtcblxuICAgICAgLy8gQ29tbW9uIGNhc2VcbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkKSB7XG4gICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XG5cbiAgICAgIC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXG4gICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxuICAgICAgLy8gcm91dGUgdG8gZ2V0IHRoZSBkZXNpcmVkIG91dHB1dCB3aXRoIG1pbmltYWwgb3ZlcmhlYWQuXG4gICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcbiAgICAgICAgbGV0IHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0gPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTcGVjaWFsIGNhc2UgaGFuZGxlIGZvciB3aGVuIG9uZSB0ZXJtaW5hbCBpcyBpZ25vcmVkLiBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZVxuICAvLyB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cbiAgbGV0IGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuICBpZiAoY29tcG9uZW50TGVuID4gMVxuICAgICAgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKVxuICAgICAgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XG4gICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBsYXN0Q29tcG9uZW50LnZhbHVlO1xuICAgIGNvbXBvbmVudHMucG9wKCk7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHsgbmV3UG9zOiBwYXRoLm5ld1BvcywgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApIH07XG59XG4iXX0=


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.characterDiff = undefined;
	exports. /*istanbul ignore end*/diffChars = diffChars;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;
	function diffChars(oldStr, newStr, callback) {
	  return characterDiff.diff(oldStr, newStr, callback);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2NoYXJhY3Rlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O2dDQUdnQixTLEdBQUEsUzs7QUFIaEIsSSx5QkFBQSx5Qix3QkFBQTs7Ozs7Ozt1QkFFTyxJQUFNLGdCLHlCQUFBLFEsd0JBQUEsZ0JBQWdCLEkseUJBQUEsbUIsd0JBQXRCO0FBQ0EsU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQTJCLE1BQTNCLEVBQW1DLFFBQW5DLEVBQTZDO0FBQUUsU0FBTyxjQUFjLElBQWQsQ0FBbUIsTUFBbkIsRUFBMkIsTUFBM0IsRUFBbUMsUUFBbkMsQ0FBUDtBQUFzRCIsImZpbGUiOiJjaGFyYWN0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgY29uc3QgY2hhcmFjdGVyRGlmZiA9IG5ldyBEaWZmKCk7XG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoYXJzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.wordDiff = undefined;
	exports. /*istanbul ignore end*/diffWords = diffWords;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/
	var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/

	// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
	//
	// Ranges and exceptions:
	// Latin-1 Supplement, 008000FF
	//  - U+00D7   Multiplication sign
	//  - U+00F7   Division sign
	// Latin Extended-A, 0100017F
	// Latin Extended-B, 0180024F
	// IPA Extensions, 025002AF
	// Spacing Modifier Letters, 02B002FF
	//  - U+02C7   &#711;  Caron
	//  - U+02D8   &#728;  Breve
	//  - U+02D9   &#729;  Dot Above
	//  - U+02DA   &#730;  Ring Above
	//  - U+02DB   &#731;  Ogonek
	//  - U+02DC   &#732;  Small Tilde
	//  - U+02DD   &#733;  Double Acute Accent
	// Latin Extended Additional, 1E001EFF
	var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;

	var reWhitespace = /\S/;

	var wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;
	wordDiff.equals = function (left, right) {
	  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
	};
	wordDiff.tokenize = function (value) {
	  var tokens = value.split(/(\s+|\b)/);

	  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
	  for (var i = 0; i < tokens.length - 1; i++) {
	    // If we have an empty string in the next field and we have only word chars before and after, merge
	    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
	      tokens[i] += tokens[i + 2];
	      tokens.splice(i + 1, 2);
	      i--;
	    }
	  }

	  return tokens;
	};

	function diffWords(oldStr, newStr, callback) {
	  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
	  return wordDiff.diff(oldStr, newStr, options);
	}
	function diffWordsWithSpace(oldStr, newStr, callback) {
	  return wordDiff.diff(oldStr, newStr, callback);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3dvcmQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztnQ0ErQ2dCLFMsR0FBQSxTO3lEQUlBLGtCLEdBQUEsa0I7O0FBbkRoQixJLHlCQUFBLHlCLHdCQUFBOzs7Ozs7QUFDQSxJLHlCQUFBLG1DLHdCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLElBQU0sb0JBQW9CLCtEQUExQjs7QUFFQSxJQUFNLGVBQWUsSUFBckI7O0FBRU8sSUFBTSxXLHlCQUFBLFEsd0JBQUEsV0FBVyxJLHlCQUFBLG1CLHdCQUFqQjtBQUNQLFNBQVMsTUFBVCxHQUFrQixVQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ3RDLFNBQU8sU0FBUyxLQUFULElBQW1CLEtBQUssT0FBTCxDQUFhLGdCQUFiLElBQWlDLENBQUMsYUFBYSxJQUFiLENBQWtCLElBQWxCLENBQWxDLElBQTZELENBQUMsYUFBYSxJQUFiLENBQWtCLEtBQWxCLENBQXhGO0FBQ0QsQ0FGRDtBQUdBLFNBQVMsUUFBVCxHQUFvQixVQUFTLEtBQVQsRUFBZ0I7QUFDbEMsTUFBSSxTQUFTLE1BQU0sS0FBTixDQUFZLFVBQVosQ0FBYjs7O0FBR0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBUCxHQUFnQixDQUFwQyxFQUF1QyxHQUF2QyxFQUE0Qzs7QUFFMUMsUUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFYLENBQUQsSUFBa0IsT0FBTyxJQUFJLENBQVgsQ0FBbEIsSUFDSyxrQkFBa0IsSUFBbEIsQ0FBdUIsT0FBTyxDQUFQLENBQXZCLENBREwsSUFFSyxrQkFBa0IsSUFBbEIsQ0FBdUIsT0FBTyxJQUFJLENBQVgsQ0FBdkIsQ0FGVCxFQUVnRDtBQUM5QyxhQUFPLENBQVAsS0FBYSxPQUFPLElBQUksQ0FBWCxDQUFiO0FBQ0EsYUFBTyxNQUFQLENBQWMsSUFBSSxDQUFsQixFQUFxQixDQUFyQjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLE1BQVA7QUFDRCxDQWhCRDs7QUFrQk8sU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQTJCLE1BQTNCLEVBQW1DLFFBQW5DLEVBQTZDO0FBQ2xELE1BQUksVSx5QkFBVSw0Qix3QkFBQSxDQUFnQixRQUFoQixFQUEwQixFQUFDLGtCQUFrQixJQUFuQixFQUExQixDQUFkO0FBQ0EsU0FBTyxTQUFTLElBQVQsQ0FBYyxNQUFkLEVBQXNCLE1BQXRCLEVBQThCLE9BQTlCLENBQVA7QUFDRDtBQUNNLFNBQVMsa0JBQVQsQ0FBNEIsTUFBNUIsRUFBb0MsTUFBcEMsRUFBNEMsUUFBNUMsRUFBc0Q7QUFDM0QsU0FBTyxTQUFTLElBQVQsQ0FBYyxNQUFkLEVBQXNCLE1BQXRCLEVBQThCLFFBQTlCLENBQVA7QUFDRCIsImZpbGUiOiJ3b3JkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7Z2VuZXJhdGVPcHRpb25zfSBmcm9tICcuLi91dGlsL3BhcmFtcyc7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXG4vL1xuLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxuLy8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxuLy8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXG4vLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cbi8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXG4vLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0RlxuLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXG4vLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXG4vLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cbi8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxuLy8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxuLy8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcbi8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcbi8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxuLy8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcbi8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXG5jb25zdCBleHRlbmRlZFdvcmRDaGFycyA9IC9eW2EtekEtWlxcdXtDMH0tXFx1e0ZGfVxcdXtEOH0tXFx1e0Y2fVxcdXtGOH0tXFx1ezJDNn1cXHV7MkM4fS1cXHV7MkQ3fVxcdXsyREV9LVxcdXsyRkZ9XFx1ezFFMDB9LVxcdXsxRUZGfV0rJC91O1xuXG5jb25zdCByZVdoaXRlc3BhY2UgPSAvXFxTLztcblxuZXhwb3J0IGNvbnN0IHdvcmREaWZmID0gbmV3IERpZmYoKTtcbndvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCkpO1xufTtcbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgbGV0IHRva2VucyA9IHZhbHVlLnNwbGl0KC8oXFxzK3xcXGIpLyk7XG5cbiAgLy8gSm9pbiB0aGUgYm91bmRhcnkgc3BsaXRzIHRoYXQgd2UgZG8gbm90IGNvbnNpZGVyIHRvIGJlIGJvdW5kYXJpZXMuIFRoaXMgaXMgcHJpbWFyaWx5IHRoZSBleHRlbmRlZCBMYXRpbiBjaGFyYWN0ZXIgc2V0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcbiAgICBpZiAoIXRva2Vuc1tpICsgMV0gJiYgdG9rZW5zW2kgKyAyXVxuICAgICAgICAgICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2ldKVxuICAgICAgICAgICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcbiAgICAgIHRva2Vuc1tpXSArPSB0b2tlbnNbaSArIDJdO1xuICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmV29yZHMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIGxldCBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKGNhbGxiYWNrLCB7aWdub3JlV2hpdGVzcGFjZTogdHJ1ZX0pO1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xufVxuIl19


/***/ },
/* 4 */
/***/ function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/generateOptions = generateOptions;
	function generateOptions(options, defaults) {
	  if (typeof options === 'function') {
	    defaults.callback = options;
	  } else if (options) {
	    for (var name in options) {
	      /* istanbul ignore else */
	      if (options.hasOwnProperty(name)) {
	        defaults[name] = options[name];
	      }
	    }
	  }
	  return defaults;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3BhcmFtcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Z0NBQWdCLGUsR0FBQSxlO0FBQVQsU0FBUyxlQUFULENBQXlCLE9BQXpCLEVBQWtDLFFBQWxDLEVBQTRDO0FBQ2pELE1BQUksT0FBTyxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2pDLGFBQVMsUUFBVCxHQUFvQixPQUFwQjtBQUNELEdBRkQsTUFFTyxJQUFJLE9BQUosRUFBYTtBQUNsQixTQUFLLElBQUksSUFBVCxJQUFpQixPQUFqQixFQUEwQjs7QUFFeEIsVUFBSSxRQUFRLGNBQVIsQ0FBdUIsSUFBdkIsQ0FBSixFQUFrQztBQUNoQyxpQkFBUyxJQUFULElBQWlCLFFBQVEsSUFBUixDQUFqQjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU8sUUFBUDtBQUNEIiwiZmlsZSI6InBhcmFtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBkZWZhdWx0c1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cbiJdfQ==


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.lineDiff = undefined;
	exports. /*istanbul ignore end*/diffLines = diffLines;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/
	var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;
	lineDiff.tokenize = function (value) {
	  var retLines = [],
	      linesAndNewlines = value.split(/(\n|\r\n)/);

	  // Ignore the final empty token that occurs if the string ends with a new line
	  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
	    linesAndNewlines.pop();
	  }

	  // Merge the content and line separators into single tokens
	  for (var i = 0; i < linesAndNewlines.length; i++) {
	    var line = linesAndNewlines[i];

	    if (i % 2 && !this.options.newlineIsToken) {
	      retLines[retLines.length - 1] += line;
	    } else {
	      if (this.options.ignoreWhitespace) {
	        line = line.trim();
	      }
	      retLines.push(line);
	    }
	  }

	  return retLines;
	};

	function diffLines(oldStr, newStr, callback) {
	  return lineDiff.diff(oldStr, newStr, callback);
	}
	function diffTrimmedLines(oldStr, newStr, callback) {
	  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
	  return lineDiff.diff(oldStr, newStr, options);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2xpbmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztnQ0E4QmdCLFMsR0FBQSxTO3lEQUNBLGdCLEdBQUEsZ0I7O0FBL0JoQixJLHlCQUFBLHlCLHdCQUFBOzs7Ozs7QUFDQSxJLHlCQUFBLG1DLHdCQUFBOzs7Ozt1QkFFTyxJQUFNLFcseUJBQUEsUSx3QkFBQSxXQUFXLEkseUJBQUEsbUIsd0JBQWpCO0FBQ1AsU0FBUyxRQUFULEdBQW9CLFVBQVMsS0FBVCxFQUFnQjtBQUNsQyxNQUFJLFdBQVcsRUFBZjtBQUFBLE1BQ0ksbUJBQW1CLE1BQU0sS0FBTixDQUFZLFdBQVosQ0FEdkI7OztBQUlBLE1BQUksQ0FBQyxpQkFBaUIsaUJBQWlCLE1BQWpCLEdBQTBCLENBQTNDLENBQUwsRUFBb0Q7QUFDbEQscUJBQWlCLEdBQWpCO0FBQ0Q7OztBQUdELE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxpQkFBaUIsTUFBckMsRUFBNkMsR0FBN0MsRUFBa0Q7QUFDaEQsUUFBSSxPQUFPLGlCQUFpQixDQUFqQixDQUFYOztBQUVBLFFBQUksSUFBSSxDQUFKLElBQVMsQ0FBQyxLQUFLLE9BQUwsQ0FBYSxjQUEzQixFQUEyQztBQUN6QyxlQUFTLFNBQVMsTUFBVCxHQUFrQixDQUEzQixLQUFpQyxJQUFqQztBQUNELEtBRkQsTUFFTztBQUNMLFVBQUksS0FBSyxPQUFMLENBQWEsZ0JBQWpCLEVBQW1DO0FBQ2pDLGVBQU8sS0FBSyxJQUFMLEVBQVA7QUFDRDtBQUNELGVBQVMsSUFBVCxDQUFjLElBQWQ7QUFDRDtBQUNGOztBQUVELFNBQU8sUUFBUDtBQUNELENBeEJEOztBQTBCTyxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBMkIsTUFBM0IsRUFBbUMsUUFBbkMsRUFBNkM7QUFBRSxTQUFPLFNBQVMsSUFBVCxDQUFjLE1BQWQsRUFBc0IsTUFBdEIsRUFBOEIsUUFBOUIsQ0FBUDtBQUFpRDtBQUNoRyxTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLE1BQWxDLEVBQTBDLFFBQTFDLEVBQW9EO0FBQ3pELE1BQUksVSx5QkFBVSw0Qix3QkFBQSxDQUFnQixRQUFoQixFQUEwQixFQUFDLGtCQUFrQixJQUFuQixFQUExQixDQUFkO0FBQ0EsU0FBTyxTQUFTLElBQVQsQ0FBYyxNQUFkLEVBQXNCLE1BQXRCLEVBQThCLE9BQTlCLENBQVA7QUFDRCIsImZpbGUiOiJsaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7Z2VuZXJhdGVPcHRpb25zfSBmcm9tICcuLi91dGlsL3BhcmFtcyc7XG5cbmV4cG9ydCBjb25zdCBsaW5lRGlmZiA9IG5ldyBEaWZmKCk7XG5saW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGxldCByZXRMaW5lcyA9IFtdLFxuICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxufFxcclxcbikvKTtcblxuICAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcbiAgaWYgKCFsaW5lc0FuZE5ld2xpbmVzW2xpbmVzQW5kTmV3bGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xuICB9XG5cbiAgLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xuXG4gICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcbiAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICB9XG4gICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXRMaW5lcztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbmV4cG9ydCBmdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICBsZXQgb3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucyhjYWxsYmFjaywge2lnbm9yZVdoaXRlc3BhY2U6IHRydWV9KTtcbiAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuIl19


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.sentenceDiff = undefined;
	exports. /*istanbul ignore end*/diffSentences = diffSentences;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;
	sentenceDiff.tokenize = function (value) {
	  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
	};

	function diffSentences(oldStr, newStr, callback) {
	  return sentenceDiff.diff(oldStr, newStr, callback);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3NlbnRlbmNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Z0NBUWdCLGEsR0FBQSxhOztBQVJoQixJLHlCQUFBLHlCLHdCQUFBOzs7Ozs7O3VCQUdPLElBQU0sZSx5QkFBQSxRLHdCQUFBLGVBQWUsSSx5QkFBQSxtQix3QkFBckI7QUFDUCxhQUFhLFFBQWIsR0FBd0IsVUFBUyxLQUFULEVBQWdCO0FBQ3RDLFNBQU8sTUFBTSxLQUFOLENBQVksdUJBQVosQ0FBUDtBQUNELENBRkQ7O0FBSU8sU0FBUyxhQUFULENBQXVCLE1BQXZCLEVBQStCLE1BQS9CLEVBQXVDLFFBQXZDLEVBQWlEO0FBQUUsU0FBTyxhQUFhLElBQWIsQ0FBa0IsTUFBbEIsRUFBMEIsTUFBMUIsRUFBa0MsUUFBbEMsQ0FBUDtBQUFxRCIsImZpbGUiOiJzZW50ZW5jZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cblxuZXhwb3J0IGNvbnN0IHNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFMuKz9bLiE/XSkoPz1cXHMrfCQpLyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.cssDiff = undefined;
	exports. /*istanbul ignore end*/diffCss = diffCss;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;
	cssDiff.tokenize = function (value) {
	  return value.split(/([{}:;,]|\s+)/);
	};

	function diffCss(oldStr, newStr, callback) {
	  return cssDiff.diff(oldStr, newStr, callback);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Nzcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O2dDQU9nQixPLEdBQUEsTzs7QUFQaEIsSSx5QkFBQSx5Qix3QkFBQTs7Ozs7Ozt1QkFFTyxJQUFNLFUseUJBQUEsUSx3QkFBQSxVQUFVLEkseUJBQUEsbUIsd0JBQWhCO0FBQ1AsUUFBUSxRQUFSLEdBQW1CLFVBQVMsS0FBVCxFQUFnQjtBQUNqQyxTQUFPLE1BQU0sS0FBTixDQUFZLGVBQVosQ0FBUDtBQUNELENBRkQ7O0FBSU8sU0FBUyxPQUFULENBQWlCLE1BQWpCLEVBQXlCLE1BQXpCLEVBQWlDLFFBQWpDLEVBQTJDO0FBQUUsU0FBTyxRQUFRLElBQVIsQ0FBYSxNQUFiLEVBQXFCLE1BQXJCLEVBQTZCLFFBQTdCLENBQVA7QUFBZ0QiLCJmaWxlIjoiY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGNzc0RpZmYgPSBuZXcgRGlmZigpO1xuY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.jsonDiff = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports. /*istanbul ignore end*/diffJson = diffJson;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	/*istanbul ignore end*/
	var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/

	var objectPrototypeToString = Object.prototype.toString;

	var jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;
	// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
	// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
	jsonDiff.useLongestToken = true;

	jsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff. /*istanbul ignore end*/tokenize;
	jsonDiff.castInput = function (value) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/undefinedReplacement = this.options.undefinedReplacement;


	  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function (k, v) {
	    if (typeof v === 'undefined') {
	      return undefinedReplacement;
	    }

	    return v;
	  }, '  ');
	};
	jsonDiff.equals = function (left, right) {
	  return (/*istanbul ignore start*/_base2['default']. /*istanbul ignore end*/prototype.equals(left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
	  );
	};

	function diffJson(oldObj, newObj, options) {
	  return jsonDiff.diff(oldObj, newObj, options);
	}

	// This function handles the presence of circular references by bailing out when encountering an
	// object that is already on the "stack" of items being processed.
	function canonicalize(obj, stack, replacementStack) {
	  stack = stack || [];
	  replacementStack = replacementStack || [];

	  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  for (i = 0; i < stack.length; i += 1) {
	    if (stack[i] === obj) {
	      return replacementStack[i];
	    }
	  }

	  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  if ('[object Array]' === objectPrototypeToString.call(obj)) {
	    stack.push(obj);
	    canonicalizedObj = new Array(obj.length);
	    replacementStack.push(canonicalizedObj);
	    for (i = 0; i < obj.length; i += 1) {
	      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
	    }
	    stack.pop();
	    replacementStack.pop();
	    return canonicalizedObj;
	  }

	  if (obj && obj.toJSON) {
	    obj = obj.toJSON();
	  }

	  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
	    stack.push(obj);
	    canonicalizedObj = {};
	    replacementStack.push(canonicalizedObj);
	    var sortedKeys = [],
	        key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	    for (key in obj) {
	      /* istanbul ignore else */
	      if (obj.hasOwnProperty(key)) {
	        sortedKeys.push(key);
	      }
	    }
	    sortedKeys.sort();
	    for (i = 0; i < sortedKeys.length; i += 1) {
	      key = sortedKeys[i];
	      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
	    }
	    stack.pop();
	    replacementStack.pop();
	  } else {
	    canonicalizedObj = obj;
	  }
	  return canonicalizedObj;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2pzb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztnQ0EyQmdCLFEsR0FBQSxRO3lEQUlBLFksR0FBQSxZOztBQS9CaEIsSSx5QkFBQSx5Qix3QkFBQTs7Ozs7O0FBQ0EsSSx5QkFBQSx5Qix3QkFBQTs7Ozs7OztBQUVBLElBQU0sMEJBQTBCLE9BQU8sU0FBUCxDQUFpQixRQUFqRDs7QUFHTyxJQUFNLFcseUJBQUEsUSx3QkFBQSxXQUFXLEkseUJBQUEsbUIsd0JBQWpCOzs7QUFHUCxTQUFTLGVBQVQsR0FBMkIsSUFBM0I7O0FBRUEsU0FBUyxRQUFULEcseUJBQW9CLGUsd0JBQVMsUUFBN0I7QUFDQSxTQUFTLFNBQVQsR0FBcUIsVUFBUyxLQUFULEVBQWdCOzJCQUFBLEksdUJBQzVCLG9CQUQ0QixHQUNKLEtBQUssT0FERCxDQUM1QixvQkFENEI7OztBQUduQyxTQUFPLE9BQU8sS0FBUCxLQUFpQixRQUFqQixHQUE0QixLQUE1QixHQUFvQyxLQUFLLFNBQUwsQ0FBZSxhQUFhLEtBQWIsQ0FBZixFQUFvQyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDNUYsUUFBSSxPQUFPLENBQVAsS0FBYSxXQUFqQixFQUE4QjtBQUM1QixhQUFPLG9CQUFQO0FBQ0Q7O0FBRUQsV0FBTyxDQUFQO0FBQ0QsR0FOMEMsRUFNeEMsSUFOd0MsQ0FBM0M7QUFPRCxDQVZEO0FBV0EsU0FBUyxNQUFULEdBQWtCLFVBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDdEMsUywwQkFBTyxrQix3QkFBSyxTQUFMLENBQWUsTUFBZixDQUFzQixLQUFLLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLElBQTNCLENBQXRCLEVBQXdELE1BQU0sT0FBTixDQUFjLFlBQWQsRUFBNEIsSUFBNUIsQ0FBeEQ7QUFBUDtBQUNELENBRkQ7O0FBSU8sU0FBUyxRQUFULENBQWtCLE1BQWxCLEVBQTBCLE1BQTFCLEVBQWtDLE9BQWxDLEVBQTJDO0FBQUUsU0FBTyxTQUFTLElBQVQsQ0FBYyxNQUFkLEVBQXNCLE1BQXRCLEVBQThCLE9BQTlCLENBQVA7QUFBZ0Q7Ozs7QUFJN0YsU0FBUyxZQUFULENBQXNCLEdBQXRCLEVBQTJCLEtBQTNCLEVBQWtDLGdCQUFsQyxFQUFvRDtBQUN6RCxVQUFRLFNBQVMsRUFBakI7QUFDQSxxQkFBbUIsb0JBQW9CLEVBQXZDOztBQUVBLE1BQUksSSx5QkFBQSxNLHdCQUFKOztBQUVBLE9BQUssSUFBSSxDQUFULEVBQVksSUFBSSxNQUFNLE1BQXRCLEVBQThCLEtBQUssQ0FBbkMsRUFBc0M7QUFDcEMsUUFBSSxNQUFNLENBQU4sTUFBYSxHQUFqQixFQUFzQjtBQUNwQixhQUFPLGlCQUFpQixDQUFqQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLG1CLHlCQUFBLE0sd0JBQUo7O0FBRUEsTUFBSSxxQkFBcUIsd0JBQXdCLElBQXhCLENBQTZCLEdBQTdCLENBQXpCLEVBQTREO0FBQzFELFVBQU0sSUFBTixDQUFXLEdBQVg7QUFDQSx1QkFBbUIsSUFBSSxLQUFKLENBQVUsSUFBSSxNQUFkLENBQW5CO0FBQ0EscUJBQWlCLElBQWpCLENBQXNCLGdCQUF0QjtBQUNBLFNBQUssSUFBSSxDQUFULEVBQVksSUFBSSxJQUFJLE1BQXBCLEVBQTRCLEtBQUssQ0FBakMsRUFBb0M7QUFDbEMsdUJBQWlCLENBQWpCLElBQXNCLGFBQWEsSUFBSSxDQUFKLENBQWIsRUFBcUIsS0FBckIsRUFBNEIsZ0JBQTVCLENBQXRCO0FBQ0Q7QUFDRCxVQUFNLEdBQU47QUFDQSxxQkFBaUIsR0FBakI7QUFDQSxXQUFPLGdCQUFQO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPLElBQUksTUFBZixFQUF1QjtBQUNyQixVQUFNLElBQUksTUFBSixFQUFOO0FBQ0Q7O0FBRUQsTSwwQkFBSSxRLHVCQUFPLEdBQVAseUNBQU8sR0FBUCxPQUFlLFFBQWYsSUFBMkIsUUFBUSxJQUF2QyxFQUE2QztBQUMzQyxVQUFNLElBQU4sQ0FBVyxHQUFYO0FBQ0EsdUJBQW1CLEVBQW5CO0FBQ0EscUJBQWlCLElBQWpCLENBQXNCLGdCQUF0QjtBQUNBLFFBQUksYUFBYSxFQUFqQjtBQUFBLFFBQ0ksTSx5QkFBQSxNLHdCQURKO0FBRUEsU0FBSyxHQUFMLElBQVksR0FBWixFQUFpQjs7QUFFZixVQUFJLElBQUksY0FBSixDQUFtQixHQUFuQixDQUFKLEVBQTZCO0FBQzNCLG1CQUFXLElBQVgsQ0FBZ0IsR0FBaEI7QUFDRDtBQUNGO0FBQ0QsZUFBVyxJQUFYO0FBQ0EsU0FBSyxJQUFJLENBQVQsRUFBWSxJQUFJLFdBQVcsTUFBM0IsRUFBbUMsS0FBSyxDQUF4QyxFQUEyQztBQUN6QyxZQUFNLFdBQVcsQ0FBWCxDQUFOO0FBQ0EsdUJBQWlCLEdBQWpCLElBQXdCLGFBQWEsSUFBSSxHQUFKLENBQWIsRUFBdUIsS0FBdkIsRUFBOEIsZ0JBQTlCLENBQXhCO0FBQ0Q7QUFDRCxVQUFNLEdBQU47QUFDQSxxQkFBaUIsR0FBakI7QUFDRCxHQW5CRCxNQW1CTztBQUNMLHVCQUFtQixHQUFuQjtBQUNEO0FBQ0QsU0FBTyxnQkFBUDtBQUNEIiwiZmlsZSI6Impzb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHtsaW5lRGlmZn0gZnJvbSAnLi9saW5lJztcblxuY29uc3Qgb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5cbmV4cG9ydCBjb25zdCBqc29uRGlmZiA9IG5ldyBEaWZmKCk7XG4vLyBEaXNjcmltaW5hdGUgYmV0d2VlbiB0d28gbGluZXMgb2YgcHJldHR5LXByaW50ZWQsIHNlcmlhbGl6ZWQgSlNPTiB3aGVyZSBvbmUgb2YgdGhlbSBoYXMgYVxuLy8gZGFuZ2xpbmcgY29tbWEgYW5kIHRoZSBvdGhlciBkb2Vzbid0LiBUdXJucyBvdXQgaW5jbHVkaW5nIHRoZSBkYW5nbGluZyBjb21tYSB5aWVsZHMgdGhlIG5pY2VzdCBvdXRwdXQ6XG5qc29uRGlmZi51c2VMb25nZXN0VG9rZW4gPSB0cnVlO1xuXG5qc29uRGlmZi50b2tlbml6ZSA9IGxpbmVEaWZmLnRva2VuaXplO1xuanNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgY29uc3Qge3VuZGVmaW5lZFJlcGxhY2VtZW50fSA9IHRoaXMub3B0aW9ucztcblxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlKSwgZnVuY3Rpb24oaywgdikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRSZXBsYWNlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbiAgfSwgJyAgJyk7XG59O1xuanNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIERpZmYucHJvdG90eXBlLmVxdWFscyhsZWZ0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHsgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpOyB9XG5cbi8vIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgcHJlc2VuY2Ugb2YgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBiYWlsaW5nIG91dCB3aGVuIGVuY291bnRlcmluZyBhblxuLy8gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBvbiB0aGUgXCJzdGFja1wiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC5cbmV4cG9ydCBmdW5jdGlvbiBjYW5vbmljYWxpemUob2JqLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaykge1xuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuICByZXBsYWNlbWVudFN0YWNrID0gcmVwbGFjZW1lbnRTdGFjayB8fCBbXTtcblxuICBsZXQgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XG4gICAgfVxuICB9XG5cbiAgbGV0IGNhbm9uaWNhbGl6ZWRPYmo7XG5cbiAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spO1xuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xuICB9XG5cbiAgaWYgKG9iaiAmJiBvYmoudG9KU09OKSB7XG4gICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICBjYW5vbmljYWxpemVkT2JqID0ge307XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xuICAgIGxldCBzb3J0ZWRLZXlzID0gW10sXG4gICAgICAgIGtleTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgc29ydGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRlZEtleXMuc29ydCgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3J0ZWRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBrZXkgPSBzb3J0ZWRLZXlzW2ldO1xuICAgICAgY2Fub25pY2FsaXplZE9ialtrZXldID0gY2Fub25pY2FsaXplKG9ialtrZXldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjayk7XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG9iajtcbiAgfVxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn1cbiJdfQ==


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports.arrayDiff = undefined;
	exports. /*istanbul ignore end*/diffArrays = diffArrays;

	var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _base2 = _interopRequireDefault(_base);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;
	arrayDiff.tokenize = arrayDiff.join = function (value) {
	  return value.slice();
	};

	function diffArrays(oldArr, newArr, callback) {
	  return arrayDiff.diff(oldArr, newArr, callback);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2FycmF5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Z0NBT2dCLFUsR0FBQSxVOztBQVBoQixJLHlCQUFBLHlCLHdCQUFBOzs7Ozs7O3VCQUVPLElBQU0sWSx5QkFBQSxRLHdCQUFBLFlBQVksSSx5QkFBQSxtQix3QkFBbEI7QUFDUCxVQUFVLFFBQVYsR0FBcUIsVUFBVSxJQUFWLEdBQWlCLFVBQVMsS0FBVCxFQUFnQjtBQUNwRCxTQUFPLE1BQU0sS0FBTixFQUFQO0FBQ0QsQ0FGRDs7QUFJTyxTQUFTLFVBQVQsQ0FBb0IsTUFBcEIsRUFBNEIsTUFBNUIsRUFBb0MsUUFBcEMsRUFBOEM7QUFBRSxTQUFPLFVBQVUsSUFBVixDQUFlLE1BQWYsRUFBdUIsTUFBdkIsRUFBK0IsUUFBL0IsQ0FBUDtBQUFrRCIsImZpbGUiOiJhcnJheS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBjb25zdCBhcnJheURpZmYgPSBuZXcgRGlmZigpO1xuYXJyYXlEaWZmLnRva2VuaXplID0gYXJyYXlEaWZmLmpvaW4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykgeyByZXR1cm4gYXJyYXlEaWZmLmRpZmYob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKTsgfVxuIl19


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/applyPatch = applyPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;

	var /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;

	var /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	var _distanceIterator2 = _interopRequireDefault(_distanceIterator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/*istanbul ignore end*/function applyPatch(source, uniDiff) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	  if (typeof uniDiff === 'string') {
	    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
	  }

	  if (Array.isArray(uniDiff)) {
	    if (uniDiff.length > 1) {
	      throw new Error('applyPatch only works with a single input.');
	    }

	    uniDiff = uniDiff[0];
	  }

	  // Apply the diff to the input
	  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
	      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	      hunks = uniDiff.hunks,
	      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{
	    return (/*istanbul ignore end*/line === patchContent
	    );
	  },
	      errorCount = 0,
	      fuzzFactor = options.fuzzFactor || 0,
	      minLine = 0,
	      offset = 0,
	      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
	      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

	  /**
	   * Checks if the hunk exactly fits on the provided location
	   */
	  function hunkFits(hunk, toPos) {
	    for (var j = 0; j < hunk.lines.length; j++) {
	      var line = hunk.lines[j],
	          operation = line[0],
	          content = line.substr(1);

	      if (operation === ' ' || operation === '-') {
	        // Context sanity check
	        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
	          errorCount++;

	          if (errorCount > fuzzFactor) {
	            return false;
	          }
	        }
	        toPos++;
	      }
	    }

	    return true;
	  }

	  // Search best fit offsets for each hunk based on the previous ones
	  for (var i = 0; i < hunks.length; i++) {
	    var hunk = hunks[i],
	        maxLine = lines.length - hunk.oldLines,
	        localOffset = 0,
	        toPos = offset + hunk.oldStart - 1;

	    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);

	    for (; localOffset !== undefined; localOffset = iterator()) {
	      if (hunkFits(hunk, toPos + localOffset)) {
	        hunk.offset = offset += localOffset;
	        break;
	      }
	    }

	    if (localOffset === undefined) {
	      return false;
	    }

	    // Set lower text limit to end of the current hunk, so next ones don't try
	    // to fit over already patched text
	    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
	  }

	  // Apply patch hunks
	  for (var _i = 0; _i < hunks.length; _i++) {
	    var _hunk = hunks[_i],
	        _toPos = _hunk.offset + _hunk.newStart - 1;
	    if (_hunk.newLines == 0) {
	      _toPos++;
	    }

	    for (var j = 0; j < _hunk.lines.length; j++) {
	      var line = _hunk.lines[j],
	          operation = line[0],
	          content = line.substr(1),
	          delimiter = _hunk.linedelimiters[j];

	      if (operation === ' ') {
	        _toPos++;
	      } else if (operation === '-') {
	        lines.splice(_toPos, 1);
	        delimiters.splice(_toPos, 1);
	        /* istanbul ignore else */
	      } else if (operation === '+') {
	          lines.splice(_toPos, 0, content);
	          delimiters.splice(_toPos, 0, delimiter);
	          _toPos++;
	        } else if (operation === '\\') {
	          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
	          if (previousOperation === '+') {
	            removeEOFNL = true;
	          } else if (previousOperation === '-') {
	            addEOFNL = true;
	          }
	        }
	    }
	  }

	  // Handle EOFNL insertion/removal
	  if (removeEOFNL) {
	    while (!lines[lines.length - 1]) {
	      lines.pop();
	      delimiters.pop();
	    }
	  } else if (addEOFNL) {
	    lines.push('');
	    delimiters.push('\n');
	  }
	  for (var _k = 0; _k < lines.length - 1; _k++) {
	    lines[_k] = lines[_k] + delimiters[_k];
	  }
	  return lines.join('');
	}

	// Wrapper that supports multiple file patches via callbacks.
	function applyPatches(uniDiff, options) {
	  if (typeof uniDiff === 'string') {
	    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
	  }

	  var currentIndex = 0;
	  function processIndex() {
	    var index = uniDiff[currentIndex++];
	    if (!index) {
	      return options.complete();
	    }

	    options.loadFile(index, function (err, data) {
	      if (err) {
	        return options.complete(err);
	      }

	      var updatedContent = applyPatch(data, index, options);
	      options.patched(index, updatedContent, function (err) {
	        if (err) {
	          return options.complete(err);
	        }

	        processIndex();
	      });
	    });
	  }
	  processIndex();
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9hcHBseS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Z0NBR2dCLFUsR0FBQSxVO3lEQStIQSxZLEdBQUEsWTs7QUFsSWhCLEkseUJBQUEsMkIsd0JBQUE7O0FBQ0EsSSx5QkFBQSx3RCx3QkFBQTs7Ozs7Ozt1QkFFTyxTQUFTLFVBQVQsQ0FBb0IsTUFBcEIsRUFBNEIsT0FBNUIsRUFBbUQ7MkJBQUEsSSx1QkFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQ3hELE1BQUksT0FBTyxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CLGMseUJBQVUsc0Isd0JBQUEsQ0FBVyxPQUFYLENBQVY7QUFDRDs7QUFFRCxNQUFJLE1BQU0sT0FBTixDQUFjLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixRQUFJLFFBQVEsTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUN0QixZQUFNLElBQUksS0FBSixDQUFVLDRDQUFWLENBQU47QUFDRDs7QUFFRCxjQUFVLFFBQVEsQ0FBUixDQUFWO0FBQ0Q7OztBQUdELE1BQUksUUFBUSxPQUFPLEtBQVAsQ0FBYSxxQkFBYixDQUFaO0FBQUEsTUFDSSxhQUFhLE9BQU8sS0FBUCxDQUFhLHNCQUFiLEtBQXdDLEVBRHpEO0FBQUEsTUFFSSxRQUFRLFFBQVEsS0FGcEI7QUFBQSxNQUlJLGNBQWMsUUFBUSxXQUFSLElBQXdCLFVBQUMsVUFBRCxFQUFhLElBQWIsRUFBbUIsU0FBbkIsRUFBOEIsWUFBOUIsRSx5QkFBQTtBQUFBLFcsd0JBQStDLFNBQVM7QUFBeEQ7QUFBQSxHQUoxQztBQUFBLE1BS0ksYUFBYSxDQUxqQjtBQUFBLE1BTUksYUFBYSxRQUFRLFVBQVIsSUFBc0IsQ0FOdkM7QUFBQSxNQU9JLFVBQVUsQ0FQZDtBQUFBLE1BUUksU0FBUyxDQVJiO0FBQUEsTUFVSSxjLHlCQUFBLE0sd0JBVko7QUFBQSxNQVdJLFcseUJBQUEsTSx3QkFYSjs7Ozs7QUFnQkEsV0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLEtBQXhCLEVBQStCO0FBQzdCLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLEtBQUwsQ0FBVyxNQUEvQixFQUF1QyxHQUF2QyxFQUE0QztBQUMxQyxVQUFJLE9BQU8sS0FBSyxLQUFMLENBQVcsQ0FBWCxDQUFYO0FBQUEsVUFDSSxZQUFZLEtBQUssQ0FBTCxDQURoQjtBQUFBLFVBRUksVUFBVSxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBRmQ7O0FBSUEsVUFBSSxjQUFjLEdBQWQsSUFBcUIsY0FBYyxHQUF2QyxFQUE0Qzs7QUFFMUMsWUFBSSxDQUFDLFlBQVksUUFBUSxDQUFwQixFQUF1QixNQUFNLEtBQU4sQ0FBdkIsRUFBcUMsU0FBckMsRUFBZ0QsT0FBaEQsQ0FBTCxFQUErRDtBQUM3RDs7QUFFQSxjQUFJLGFBQWEsVUFBakIsRUFBNkI7QUFDM0IsbUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7OztBQUdELE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3JDLFFBQUksT0FBTyxNQUFNLENBQU4sQ0FBWDtBQUFBLFFBQ0ksVUFBVSxNQUFNLE1BQU4sR0FBZSxLQUFLLFFBRGxDO0FBQUEsUUFFSSxjQUFjLENBRmxCO0FBQUEsUUFHSSxRQUFRLFNBQVMsS0FBSyxRQUFkLEdBQXlCLENBSHJDOztBQUtBLFFBQUksVyx5QkFBVyxrQyx3QkFBQSxDQUFpQixLQUFqQixFQUF3QixPQUF4QixFQUFpQyxPQUFqQyxDQUFmOztBQUVBLFdBQU8sZ0JBQWdCLFNBQXZCLEVBQWtDLGNBQWMsVUFBaEQsRUFBNEQ7QUFDMUQsVUFBSSxTQUFTLElBQVQsRUFBZSxRQUFRLFdBQXZCLENBQUosRUFBeUM7QUFDdkMsYUFBSyxNQUFMLEdBQWMsVUFBVSxXQUF4QjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJLGdCQUFnQixTQUFwQixFQUErQjtBQUM3QixhQUFPLEtBQVA7QUFDRDs7OztBQUlELGNBQVUsS0FBSyxNQUFMLEdBQWMsS0FBSyxRQUFuQixHQUE4QixLQUFLLFFBQTdDO0FBQ0Q7OztBQUdELE9BQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsS0FBSSxNQUFNLE1BQTFCLEVBQWtDLElBQWxDLEVBQXVDO0FBQ3JDLFFBQUksUUFBTyxNQUFNLEVBQU4sQ0FBWDtBQUFBLFFBQ0ksU0FBUSxNQUFLLE1BQUwsR0FBYyxNQUFLLFFBQW5CLEdBQThCLENBRDFDO0FBRUEsUUFBSSxNQUFLLFFBQUwsSUFBaUIsQ0FBckIsRUFBd0I7QUFBRTtBQUFVOztBQUVwQyxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBSyxLQUFMLENBQVcsTUFBL0IsRUFBdUMsR0FBdkMsRUFBNEM7QUFDMUMsVUFBSSxPQUFPLE1BQUssS0FBTCxDQUFXLENBQVgsQ0FBWDtBQUFBLFVBQ0ksWUFBWSxLQUFLLENBQUwsQ0FEaEI7QUFBQSxVQUVJLFVBQVUsS0FBSyxNQUFMLENBQVksQ0FBWixDQUZkO0FBQUEsVUFHSSxZQUFZLE1BQUssY0FBTCxDQUFvQixDQUFwQixDQUhoQjs7QUFLQSxVQUFJLGNBQWMsR0FBbEIsRUFBdUI7QUFDckI7QUFDRCxPQUZELE1BRU8sSUFBSSxjQUFjLEdBQWxCLEVBQXVCO0FBQzVCLGNBQU0sTUFBTixDQUFhLE1BQWIsRUFBb0IsQ0FBcEI7QUFDQSxtQkFBVyxNQUFYLENBQWtCLE1BQWxCLEVBQXlCLENBQXpCOztBQUVELE9BSk0sTUFJQSxJQUFJLGNBQWMsR0FBbEIsRUFBdUI7QUFDNUIsZ0JBQU0sTUFBTixDQUFhLE1BQWIsRUFBb0IsQ0FBcEIsRUFBdUIsT0FBdkI7QUFDQSxxQkFBVyxNQUFYLENBQWtCLE1BQWxCLEVBQXlCLENBQXpCLEVBQTRCLFNBQTVCO0FBQ0E7QUFDRCxTQUpNLE1BSUEsSUFBSSxjQUFjLElBQWxCLEVBQXdCO0FBQzdCLGNBQUksb0JBQW9CLE1BQUssS0FBTCxDQUFXLElBQUksQ0FBZixJQUFvQixNQUFLLEtBQUwsQ0FBVyxJQUFJLENBQWYsRUFBa0IsQ0FBbEIsQ0FBcEIsR0FBMkMsSUFBbkU7QUFDQSxjQUFJLHNCQUFzQixHQUExQixFQUErQjtBQUM3QiwwQkFBYyxJQUFkO0FBQ0QsV0FGRCxNQUVPLElBQUksc0JBQXNCLEdBQTFCLEVBQStCO0FBQ3BDLHVCQUFXLElBQVg7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7O0FBR0QsTUFBSSxXQUFKLEVBQWlCO0FBQ2YsV0FBTyxDQUFDLE1BQU0sTUFBTSxNQUFOLEdBQWUsQ0FBckIsQ0FBUixFQUFpQztBQUMvQixZQUFNLEdBQU47QUFDQSxpQkFBVyxHQUFYO0FBQ0Q7QUFDRixHQUxELE1BS08sSUFBSSxRQUFKLEVBQWM7QUFDbkIsVUFBTSxJQUFOLENBQVcsRUFBWDtBQUNBLGVBQVcsSUFBWCxDQUFnQixJQUFoQjtBQUNEO0FBQ0QsT0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLE1BQU0sTUFBTixHQUFlLENBQXJDLEVBQXdDLElBQXhDLEVBQThDO0FBQzVDLFVBQU0sRUFBTixJQUFZLE1BQU0sRUFBTixJQUFZLFdBQVcsRUFBWCxDQUF4QjtBQUNEO0FBQ0QsU0FBTyxNQUFNLElBQU4sQ0FBVyxFQUFYLENBQVA7QUFDRDs7O0FBR00sU0FBUyxZQUFULENBQXNCLE9BQXRCLEVBQStCLE9BQS9CLEVBQXdDO0FBQzdDLE1BQUksT0FBTyxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CLGMseUJBQVUsc0Isd0JBQUEsQ0FBVyxPQUFYLENBQVY7QUFDRDs7QUFFRCxNQUFJLGVBQWUsQ0FBbkI7QUFDQSxXQUFTLFlBQVQsR0FBd0I7QUFDdEIsUUFBSSxRQUFRLFFBQVEsY0FBUixDQUFaO0FBQ0EsUUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLGFBQU8sUUFBUSxRQUFSLEVBQVA7QUFDRDs7QUFFRCxZQUFRLFFBQVIsQ0FBaUIsS0FBakIsRUFBd0IsVUFBUyxHQUFULEVBQWMsSUFBZCxFQUFvQjtBQUMxQyxVQUFJLEdBQUosRUFBUztBQUNQLGVBQU8sUUFBUSxRQUFSLENBQWlCLEdBQWpCLENBQVA7QUFDRDs7QUFFRCxVQUFJLGlCQUFpQixXQUFXLElBQVgsRUFBaUIsS0FBakIsRUFBd0IsT0FBeEIsQ0FBckI7QUFDQSxjQUFRLE9BQVIsQ0FBZ0IsS0FBaEIsRUFBdUIsY0FBdkIsRUFBdUMsVUFBUyxHQUFULEVBQWM7QUFDbkQsWUFBSSxHQUFKLEVBQVM7QUFDUCxpQkFBTyxRQUFRLFFBQVIsQ0FBaUIsR0FBakIsQ0FBUDtBQUNEOztBQUVEO0FBQ0QsT0FORDtBQU9ELEtBYkQ7QUFjRDtBQUNEO0FBQ0QiLCJmaWxlIjoiYXBwbHkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3BhcnNlUGF0Y2h9IGZyb20gJy4vcGFyc2UnO1xuaW1wb3J0IGRpc3RhbmNlSXRlcmF0b3IgZnJvbSAnLi4vdXRpbC9kaXN0YW5jZS1pdGVyYXRvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKHNvdXJjZSwgdW5pRGlmZiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XG4gICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBseVBhdGNoIG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcbiAgICB9XG5cbiAgICB1bmlEaWZmID0gdW5pRGlmZlswXTtcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBpbnB1dFxuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcblxuICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8ICgobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpID0+IGxpbmUgPT09IHBhdGNoQ29udGVudCksXG4gICAgICBlcnJvckNvdW50ID0gMCxcbiAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcbiAgICAgIG1pbkxpbmUgPSAwLFxuICAgICAgb2Zmc2V0ID0gMCxcblxuICAgICAgcmVtb3ZlRU9GTkwsXG4gICAgICBhZGRFT0ZOTDtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsZXQgbGluZSA9IGh1bmsubGluZXNbal0sXG4gICAgICAgICAgb3BlcmF0aW9uID0gbGluZVswXSxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5zdWJzdHIoMSk7XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAvLyBDb250ZXh0IHNhbml0eSBjaGVja1xuICAgICAgICBpZiAoIWNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XG4gICAgICAgICAgZXJyb3JDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKGVycm9yQ291bnQgPiBmdXp6RmFjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTZWFyY2ggYmVzdCBmaXQgb2Zmc2V0cyBmb3IgZWFjaCBodW5rIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBvbmVzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaHVuayA9IGh1bmtzW2ldLFxuICAgICAgICBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyxcbiAgICAgICAgbG9jYWxPZmZzZXQgPSAwLFxuICAgICAgICB0b1BvcyA9IG9mZnNldCArIGh1bmsub2xkU3RhcnQgLSAxO1xuXG4gICAgbGV0IGl0ZXJhdG9yID0gZGlzdGFuY2VJdGVyYXRvcih0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XG5cbiAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XG4gICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcbiAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2V0IGxvd2VyIHRleHQgbGltaXQgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGh1bmssIHNvIG5leHQgb25lcyBkb24ndCB0cnlcbiAgICAvLyB0byBmaXQgb3ZlciBhbHJlYWR5IHBhdGNoZWQgdGV4dFxuICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xuICB9XG5cbiAgLy8gQXBwbHkgcGF0Y2ggaHVua3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBodW5rID0gaHVua3NbaV0sXG4gICAgICAgIHRvUG9zID0gaHVuay5vZmZzZXQgKyBodW5rLm5ld1N0YXJ0IC0gMTtcbiAgICBpZiAoaHVuay5uZXdMaW5lcyA9PSAwKSB7IHRvUG9zKys7IH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGxpbmUgPSBodW5rLmxpbmVzW2pdLFxuICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmVbMF0sXG4gICAgICAgICAgY29udGVudCA9IGxpbmUuc3Vic3RyKDEpLFxuICAgICAgICAgIGRlbGltaXRlciA9IGh1bmsubGluZWRlbGltaXRlcnNbal07XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICB0b1BvcysrO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICBsaW5lcy5zcGxpY2UodG9Qb3MsIDEpO1xuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZSh0b1BvcywgMSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICBsaW5lcy5zcGxpY2UodG9Qb3MsIDAsIGNvbnRlbnQpO1xuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZSh0b1BvcywgMCwgZGVsaW1pdGVyKTtcbiAgICAgICAgdG9Qb3MrKztcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgbGV0IHByZXZpb3VzT3BlcmF0aW9uID0gaHVuay5saW5lc1tqIC0gMV0gPyBodW5rLmxpbmVzW2ogLSAxXVswXSA6IG51bGw7XG4gICAgICAgIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgcmVtb3ZlRU9GTkwgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICBhZGRFT0ZOTCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgRU9GTkwgaW5zZXJ0aW9uL3JlbW92YWxcbiAgaWYgKHJlbW92ZUVPRk5MKSB7XG4gICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgbGluZXMucG9wKCk7XG4gICAgICBkZWxpbWl0ZXJzLnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xuICAgIGxpbmVzLnB1c2goJycpO1xuICAgIGRlbGltaXRlcnMucHVzaCgnXFxuJyk7XG4gIH1cbiAgZm9yIChsZXQgX2sgPSAwOyBfayA8IGxpbmVzLmxlbmd0aCAtIDE7IF9rKyspIHtcbiAgICBsaW5lc1tfa10gPSBsaW5lc1tfa10gKyBkZWxpbWl0ZXJzW19rXTtcbiAgfVxuICByZXR1cm4gbGluZXMuam9pbignJyk7XG59XG5cbi8vIFdyYXBwZXIgdGhhdCBzdXBwb3J0cyBtdWx0aXBsZSBmaWxlIHBhdGNoZXMgdmlhIGNhbGxiYWNrcy5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoZXModW5pRGlmZiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgdW5pRGlmZiA9IHBhcnNlUGF0Y2godW5pRGlmZik7XG4gIH1cblxuICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgZnVuY3Rpb24gcHJvY2Vzc0luZGV4KCkge1xuICAgIGxldCBpbmRleCA9IHVuaURpZmZbY3VycmVudEluZGV4KytdO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5sb2FkRmlsZShpbmRleCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICB9XG5cbiAgICAgIGxldCB1cGRhdGVkQ29udGVudCA9IGFwcGx5UGF0Y2goZGF0YSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5wYXRjaGVkKGluZGV4LCB1cGRhdGVkQ29udGVudCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc0luZGV4KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzSW5kZXgoKTtcbn1cbiJdfQ==


/***/ },
/* 11 */
/***/ function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/parsePatch = parsePatch;
	function parsePatch(uniDiff) {
	  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
	      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	      list = [],
	      i = 0;

	  function parseIndex() {
	    var index = {};
	    list.push(index);

	    // Parse diff metadata
	    while (i < diffstr.length) {
	      var line = diffstr[i];

	      // File header found, end parsing diff metadata
	      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
	        break;
	      }

	      // Diff index
	      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
	      if (header) {
	        index.index = header[1];
	      }

	      i++;
	    }

	    // Parse file headers if they are defined. Unified diff requires them, but
	    // there's no technical issues to have an isolated hunk without file header
	    parseFileHeader(index);
	    parseFileHeader(index);

	    // Parse hunks
	    index.hunks = [];

	    while (i < diffstr.length) {
	      var _line = diffstr[i];

	      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
	        break;
	      } else if (/^@@/.test(_line)) {
	        index.hunks.push(parseHunk());
	      } else if (_line && options.strict) {
	        // Ignore unexpected content unless in strict mode
	        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
	      } else {
	        i++;
	      }
	    }
	  }

	  // Parses the --- and +++ headers, if none are found, no lines
	  // are consumed.
	  function parseFileHeader(index) {
	    var headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
	    var fileHeader = headerPattern.exec(diffstr[i]);
	    if (fileHeader) {
	      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
	      index[keyPrefix + 'FileName'] = fileHeader[2];
	      index[keyPrefix + 'Header'] = fileHeader[3];

	      i++;
	    }
	  }

	  // Parses a hunk
	  // This assumes that we are at the start of a hunk.
	  function parseHunk() {
	    var chunkHeaderIndex = i,
	        chunkHeaderLine = diffstr[i++],
	        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);

	    var hunk = {
	      oldStart: +chunkHeader[1],
	      oldLines: +chunkHeader[2] || 1,
	      newStart: +chunkHeader[3],
	      newLines: +chunkHeader[4] || 1,
	      lines: [],
	      linedelimiters: []
	    };

	    var addCount = 0,
	        removeCount = 0;
	    for (; i < diffstr.length; i++) {
	      // Lines starting with '---' could be mistaken for the "remove line" operation
	      // But they could be the header for the next file. Therefore prune such cases out.
	      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
	        break;
	      }
	      var operation = diffstr[i][0];

	      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
	        hunk.lines.push(diffstr[i]);
	        hunk.linedelimiters.push(delimiters[i] || '\n');

	        if (operation === '+') {
	          addCount++;
	        } else if (operation === '-') {
	          removeCount++;
	        } else if (operation === ' ') {
	          addCount++;
	          removeCount++;
	        }
	      } else {
	        break;
	      }
	    }

	    // Handle the empty block count case
	    if (!addCount && hunk.newLines === 1) {
	      hunk.newLines = 0;
	    }
	    if (!removeCount && hunk.oldLines === 1) {
	      hunk.oldLines = 0;
	    }

	    // Perform optional sanity checking
	    if (options.strict) {
	      if (addCount !== hunk.newLines) {
	        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	      }
	      if (removeCount !== hunk.oldLines) {
	        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	      }
	    }

	    return hunk;
	  }

	  while (i < diffstr.length) {
	    parseIndex();
	  }

	  return list;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9wYXJzZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Z0NBQWdCLFUsR0FBQSxVO0FBQVQsU0FBUyxVQUFULENBQW9CLE9BQXBCLEVBQTJDOzJCQUFBLEksdUJBQWQsT0FBYyx5REFBSixFQUFJOztBQUNoRCxNQUFJLFVBQVUsUUFBUSxLQUFSLENBQWMscUJBQWQsQ0FBZDtBQUFBLE1BQ0ksYUFBYSxRQUFRLEtBQVIsQ0FBYyxzQkFBZCxLQUF5QyxFQUQxRDtBQUFBLE1BRUksT0FBTyxFQUZYO0FBQUEsTUFHSSxJQUFJLENBSFI7O0FBS0EsV0FBUyxVQUFULEdBQXNCO0FBQ3BCLFFBQUksUUFBUSxFQUFaO0FBQ0EsU0FBSyxJQUFMLENBQVUsS0FBVjs7O0FBR0EsV0FBTyxJQUFJLFFBQVEsTUFBbkIsRUFBMkI7QUFDekIsVUFBSSxPQUFPLFFBQVEsQ0FBUixDQUFYOzs7QUFHQSxVQUFJLHdCQUF3QixJQUF4QixDQUE2QixJQUE3QixDQUFKLEVBQXdDO0FBQ3RDO0FBQ0Q7OztBQUdELFVBQUksU0FBVSwwQ0FBRCxDQUE2QyxJQUE3QyxDQUFrRCxJQUFsRCxDQUFiO0FBQ0EsVUFBSSxNQUFKLEVBQVk7QUFDVixjQUFNLEtBQU4sR0FBYyxPQUFPLENBQVAsQ0FBZDtBQUNEOztBQUVEO0FBQ0Q7Ozs7QUFJRCxvQkFBZ0IsS0FBaEI7QUFDQSxvQkFBZ0IsS0FBaEI7OztBQUdBLFVBQU0sS0FBTixHQUFjLEVBQWQ7O0FBRUEsV0FBTyxJQUFJLFFBQVEsTUFBbkIsRUFBMkI7QUFDekIsVUFBSSxRQUFPLFFBQVEsQ0FBUixDQUFYOztBQUVBLFVBQUksaUNBQWlDLElBQWpDLENBQXNDLEtBQXRDLENBQUosRUFBaUQ7QUFDL0M7QUFDRCxPQUZELE1BRU8sSUFBSSxNQUFNLElBQU4sQ0FBVyxLQUFYLENBQUosRUFBc0I7QUFDM0IsY0FBTSxLQUFOLENBQVksSUFBWixDQUFpQixXQUFqQjtBQUNELE9BRk0sTUFFQSxJQUFJLFNBQVEsUUFBUSxNQUFwQixFQUE0Qjs7QUFFakMsY0FBTSxJQUFJLEtBQUosQ0FBVSxtQkFBbUIsSUFBSSxDQUF2QixJQUE0QixHQUE1QixHQUFrQyxLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQTVDLENBQU47QUFDRCxPQUhNLE1BR0E7QUFDTDtBQUNEO0FBQ0Y7QUFDRjs7OztBQUlELFdBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQztBQUM5QixRQUFNLGdCQUFnQiwwQ0FBdEI7QUFDQSxRQUFNLGFBQWEsY0FBYyxJQUFkLENBQW1CLFFBQVEsQ0FBUixDQUFuQixDQUFuQjtBQUNBLFFBQUksVUFBSixFQUFnQjtBQUNkLFVBQUksWUFBWSxXQUFXLENBQVgsTUFBa0IsS0FBbEIsR0FBMEIsS0FBMUIsR0FBa0MsS0FBbEQ7QUFDQSxZQUFNLFlBQVksVUFBbEIsSUFBZ0MsV0FBVyxDQUFYLENBQWhDO0FBQ0EsWUFBTSxZQUFZLFFBQWxCLElBQThCLFdBQVcsQ0FBWCxDQUE5Qjs7QUFFQTtBQUNEO0FBQ0Y7Ozs7QUFJRCxXQUFTLFNBQVQsR0FBcUI7QUFDbkIsUUFBSSxtQkFBbUIsQ0FBdkI7QUFBQSxRQUNJLGtCQUFrQixRQUFRLEdBQVIsQ0FEdEI7QUFBQSxRQUVJLGNBQWMsZ0JBQWdCLEtBQWhCLENBQXNCLDRDQUF0QixDQUZsQjs7QUFJQSxRQUFJLE9BQU87QUFDVCxnQkFBVSxDQUFDLFlBQVksQ0FBWixDQURGO0FBRVQsZ0JBQVUsQ0FBQyxZQUFZLENBQVosQ0FBRCxJQUFtQixDQUZwQjtBQUdULGdCQUFVLENBQUMsWUFBWSxDQUFaLENBSEY7QUFJVCxnQkFBVSxDQUFDLFlBQVksQ0FBWixDQUFELElBQW1CLENBSnBCO0FBS1QsYUFBTyxFQUxFO0FBTVQsc0JBQWdCO0FBTlAsS0FBWDs7QUFTQSxRQUFJLFdBQVcsQ0FBZjtBQUFBLFFBQ0ksY0FBYyxDQURsQjtBQUVBLFdBQU8sSUFBSSxRQUFRLE1BQW5CLEVBQTJCLEdBQTNCLEVBQWdDOzs7QUFHOUIsVUFBSSxRQUFRLENBQVIsRUFBVyxPQUFYLENBQW1CLE1BQW5CLE1BQStCLENBQS9CLElBQ00sSUFBSSxDQUFKLEdBQVEsUUFBUSxNQUR0QixJQUVLLFFBQVEsSUFBSSxDQUFaLEVBQWUsT0FBZixDQUF1QixNQUF2QixNQUFtQyxDQUZ4QyxJQUdLLFFBQVEsSUFBSSxDQUFaLEVBQWUsT0FBZixDQUF1QixJQUF2QixNQUFpQyxDQUgxQyxFQUc2QztBQUN6QztBQUNIO0FBQ0QsVUFBSSxZQUFZLFFBQVEsQ0FBUixFQUFXLENBQVgsQ0FBaEI7O0FBRUEsVUFBSSxjQUFjLEdBQWQsSUFBcUIsY0FBYyxHQUFuQyxJQUEwQyxjQUFjLEdBQXhELElBQStELGNBQWMsSUFBakYsRUFBdUY7QUFDckYsYUFBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixRQUFRLENBQVIsQ0FBaEI7QUFDQSxhQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBeUIsV0FBVyxDQUFYLEtBQWlCLElBQTFDOztBQUVBLFlBQUksY0FBYyxHQUFsQixFQUF1QjtBQUNyQjtBQUNELFNBRkQsTUFFTyxJQUFJLGNBQWMsR0FBbEIsRUFBdUI7QUFDNUI7QUFDRCxTQUZNLE1BRUEsSUFBSSxjQUFjLEdBQWxCLEVBQXVCO0FBQzVCO0FBQ0E7QUFDRDtBQUNGLE9BWkQsTUFZTztBQUNMO0FBQ0Q7QUFDRjs7O0FBR0QsUUFBSSxDQUFDLFFBQUQsSUFBYSxLQUFLLFFBQUwsS0FBa0IsQ0FBbkMsRUFBc0M7QUFDcEMsV0FBSyxRQUFMLEdBQWdCLENBQWhCO0FBQ0Q7QUFDRCxRQUFJLENBQUMsV0FBRCxJQUFnQixLQUFLLFFBQUwsS0FBa0IsQ0FBdEMsRUFBeUM7QUFDdkMsV0FBSyxRQUFMLEdBQWdCLENBQWhCO0FBQ0Q7OztBQUdELFFBQUksUUFBUSxNQUFaLEVBQW9CO0FBQ2xCLFVBQUksYUFBYSxLQUFLLFFBQXRCLEVBQWdDO0FBQzlCLGNBQU0sSUFBSSxLQUFKLENBQVUsc0RBQXNELG1CQUFtQixDQUF6RSxDQUFWLENBQU47QUFDRDtBQUNELFVBQUksZ0JBQWdCLEtBQUssUUFBekIsRUFBbUM7QUFDakMsY0FBTSxJQUFJLEtBQUosQ0FBVSx3REFBd0QsbUJBQW1CLENBQTNFLENBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBTyxJQUFJLFFBQVEsTUFBbkIsRUFBMkI7QUFDekI7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRCIsImZpbGUiOiJwYXJzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdLyksXG4gICAgICBkZWxpbWl0ZXJzID0gdW5pRGlmZi5tYXRjaCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vZykgfHwgW10sXG4gICAgICBsaXN0ID0gW10sXG4gICAgICBpID0gMDtcblxuICBmdW5jdGlvbiBwYXJzZUluZGV4KCkge1xuICAgIGxldCBpbmRleCA9IHt9O1xuICAgIGxpc3QucHVzaChpbmRleCk7XG5cbiAgICAvLyBQYXJzZSBkaWZmIG1ldGFkYXRhXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgbGV0IGxpbmUgPSBkaWZmc3RyW2ldO1xuXG4gICAgICAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxuICAgICAgaWYgKC9eKFxcLVxcLVxcLXxcXCtcXCtcXCt8QEApXFxzLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBEaWZmIGluZGV4XG4gICAgICBsZXQgaGVhZGVyID0gKC9eKD86SW5kZXg6fGRpZmYoPzogLXIgXFx3KykrKVxccysoLis/KVxccyokLykuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxuICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcblxuICAgIC8vIFBhcnNlIGh1bmtzXG4gICAgaW5kZXguaHVua3MgPSBbXTtcblxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgaWYgKC9eKEluZGV4OnxkaWZmfFxcLVxcLVxcLXxcXCtcXCtcXCspXFxzLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICgvXkBALy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGluZGV4Lmh1bmtzLnB1c2gocGFyc2VIdW5rKCkpO1xuICAgICAgfSBlbHNlIGlmIChsaW5lICYmIG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgIC8vIElnbm9yZSB1bmV4cGVjdGVkIGNvbnRlbnQgdW5sZXNzIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsaW5lICcgKyAoaSArIDEpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkobGluZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlcyB0aGUgLS0tIGFuZCArKysgaGVhZGVycywgaWYgbm9uZSBhcmUgZm91bmQsIG5vIGxpbmVzXG4gIC8vIGFyZSBjb25zdW1lZC5cbiAgZnVuY3Rpb24gcGFyc2VGaWxlSGVhZGVyKGluZGV4KSB7XG4gICAgY29uc3QgaGVhZGVyUGF0dGVybiA9IC9eKC0tLXxcXCtcXCtcXCspXFxzKyhbXFxTIF0qKSg/OlxcdCguKj8pXFxzKik/JC87XG4gICAgY29uc3QgZmlsZUhlYWRlciA9IGhlYWRlclBhdHRlcm4uZXhlYyhkaWZmc3RyW2ldKTtcbiAgICBpZiAoZmlsZUhlYWRlcikge1xuICAgICAgbGV0IGtleVByZWZpeCA9IGZpbGVIZWFkZXJbMV0gPT09ICctLS0nID8gJ29sZCcgOiAnbmV3JztcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZUhlYWRlclsyXTtcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IGZpbGVIZWFkZXJbM107XG5cbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgYSBodW5rXG4gIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYSBodW5rLlxuICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XG4gICAgbGV0IGNodW5rSGVhZGVySW5kZXggPSBpLFxuICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXG4gICAgICAgIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcZCspKD86LChcXGQrKSk/IFxcKyhcXGQrKSg/OiwoXFxkKykpPyBAQC8pO1xuXG4gICAgbGV0IGh1bmsgPSB7XG4gICAgICBvbGRTdGFydDogK2NodW5rSGVhZGVyWzFdLFxuICAgICAgb2xkTGluZXM6ICtjaHVua0hlYWRlclsyXSB8fCAxLFxuICAgICAgbmV3U3RhcnQ6ICtjaHVua0hlYWRlclszXSxcbiAgICAgIG5ld0xpbmVzOiArY2h1bmtIZWFkZXJbNF0gfHwgMSxcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIGxpbmVkZWxpbWl0ZXJzOiBbXVxuICAgIH07XG5cbiAgICBsZXQgYWRkQ291bnQgPSAwLFxuICAgICAgICByZW1vdmVDb3VudCA9IDA7XG4gICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXCJyZW1vdmUgbGluZVwiIG9wZXJhdGlvblxuICAgICAgLy8gQnV0IHRoZXkgY291bGQgYmUgdGhlIGhlYWRlciBmb3IgdGhlIG5leHQgZmlsZS4gVGhlcmVmb3JlIHBydW5lIHN1Y2ggY2FzZXMgb3V0LlxuICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwXG4gICAgICAgICAgICAmJiAoaSArIDIgPCBkaWZmc3RyLmxlbmd0aClcbiAgICAgICAgICAgICYmIGRpZmZzdHJbaSArIDFdLmluZGV4T2YoJysrKyAnKSA9PT0gMFxuICAgICAgICAgICAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IG9wZXJhdGlvbiA9IGRpZmZzdHJbaV1bMF07XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJyB8fCBvcGVyYXRpb24gPT09ICctJyB8fCBvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICBodW5rLmxpbmVzLnB1c2goZGlmZnN0cltpXSk7XG4gICAgICAgIGh1bmsubGluZWRlbGltaXRlcnMucHVzaChkZWxpbWl0ZXJzW2ldIHx8ICdcXG4nKTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgICAgcmVtb3ZlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXG4gICAgaWYgKCFhZGRDb3VudCAmJiBodW5rLm5ld0xpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm5ld0xpbmVzID0gMDtcbiAgICB9XG4gICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm9sZExpbmVzID0gMDtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgaWYgKGFkZENvdW50ICE9PSBodW5rLm5ld0xpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZUNvdW50ICE9PSBodW5rLm9sZExpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh1bms7XG4gIH1cblxuICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgcGFyc2VJbmRleCgpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG4iXX0=


/***/ },
/* 12 */
/***/ function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;

	exports["default"] = /*istanbul ignore end*/function (start, minLine, maxLine) {
	  var wantForward = true,
	      backwardExhausted = false,
	      forwardExhausted = false,
	      localOffset = 1;

	  return function iterator() {
	    if (wantForward && !forwardExhausted) {
	      if (backwardExhausted) {
	        localOffset++;
	      } else {
	        wantForward = false;
	      }

	      // Check if trying to fit beyond text length, and if not, check it fits
	      // after offset location (or desired location on first iteration)
	      if (start + localOffset <= maxLine) {
	        return localOffset;
	      }

	      forwardExhausted = true;
	    }

	    if (!backwardExhausted) {
	      if (!forwardExhausted) {
	        wantForward = true;
	      }

	      // Check if trying to fit before text beginning, and if not, check it fits
	      // before offset location
	      if (minLine <= start - localOffset) {
	        return -localOffset++;
	      }

	      backwardExhausted = true;
	      return iterator();
	    }

	    // We tried to fit hunk before text beginning and beyond text lenght, then
	    // hunk can't fit on the text. Return undefined
	  };
	};
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7NENBR2UsVUFBUyxLQUFULEVBQWdCLE9BQWhCLEVBQXlCLE9BQXpCLEVBQWtDO0FBQy9DLE1BQUksY0FBYyxJQUFsQjtBQUFBLE1BQ0ksb0JBQW9CLEtBRHhCO0FBQUEsTUFFSSxtQkFBbUIsS0FGdkI7QUFBQSxNQUdJLGNBQWMsQ0FIbEI7O0FBS0EsU0FBTyxTQUFTLFFBQVQsR0FBb0I7QUFDekIsUUFBSSxlQUFlLENBQUMsZ0JBQXBCLEVBQXNDO0FBQ3BDLFVBQUksaUJBQUosRUFBdUI7QUFDckI7QUFDRCxPQUZELE1BRU87QUFDTCxzQkFBYyxLQUFkO0FBQ0Q7Ozs7QUFJRCxVQUFJLFFBQVEsV0FBUixJQUF1QixPQUEzQixFQUFvQztBQUNsQyxlQUFPLFdBQVA7QUFDRDs7QUFFRCx5QkFBbUIsSUFBbkI7QUFDRDs7QUFFRCxRQUFJLENBQUMsaUJBQUwsRUFBd0I7QUFDdEIsVUFBSSxDQUFDLGdCQUFMLEVBQXVCO0FBQ3JCLHNCQUFjLElBQWQ7QUFDRDs7OztBQUlELFVBQUksV0FBVyxRQUFRLFdBQXZCLEVBQW9DO0FBQ2xDLGVBQU8sQ0FBQyxhQUFSO0FBQ0Q7O0FBRUQsMEJBQW9CLElBQXBCO0FBQ0EsYUFBTyxVQUFQO0FBQ0Q7Ozs7QUFJRixHQWxDRDtBQW1DRCxDIiwiZmlsZSI6ImRpc3RhbmNlLWl0ZXJhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSXRlcmF0b3IgdGhhdCB0cmF2ZXJzZXMgaW4gdGhlIHJhbmdlIG9mIFttaW4sIG1heF0sIHN0ZXBwaW5nXG4vLyBieSBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RhcnQgcG9zaXRpb24uIEkuZS4gZm9yIFswLCA0XSwgd2l0aFxuLy8gc3RhcnQgb2YgMiwgdGhpcyB3aWxsIGl0ZXJhdGUgMiwgMywgMSwgNCwgMC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XG4gIGxldCB3YW50Rm9yd2FyZCA9IHRydWUsXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgbG9jYWxPZmZzZXQgPSAxO1xuXG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG4gICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XG4gICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cbiAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gaXRlcmF0b3IoKTtcbiAgICB9XG5cbiAgICAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmdodCwgdGhlblxuICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXG4gIH07XG59XG4iXX0=


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/structuredPatch = structuredPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;
	/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;

	var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;

	/*istanbul ignore start*/
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	  if (!options) {
	    options = {};
	  }
	  if (typeof options.context === 'undefined') {
	    options.context = 4;
	  }

	  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);
	  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier

	  function contextLines(lines) {
	    return lines.map(function (entry) {
	      return ' ' + entry;
	    });
	  }

	  var hunks = [];
	  var oldRangeStart = 0,
	      newRangeStart = 0,
	      curRange = [],
	      oldLine = 1,
	      newLine = 1;
	  /*istanbul ignore start*/
	  var _loop = function _loop( /*istanbul ignore end*/i) {
	    var current = diff[i],
	        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
	    current.lines = lines;

	    if (current.added || current.removed) {
	      /*istanbul ignore start*/
	      var _curRange;

	      /*istanbul ignore end*/
	      // If we have previous context, start with that
	      if (!oldRangeStart) {
	        var prev = diff[i - 1];
	        oldRangeStart = oldLine;
	        newRangeStart = newLine;

	        if (prev) {
	          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
	          oldRangeStart -= curRange.length;
	          newRangeStart -= curRange.length;
	        }
	      }

	      // Output our changes
	      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {
	        return (current.added ? '+' : '-') + entry;
	      })));

	      // Track the updated file position
	      if (current.added) {
	        newLine += lines.length;
	      } else {
	        oldLine += lines.length;
	      }
	    } else {
	      // Identical context lines. Track line changes
	      if (oldRangeStart) {
	        // Close out any changes that have been output (or join overlapping)
	        if (lines.length <= options.context * 2 && i < diff.length - 2) {
	          /*istanbul ignore start*/
	          var _curRange2;

	          /*istanbul ignore end*/
	          // Overlapping
	          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));
	        } else {
	          /*istanbul ignore start*/
	          var _curRange3;

	          /*istanbul ignore end*/
	          // end the range and output
	          var contextSize = Math.min(lines.length, options.context);
	          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));

	          var hunk = {
	            oldStart: oldRangeStart,
	            oldLines: oldLine - oldRangeStart + contextSize,
	            newStart: newRangeStart,
	            newLines: newLine - newRangeStart + contextSize,
	            lines: curRange
	          };
	          if (i >= diff.length - 2 && lines.length <= options.context) {
	            // EOF is inside this hunk
	            var oldEOFNewline = /\n$/.test(oldStr);
	            var newEOFNewline = /\n$/.test(newStr);
	            if (lines.length == 0 && !oldEOFNewline) {
	              // special case: old has no eol and no trailing context; no-nl can end up before adds
	              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
	            } else if (!oldEOFNewline || !newEOFNewline) {
	              curRange.push('\\ No newline at end of file');
	            }
	          }
	          hunks.push(hunk);

	          oldRangeStart = 0;
	          newRangeStart = 0;
	          curRange = [];
	        }
	      }
	      oldLine += lines.length;
	      newLine += lines.length;
	    }
	  };

	  for (var i = 0; i < diff.length; i++) {
	    /*istanbul ignore start*/
	    _loop( /*istanbul ignore end*/i);
	  }

	  return {
	    oldFileName: oldFileName, newFileName: newFileName,
	    oldHeader: oldHeader, newHeader: newHeader,
	    hunks: hunks
	  };
	}

	function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);

	  var ret = [];
	  if (oldFileName == newFileName) {
	    ret.push('Index: ' + oldFileName);
	  }
	  ret.push('===================================================================');
	  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
	  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

	  for (var i = 0; i < diff.hunks.length; i++) {
	    var hunk = diff.hunks[i];
	    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
	    ret.push.apply(ret, hunk.lines);
	  }

	  return ret.join('\n') + '\n';
	}

	function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
	  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9jcmVhdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O2dDQUVnQixlLEdBQUEsZTt5REFpR0EsbUIsR0FBQSxtQjt5REF3QkEsVyxHQUFBLFc7O0FBM0hoQixJLHlCQUFBLCtCLHdCQUFBOzs7Ozt1QkFFTyxTQUFTLGVBQVQsQ0FBeUIsV0FBekIsRUFBc0MsV0FBdEMsRUFBbUQsTUFBbkQsRUFBMkQsTUFBM0QsRUFBbUUsU0FBbkUsRUFBOEUsU0FBOUUsRUFBeUYsT0FBekYsRUFBa0c7QUFDdkcsTUFBSSxDQUFDLE9BQUwsRUFBYztBQUNaLGNBQVUsRUFBVjtBQUNEO0FBQ0QsTUFBSSxPQUFPLFFBQVEsT0FBZixLQUEyQixXQUEvQixFQUE0QztBQUMxQyxZQUFRLE9BQVIsR0FBa0IsQ0FBbEI7QUFDRDs7QUFFRCxNQUFNLE8seUJBQU8sb0Isd0JBQUEsQ0FBVSxNQUFWLEVBQWtCLE1BQWxCLEVBQTBCLE9BQTFCLENBQWI7QUFDQSxPQUFLLElBQUwsQ0FBVSxFQUFDLE9BQU8sRUFBUixFQUFZLE9BQU8sRUFBbkIsRUFBVixFOztBQUVBLFdBQVMsWUFBVCxDQUFzQixLQUF0QixFQUE2QjtBQUMzQixXQUFPLE1BQU0sR0FBTixDQUFVLFVBQVMsS0FBVCxFQUFnQjtBQUFFLGFBQU8sTUFBTSxLQUFiO0FBQXFCLEtBQWpELENBQVA7QUFDRDs7QUFFRCxNQUFJLFFBQVEsRUFBWjtBQUNBLE1BQUksZ0JBQWdCLENBQXBCO0FBQUEsTUFBdUIsZ0JBQWdCLENBQXZDO0FBQUEsTUFBMEMsV0FBVyxFQUFyRDtBQUFBLE1BQ0ksVUFBVSxDQURkO0FBQUEsTUFDaUIsVUFBVSxDQUQzQjs7QUFoQnVHLDZCLHdCQWtCOUYsQ0FsQjhGO0FBbUJyRyxRQUFNLFVBQVUsS0FBSyxDQUFMLENBQWhCO0FBQUEsUUFDTSxRQUFRLFFBQVEsS0FBUixJQUFpQixRQUFRLEtBQVIsQ0FBYyxPQUFkLENBQXNCLEtBQXRCLEVBQTZCLEVBQTdCLEVBQWlDLEtBQWpDLENBQXVDLElBQXZDLENBRC9CO0FBRUEsWUFBUSxLQUFSLEdBQWdCLEtBQWhCOztBQUVBLFFBQUksUUFBUSxLQUFSLElBQWlCLFFBQVEsT0FBN0IsRUFBc0M7O0FBQUE7Ozs7QUFFcEMsVUFBSSxDQUFDLGFBQUwsRUFBb0I7QUFDbEIsWUFBTSxPQUFPLEtBQUssSUFBSSxDQUFULENBQWI7QUFDQSx3QkFBZ0IsT0FBaEI7QUFDQSx3QkFBZ0IsT0FBaEI7O0FBRUEsWUFBSSxJQUFKLEVBQVU7QUFDUixxQkFBVyxRQUFRLE9BQVIsR0FBa0IsQ0FBbEIsR0FBc0IsYUFBYSxLQUFLLEtBQUwsQ0FBVyxLQUFYLENBQWlCLENBQUMsUUFBUSxPQUExQixDQUFiLENBQXRCLEdBQXlFLEVBQXBGO0FBQ0EsMkJBQWlCLFNBQVMsTUFBMUI7QUFDQSwyQkFBaUIsU0FBUyxNQUExQjtBQUNEO0FBQ0Y7OzsrQkFHRCxhLHVCQUFBLFVBQVMsSUFBVCxDLDBCQUFBLEssd0JBQUEsQywwQkFBQSxTLHdCQUFBLEUseUJBQUEsbUIsd0JBQWtCLE1BQU0sR0FBTixDQUFVLFVBQVMsS0FBVCxFQUFnQjtBQUMxQyxlQUFPLENBQUMsUUFBUSxLQUFSLEdBQWdCLEdBQWhCLEdBQXNCLEdBQXZCLElBQThCLEtBQXJDO0FBQ0QsT0FGaUIsQ0FBbEI7OztBQUtBLFVBQUksUUFBUSxLQUFaLEVBQW1CO0FBQ2pCLG1CQUFXLE1BQU0sTUFBakI7QUFDRCxPQUZELE1BRU87QUFDTCxtQkFBVyxNQUFNLE1BQWpCO0FBQ0Q7QUFDRixLQXpCRCxNQXlCTzs7QUFFTCxVQUFJLGFBQUosRUFBbUI7O0FBRWpCLFlBQUksTUFBTSxNQUFOLElBQWdCLFFBQVEsT0FBUixHQUFrQixDQUFsQyxJQUF1QyxJQUFJLEtBQUssTUFBTCxHQUFjLENBQTdELEVBQWdFOztBQUFBOzs7O21DQUU5RCxjLHVCQUFBLFVBQVMsSUFBVCxDLDBCQUFBLEssd0JBQUEsQywwQkFBQSxVLHdCQUFBLEUseUJBQUEsbUIsd0JBQWtCLGFBQWEsS0FBYixDQUFsQjtBQUNELFNBSEQsTUFHTzs7QUFBQTs7OztBQUVMLGNBQUksY0FBYyxLQUFLLEdBQUwsQ0FBUyxNQUFNLE1BQWYsRUFBdUIsUUFBUSxPQUEvQixDQUFsQjttQ0FDQSxjLHVCQUFBLFVBQVMsSUFBVCxDLDBCQUFBLEssd0JBQUEsQywwQkFBQSxVLHdCQUFBLEUseUJBQUEsbUIsd0JBQWtCLGFBQWEsTUFBTSxLQUFOLENBQVksQ0FBWixFQUFlLFdBQWYsQ0FBYixDQUFsQjs7QUFFQSxjQUFJLE9BQU87QUFDVCxzQkFBVSxhQUREO0FBRVQsc0JBQVcsVUFBVSxhQUFWLEdBQTBCLFdBRjVCO0FBR1Qsc0JBQVUsYUFIRDtBQUlULHNCQUFXLFVBQVUsYUFBVixHQUEwQixXQUo1QjtBQUtULG1CQUFPO0FBTEUsV0FBWDtBQU9BLGNBQUksS0FBSyxLQUFLLE1BQUwsR0FBYyxDQUFuQixJQUF3QixNQUFNLE1BQU4sSUFBZ0IsUUFBUSxPQUFwRCxFQUE2RDs7QUFFM0QsZ0JBQUksZ0JBQWlCLE1BQU0sSUFBTixDQUFXLE1BQVgsQ0FBckI7QUFDQSxnQkFBSSxnQkFBaUIsTUFBTSxJQUFOLENBQVcsTUFBWCxDQUFyQjtBQUNBLGdCQUFJLE1BQU0sTUFBTixJQUFnQixDQUFoQixJQUFxQixDQUFDLGFBQTFCLEVBQXlDOztBQUV2Qyx1QkFBUyxNQUFULENBQWdCLEtBQUssUUFBckIsRUFBK0IsQ0FBL0IsRUFBa0MsOEJBQWxDO0FBQ0QsYUFIRCxNQUdPLElBQUksQ0FBQyxhQUFELElBQWtCLENBQUMsYUFBdkIsRUFBc0M7QUFDM0MsdUJBQVMsSUFBVCxDQUFjLDhCQUFkO0FBQ0Q7QUFDRjtBQUNELGdCQUFNLElBQU4sQ0FBVyxJQUFYOztBQUVBLDBCQUFnQixDQUFoQjtBQUNBLDBCQUFnQixDQUFoQjtBQUNBLHFCQUFXLEVBQVg7QUFDRDtBQUNGO0FBQ0QsaUJBQVcsTUFBTSxNQUFqQjtBQUNBLGlCQUFXLE1BQU0sTUFBakI7QUFDRDtBQXZGb0c7O0FBa0J2RyxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUF6QixFQUFpQyxHQUFqQyxFQUFzQzs7QUFBQSxVLHdCQUE3QixDQUE2QjtBQXNFckM7O0FBRUQsU0FBTztBQUNMLGlCQUFhLFdBRFIsRUFDcUIsYUFBYSxXQURsQztBQUVMLGVBQVcsU0FGTixFQUVpQixXQUFXLFNBRjVCO0FBR0wsV0FBTztBQUhGLEdBQVA7QUFLRDs7QUFFTSxTQUFTLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDLFdBQTFDLEVBQXVELE1BQXZELEVBQStELE1BQS9ELEVBQXVFLFNBQXZFLEVBQWtGLFNBQWxGLEVBQTZGLE9BQTdGLEVBQXNHO0FBQzNHLE1BQU0sT0FBTyxnQkFBZ0IsV0FBaEIsRUFBNkIsV0FBN0IsRUFBMEMsTUFBMUMsRUFBa0QsTUFBbEQsRUFBMEQsU0FBMUQsRUFBcUUsU0FBckUsRUFBZ0YsT0FBaEYsQ0FBYjs7QUFFQSxNQUFNLE1BQU0sRUFBWjtBQUNBLE1BQUksZUFBZSxXQUFuQixFQUFnQztBQUM5QixRQUFJLElBQUosQ0FBUyxZQUFZLFdBQXJCO0FBQ0Q7QUFDRCxNQUFJLElBQUosQ0FBUyxxRUFBVDtBQUNBLE1BQUksSUFBSixDQUFTLFNBQVMsS0FBSyxXQUFkLElBQTZCLE9BQU8sS0FBSyxTQUFaLEtBQTBCLFdBQTFCLEdBQXdDLEVBQXhDLEdBQTZDLE9BQU8sS0FBSyxTQUF0RixDQUFUO0FBQ0EsTUFBSSxJQUFKLENBQVMsU0FBUyxLQUFLLFdBQWQsSUFBNkIsT0FBTyxLQUFLLFNBQVosS0FBMEIsV0FBMUIsR0FBd0MsRUFBeEMsR0FBNkMsT0FBTyxLQUFLLFNBQXRGLENBQVQ7O0FBRUEsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssS0FBTCxDQUFXLE1BQS9CLEVBQXVDLEdBQXZDLEVBQTRDO0FBQzFDLFFBQU0sT0FBTyxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQWI7QUFDQSxRQUFJLElBQUosQ0FDRSxTQUFTLEtBQUssUUFBZCxHQUF5QixHQUF6QixHQUErQixLQUFLLFFBQXBDLEdBQ0UsSUFERixHQUNTLEtBQUssUUFEZCxHQUN5QixHQUR6QixHQUMrQixLQUFLLFFBRHBDLEdBRUUsS0FISjtBQUtBLFFBQUksSUFBSixDQUFTLEtBQVQsQ0FBZSxHQUFmLEVBQW9CLEtBQUssS0FBekI7QUFDRDs7QUFFRCxTQUFPLElBQUksSUFBSixDQUFTLElBQVQsSUFBaUIsSUFBeEI7QUFDRDs7QUFFTSxTQUFTLFdBQVQsQ0FBcUIsUUFBckIsRUFBK0IsTUFBL0IsRUFBdUMsTUFBdkMsRUFBK0MsU0FBL0MsRUFBMEQsU0FBMUQsRUFBcUUsT0FBckUsRUFBOEU7QUFDbkYsU0FBTyxvQkFBb0IsUUFBcEIsRUFBOEIsUUFBOUIsRUFBd0MsTUFBeEMsRUFBZ0QsTUFBaEQsRUFBd0QsU0FBeEQsRUFBbUUsU0FBbkUsRUFBOEUsT0FBOUUsQ0FBUDtBQUNEIiwiZmlsZSI6ImNyZWF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZGlmZkxpbmVzfSBmcm9tICcuLi9kaWZmL2xpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zLmNvbnRleHQgPSA0O1xuICB9XG5cbiAgY29uc3QgZGlmZiA9IGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG4gIGRpZmYucHVzaCh7dmFsdWU6ICcnLCBsaW5lczogW119KTsgICAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxuXG4gIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xuICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuICcgJyArIGVudHJ5OyB9KTtcbiAgfVxuXG4gIGxldCBodW5rcyA9IFtdO1xuICBsZXQgb2xkUmFuZ2VTdGFydCA9IDAsIG5ld1JhbmdlU3RhcnQgPSAwLCBjdXJSYW5nZSA9IFtdLFxuICAgICAgb2xkTGluZSA9IDEsIG5ld0xpbmUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50ID0gZGlmZltpXSxcbiAgICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XG5cbiAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgcHJldmlvdXMgY29udGV4dCwgc3RhcnQgd2l0aCB0aGF0XG4gICAgICBpZiAoIW9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGRpZmZbaSAtIDFdO1xuICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcbiAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBjdXJSYW5nZSA9IG9wdGlvbnMuY29udGV4dCA+IDAgPyBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtb3B0aW9ucy5jb250ZXh0KSkgOiBbXTtcbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcbiAgICAgIGN1clJhbmdlLnB1c2goLi4uIGxpbmVzLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cbiAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XG4gICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcbiAgICAgIGlmIChvbGRSYW5nZVN0YXJ0KSB7XG4gICAgICAgIC8vIENsb3NlIG91dCBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgKG9yIGpvaW4gb3ZlcmxhcHBpbmcpXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgLy8gT3ZlcmxhcHBpbmdcbiAgICAgICAgICBjdXJSYW5nZS5wdXNoKC4uLiBjb250ZXh0TGluZXMobGluZXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcbiAgICAgICAgICBsZXQgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XG4gICAgICAgICAgY3VyUmFuZ2UucHVzaCguLi4gY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpO1xuXG4gICAgICAgICAgbGV0IGh1bmsgPSB7XG4gICAgICAgICAgICBvbGRTdGFydDogb2xkUmFuZ2VTdGFydCxcbiAgICAgICAgICAgIG9sZExpbmVzOiAob2xkTGluZSAtIG9sZFJhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSksXG4gICAgICAgICAgICBuZXdTdGFydDogbmV3UmFuZ2VTdGFydCxcbiAgICAgICAgICAgIG5ld0xpbmVzOiAobmV3TGluZSAtIG5ld1JhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSksXG4gICAgICAgICAgICBsaW5lczogY3VyUmFuZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpID49IGRpZmYubGVuZ3RoIC0gMiAmJiBsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBFT0YgaXMgaW5zaWRlIHRoaXMgaHVua1xuICAgICAgICAgICAgbGV0IG9sZEVPRk5ld2xpbmUgPSAoL1xcbiQvLnRlc3Qob2xkU3RyKSk7XG4gICAgICAgICAgICBsZXQgbmV3RU9GTmV3bGluZSA9ICgvXFxuJC8udGVzdChuZXdTdHIpKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gMCAmJiAhb2xkRU9GTmV3bGluZSkge1xuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXG4gICAgICAgICAgICAgIGN1clJhbmdlLnNwbGljZShodW5rLm9sZExpbmVzLCAwLCAnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvbGRFT0ZOZXdsaW5lIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XG4gICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuXG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWU6IG5ld0ZpbGVOYW1lLFxuICAgIG9sZEhlYWRlcjogb2xkSGVhZGVyLCBuZXdIZWFkZXI6IG5ld0hlYWRlcixcbiAgICBodW5rczogaHVua3NcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGlmZiA9IHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XG5cbiAgY29uc3QgcmV0ID0gW107XG4gIGlmIChvbGRGaWxlTmFtZSA9PSBuZXdGaWxlTmFtZSkge1xuICAgIHJldC5wdXNoKCdJbmRleDogJyArIG9sZEZpbGVOYW1lKTtcbiAgfVxuICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcbiAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmLmh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaHVuayA9IGRpZmYuaHVua3NbaV07XG4gICAgcmV0LnB1c2goXG4gICAgICAnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lc1xuICAgICAgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXNcbiAgICAgICsgJyBAQCdcbiAgICApO1xuICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpICsgJ1xcbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcbn1cbiJdfQ==


/***/ },
/* 14 */
/***/ function(module, exports) {

	/*istanbul ignore start*/"use strict";

	exports.__esModule = true;
	exports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;
	// See: http://code.google.com/p/google-diff-match-patch/wiki/API
	function convertChangesToDMP(changes) {
	  var ret = [],
	      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
	      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
	  for (var i = 0; i < changes.length; i++) {
	    change = changes[i];
	    if (change.added) {
	      operation = 1;
	    } else if (change.removed) {
	      operation = -1;
	    } else {
	      operation = 0;
	    }

	    ret.push([operation, change.value]);
	  }
	  return ret;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L2RtcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Z0NBQ2dCLG1CLEdBQUEsbUI7O0FBQVQsU0FBUyxtQkFBVCxDQUE2QixPQUE3QixFQUFzQztBQUMzQyxNQUFJLE1BQU0sRUFBVjtBQUFBLE1BQ0ksUyx5QkFBQSxNLHdCQURKO0FBQUEsTUFFSSxZLHlCQUFBLE0sd0JBRko7QUFHQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUN2QyxhQUFTLFFBQVEsQ0FBUixDQUFUO0FBQ0EsUUFBSSxPQUFPLEtBQVgsRUFBa0I7QUFDaEIsa0JBQVksQ0FBWjtBQUNELEtBRkQsTUFFTyxJQUFJLE9BQU8sT0FBWCxFQUFvQjtBQUN6QixrQkFBWSxDQUFDLENBQWI7QUFDRCxLQUZNLE1BRUE7QUFDTCxrQkFBWSxDQUFaO0FBQ0Q7O0FBRUQsUUFBSSxJQUFKLENBQVMsQ0FBQyxTQUFELEVBQVksT0FBTyxLQUFuQixDQUFUO0FBQ0Q7QUFDRCxTQUFPLEdBQVA7QUFDRCIsImZpbGUiOiJkbXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9ETVAoY2hhbmdlcykge1xuICBsZXQgcmV0ID0gW10sXG4gICAgICBjaGFuZ2UsXG4gICAgICBvcGVyYXRpb247XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgb3BlcmF0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19


/***/ },
/* 15 */
/***/ function(module, exports) {

	/*istanbul ignore start*/'use strict';

	exports.__esModule = true;
	exports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;
	function convertChangesToXML(changes) {
	  var ret = [];
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i];
	    if (change.added) {
	      ret.push('<ins>');
	    } else if (change.removed) {
	      ret.push('<del>');
	    }

	    ret.push(escapeHTML(change.value));

	    if (change.added) {
	      ret.push('</ins>');
	    } else if (change.removed) {
	      ret.push('</del>');
	    }
	  }
	  return ret.join('');
	}

	function escapeHTML(s) {
	  var n = s;
	  n = n.replace(/&/g, '&amp;');
	  n = n.replace(/</g, '&lt;');
	  n = n.replace(/>/g, '&gt;');
	  n = n.replace(/"/g, '&quot;');

	  return n;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L3htbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Z0NBQWdCLG1CLEdBQUEsbUI7QUFBVCxTQUFTLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDO0FBQzNDLE1BQUksTUFBTSxFQUFWO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDdkMsUUFBSSxTQUFTLFFBQVEsQ0FBUixDQUFiO0FBQ0EsUUFBSSxPQUFPLEtBQVgsRUFBa0I7QUFDaEIsVUFBSSxJQUFKLENBQVMsT0FBVDtBQUNELEtBRkQsTUFFTyxJQUFJLE9BQU8sT0FBWCxFQUFvQjtBQUN6QixVQUFJLElBQUosQ0FBUyxPQUFUO0FBQ0Q7O0FBRUQsUUFBSSxJQUFKLENBQVMsV0FBVyxPQUFPLEtBQWxCLENBQVQ7O0FBRUEsUUFBSSxPQUFPLEtBQVgsRUFBa0I7QUFDaEIsVUFBSSxJQUFKLENBQVMsUUFBVDtBQUNELEtBRkQsTUFFTyxJQUFJLE9BQU8sT0FBWCxFQUFvQjtBQUN6QixVQUFJLElBQUosQ0FBUyxRQUFUO0FBQ0Q7QUFDRjtBQUNELFNBQU8sSUFBSSxJQUFKLENBQVMsRUFBVCxDQUFQO0FBQ0Q7O0FBRUQsU0FBUyxVQUFULENBQW9CLENBQXBCLEVBQXVCO0FBQ3JCLE1BQUksSUFBSSxDQUFSO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE9BQWhCLENBQUo7QUFDQSxNQUFJLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsTUFBaEIsQ0FBSjtBQUNBLE1BQUksRUFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixNQUFoQixDQUFKO0FBQ0EsTUFBSSxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLFFBQWhCLENBQUo7O0FBRUEsU0FBTyxDQUFQO0FBQ0QiLCJmaWxlIjoieG1sLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICBsZXQgcmV0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xuICAgIH1cblxuICAgIHJldC5wdXNoKGVzY2FwZUhUTUwoY2hhbmdlLnZhbHVlKSk7XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgbGV0IG4gPSBzO1xuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuXG4gIHJldHVybiBuO1xufVxuIl19


/***/ }
/******/ ])
});
;
/*! markdown-it 12.3.2 https://github.com/markdown-it/markdown-it @license MIT */
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define('markdown-it',factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, 
  global.markdownit = factory());
})(this, (function() {
  "use strict";
  function createCommonjsModule(fn, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function(path, base) {
        return commonjsRequire(path, base === undefined || base === null ? module.path : base);
      }
    }, fn(module, module.exports), module.exports;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var a = Object.defineProperty({}, "__esModule", {
      value: true
    });
    Object.keys(n).forEach((function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    }));
    return a;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var require$$0 = {
    Aacute: "\xc1",
    aacute: "\xe1",
    Abreve: "\u0102",
    abreve: "\u0103",
    ac: "\u223e",
    acd: "\u223f",
    acE: "\u223e\u0333",
    Acirc: "\xc2",
    acirc: "\xe2",
    acute: "\xb4",
    Acy: "\u0410",
    acy: "\u0430",
    AElig: "\xc6",
    aelig: "\xe6",
    af: "\u2061",
    Afr: "\ud835\udd04",
    afr: "\ud835\udd1e",
    Agrave: "\xc0",
    agrave: "\xe0",
    alefsym: "\u2135",
    aleph: "\u2135",
    Alpha: "\u0391",
    alpha: "\u03b1",
    Amacr: "\u0100",
    amacr: "\u0101",
    amalg: "\u2a3f",
    amp: "&",
    AMP: "&",
    andand: "\u2a55",
    And: "\u2a53",
    and: "\u2227",
    andd: "\u2a5c",
    andslope: "\u2a58",
    andv: "\u2a5a",
    ang: "\u2220",
    ange: "\u29a4",
    angle: "\u2220",
    angmsdaa: "\u29a8",
    angmsdab: "\u29a9",
    angmsdac: "\u29aa",
    angmsdad: "\u29ab",
    angmsdae: "\u29ac",
    angmsdaf: "\u29ad",
    angmsdag: "\u29ae",
    angmsdah: "\u29af",
    angmsd: "\u2221",
    angrt: "\u221f",
    angrtvb: "\u22be",
    angrtvbd: "\u299d",
    angsph: "\u2222",
    angst: "\xc5",
    angzarr: "\u237c",
    Aogon: "\u0104",
    aogon: "\u0105",
    Aopf: "\ud835\udd38",
    aopf: "\ud835\udd52",
    apacir: "\u2a6f",
    ap: "\u2248",
    apE: "\u2a70",
    ape: "\u224a",
    apid: "\u224b",
    apos: "'",
    ApplyFunction: "\u2061",
    approx: "\u2248",
    approxeq: "\u224a",
    Aring: "\xc5",
    aring: "\xe5",
    Ascr: "\ud835\udc9c",
    ascr: "\ud835\udcb6",
    Assign: "\u2254",
    ast: "*",
    asymp: "\u2248",
    asympeq: "\u224d",
    Atilde: "\xc3",
    atilde: "\xe3",
    Auml: "\xc4",
    auml: "\xe4",
    awconint: "\u2233",
    awint: "\u2a11",
    backcong: "\u224c",
    backepsilon: "\u03f6",
    backprime: "\u2035",
    backsim: "\u223d",
    backsimeq: "\u22cd",
    Backslash: "\u2216",
    Barv: "\u2ae7",
    barvee: "\u22bd",
    barwed: "\u2305",
    Barwed: "\u2306",
    barwedge: "\u2305",
    bbrk: "\u23b5",
    bbrktbrk: "\u23b6",
    bcong: "\u224c",
    Bcy: "\u0411",
    bcy: "\u0431",
    bdquo: "\u201e",
    becaus: "\u2235",
    because: "\u2235",
    Because: "\u2235",
    bemptyv: "\u29b0",
    bepsi: "\u03f6",
    bernou: "\u212c",
    Bernoullis: "\u212c",
    Beta: "\u0392",
    beta: "\u03b2",
    beth: "\u2136",
    between: "\u226c",
    Bfr: "\ud835\udd05",
    bfr: "\ud835\udd1f",
    bigcap: "\u22c2",
    bigcirc: "\u25ef",
    bigcup: "\u22c3",
    bigodot: "\u2a00",
    bigoplus: "\u2a01",
    bigotimes: "\u2a02",
    bigsqcup: "\u2a06",
    bigstar: "\u2605",
    bigtriangledown: "\u25bd",
    bigtriangleup: "\u25b3",
    biguplus: "\u2a04",
    bigvee: "\u22c1",
    bigwedge: "\u22c0",
    bkarow: "\u290d",
    blacklozenge: "\u29eb",
    blacksquare: "\u25aa",
    blacktriangle: "\u25b4",
    blacktriangledown: "\u25be",
    blacktriangleleft: "\u25c2",
    blacktriangleright: "\u25b8",
    blank: "\u2423",
    blk12: "\u2592",
    blk14: "\u2591",
    blk34: "\u2593",
    block: "\u2588",
    bne: "=\u20e5",
    bnequiv: "\u2261\u20e5",
    bNot: "\u2aed",
    bnot: "\u2310",
    Bopf: "\ud835\udd39",
    bopf: "\ud835\udd53",
    bot: "\u22a5",
    bottom: "\u22a5",
    bowtie: "\u22c8",
    boxbox: "\u29c9",
    boxdl: "\u2510",
    boxdL: "\u2555",
    boxDl: "\u2556",
    boxDL: "\u2557",
    boxdr: "\u250c",
    boxdR: "\u2552",
    boxDr: "\u2553",
    boxDR: "\u2554",
    boxh: "\u2500",
    boxH: "\u2550",
    boxhd: "\u252c",
    boxHd: "\u2564",
    boxhD: "\u2565",
    boxHD: "\u2566",
    boxhu: "\u2534",
    boxHu: "\u2567",
    boxhU: "\u2568",
    boxHU: "\u2569",
    boxminus: "\u229f",
    boxplus: "\u229e",
    boxtimes: "\u22a0",
    boxul: "\u2518",
    boxuL: "\u255b",
    boxUl: "\u255c",
    boxUL: "\u255d",
    boxur: "\u2514",
    boxuR: "\u2558",
    boxUr: "\u2559",
    boxUR: "\u255a",
    boxv: "\u2502",
    boxV: "\u2551",
    boxvh: "\u253c",
    boxvH: "\u256a",
    boxVh: "\u256b",
    boxVH: "\u256c",
    boxvl: "\u2524",
    boxvL: "\u2561",
    boxVl: "\u2562",
    boxVL: "\u2563",
    boxvr: "\u251c",
    boxvR: "\u255e",
    boxVr: "\u255f",
    boxVR: "\u2560",
    bprime: "\u2035",
    breve: "\u02d8",
    Breve: "\u02d8",
    brvbar: "\xa6",
    bscr: "\ud835\udcb7",
    Bscr: "\u212c",
    bsemi: "\u204f",
    bsim: "\u223d",
    bsime: "\u22cd",
    bsolb: "\u29c5",
    bsol: "\\",
    bsolhsub: "\u27c8",
    bull: "\u2022",
    bullet: "\u2022",
    bump: "\u224e",
    bumpE: "\u2aae",
    bumpe: "\u224f",
    Bumpeq: "\u224e",
    bumpeq: "\u224f",
    Cacute: "\u0106",
    cacute: "\u0107",
    capand: "\u2a44",
    capbrcup: "\u2a49",
    capcap: "\u2a4b",
    cap: "\u2229",
    Cap: "\u22d2",
    capcup: "\u2a47",
    capdot: "\u2a40",
    CapitalDifferentialD: "\u2145",
    caps: "\u2229\ufe00",
    caret: "\u2041",
    caron: "\u02c7",
    Cayleys: "\u212d",
    ccaps: "\u2a4d",
    Ccaron: "\u010c",
    ccaron: "\u010d",
    Ccedil: "\xc7",
    ccedil: "\xe7",
    Ccirc: "\u0108",
    ccirc: "\u0109",
    Cconint: "\u2230",
    ccups: "\u2a4c",
    ccupssm: "\u2a50",
    Cdot: "\u010a",
    cdot: "\u010b",
    cedil: "\xb8",
    Cedilla: "\xb8",
    cemptyv: "\u29b2",
    cent: "\xa2",
    centerdot: "\xb7",
    CenterDot: "\xb7",
    cfr: "\ud835\udd20",
    Cfr: "\u212d",
    CHcy: "\u0427",
    chcy: "\u0447",
    check: "\u2713",
    checkmark: "\u2713",
    Chi: "\u03a7",
    chi: "\u03c7",
    circ: "\u02c6",
    circeq: "\u2257",
    circlearrowleft: "\u21ba",
    circlearrowright: "\u21bb",
    circledast: "\u229b",
    circledcirc: "\u229a",
    circleddash: "\u229d",
    CircleDot: "\u2299",
    circledR: "\xae",
    circledS: "\u24c8",
    CircleMinus: "\u2296",
    CirclePlus: "\u2295",
    CircleTimes: "\u2297",
    cir: "\u25cb",
    cirE: "\u29c3",
    cire: "\u2257",
    cirfnint: "\u2a10",
    cirmid: "\u2aef",
    cirscir: "\u29c2",
    ClockwiseContourIntegral: "\u2232",
    CloseCurlyDoubleQuote: "\u201d",
    CloseCurlyQuote: "\u2019",
    clubs: "\u2663",
    clubsuit: "\u2663",
    colon: ":",
    Colon: "\u2237",
    Colone: "\u2a74",
    colone: "\u2254",
    coloneq: "\u2254",
    comma: ",",
    commat: "@",
    comp: "\u2201",
    compfn: "\u2218",
    complement: "\u2201",
    complexes: "\u2102",
    cong: "\u2245",
    congdot: "\u2a6d",
    Congruent: "\u2261",
    conint: "\u222e",
    Conint: "\u222f",
    ContourIntegral: "\u222e",
    copf: "\ud835\udd54",
    Copf: "\u2102",
    coprod: "\u2210",
    Coproduct: "\u2210",
    copy: "\xa9",
    COPY: "\xa9",
    copysr: "\u2117",
    CounterClockwiseContourIntegral: "\u2233",
    crarr: "\u21b5",
    cross: "\u2717",
    Cross: "\u2a2f",
    Cscr: "\ud835\udc9e",
    cscr: "\ud835\udcb8",
    csub: "\u2acf",
    csube: "\u2ad1",
    csup: "\u2ad0",
    csupe: "\u2ad2",
    ctdot: "\u22ef",
    cudarrl: "\u2938",
    cudarrr: "\u2935",
    cuepr: "\u22de",
    cuesc: "\u22df",
    cularr: "\u21b6",
    cularrp: "\u293d",
    cupbrcap: "\u2a48",
    cupcap: "\u2a46",
    CupCap: "\u224d",
    cup: "\u222a",
    Cup: "\u22d3",
    cupcup: "\u2a4a",
    cupdot: "\u228d",
    cupor: "\u2a45",
    cups: "\u222a\ufe00",
    curarr: "\u21b7",
    curarrm: "\u293c",
    curlyeqprec: "\u22de",
    curlyeqsucc: "\u22df",
    curlyvee: "\u22ce",
    curlywedge: "\u22cf",
    curren: "\xa4",
    curvearrowleft: "\u21b6",
    curvearrowright: "\u21b7",
    cuvee: "\u22ce",
    cuwed: "\u22cf",
    cwconint: "\u2232",
    cwint: "\u2231",
    cylcty: "\u232d",
    dagger: "\u2020",
    Dagger: "\u2021",
    daleth: "\u2138",
    darr: "\u2193",
    Darr: "\u21a1",
    dArr: "\u21d3",
    dash: "\u2010",
    Dashv: "\u2ae4",
    dashv: "\u22a3",
    dbkarow: "\u290f",
    dblac: "\u02dd",
    Dcaron: "\u010e",
    dcaron: "\u010f",
    Dcy: "\u0414",
    dcy: "\u0434",
    ddagger: "\u2021",
    ddarr: "\u21ca",
    DD: "\u2145",
    dd: "\u2146",
    DDotrahd: "\u2911",
    ddotseq: "\u2a77",
    deg: "\xb0",
    Del: "\u2207",
    Delta: "\u0394",
    delta: "\u03b4",
    demptyv: "\u29b1",
    dfisht: "\u297f",
    Dfr: "\ud835\udd07",
    dfr: "\ud835\udd21",
    dHar: "\u2965",
    dharl: "\u21c3",
    dharr: "\u21c2",
    DiacriticalAcute: "\xb4",
    DiacriticalDot: "\u02d9",
    DiacriticalDoubleAcute: "\u02dd",
    DiacriticalGrave: "`",
    DiacriticalTilde: "\u02dc",
    diam: "\u22c4",
    diamond: "\u22c4",
    Diamond: "\u22c4",
    diamondsuit: "\u2666",
    diams: "\u2666",
    die: "\xa8",
    DifferentialD: "\u2146",
    digamma: "\u03dd",
    disin: "\u22f2",
    div: "\xf7",
    divide: "\xf7",
    divideontimes: "\u22c7",
    divonx: "\u22c7",
    DJcy: "\u0402",
    djcy: "\u0452",
    dlcorn: "\u231e",
    dlcrop: "\u230d",
    dollar: "$",
    Dopf: "\ud835\udd3b",
    dopf: "\ud835\udd55",
    Dot: "\xa8",
    dot: "\u02d9",
    DotDot: "\u20dc",
    doteq: "\u2250",
    doteqdot: "\u2251",
    DotEqual: "\u2250",
    dotminus: "\u2238",
    dotplus: "\u2214",
    dotsquare: "\u22a1",
    doublebarwedge: "\u2306",
    DoubleContourIntegral: "\u222f",
    DoubleDot: "\xa8",
    DoubleDownArrow: "\u21d3",
    DoubleLeftArrow: "\u21d0",
    DoubleLeftRightArrow: "\u21d4",
    DoubleLeftTee: "\u2ae4",
    DoubleLongLeftArrow: "\u27f8",
    DoubleLongLeftRightArrow: "\u27fa",
    DoubleLongRightArrow: "\u27f9",
    DoubleRightArrow: "\u21d2",
    DoubleRightTee: "\u22a8",
    DoubleUpArrow: "\u21d1",
    DoubleUpDownArrow: "\u21d5",
    DoubleVerticalBar: "\u2225",
    DownArrowBar: "\u2913",
    downarrow: "\u2193",
    DownArrow: "\u2193",
    Downarrow: "\u21d3",
    DownArrowUpArrow: "\u21f5",
    DownBreve: "\u0311",
    downdownarrows: "\u21ca",
    downharpoonleft: "\u21c3",
    downharpoonright: "\u21c2",
    DownLeftRightVector: "\u2950",
    DownLeftTeeVector: "\u295e",
    DownLeftVectorBar: "\u2956",
    DownLeftVector: "\u21bd",
    DownRightTeeVector: "\u295f",
    DownRightVectorBar: "\u2957",
    DownRightVector: "\u21c1",
    DownTeeArrow: "\u21a7",
    DownTee: "\u22a4",
    drbkarow: "\u2910",
    drcorn: "\u231f",
    drcrop: "\u230c",
    Dscr: "\ud835\udc9f",
    dscr: "\ud835\udcb9",
    DScy: "\u0405",
    dscy: "\u0455",
    dsol: "\u29f6",
    Dstrok: "\u0110",
    dstrok: "\u0111",
    dtdot: "\u22f1",
    dtri: "\u25bf",
    dtrif: "\u25be",
    duarr: "\u21f5",
    duhar: "\u296f",
    dwangle: "\u29a6",
    DZcy: "\u040f",
    dzcy: "\u045f",
    dzigrarr: "\u27ff",
    Eacute: "\xc9",
    eacute: "\xe9",
    easter: "\u2a6e",
    Ecaron: "\u011a",
    ecaron: "\u011b",
    Ecirc: "\xca",
    ecirc: "\xea",
    ecir: "\u2256",
    ecolon: "\u2255",
    Ecy: "\u042d",
    ecy: "\u044d",
    eDDot: "\u2a77",
    Edot: "\u0116",
    edot: "\u0117",
    eDot: "\u2251",
    ee: "\u2147",
    efDot: "\u2252",
    Efr: "\ud835\udd08",
    efr: "\ud835\udd22",
    eg: "\u2a9a",
    Egrave: "\xc8",
    egrave: "\xe8",
    egs: "\u2a96",
    egsdot: "\u2a98",
    el: "\u2a99",
    Element: "\u2208",
    elinters: "\u23e7",
    ell: "\u2113",
    els: "\u2a95",
    elsdot: "\u2a97",
    Emacr: "\u0112",
    emacr: "\u0113",
    empty: "\u2205",
    emptyset: "\u2205",
    EmptySmallSquare: "\u25fb",
    emptyv: "\u2205",
    EmptyVerySmallSquare: "\u25ab",
    emsp13: "\u2004",
    emsp14: "\u2005",
    emsp: "\u2003",
    ENG: "\u014a",
    eng: "\u014b",
    ensp: "\u2002",
    Eogon: "\u0118",
    eogon: "\u0119",
    Eopf: "\ud835\udd3c",
    eopf: "\ud835\udd56",
    epar: "\u22d5",
    eparsl: "\u29e3",
    eplus: "\u2a71",
    epsi: "\u03b5",
    Epsilon: "\u0395",
    epsilon: "\u03b5",
    epsiv: "\u03f5",
    eqcirc: "\u2256",
    eqcolon: "\u2255",
    eqsim: "\u2242",
    eqslantgtr: "\u2a96",
    eqslantless: "\u2a95",
    Equal: "\u2a75",
    equals: "=",
    EqualTilde: "\u2242",
    equest: "\u225f",
    Equilibrium: "\u21cc",
    equiv: "\u2261",
    equivDD: "\u2a78",
    eqvparsl: "\u29e5",
    erarr: "\u2971",
    erDot: "\u2253",
    escr: "\u212f",
    Escr: "\u2130",
    esdot: "\u2250",
    Esim: "\u2a73",
    esim: "\u2242",
    Eta: "\u0397",
    eta: "\u03b7",
    ETH: "\xd0",
    eth: "\xf0",
    Euml: "\xcb",
    euml: "\xeb",
    euro: "\u20ac",
    excl: "!",
    exist: "\u2203",
    Exists: "\u2203",
    expectation: "\u2130",
    exponentiale: "\u2147",
    ExponentialE: "\u2147",
    fallingdotseq: "\u2252",
    Fcy: "\u0424",
    fcy: "\u0444",
    female: "\u2640",
    ffilig: "\ufb03",
    fflig: "\ufb00",
    ffllig: "\ufb04",
    Ffr: "\ud835\udd09",
    ffr: "\ud835\udd23",
    filig: "\ufb01",
    FilledSmallSquare: "\u25fc",
    FilledVerySmallSquare: "\u25aa",
    fjlig: "fj",
    flat: "\u266d",
    fllig: "\ufb02",
    fltns: "\u25b1",
    fnof: "\u0192",
    Fopf: "\ud835\udd3d",
    fopf: "\ud835\udd57",
    forall: "\u2200",
    ForAll: "\u2200",
    fork: "\u22d4",
    forkv: "\u2ad9",
    Fouriertrf: "\u2131",
    fpartint: "\u2a0d",
    frac12: "\xbd",
    frac13: "\u2153",
    frac14: "\xbc",
    frac15: "\u2155",
    frac16: "\u2159",
    frac18: "\u215b",
    frac23: "\u2154",
    frac25: "\u2156",
    frac34: "\xbe",
    frac35: "\u2157",
    frac38: "\u215c",
    frac45: "\u2158",
    frac56: "\u215a",
    frac58: "\u215d",
    frac78: "\u215e",
    frasl: "\u2044",
    frown: "\u2322",
    fscr: "\ud835\udcbb",
    Fscr: "\u2131",
    gacute: "\u01f5",
    Gamma: "\u0393",
    gamma: "\u03b3",
    Gammad: "\u03dc",
    gammad: "\u03dd",
    gap: "\u2a86",
    Gbreve: "\u011e",
    gbreve: "\u011f",
    Gcedil: "\u0122",
    Gcirc: "\u011c",
    gcirc: "\u011d",
    Gcy: "\u0413",
    gcy: "\u0433",
    Gdot: "\u0120",
    gdot: "\u0121",
    ge: "\u2265",
    gE: "\u2267",
    gEl: "\u2a8c",
    gel: "\u22db",
    geq: "\u2265",
    geqq: "\u2267",
    geqslant: "\u2a7e",
    gescc: "\u2aa9",
    ges: "\u2a7e",
    gesdot: "\u2a80",
    gesdoto: "\u2a82",
    gesdotol: "\u2a84",
    gesl: "\u22db\ufe00",
    gesles: "\u2a94",
    Gfr: "\ud835\udd0a",
    gfr: "\ud835\udd24",
    gg: "\u226b",
    Gg: "\u22d9",
    ggg: "\u22d9",
    gimel: "\u2137",
    GJcy: "\u0403",
    gjcy: "\u0453",
    gla: "\u2aa5",
    gl: "\u2277",
    glE: "\u2a92",
    glj: "\u2aa4",
    gnap: "\u2a8a",
    gnapprox: "\u2a8a",
    gne: "\u2a88",
    gnE: "\u2269",
    gneq: "\u2a88",
    gneqq: "\u2269",
    gnsim: "\u22e7",
    Gopf: "\ud835\udd3e",
    gopf: "\ud835\udd58",
    grave: "`",
    GreaterEqual: "\u2265",
    GreaterEqualLess: "\u22db",
    GreaterFullEqual: "\u2267",
    GreaterGreater: "\u2aa2",
    GreaterLess: "\u2277",
    GreaterSlantEqual: "\u2a7e",
    GreaterTilde: "\u2273",
    Gscr: "\ud835\udca2",
    gscr: "\u210a",
    gsim: "\u2273",
    gsime: "\u2a8e",
    gsiml: "\u2a90",
    gtcc: "\u2aa7",
    gtcir: "\u2a7a",
    gt: ">",
    GT: ">",
    Gt: "\u226b",
    gtdot: "\u22d7",
    gtlPar: "\u2995",
    gtquest: "\u2a7c",
    gtrapprox: "\u2a86",
    gtrarr: "\u2978",
    gtrdot: "\u22d7",
    gtreqless: "\u22db",
    gtreqqless: "\u2a8c",
    gtrless: "\u2277",
    gtrsim: "\u2273",
    gvertneqq: "\u2269\ufe00",
    gvnE: "\u2269\ufe00",
    Hacek: "\u02c7",
    hairsp: "\u200a",
    half: "\xbd",
    hamilt: "\u210b",
    HARDcy: "\u042a",
    hardcy: "\u044a",
    harrcir: "\u2948",
    harr: "\u2194",
    hArr: "\u21d4",
    harrw: "\u21ad",
    Hat: "^",
    hbar: "\u210f",
    Hcirc: "\u0124",
    hcirc: "\u0125",
    hearts: "\u2665",
    heartsuit: "\u2665",
    hellip: "\u2026",
    hercon: "\u22b9",
    hfr: "\ud835\udd25",
    Hfr: "\u210c",
    HilbertSpace: "\u210b",
    hksearow: "\u2925",
    hkswarow: "\u2926",
    hoarr: "\u21ff",
    homtht: "\u223b",
    hookleftarrow: "\u21a9",
    hookrightarrow: "\u21aa",
    hopf: "\ud835\udd59",
    Hopf: "\u210d",
    horbar: "\u2015",
    HorizontalLine: "\u2500",
    hscr: "\ud835\udcbd",
    Hscr: "\u210b",
    hslash: "\u210f",
    Hstrok: "\u0126",
    hstrok: "\u0127",
    HumpDownHump: "\u224e",
    HumpEqual: "\u224f",
    hybull: "\u2043",
    hyphen: "\u2010",
    Iacute: "\xcd",
    iacute: "\xed",
    ic: "\u2063",
    Icirc: "\xce",
    icirc: "\xee",
    Icy: "\u0418",
    icy: "\u0438",
    Idot: "\u0130",
    IEcy: "\u0415",
    iecy: "\u0435",
    iexcl: "\xa1",
    iff: "\u21d4",
    ifr: "\ud835\udd26",
    Ifr: "\u2111",
    Igrave: "\xcc",
    igrave: "\xec",
    ii: "\u2148",
    iiiint: "\u2a0c",
    iiint: "\u222d",
    iinfin: "\u29dc",
    iiota: "\u2129",
    IJlig: "\u0132",
    ijlig: "\u0133",
    Imacr: "\u012a",
    imacr: "\u012b",
    image: "\u2111",
    ImaginaryI: "\u2148",
    imagline: "\u2110",
    imagpart: "\u2111",
    imath: "\u0131",
    Im: "\u2111",
    imof: "\u22b7",
    imped: "\u01b5",
    Implies: "\u21d2",
    incare: "\u2105",
    in: "\u2208",
    infin: "\u221e",
    infintie: "\u29dd",
    inodot: "\u0131",
    intcal: "\u22ba",
    int: "\u222b",
    Int: "\u222c",
    integers: "\u2124",
    Integral: "\u222b",
    intercal: "\u22ba",
    Intersection: "\u22c2",
    intlarhk: "\u2a17",
    intprod: "\u2a3c",
    InvisibleComma: "\u2063",
    InvisibleTimes: "\u2062",
    IOcy: "\u0401",
    iocy: "\u0451",
    Iogon: "\u012e",
    iogon: "\u012f",
    Iopf: "\ud835\udd40",
    iopf: "\ud835\udd5a",
    Iota: "\u0399",
    iota: "\u03b9",
    iprod: "\u2a3c",
    iquest: "\xbf",
    iscr: "\ud835\udcbe",
    Iscr: "\u2110",
    isin: "\u2208",
    isindot: "\u22f5",
    isinE: "\u22f9",
    isins: "\u22f4",
    isinsv: "\u22f3",
    isinv: "\u2208",
    it: "\u2062",
    Itilde: "\u0128",
    itilde: "\u0129",
    Iukcy: "\u0406",
    iukcy: "\u0456",
    Iuml: "\xcf",
    iuml: "\xef",
    Jcirc: "\u0134",
    jcirc: "\u0135",
    Jcy: "\u0419",
    jcy: "\u0439",
    Jfr: "\ud835\udd0d",
    jfr: "\ud835\udd27",
    jmath: "\u0237",
    Jopf: "\ud835\udd41",
    jopf: "\ud835\udd5b",
    Jscr: "\ud835\udca5",
    jscr: "\ud835\udcbf",
    Jsercy: "\u0408",
    jsercy: "\u0458",
    Jukcy: "\u0404",
    jukcy: "\u0454",
    Kappa: "\u039a",
    kappa: "\u03ba",
    kappav: "\u03f0",
    Kcedil: "\u0136",
    kcedil: "\u0137",
    Kcy: "\u041a",
    kcy: "\u043a",
    Kfr: "\ud835\udd0e",
    kfr: "\ud835\udd28",
    kgreen: "\u0138",
    KHcy: "\u0425",
    khcy: "\u0445",
    KJcy: "\u040c",
    kjcy: "\u045c",
    Kopf: "\ud835\udd42",
    kopf: "\ud835\udd5c",
    Kscr: "\ud835\udca6",
    kscr: "\ud835\udcc0",
    lAarr: "\u21da",
    Lacute: "\u0139",
    lacute: "\u013a",
    laemptyv: "\u29b4",
    lagran: "\u2112",
    Lambda: "\u039b",
    lambda: "\u03bb",
    lang: "\u27e8",
    Lang: "\u27ea",
    langd: "\u2991",
    langle: "\u27e8",
    lap: "\u2a85",
    Laplacetrf: "\u2112",
    laquo: "\xab",
    larrb: "\u21e4",
    larrbfs: "\u291f",
    larr: "\u2190",
    Larr: "\u219e",
    lArr: "\u21d0",
    larrfs: "\u291d",
    larrhk: "\u21a9",
    larrlp: "\u21ab",
    larrpl: "\u2939",
    larrsim: "\u2973",
    larrtl: "\u21a2",
    latail: "\u2919",
    lAtail: "\u291b",
    lat: "\u2aab",
    late: "\u2aad",
    lates: "\u2aad\ufe00",
    lbarr: "\u290c",
    lBarr: "\u290e",
    lbbrk: "\u2772",
    lbrace: "{",
    lbrack: "[",
    lbrke: "\u298b",
    lbrksld: "\u298f",
    lbrkslu: "\u298d",
    Lcaron: "\u013d",
    lcaron: "\u013e",
    Lcedil: "\u013b",
    lcedil: "\u013c",
    lceil: "\u2308",
    lcub: "{",
    Lcy: "\u041b",
    lcy: "\u043b",
    ldca: "\u2936",
    ldquo: "\u201c",
    ldquor: "\u201e",
    ldrdhar: "\u2967",
    ldrushar: "\u294b",
    ldsh: "\u21b2",
    le: "\u2264",
    lE: "\u2266",
    LeftAngleBracket: "\u27e8",
    LeftArrowBar: "\u21e4",
    leftarrow: "\u2190",
    LeftArrow: "\u2190",
    Leftarrow: "\u21d0",
    LeftArrowRightArrow: "\u21c6",
    leftarrowtail: "\u21a2",
    LeftCeiling: "\u2308",
    LeftDoubleBracket: "\u27e6",
    LeftDownTeeVector: "\u2961",
    LeftDownVectorBar: "\u2959",
    LeftDownVector: "\u21c3",
    LeftFloor: "\u230a",
    leftharpoondown: "\u21bd",
    leftharpoonup: "\u21bc",
    leftleftarrows: "\u21c7",
    leftrightarrow: "\u2194",
    LeftRightArrow: "\u2194",
    Leftrightarrow: "\u21d4",
    leftrightarrows: "\u21c6",
    leftrightharpoons: "\u21cb",
    leftrightsquigarrow: "\u21ad",
    LeftRightVector: "\u294e",
    LeftTeeArrow: "\u21a4",
    LeftTee: "\u22a3",
    LeftTeeVector: "\u295a",
    leftthreetimes: "\u22cb",
    LeftTriangleBar: "\u29cf",
    LeftTriangle: "\u22b2",
    LeftTriangleEqual: "\u22b4",
    LeftUpDownVector: "\u2951",
    LeftUpTeeVector: "\u2960",
    LeftUpVectorBar: "\u2958",
    LeftUpVector: "\u21bf",
    LeftVectorBar: "\u2952",
    LeftVector: "\u21bc",
    lEg: "\u2a8b",
    leg: "\u22da",
    leq: "\u2264",
    leqq: "\u2266",
    leqslant: "\u2a7d",
    lescc: "\u2aa8",
    les: "\u2a7d",
    lesdot: "\u2a7f",
    lesdoto: "\u2a81",
    lesdotor: "\u2a83",
    lesg: "\u22da\ufe00",
    lesges: "\u2a93",
    lessapprox: "\u2a85",
    lessdot: "\u22d6",
    lesseqgtr: "\u22da",
    lesseqqgtr: "\u2a8b",
    LessEqualGreater: "\u22da",
    LessFullEqual: "\u2266",
    LessGreater: "\u2276",
    lessgtr: "\u2276",
    LessLess: "\u2aa1",
    lesssim: "\u2272",
    LessSlantEqual: "\u2a7d",
    LessTilde: "\u2272",
    lfisht: "\u297c",
    lfloor: "\u230a",
    Lfr: "\ud835\udd0f",
    lfr: "\ud835\udd29",
    lg: "\u2276",
    lgE: "\u2a91",
    lHar: "\u2962",
    lhard: "\u21bd",
    lharu: "\u21bc",
    lharul: "\u296a",
    lhblk: "\u2584",
    LJcy: "\u0409",
    ljcy: "\u0459",
    llarr: "\u21c7",
    ll: "\u226a",
    Ll: "\u22d8",
    llcorner: "\u231e",
    Lleftarrow: "\u21da",
    llhard: "\u296b",
    lltri: "\u25fa",
    Lmidot: "\u013f",
    lmidot: "\u0140",
    lmoustache: "\u23b0",
    lmoust: "\u23b0",
    lnap: "\u2a89",
    lnapprox: "\u2a89",
    lne: "\u2a87",
    lnE: "\u2268",
    lneq: "\u2a87",
    lneqq: "\u2268",
    lnsim: "\u22e6",
    loang: "\u27ec",
    loarr: "\u21fd",
    lobrk: "\u27e6",
    longleftarrow: "\u27f5",
    LongLeftArrow: "\u27f5",
    Longleftarrow: "\u27f8",
    longleftrightarrow: "\u27f7",
    LongLeftRightArrow: "\u27f7",
    Longleftrightarrow: "\u27fa",
    longmapsto: "\u27fc",
    longrightarrow: "\u27f6",
    LongRightArrow: "\u27f6",
    Longrightarrow: "\u27f9",
    looparrowleft: "\u21ab",
    looparrowright: "\u21ac",
    lopar: "\u2985",
    Lopf: "\ud835\udd43",
    lopf: "\ud835\udd5d",
    loplus: "\u2a2d",
    lotimes: "\u2a34",
    lowast: "\u2217",
    lowbar: "_",
    LowerLeftArrow: "\u2199",
    LowerRightArrow: "\u2198",
    loz: "\u25ca",
    lozenge: "\u25ca",
    lozf: "\u29eb",
    lpar: "(",
    lparlt: "\u2993",
    lrarr: "\u21c6",
    lrcorner: "\u231f",
    lrhar: "\u21cb",
    lrhard: "\u296d",
    lrm: "\u200e",
    lrtri: "\u22bf",
    lsaquo: "\u2039",
    lscr: "\ud835\udcc1",
    Lscr: "\u2112",
    lsh: "\u21b0",
    Lsh: "\u21b0",
    lsim: "\u2272",
    lsime: "\u2a8d",
    lsimg: "\u2a8f",
    lsqb: "[",
    lsquo: "\u2018",
    lsquor: "\u201a",
    Lstrok: "\u0141",
    lstrok: "\u0142",
    ltcc: "\u2aa6",
    ltcir: "\u2a79",
    lt: "<",
    LT: "<",
    Lt: "\u226a",
    ltdot: "\u22d6",
    lthree: "\u22cb",
    ltimes: "\u22c9",
    ltlarr: "\u2976",
    ltquest: "\u2a7b",
    ltri: "\u25c3",
    ltrie: "\u22b4",
    ltrif: "\u25c2",
    ltrPar: "\u2996",
    lurdshar: "\u294a",
    luruhar: "\u2966",
    lvertneqq: "\u2268\ufe00",
    lvnE: "\u2268\ufe00",
    macr: "\xaf",
    male: "\u2642",
    malt: "\u2720",
    maltese: "\u2720",
    Map: "\u2905",
    map: "\u21a6",
    mapsto: "\u21a6",
    mapstodown: "\u21a7",
    mapstoleft: "\u21a4",
    mapstoup: "\u21a5",
    marker: "\u25ae",
    mcomma: "\u2a29",
    Mcy: "\u041c",
    mcy: "\u043c",
    mdash: "\u2014",
    mDDot: "\u223a",
    measuredangle: "\u2221",
    MediumSpace: "\u205f",
    Mellintrf: "\u2133",
    Mfr: "\ud835\udd10",
    mfr: "\ud835\udd2a",
    mho: "\u2127",
    micro: "\xb5",
    midast: "*",
    midcir: "\u2af0",
    mid: "\u2223",
    middot: "\xb7",
    minusb: "\u229f",
    minus: "\u2212",
    minusd: "\u2238",
    minusdu: "\u2a2a",
    MinusPlus: "\u2213",
    mlcp: "\u2adb",
    mldr: "\u2026",
    mnplus: "\u2213",
    models: "\u22a7",
    Mopf: "\ud835\udd44",
    mopf: "\ud835\udd5e",
    mp: "\u2213",
    mscr: "\ud835\udcc2",
    Mscr: "\u2133",
    mstpos: "\u223e",
    Mu: "\u039c",
    mu: "\u03bc",
    multimap: "\u22b8",
    mumap: "\u22b8",
    nabla: "\u2207",
    Nacute: "\u0143",
    nacute: "\u0144",
    nang: "\u2220\u20d2",
    nap: "\u2249",
    napE: "\u2a70\u0338",
    napid: "\u224b\u0338",
    napos: "\u0149",
    napprox: "\u2249",
    natural: "\u266e",
    naturals: "\u2115",
    natur: "\u266e",
    nbsp: "\xa0",
    nbump: "\u224e\u0338",
    nbumpe: "\u224f\u0338",
    ncap: "\u2a43",
    Ncaron: "\u0147",
    ncaron: "\u0148",
    Ncedil: "\u0145",
    ncedil: "\u0146",
    ncong: "\u2247",
    ncongdot: "\u2a6d\u0338",
    ncup: "\u2a42",
    Ncy: "\u041d",
    ncy: "\u043d",
    ndash: "\u2013",
    nearhk: "\u2924",
    nearr: "\u2197",
    neArr: "\u21d7",
    nearrow: "\u2197",
    ne: "\u2260",
    nedot: "\u2250\u0338",
    NegativeMediumSpace: "\u200b",
    NegativeThickSpace: "\u200b",
    NegativeThinSpace: "\u200b",
    NegativeVeryThinSpace: "\u200b",
    nequiv: "\u2262",
    nesear: "\u2928",
    nesim: "\u2242\u0338",
    NestedGreaterGreater: "\u226b",
    NestedLessLess: "\u226a",
    NewLine: "\n",
    nexist: "\u2204",
    nexists: "\u2204",
    Nfr: "\ud835\udd11",
    nfr: "\ud835\udd2b",
    ngE: "\u2267\u0338",
    nge: "\u2271",
    ngeq: "\u2271",
    ngeqq: "\u2267\u0338",
    ngeqslant: "\u2a7e\u0338",
    nges: "\u2a7e\u0338",
    nGg: "\u22d9\u0338",
    ngsim: "\u2275",
    nGt: "\u226b\u20d2",
    ngt: "\u226f",
    ngtr: "\u226f",
    nGtv: "\u226b\u0338",
    nharr: "\u21ae",
    nhArr: "\u21ce",
    nhpar: "\u2af2",
    ni: "\u220b",
    nis: "\u22fc",
    nisd: "\u22fa",
    niv: "\u220b",
    NJcy: "\u040a",
    njcy: "\u045a",
    nlarr: "\u219a",
    nlArr: "\u21cd",
    nldr: "\u2025",
    nlE: "\u2266\u0338",
    nle: "\u2270",
    nleftarrow: "\u219a",
    nLeftarrow: "\u21cd",
    nleftrightarrow: "\u21ae",
    nLeftrightarrow: "\u21ce",
    nleq: "\u2270",
    nleqq: "\u2266\u0338",
    nleqslant: "\u2a7d\u0338",
    nles: "\u2a7d\u0338",
    nless: "\u226e",
    nLl: "\u22d8\u0338",
    nlsim: "\u2274",
    nLt: "\u226a\u20d2",
    nlt: "\u226e",
    nltri: "\u22ea",
    nltrie: "\u22ec",
    nLtv: "\u226a\u0338",
    nmid: "\u2224",
    NoBreak: "\u2060",
    NonBreakingSpace: "\xa0",
    nopf: "\ud835\udd5f",
    Nopf: "\u2115",
    Not: "\u2aec",
    not: "\xac",
    NotCongruent: "\u2262",
    NotCupCap: "\u226d",
    NotDoubleVerticalBar: "\u2226",
    NotElement: "\u2209",
    NotEqual: "\u2260",
    NotEqualTilde: "\u2242\u0338",
    NotExists: "\u2204",
    NotGreater: "\u226f",
    NotGreaterEqual: "\u2271",
    NotGreaterFullEqual: "\u2267\u0338",
    NotGreaterGreater: "\u226b\u0338",
    NotGreaterLess: "\u2279",
    NotGreaterSlantEqual: "\u2a7e\u0338",
    NotGreaterTilde: "\u2275",
    NotHumpDownHump: "\u224e\u0338",
    NotHumpEqual: "\u224f\u0338",
    notin: "\u2209",
    notindot: "\u22f5\u0338",
    notinE: "\u22f9\u0338",
    notinva: "\u2209",
    notinvb: "\u22f7",
    notinvc: "\u22f6",
    NotLeftTriangleBar: "\u29cf\u0338",
    NotLeftTriangle: "\u22ea",
    NotLeftTriangleEqual: "\u22ec",
    NotLess: "\u226e",
    NotLessEqual: "\u2270",
    NotLessGreater: "\u2278",
    NotLessLess: "\u226a\u0338",
    NotLessSlantEqual: "\u2a7d\u0338",
    NotLessTilde: "\u2274",
    NotNestedGreaterGreater: "\u2aa2\u0338",
    NotNestedLessLess: "\u2aa1\u0338",
    notni: "\u220c",
    notniva: "\u220c",
    notnivb: "\u22fe",
    notnivc: "\u22fd",
    NotPrecedes: "\u2280",
    NotPrecedesEqual: "\u2aaf\u0338",
    NotPrecedesSlantEqual: "\u22e0",
    NotReverseElement: "\u220c",
    NotRightTriangleBar: "\u29d0\u0338",
    NotRightTriangle: "\u22eb",
    NotRightTriangleEqual: "\u22ed",
    NotSquareSubset: "\u228f\u0338",
    NotSquareSubsetEqual: "\u22e2",
    NotSquareSuperset: "\u2290\u0338",
    NotSquareSupersetEqual: "\u22e3",
    NotSubset: "\u2282\u20d2",
    NotSubsetEqual: "\u2288",
    NotSucceeds: "\u2281",
    NotSucceedsEqual: "\u2ab0\u0338",
    NotSucceedsSlantEqual: "\u22e1",
    NotSucceedsTilde: "\u227f\u0338",
    NotSuperset: "\u2283\u20d2",
    NotSupersetEqual: "\u2289",
    NotTilde: "\u2241",
    NotTildeEqual: "\u2244",
    NotTildeFullEqual: "\u2247",
    NotTildeTilde: "\u2249",
    NotVerticalBar: "\u2224",
    nparallel: "\u2226",
    npar: "\u2226",
    nparsl: "\u2afd\u20e5",
    npart: "\u2202\u0338",
    npolint: "\u2a14",
    npr: "\u2280",
    nprcue: "\u22e0",
    nprec: "\u2280",
    npreceq: "\u2aaf\u0338",
    npre: "\u2aaf\u0338",
    nrarrc: "\u2933\u0338",
    nrarr: "\u219b",
    nrArr: "\u21cf",
    nrarrw: "\u219d\u0338",
    nrightarrow: "\u219b",
    nRightarrow: "\u21cf",
    nrtri: "\u22eb",
    nrtrie: "\u22ed",
    nsc: "\u2281",
    nsccue: "\u22e1",
    nsce: "\u2ab0\u0338",
    Nscr: "\ud835\udca9",
    nscr: "\ud835\udcc3",
    nshortmid: "\u2224",
    nshortparallel: "\u2226",
    nsim: "\u2241",
    nsime: "\u2244",
    nsimeq: "\u2244",
    nsmid: "\u2224",
    nspar: "\u2226",
    nsqsube: "\u22e2",
    nsqsupe: "\u22e3",
    nsub: "\u2284",
    nsubE: "\u2ac5\u0338",
    nsube: "\u2288",
    nsubset: "\u2282\u20d2",
    nsubseteq: "\u2288",
    nsubseteqq: "\u2ac5\u0338",
    nsucc: "\u2281",
    nsucceq: "\u2ab0\u0338",
    nsup: "\u2285",
    nsupE: "\u2ac6\u0338",
    nsupe: "\u2289",
    nsupset: "\u2283\u20d2",
    nsupseteq: "\u2289",
    nsupseteqq: "\u2ac6\u0338",
    ntgl: "\u2279",
    Ntilde: "\xd1",
    ntilde: "\xf1",
    ntlg: "\u2278",
    ntriangleleft: "\u22ea",
    ntrianglelefteq: "\u22ec",
    ntriangleright: "\u22eb",
    ntrianglerighteq: "\u22ed",
    Nu: "\u039d",
    nu: "\u03bd",
    num: "#",
    numero: "\u2116",
    numsp: "\u2007",
    nvap: "\u224d\u20d2",
    nvdash: "\u22ac",
    nvDash: "\u22ad",
    nVdash: "\u22ae",
    nVDash: "\u22af",
    nvge: "\u2265\u20d2",
    nvgt: ">\u20d2",
    nvHarr: "\u2904",
    nvinfin: "\u29de",
    nvlArr: "\u2902",
    nvle: "\u2264\u20d2",
    nvlt: "<\u20d2",
    nvltrie: "\u22b4\u20d2",
    nvrArr: "\u2903",
    nvrtrie: "\u22b5\u20d2",
    nvsim: "\u223c\u20d2",
    nwarhk: "\u2923",
    nwarr: "\u2196",
    nwArr: "\u21d6",
    nwarrow: "\u2196",
    nwnear: "\u2927",
    Oacute: "\xd3",
    oacute: "\xf3",
    oast: "\u229b",
    Ocirc: "\xd4",
    ocirc: "\xf4",
    ocir: "\u229a",
    Ocy: "\u041e",
    ocy: "\u043e",
    odash: "\u229d",
    Odblac: "\u0150",
    odblac: "\u0151",
    odiv: "\u2a38",
    odot: "\u2299",
    odsold: "\u29bc",
    OElig: "\u0152",
    oelig: "\u0153",
    ofcir: "\u29bf",
    Ofr: "\ud835\udd12",
    ofr: "\ud835\udd2c",
    ogon: "\u02db",
    Ograve: "\xd2",
    ograve: "\xf2",
    ogt: "\u29c1",
    ohbar: "\u29b5",
    ohm: "\u03a9",
    oint: "\u222e",
    olarr: "\u21ba",
    olcir: "\u29be",
    olcross: "\u29bb",
    oline: "\u203e",
    olt: "\u29c0",
    Omacr: "\u014c",
    omacr: "\u014d",
    Omega: "\u03a9",
    omega: "\u03c9",
    Omicron: "\u039f",
    omicron: "\u03bf",
    omid: "\u29b6",
    ominus: "\u2296",
    Oopf: "\ud835\udd46",
    oopf: "\ud835\udd60",
    opar: "\u29b7",
    OpenCurlyDoubleQuote: "\u201c",
    OpenCurlyQuote: "\u2018",
    operp: "\u29b9",
    oplus: "\u2295",
    orarr: "\u21bb",
    Or: "\u2a54",
    or: "\u2228",
    ord: "\u2a5d",
    order: "\u2134",
    orderof: "\u2134",
    ordf: "\xaa",
    ordm: "\xba",
    origof: "\u22b6",
    oror: "\u2a56",
    orslope: "\u2a57",
    orv: "\u2a5b",
    oS: "\u24c8",
    Oscr: "\ud835\udcaa",
    oscr: "\u2134",
    Oslash: "\xd8",
    oslash: "\xf8",
    osol: "\u2298",
    Otilde: "\xd5",
    otilde: "\xf5",
    otimesas: "\u2a36",
    Otimes: "\u2a37",
    otimes: "\u2297",
    Ouml: "\xd6",
    ouml: "\xf6",
    ovbar: "\u233d",
    OverBar: "\u203e",
    OverBrace: "\u23de",
    OverBracket: "\u23b4",
    OverParenthesis: "\u23dc",
    para: "\xb6",
    parallel: "\u2225",
    par: "\u2225",
    parsim: "\u2af3",
    parsl: "\u2afd",
    part: "\u2202",
    PartialD: "\u2202",
    Pcy: "\u041f",
    pcy: "\u043f",
    percnt: "%",
    period: ".",
    permil: "\u2030",
    perp: "\u22a5",
    pertenk: "\u2031",
    Pfr: "\ud835\udd13",
    pfr: "\ud835\udd2d",
    Phi: "\u03a6",
    phi: "\u03c6",
    phiv: "\u03d5",
    phmmat: "\u2133",
    phone: "\u260e",
    Pi: "\u03a0",
    pi: "\u03c0",
    pitchfork: "\u22d4",
    piv: "\u03d6",
    planck: "\u210f",
    planckh: "\u210e",
    plankv: "\u210f",
    plusacir: "\u2a23",
    plusb: "\u229e",
    pluscir: "\u2a22",
    plus: "+",
    plusdo: "\u2214",
    plusdu: "\u2a25",
    pluse: "\u2a72",
    PlusMinus: "\xb1",
    plusmn: "\xb1",
    plussim: "\u2a26",
    plustwo: "\u2a27",
    pm: "\xb1",
    Poincareplane: "\u210c",
    pointint: "\u2a15",
    popf: "\ud835\udd61",
    Popf: "\u2119",
    pound: "\xa3",
    prap: "\u2ab7",
    Pr: "\u2abb",
    pr: "\u227a",
    prcue: "\u227c",
    precapprox: "\u2ab7",
    prec: "\u227a",
    preccurlyeq: "\u227c",
    Precedes: "\u227a",
    PrecedesEqual: "\u2aaf",
    PrecedesSlantEqual: "\u227c",
    PrecedesTilde: "\u227e",
    preceq: "\u2aaf",
    precnapprox: "\u2ab9",
    precneqq: "\u2ab5",
    precnsim: "\u22e8",
    pre: "\u2aaf",
    prE: "\u2ab3",
    precsim: "\u227e",
    prime: "\u2032",
    Prime: "\u2033",
    primes: "\u2119",
    prnap: "\u2ab9",
    prnE: "\u2ab5",
    prnsim: "\u22e8",
    prod: "\u220f",
    Product: "\u220f",
    profalar: "\u232e",
    profline: "\u2312",
    profsurf: "\u2313",
    prop: "\u221d",
    Proportional: "\u221d",
    Proportion: "\u2237",
    propto: "\u221d",
    prsim: "\u227e",
    prurel: "\u22b0",
    Pscr: "\ud835\udcab",
    pscr: "\ud835\udcc5",
    Psi: "\u03a8",
    psi: "\u03c8",
    puncsp: "\u2008",
    Qfr: "\ud835\udd14",
    qfr: "\ud835\udd2e",
    qint: "\u2a0c",
    qopf: "\ud835\udd62",
    Qopf: "\u211a",
    qprime: "\u2057",
    Qscr: "\ud835\udcac",
    qscr: "\ud835\udcc6",
    quaternions: "\u210d",
    quatint: "\u2a16",
    quest: "?",
    questeq: "\u225f",
    quot: '"',
    QUOT: '"',
    rAarr: "\u21db",
    race: "\u223d\u0331",
    Racute: "\u0154",
    racute: "\u0155",
    radic: "\u221a",
    raemptyv: "\u29b3",
    rang: "\u27e9",
    Rang: "\u27eb",
    rangd: "\u2992",
    range: "\u29a5",
    rangle: "\u27e9",
    raquo: "\xbb",
    rarrap: "\u2975",
    rarrb: "\u21e5",
    rarrbfs: "\u2920",
    rarrc: "\u2933",
    rarr: "\u2192",
    Rarr: "\u21a0",
    rArr: "\u21d2",
    rarrfs: "\u291e",
    rarrhk: "\u21aa",
    rarrlp: "\u21ac",
    rarrpl: "\u2945",
    rarrsim: "\u2974",
    Rarrtl: "\u2916",
    rarrtl: "\u21a3",
    rarrw: "\u219d",
    ratail: "\u291a",
    rAtail: "\u291c",
    ratio: "\u2236",
    rationals: "\u211a",
    rbarr: "\u290d",
    rBarr: "\u290f",
    RBarr: "\u2910",
    rbbrk: "\u2773",
    rbrace: "}",
    rbrack: "]",
    rbrke: "\u298c",
    rbrksld: "\u298e",
    rbrkslu: "\u2990",
    Rcaron: "\u0158",
    rcaron: "\u0159",
    Rcedil: "\u0156",
    rcedil: "\u0157",
    rceil: "\u2309",
    rcub: "}",
    Rcy: "\u0420",
    rcy: "\u0440",
    rdca: "\u2937",
    rdldhar: "\u2969",
    rdquo: "\u201d",
    rdquor: "\u201d",
    rdsh: "\u21b3",
    real: "\u211c",
    realine: "\u211b",
    realpart: "\u211c",
    reals: "\u211d",
    Re: "\u211c",
    rect: "\u25ad",
    reg: "\xae",
    REG: "\xae",
    ReverseElement: "\u220b",
    ReverseEquilibrium: "\u21cb",
    ReverseUpEquilibrium: "\u296f",
    rfisht: "\u297d",
    rfloor: "\u230b",
    rfr: "\ud835\udd2f",
    Rfr: "\u211c",
    rHar: "\u2964",
    rhard: "\u21c1",
    rharu: "\u21c0",
    rharul: "\u296c",
    Rho: "\u03a1",
    rho: "\u03c1",
    rhov: "\u03f1",
    RightAngleBracket: "\u27e9",
    RightArrowBar: "\u21e5",
    rightarrow: "\u2192",
    RightArrow: "\u2192",
    Rightarrow: "\u21d2",
    RightArrowLeftArrow: "\u21c4",
    rightarrowtail: "\u21a3",
    RightCeiling: "\u2309",
    RightDoubleBracket: "\u27e7",
    RightDownTeeVector: "\u295d",
    RightDownVectorBar: "\u2955",
    RightDownVector: "\u21c2",
    RightFloor: "\u230b",
    rightharpoondown: "\u21c1",
    rightharpoonup: "\u21c0",
    rightleftarrows: "\u21c4",
    rightleftharpoons: "\u21cc",
    rightrightarrows: "\u21c9",
    rightsquigarrow: "\u219d",
    RightTeeArrow: "\u21a6",
    RightTee: "\u22a2",
    RightTeeVector: "\u295b",
    rightthreetimes: "\u22cc",
    RightTriangleBar: "\u29d0",
    RightTriangle: "\u22b3",
    RightTriangleEqual: "\u22b5",
    RightUpDownVector: "\u294f",
    RightUpTeeVector: "\u295c",
    RightUpVectorBar: "\u2954",
    RightUpVector: "\u21be",
    RightVectorBar: "\u2953",
    RightVector: "\u21c0",
    ring: "\u02da",
    risingdotseq: "\u2253",
    rlarr: "\u21c4",
    rlhar: "\u21cc",
    rlm: "\u200f",
    rmoustache: "\u23b1",
    rmoust: "\u23b1",
    rnmid: "\u2aee",
    roang: "\u27ed",
    roarr: "\u21fe",
    robrk: "\u27e7",
    ropar: "\u2986",
    ropf: "\ud835\udd63",
    Ropf: "\u211d",
    roplus: "\u2a2e",
    rotimes: "\u2a35",
    RoundImplies: "\u2970",
    rpar: ")",
    rpargt: "\u2994",
    rppolint: "\u2a12",
    rrarr: "\u21c9",
    Rrightarrow: "\u21db",
    rsaquo: "\u203a",
    rscr: "\ud835\udcc7",
    Rscr: "\u211b",
    rsh: "\u21b1",
    Rsh: "\u21b1",
    rsqb: "]",
    rsquo: "\u2019",
    rsquor: "\u2019",
    rthree: "\u22cc",
    rtimes: "\u22ca",
    rtri: "\u25b9",
    rtrie: "\u22b5",
    rtrif: "\u25b8",
    rtriltri: "\u29ce",
    RuleDelayed: "\u29f4",
    ruluhar: "\u2968",
    rx: "\u211e",
    Sacute: "\u015a",
    sacute: "\u015b",
    sbquo: "\u201a",
    scap: "\u2ab8",
    Scaron: "\u0160",
    scaron: "\u0161",
    Sc: "\u2abc",
    sc: "\u227b",
    sccue: "\u227d",
    sce: "\u2ab0",
    scE: "\u2ab4",
    Scedil: "\u015e",
    scedil: "\u015f",
    Scirc: "\u015c",
    scirc: "\u015d",
    scnap: "\u2aba",
    scnE: "\u2ab6",
    scnsim: "\u22e9",
    scpolint: "\u2a13",
    scsim: "\u227f",
    Scy: "\u0421",
    scy: "\u0441",
    sdotb: "\u22a1",
    sdot: "\u22c5",
    sdote: "\u2a66",
    searhk: "\u2925",
    searr: "\u2198",
    seArr: "\u21d8",
    searrow: "\u2198",
    sect: "\xa7",
    semi: ";",
    seswar: "\u2929",
    setminus: "\u2216",
    setmn: "\u2216",
    sext: "\u2736",
    Sfr: "\ud835\udd16",
    sfr: "\ud835\udd30",
    sfrown: "\u2322",
    sharp: "\u266f",
    SHCHcy: "\u0429",
    shchcy: "\u0449",
    SHcy: "\u0428",
    shcy: "\u0448",
    ShortDownArrow: "\u2193",
    ShortLeftArrow: "\u2190",
    shortmid: "\u2223",
    shortparallel: "\u2225",
    ShortRightArrow: "\u2192",
    ShortUpArrow: "\u2191",
    shy: "\xad",
    Sigma: "\u03a3",
    sigma: "\u03c3",
    sigmaf: "\u03c2",
    sigmav: "\u03c2",
    sim: "\u223c",
    simdot: "\u2a6a",
    sime: "\u2243",
    simeq: "\u2243",
    simg: "\u2a9e",
    simgE: "\u2aa0",
    siml: "\u2a9d",
    simlE: "\u2a9f",
    simne: "\u2246",
    simplus: "\u2a24",
    simrarr: "\u2972",
    slarr: "\u2190",
    SmallCircle: "\u2218",
    smallsetminus: "\u2216",
    smashp: "\u2a33",
    smeparsl: "\u29e4",
    smid: "\u2223",
    smile: "\u2323",
    smt: "\u2aaa",
    smte: "\u2aac",
    smtes: "\u2aac\ufe00",
    SOFTcy: "\u042c",
    softcy: "\u044c",
    solbar: "\u233f",
    solb: "\u29c4",
    sol: "/",
    Sopf: "\ud835\udd4a",
    sopf: "\ud835\udd64",
    spades: "\u2660",
    spadesuit: "\u2660",
    spar: "\u2225",
    sqcap: "\u2293",
    sqcaps: "\u2293\ufe00",
    sqcup: "\u2294",
    sqcups: "\u2294\ufe00",
    Sqrt: "\u221a",
    sqsub: "\u228f",
    sqsube: "\u2291",
    sqsubset: "\u228f",
    sqsubseteq: "\u2291",
    sqsup: "\u2290",
    sqsupe: "\u2292",
    sqsupset: "\u2290",
    sqsupseteq: "\u2292",
    square: "\u25a1",
    Square: "\u25a1",
    SquareIntersection: "\u2293",
    SquareSubset: "\u228f",
    SquareSubsetEqual: "\u2291",
    SquareSuperset: "\u2290",
    SquareSupersetEqual: "\u2292",
    SquareUnion: "\u2294",
    squarf: "\u25aa",
    squ: "\u25a1",
    squf: "\u25aa",
    srarr: "\u2192",
    Sscr: "\ud835\udcae",
    sscr: "\ud835\udcc8",
    ssetmn: "\u2216",
    ssmile: "\u2323",
    sstarf: "\u22c6",
    Star: "\u22c6",
    star: "\u2606",
    starf: "\u2605",
    straightepsilon: "\u03f5",
    straightphi: "\u03d5",
    strns: "\xaf",
    sub: "\u2282",
    Sub: "\u22d0",
    subdot: "\u2abd",
    subE: "\u2ac5",
    sube: "\u2286",
    subedot: "\u2ac3",
    submult: "\u2ac1",
    subnE: "\u2acb",
    subne: "\u228a",
    subplus: "\u2abf",
    subrarr: "\u2979",
    subset: "\u2282",
    Subset: "\u22d0",
    subseteq: "\u2286",
    subseteqq: "\u2ac5",
    SubsetEqual: "\u2286",
    subsetneq: "\u228a",
    subsetneqq: "\u2acb",
    subsim: "\u2ac7",
    subsub: "\u2ad5",
    subsup: "\u2ad3",
    succapprox: "\u2ab8",
    succ: "\u227b",
    succcurlyeq: "\u227d",
    Succeeds: "\u227b",
    SucceedsEqual: "\u2ab0",
    SucceedsSlantEqual: "\u227d",
    SucceedsTilde: "\u227f",
    succeq: "\u2ab0",
    succnapprox: "\u2aba",
    succneqq: "\u2ab6",
    succnsim: "\u22e9",
    succsim: "\u227f",
    SuchThat: "\u220b",
    sum: "\u2211",
    Sum: "\u2211",
    sung: "\u266a",
    sup1: "\xb9",
    sup2: "\xb2",
    sup3: "\xb3",
    sup: "\u2283",
    Sup: "\u22d1",
    supdot: "\u2abe",
    supdsub: "\u2ad8",
    supE: "\u2ac6",
    supe: "\u2287",
    supedot: "\u2ac4",
    Superset: "\u2283",
    SupersetEqual: "\u2287",
    suphsol: "\u27c9",
    suphsub: "\u2ad7",
    suplarr: "\u297b",
    supmult: "\u2ac2",
    supnE: "\u2acc",
    supne: "\u228b",
    supplus: "\u2ac0",
    supset: "\u2283",
    Supset: "\u22d1",
    supseteq: "\u2287",
    supseteqq: "\u2ac6",
    supsetneq: "\u228b",
    supsetneqq: "\u2acc",
    supsim: "\u2ac8",
    supsub: "\u2ad4",
    supsup: "\u2ad6",
    swarhk: "\u2926",
    swarr: "\u2199",
    swArr: "\u21d9",
    swarrow: "\u2199",
    swnwar: "\u292a",
    szlig: "\xdf",
    Tab: "\t",
    target: "\u2316",
    Tau: "\u03a4",
    tau: "\u03c4",
    tbrk: "\u23b4",
    Tcaron: "\u0164",
    tcaron: "\u0165",
    Tcedil: "\u0162",
    tcedil: "\u0163",
    Tcy: "\u0422",
    tcy: "\u0442",
    tdot: "\u20db",
    telrec: "\u2315",
    Tfr: "\ud835\udd17",
    tfr: "\ud835\udd31",
    there4: "\u2234",
    therefore: "\u2234",
    Therefore: "\u2234",
    Theta: "\u0398",
    theta: "\u03b8",
    thetasym: "\u03d1",
    thetav: "\u03d1",
    thickapprox: "\u2248",
    thicksim: "\u223c",
    ThickSpace: "\u205f\u200a",
    ThinSpace: "\u2009",
    thinsp: "\u2009",
    thkap: "\u2248",
    thksim: "\u223c",
    THORN: "\xde",
    thorn: "\xfe",
    tilde: "\u02dc",
    Tilde: "\u223c",
    TildeEqual: "\u2243",
    TildeFullEqual: "\u2245",
    TildeTilde: "\u2248",
    timesbar: "\u2a31",
    timesb: "\u22a0",
    times: "\xd7",
    timesd: "\u2a30",
    tint: "\u222d",
    toea: "\u2928",
    topbot: "\u2336",
    topcir: "\u2af1",
    top: "\u22a4",
    Topf: "\ud835\udd4b",
    topf: "\ud835\udd65",
    topfork: "\u2ada",
    tosa: "\u2929",
    tprime: "\u2034",
    trade: "\u2122",
    TRADE: "\u2122",
    triangle: "\u25b5",
    triangledown: "\u25bf",
    triangleleft: "\u25c3",
    trianglelefteq: "\u22b4",
    triangleq: "\u225c",
    triangleright: "\u25b9",
    trianglerighteq: "\u22b5",
    tridot: "\u25ec",
    trie: "\u225c",
    triminus: "\u2a3a",
    TripleDot: "\u20db",
    triplus: "\u2a39",
    trisb: "\u29cd",
    tritime: "\u2a3b",
    trpezium: "\u23e2",
    Tscr: "\ud835\udcaf",
    tscr: "\ud835\udcc9",
    TScy: "\u0426",
    tscy: "\u0446",
    TSHcy: "\u040b",
    tshcy: "\u045b",
    Tstrok: "\u0166",
    tstrok: "\u0167",
    twixt: "\u226c",
    twoheadleftarrow: "\u219e",
    twoheadrightarrow: "\u21a0",
    Uacute: "\xda",
    uacute: "\xfa",
    uarr: "\u2191",
    Uarr: "\u219f",
    uArr: "\u21d1",
    Uarrocir: "\u2949",
    Ubrcy: "\u040e",
    ubrcy: "\u045e",
    Ubreve: "\u016c",
    ubreve: "\u016d",
    Ucirc: "\xdb",
    ucirc: "\xfb",
    Ucy: "\u0423",
    ucy: "\u0443",
    udarr: "\u21c5",
    Udblac: "\u0170",
    udblac: "\u0171",
    udhar: "\u296e",
    ufisht: "\u297e",
    Ufr: "\ud835\udd18",
    ufr: "\ud835\udd32",
    Ugrave: "\xd9",
    ugrave: "\xf9",
    uHar: "\u2963",
    uharl: "\u21bf",
    uharr: "\u21be",
    uhblk: "\u2580",
    ulcorn: "\u231c",
    ulcorner: "\u231c",
    ulcrop: "\u230f",
    ultri: "\u25f8",
    Umacr: "\u016a",
    umacr: "\u016b",
    uml: "\xa8",
    UnderBar: "_",
    UnderBrace: "\u23df",
    UnderBracket: "\u23b5",
    UnderParenthesis: "\u23dd",
    Union: "\u22c3",
    UnionPlus: "\u228e",
    Uogon: "\u0172",
    uogon: "\u0173",
    Uopf: "\ud835\udd4c",
    uopf: "\ud835\udd66",
    UpArrowBar: "\u2912",
    uparrow: "\u2191",
    UpArrow: "\u2191",
    Uparrow: "\u21d1",
    UpArrowDownArrow: "\u21c5",
    updownarrow: "\u2195",
    UpDownArrow: "\u2195",
    Updownarrow: "\u21d5",
    UpEquilibrium: "\u296e",
    upharpoonleft: "\u21bf",
    upharpoonright: "\u21be",
    uplus: "\u228e",
    UpperLeftArrow: "\u2196",
    UpperRightArrow: "\u2197",
    upsi: "\u03c5",
    Upsi: "\u03d2",
    upsih: "\u03d2",
    Upsilon: "\u03a5",
    upsilon: "\u03c5",
    UpTeeArrow: "\u21a5",
    UpTee: "\u22a5",
    upuparrows: "\u21c8",
    urcorn: "\u231d",
    urcorner: "\u231d",
    urcrop: "\u230e",
    Uring: "\u016e",
    uring: "\u016f",
    urtri: "\u25f9",
    Uscr: "\ud835\udcb0",
    uscr: "\ud835\udcca",
    utdot: "\u22f0",
    Utilde: "\u0168",
    utilde: "\u0169",
    utri: "\u25b5",
    utrif: "\u25b4",
    uuarr: "\u21c8",
    Uuml: "\xdc",
    uuml: "\xfc",
    uwangle: "\u29a7",
    vangrt: "\u299c",
    varepsilon: "\u03f5",
    varkappa: "\u03f0",
    varnothing: "\u2205",
    varphi: "\u03d5",
    varpi: "\u03d6",
    varpropto: "\u221d",
    varr: "\u2195",
    vArr: "\u21d5",
    varrho: "\u03f1",
    varsigma: "\u03c2",
    varsubsetneq: "\u228a\ufe00",
    varsubsetneqq: "\u2acb\ufe00",
    varsupsetneq: "\u228b\ufe00",
    varsupsetneqq: "\u2acc\ufe00",
    vartheta: "\u03d1",
    vartriangleleft: "\u22b2",
    vartriangleright: "\u22b3",
    vBar: "\u2ae8",
    Vbar: "\u2aeb",
    vBarv: "\u2ae9",
    Vcy: "\u0412",
    vcy: "\u0432",
    vdash: "\u22a2",
    vDash: "\u22a8",
    Vdash: "\u22a9",
    VDash: "\u22ab",
    Vdashl: "\u2ae6",
    veebar: "\u22bb",
    vee: "\u2228",
    Vee: "\u22c1",
    veeeq: "\u225a",
    vellip: "\u22ee",
    verbar: "|",
    Verbar: "\u2016",
    vert: "|",
    Vert: "\u2016",
    VerticalBar: "\u2223",
    VerticalLine: "|",
    VerticalSeparator: "\u2758",
    VerticalTilde: "\u2240",
    VeryThinSpace: "\u200a",
    Vfr: "\ud835\udd19",
    vfr: "\ud835\udd33",
    vltri: "\u22b2",
    vnsub: "\u2282\u20d2",
    vnsup: "\u2283\u20d2",
    Vopf: "\ud835\udd4d",
    vopf: "\ud835\udd67",
    vprop: "\u221d",
    vrtri: "\u22b3",
    Vscr: "\ud835\udcb1",
    vscr: "\ud835\udccb",
    vsubnE: "\u2acb\ufe00",
    vsubne: "\u228a\ufe00",
    vsupnE: "\u2acc\ufe00",
    vsupne: "\u228b\ufe00",
    Vvdash: "\u22aa",
    vzigzag: "\u299a",
    Wcirc: "\u0174",
    wcirc: "\u0175",
    wedbar: "\u2a5f",
    wedge: "\u2227",
    Wedge: "\u22c0",
    wedgeq: "\u2259",
    weierp: "\u2118",
    Wfr: "\ud835\udd1a",
    wfr: "\ud835\udd34",
    Wopf: "\ud835\udd4e",
    wopf: "\ud835\udd68",
    wp: "\u2118",
    wr: "\u2240",
    wreath: "\u2240",
    Wscr: "\ud835\udcb2",
    wscr: "\ud835\udccc",
    xcap: "\u22c2",
    xcirc: "\u25ef",
    xcup: "\u22c3",
    xdtri: "\u25bd",
    Xfr: "\ud835\udd1b",
    xfr: "\ud835\udd35",
    xharr: "\u27f7",
    xhArr: "\u27fa",
    Xi: "\u039e",
    xi: "\u03be",
    xlarr: "\u27f5",
    xlArr: "\u27f8",
    xmap: "\u27fc",
    xnis: "\u22fb",
    xodot: "\u2a00",
    Xopf: "\ud835\udd4f",
    xopf: "\ud835\udd69",
    xoplus: "\u2a01",
    xotime: "\u2a02",
    xrarr: "\u27f6",
    xrArr: "\u27f9",
    Xscr: "\ud835\udcb3",
    xscr: "\ud835\udccd",
    xsqcup: "\u2a06",
    xuplus: "\u2a04",
    xutri: "\u25b3",
    xvee: "\u22c1",
    xwedge: "\u22c0",
    Yacute: "\xdd",
    yacute: "\xfd",
    YAcy: "\u042f",
    yacy: "\u044f",
    Ycirc: "\u0176",
    ycirc: "\u0177",
    Ycy: "\u042b",
    ycy: "\u044b",
    yen: "\xa5",
    Yfr: "\ud835\udd1c",
    yfr: "\ud835\udd36",
    YIcy: "\u0407",
    yicy: "\u0457",
    Yopf: "\ud835\udd50",
    yopf: "\ud835\udd6a",
    Yscr: "\ud835\udcb4",
    yscr: "\ud835\udcce",
    YUcy: "\u042e",
    yucy: "\u044e",
    yuml: "\xff",
    Yuml: "\u0178",
    Zacute: "\u0179",
    zacute: "\u017a",
    Zcaron: "\u017d",
    zcaron: "\u017e",
    Zcy: "\u0417",
    zcy: "\u0437",
    Zdot: "\u017b",
    zdot: "\u017c",
    zeetrf: "\u2128",
    ZeroWidthSpace: "\u200b",
    Zeta: "\u0396",
    zeta: "\u03b6",
    zfr: "\ud835\udd37",
    Zfr: "\u2128",
    ZHcy: "\u0416",
    zhcy: "\u0436",
    zigrarr: "\u21dd",
    zopf: "\ud835\udd6b",
    Zopf: "\u2124",
    Zscr: "\ud835\udcb5",
    zscr: "\ud835\udccf",
    zwj: "\u200d",
    zwnj: "\u200c"
  };
  /*eslint quotes:0*/  var entities = require$$0;
  var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  var encodeCache = {};
  // Create a lookup array where anything but characters in `chars` string
  // and alphanumeric chars is percent-encoded.
  
    function getEncodeCache(exclude) {
    var i, ch, cache = encodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = encodeCache[exclude] = [];
    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      if (/^[0-9a-z]$/i.test(ch)) {
        // always allow unencoded alphanumeric characters
        cache.push(ch);
      } else {
        cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
      }
    }
    for (i = 0; i < exclude.length; i++) {
      cache[exclude.charCodeAt(i)] = exclude[i];
    }
    return cache;
  }
  // Encode unsafe characters with percent-encoding, skipping already
  // encoded sequences.
  
  //  - string       - string to encode
  //  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
  //  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
  
    function encode$2(string, exclude, keepEscaped) {
    var i, l, code, nextCode, cache, result = "";
    if (typeof exclude !== "string") {
      // encode(string, keepEscaped)
      keepEscaped = exclude;
      exclude = encode$2.defaultChars;
    }
    if (typeof keepEscaped === "undefined") {
      keepEscaped = true;
    }
    cache = getEncodeCache(exclude);
    for (i = 0, l = string.length; i < l; i++) {
      code = string.charCodeAt(i);
      if (keepEscaped && code === 37 /* % */ && i + 2 < l) {
        if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
          result += string.slice(i, i + 3);
          i += 2;
          continue;
        }
      }
      if (code < 128) {
        result += cache[code];
        continue;
      }
      if (code >= 55296 && code <= 57343) {
        if (code >= 55296 && code <= 56319 && i + 1 < l) {
          nextCode = string.charCodeAt(i + 1);
          if (nextCode >= 56320 && nextCode <= 57343) {
            result += encodeURIComponent(string[i] + string[i + 1]);
            i++;
            continue;
          }
        }
        result += "%EF%BF%BD";
        continue;
      }
      result += encodeURIComponent(string[i]);
    }
    return result;
  }
  encode$2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
  encode$2.componentChars = "-_.!~*'()";
  var encode_1 = encode$2;
  /* eslint-disable no-bitwise */  var decodeCache = {};
  function getDecodeCache(exclude) {
    var i, ch, cache = decodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = decodeCache[exclude] = [];
    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      cache.push(ch);
    }
    for (i = 0; i < exclude.length; i++) {
      ch = exclude.charCodeAt(i);
      cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
    }
    return cache;
  }
  // Decode percent-encoded string.
  
    function decode$2(string, exclude) {
    var cache;
    if (typeof exclude !== "string") {
      exclude = decode$2.defaultChars;
    }
    cache = getDecodeCache(exclude);
    return string.replace(/(%[a-f0-9]{2})+/gi, (function(seq) {
      var i, l, b1, b2, b3, b4, chr, result = "";
      for (i = 0, l = seq.length; i < l; i += 3) {
        b1 = parseInt(seq.slice(i + 1, i + 3), 16);
        if (b1 < 128) {
          result += cache[b1];
          continue;
        }
        if ((b1 & 224) === 192 && i + 3 < l) {
          // 110xxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          if ((b2 & 192) === 128) {
            chr = b1 << 6 & 1984 | b2 & 63;
            if (chr < 128) {
              result += "\ufffd\ufffd";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 3;
            continue;
          }
        }
        if ((b1 & 240) === 224 && i + 6 < l) {
          // 1110xxxx 10xxxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128) {
            chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
            if (chr < 2048 || chr >= 55296 && chr <= 57343) {
              result += "\ufffd\ufffd\ufffd";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 6;
            continue;
          }
        }
        if ((b1 & 248) === 240 && i + 9 < l) {
          // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          b4 = parseInt(seq.slice(i + 10, i + 12), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
            chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
            if (chr < 65536 || chr > 1114111) {
              result += "\ufffd\ufffd\ufffd\ufffd";
            } else {
              chr -= 65536;
              result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
            }
            i += 9;
            continue;
          }
        }
        result += "\ufffd";
      }
      return result;
    }));
  }
  decode$2.defaultChars = ";/?:@&=+$,#";
  decode$2.componentChars = "";
  var decode_1 = decode$2;
  var format$1 = function format(url) {
    var result = "";
    result += url.protocol || "";
    result += url.slashes ? "//" : "";
    result += url.auth ? url.auth + "@" : "";
    if (url.hostname && url.hostname.indexOf(":") !== -1) {
      // ipv6 address
      result += "[" + url.hostname + "]";
    } else {
      result += url.hostname || "";
    }
    result += url.port ? ":" + url.port : "";
    result += url.pathname || "";
    result += url.search || "";
    result += url.hash || "";
    return result;
  };
  // Copyright Joyent, Inc. and other Node contributors.
  
  // Changes from joyent/node:
  
  // 1. No leading slash in paths,
  //    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
  
  // 2. Backslashes are not replaced with slashes,
  //    so `http:\\example.org\` is treated like a relative path
  
  // 3. Trailing colon is treated like a part of the path,
  //    i.e. in `http://example.org:foo` pathname is `:foo`
  
  // 4. Nothing is URL-encoded in the resulting object,
  //    (in joyent/node some chars in auth and paths are encoded)
  
  // 5. `url.parse()` does not have `parseQueryString` argument
  
  // 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
  //    which can be constructed using other parts of the url.
  
    function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
  }
  // Reference: RFC 3986, RFC 1808, RFC 2396
  // define these here so at least they only have to be
  // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, 
  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, 
  // RFC 2396: characters reserved for delimiting URLs.
  // We actually just auto-escape these.
  delims = [ "<", ">", '"', "`", " ", "\r", "\n", "\t" ], 
  // RFC 2396: characters not allowed for various reasons.
  unwise = [ "{", "}", "|", "\\", "^", "`" ].concat(delims), 
  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = [ "'" ].concat(unwise), 
  // Characters that are never ever allowed in a hostname.
  // Note that any invalid chars are also handled, but these
  // are the ones that are *expected* to be seen, so we fast-path
  // them.
  nonHostChars = [ "%", "/", "?", ";", "#" ].concat(autoEscape), hostEndingChars = [ "/", "?", "#" ], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, 
  // protocols that can allow "unsafe" and "unwise" chars.
  /* eslint-disable no-script-url */
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    "javascript:": true
  }, 
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  /* eslint-enable no-script-url */  function urlParse(url, slashesDenoteHost) {
    if (url && url instanceof Url) {
      return url;
    }
    var u = new Url;
    u.parse(url, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, slashesDenoteHost) {
    var i, l, lowerProto, hec, slashes, rest = url;
    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      // Try fast path regexp
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = proto;
      rest = rest.substr(proto.length);
    }
    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c
      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.
      // find the first instance of any hostEndingChars
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf("@");
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      // Now we have a portion which is definitely the auth.
      // Pull that off.
            if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = auth;
      }
      // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      if (rest[hostEnd - 1] === ":") {
        hostEnd--;
      }
      var host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      // pull out port.
            this.parseHost(host);
      // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.
            this.hostname = this.hostname || "";
      // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      // validate a little.
            if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) {
            continue;
          }
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            // we test again with ASCII char only
                        if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      }
      // strip [ and ] from the hostname
      // the host field still retains them, though
            if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      }
    }
    // chop off from the tail first.
        var hash = rest.indexOf("#");
    if (hash !== -1) {
      // got a fragment string.
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      rest = rest.slice(0, qm);
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "";
    }
    return this;
  };
  Url.prototype.parseHost = function(host) {
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  var parse$1 = urlParse;
  var encode$1 = encode_1;
  var decode$1 = decode_1;
  var format = format$1;
  var parse = parse$1;
  var mdurl = {
    encode: encode$1,
    decode: decode$1,
    format: format,
    parse: parse
  };
  var regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var regex$2 = /[\0-\x1F\x7F-\x9F]/;
  var regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  var regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  var Any = regex$3;
  var Cc = regex$2;
  var Cf = regex$1;
  var P = regex$4;
  var Z = regex;
  var uc_micro = {
    Any: Any,
    Cc: Cc,
    Cf: Cf,
    P: P,
    Z: Z
  };
  var utils = createCommonjsModule((function(module, exports) {
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    // Merge objects
    
        function assign(obj /*from1, from2, from3, ...*/) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach((function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach((function(key) {
          obj[key] = source[key];
        }));
      }));
      return obj;
    }
    // Remove element from array and put another array at those position.
    // Useful for some operations with tokens
        function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    ////////////////////////////////////////////////////////////////////////////////
        function isValidEntityCode(c) {
      /*eslint no-bitwise:0*/
      // broken sequence
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      // never used
            if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      // control codes
            if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      // out of range
            if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      /*eslint no-bitwise:0*/
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    function replaceEntityPattern(match, name) {
      var code = 0;
      if (has(entities, name)) {
        return entities[name];
      }
      if (name.charCodeAt(0) === 35 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match;
    }
    /*function replaceEntities(str) {
	  if (str.indexOf('&') < 0) { return str; }

	  return str.replace(ENTITY_RE, replaceEntityPattern);
	}*/    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, (function(match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity);
      }));
    }
    ////////////////////////////////////////////////////////////////////////////////
        var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    ////////////////////////////////////////////////////////////////////////////////
        var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    ////////////////////////////////////////////////////////////////////////////////
        function isSpace(code) {
      switch (code) {
       case 9:
       case 32:
        return true;
      }
      return false;
    }
    // Zs (unicode class) || [\t\f\v\r\n]
        function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
       case 9:
 // \t
               case 10:
 // \n
               case 11:
 // \v
               case 12:
 // \f
               case 13:
 // \r
               case 32:
       case 160:
       case 5760:
       case 8239:
       case 8287:
       case 12288:
        return true;
      }
      return false;
    }
    ////////////////////////////////////////////////////////////////////////////////
    /*eslint-disable max-len*/
    // Currently without astral characters support.
        function isPunctChar(ch) {
      return regex$4.test(ch);
    }
    // Markdown ASCII punctuation characters.
    
    // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
    // http://spec.commonmark.org/0.15/#ascii-punctuation-character
    
    // Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
    
        function isMdAsciiPunct(ch) {
      switch (ch) {
       case 33 /* ! */ :
       case 34 /* " */ :
       case 35 /* # */ :
       case 36 /* $ */ :
       case 37 /* % */ :
       case 38 /* & */ :
       case 39 /* ' */ :
       case 40 /* ( */ :
       case 41 /* ) */ :
       case 42 /* * */ :
       case 43 /* + */ :
       case 44 /* , */ :
       case 45 /* - */ :
       case 46 /* . */ :
       case 47 /* / */ :
       case 58 /* : */ :
       case 59 /* ; */ :
       case 60 /* < */ :
       case 61 /* = */ :
       case 62 /* > */ :
       case 63 /* ? */ :
       case 64 /* @ */ :
       case 91 /* [ */ :
       case 92 /* \ */ :
       case 93 /* ] */ :
       case 94 /* ^ */ :
       case 95 /* _ */ :
       case 96 /* ` */ :
       case 123 /* { */ :
       case 124 /* | */ :
       case 125 /* } */ :
       case 126 /* ~ */ :
        return true;

       default:
        return false;
      }
    }
    // Hepler to unify [reference labels].
    
        function normalizeReference(str) {
      // Trim and collapse whitespace
      str = str.trim().replace(/\s+/g, " ");
      // In node v10 ''.toLowerCase() === '', which is presumed to be a bug
      // fixed in v12 (couldn't find any details).
      
      // So treat this one as a special case
      // (remove this when node v10 is no longer supported).
      
            if ("\u1e9e".toLowerCase() === "\u1e7e") {
        str = str.replace(/\u1e9e/g, "\xdf");
      }
      // .toLowerCase().toUpperCase() should get rid of all differences
      // between letter variants.
      
      // Simple .toLowerCase() doesn't normalize 125 code points correctly,
      // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
      // , , , , ,  - those are already uppercased, but have differently
      // uppercased versions).
      
      // Here's an example showing how it happens. Lets take greek letter omega:
      // uppercase U+0398 (), U+03f4 () and lowercase U+03b8 (), U+03d1 ()
      
      // Unicode entries:
      // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
      // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
      // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
      // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
      
      // Case-insensitive comparison should treat all of them as equivalent.
      
      // But .toLowerCase() doesn't change  (it's already lowercase),
      // and .toUpperCase() doesn't change  (already uppercase).
      
      // Applying first lower then upper case normalizes any character:
      // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
      
      // Note: this is equivalent to unicode case folding; unicode normalization
      // is a different step that is not required here.
      
      // Final result should be uppercased, because it's later stored in an object
      // (this avoid a conflict with Object.prototype members,
      // most notably, `__proto__`)
      
            return str.toLowerCase().toUpperCase();
    }
    ////////////////////////////////////////////////////////////////////////////////
    // Re-export libraries commonly used in both markdown-it and its plugins,
    // so plugins won't have to depend on them explicitly, which reduces their
    // bundled size (e.g. a browser build).
    
        exports.lib = {};
    exports.lib.mdurl = mdurl;
    exports.lib.ucmicro = uc_micro;
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    // exports.replaceEntities     = replaceEntities;
        exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }));
  // Parse link label
    var parse_link_label = function parseLinkLabel(state, start, disableNested) {
    var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
    state.pos = start + 1;
    level = 1;
    while (state.pos < max) {
      marker = state.src.charCodeAt(state.pos);
      if (marker === 93 /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }
      prevPos = state.pos;
      state.md.inline.skipToken(state);
      if (marker === 91 /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
    }
    if (found) {
      labelEnd = state.pos;
    }
    // restore old state
        state.pos = oldPos;
    return labelEnd;
  };
  var unescapeAll$2 = utils.unescapeAll;
  var parse_link_destination = function parseLinkDestination(str, pos, max) {
    var code, level, lines = 0, start = pos, result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (str.charCodeAt(pos) === 60 /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 10 /* \n */) {
          return result;
        }
        if (code === 60 /* < */) {
          return result;
        }
        if (code === 62 /* > */) {
          result.pos = pos + 1;
          result.str = unescapeAll$2(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        }
        if (code === 92 /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }
        pos++;
      }
      // no closing '>'
            return result;
    }
    // this should be ... } else { ... branch
        level = 0;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 32) {
        break;
      }
      // ascii control characters
            if (code < 32 || code === 127) {
        break;
      }
      if (code === 92 /* \ */ && pos + 1 < max) {
        if (str.charCodeAt(pos + 1) === 32) {
          break;
        }
        pos += 2;
        continue;
      }
      if (code === 40 /* ( */) {
        level++;
        if (level > 32) {
          return result;
        }
      }
      if (code === 41 /* ) */) {
        if (level === 0) {
          break;
        }
        level--;
      }
      pos++;
    }
    if (start === pos) {
      return result;
    }
    if (level !== 0) {
      return result;
    }
    result.str = unescapeAll$2(str.slice(start, pos));
    result.lines = lines;
    result.pos = pos;
    result.ok = true;
    return result;
  };
  var unescapeAll$1 = utils.unescapeAll;
  var parse_link_title = function parseLinkTitle(str, pos, max) {
    var code, marker, lines = 0, start = pos, result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (pos >= max) {
      return result;
    }
    marker = str.charCodeAt(pos);
    if (marker !== 34 /* " */ && marker !== 39 /* ' */ && marker !== 40 /* ( */) {
      return result;
    }
    pos++;
    // if opening marker is "(", switch it to closing marker ")"
        if (marker === 40) {
      marker = 41;
    }
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === marker) {
        result.pos = pos + 1;
        result.lines = lines;
        result.str = unescapeAll$1(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      } else if (code === 40 /* ( */ && marker === 41 /* ) */) {
        return result;
      } else if (code === 10) {
        lines++;
      } else if (code === 92 /* \ */ && pos + 1 < max) {
        pos++;
        if (str.charCodeAt(pos) === 10) {
          lines++;
        }
      }
      pos++;
    }
    return result;
  };
  var parseLinkLabel = parse_link_label;
  var parseLinkDestination = parse_link_destination;
  var parseLinkTitle = parse_link_title;
  var helpers = {
    parseLinkLabel: parseLinkLabel,
    parseLinkDestination: parseLinkDestination,
    parseLinkTitle: parseLinkTitle
  };
  var assign$1 = utils.assign;
  var unescapeAll = utils.unescapeAll;
  var escapeHtml = utils.escapeHtml;
  ////////////////////////////////////////////////////////////////////////////////
    var default_rules = {};
  default_rules.code_inline = function(tokens, idx, options, env, slf) {
    var token = tokens[idx];
    return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
  };
  default_rules.code_block = function(tokens, idx, options, env, slf) {
    var token = tokens[idx];
    return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
  };
  default_rules.fence = function(tokens, idx, options, env, slf) {
    var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
    if (info) {
      arr = info.split(/(\s+)/g);
      langName = arr[0];
      langAttrs = arr.slice(2).join("");
    }
    if (options.highlight) {
      highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
    } else {
      highlighted = escapeHtml(token.content);
    }
    if (highlighted.indexOf("<pre") === 0) {
      return highlighted + "\n";
    }
    // If language exists, inject class gently, without modifying original token.
    // May be, one day we will add .deepClone() for token and simplify this part, but
    // now we prefer to keep things local.
        if (info) {
      i = token.attrIndex("class");
      tmpAttrs = token.attrs ? token.attrs.slice() : [];
      if (i < 0) {
        tmpAttrs.push([ "class", options.langPrefix + langName ]);
      } else {
        tmpAttrs[i] = tmpAttrs[i].slice();
        tmpAttrs[i][1] += " " + options.langPrefix + langName;
      }
      // Fake token just to render attributes
            tmpToken = {
        attrs: tmpAttrs
      };
      return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
    }
    return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
  };
  default_rules.image = function(tokens, idx, options, env, slf) {
    var token = tokens[idx];
    // "alt" attr MUST be set, even if empty. Because it's mandatory and
    // should be placed on proper position for tests.
    
    // Replace content with actual value
        token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
    return slf.renderToken(tokens, idx, options);
  };
  default_rules.hardbreak = function(tokens, idx, options /*, env */) {
    return options.xhtmlOut ? "<br />\n" : "<br>\n";
  };
  default_rules.softbreak = function(tokens, idx, options /*, env */) {
    return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
  };
  default_rules.text = function(tokens, idx /*, options, env */) {
    return escapeHtml(tokens[idx].content);
  };
  default_rules.html_block = function(tokens, idx /*, options, env */) {
    return tokens[idx].content;
  };
  default_rules.html_inline = function(tokens, idx /*, options, env */) {
    return tokens[idx].content;
  };
  /**
	 * new Renderer()
	 *
	 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
	 **/  function Renderer() {
    /**
	   * Renderer#rules -> Object
	   *
	   * Contains render rules for tokens. Can be updated and extended.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * md.renderer.rules.strong_open  = function () { return '<b>'; };
	   * md.renderer.rules.strong_close = function () { return '</b>'; };
	   *
	   * var result = md.renderInline(...);
	   * ```
	   *
	   * Each rule is called as independent static function with fixed signature:
	   *
	   * ```javascript
	   * function my_token_render(tokens, idx, options, env, renderer) {
	   *   // ...
	   *   return renderedHTML;
	   * }
	   * ```
	   *
	   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
	   * for more details and examples.
	   **/
    this.rules = assign$1({}, default_rules);
  }
  /**
	 * Renderer.renderAttrs(token) -> String
	 *
	 * Render token attributes to string.
	 **/  Renderer.prototype.renderAttrs = function renderAttrs(token) {
    var i, l, result;
    if (!token.attrs) {
      return "";
    }
    result = "";
    for (i = 0, l = token.attrs.length; i < l; i++) {
      result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
    }
    return result;
  };
  /**
	 * Renderer.renderToken(tokens, idx, options) -> String
	 * - tokens (Array): list of tokens
	 * - idx (Numbed): token index to render
	 * - options (Object): params of parser instance
	 *
	 * Default token renderer. Can be overriden by custom function
	 * in [[Renderer#rules]].
	 **/  Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
    var nextToken, result = "", needLf = false, token = tokens[idx];
    // Tight list paragraphs
        if (token.hidden) {
      return "";
    }
    // Insert a newline between hidden paragraph and subsequent opening
    // block-level tag.
    
    // For example, here we should insert a newline before blockquote:
    //  - a
    //    >
    
        if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
      result += "\n";
    }
    // Add token name, e.g. `<img`
        result += (token.nesting === -1 ? "</" : "<") + token.tag;
    // Encode attributes, e.g. `<img src="foo"`
        result += this.renderAttrs(token);
    // Add a slash for self-closing tags, e.g. `<img src="foo" /`
        if (token.nesting === 0 && options.xhtmlOut) {
      result += " /";
    }
    // Check if we need to add a newline after this tag
        if (token.block) {
      needLf = true;
      if (token.nesting === 1) {
        if (idx + 1 < tokens.length) {
          nextToken = tokens[idx + 1];
          if (nextToken.type === "inline" || nextToken.hidden) {
            // Block-level tag containing an inline tag.
            needLf = false;
          } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
            // Opening tag + closing tag of the same type. E.g. `<li></li>`.
            needLf = false;
          }
        }
      }
    }
    result += needLf ? ">\n" : ">";
    return result;
  };
  /**
	 * Renderer.renderInline(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to render
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * The same as [[Renderer.render]], but for single token of `inline` type.
	 **/  Renderer.prototype.renderInline = function(tokens, options, env) {
    var type, result = "", rules = this.rules;
    for (var i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;
      if (typeof rules[type] !== "undefined") {
        result += rules[type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options);
      }
    }
    return result;
  };
  /** internal
	 * Renderer.renderInlineAsText(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to render
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Special kludge for image `alt` attributes to conform CommonMark spec.
	 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
	 * instead of simple escaping.
	 **/  Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
    var result = "";
    for (var i = 0, len = tokens.length; i < len; i++) {
      if (tokens[i].type === "text") {
        result += tokens[i].content;
      } else if (tokens[i].type === "image") {
        result += this.renderInlineAsText(tokens[i].children, options, env);
      } else if (tokens[i].type === "softbreak") {
        result += "\n";
      }
    }
    return result;
  };
  /**
	 * Renderer.render(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to render
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Takes token stream and generates HTML. Probably, you will never need to call
	 * this method directly.
	 **/  Renderer.prototype.render = function(tokens, options, env) {
    var i, len, type, result = "", rules = this.rules;
    for (i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;
      if (type === "inline") {
        result += this.renderInline(tokens[i].children, options, env);
      } else if (typeof rules[type] !== "undefined") {
        result += rules[tokens[i].type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options, env);
      }
    }
    return result;
  };
  var renderer = Renderer;
  /**
	 * class Ruler
	 *
	 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
	 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
	 *
	 * - keep rules in defined order
	 * - assign the name to each rule
	 * - enable/disable rules
	 * - add/replace rules
	 * - allow assign rules to additional named chains (in the same)
	 * - cacheing lists of active rules
	 *
	 * You will not need use this class directly until write plugins. For simple
	 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
	 * [[MarkdownIt.use]].
	 **/
  /**
	 * new Ruler()
	 **/  function Ruler() {
    // List of added rules. Each element is:
    // {
    //   name: XXX,
    //   enabled: Boolean,
    //   fn: Function(),
    //   alt: [ name2, name3 ]
    // }
    this.__rules__ = [];
    // Cached rule chains.
    
    // First level - chain name, '' for default.
    // Second level - diginal anchor for fast filtering by charcodes.
    
        this.__cache__ = null;
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Helper methods, should not be used directly
  // Find rule index by name
  
    Ruler.prototype.__find__ = function(name) {
    for (var i = 0; i < this.__rules__.length; i++) {
      if (this.__rules__[i].name === name) {
        return i;
      }
    }
    return -1;
  };
  // Build rules lookup cache
  
    Ruler.prototype.__compile__ = function() {
    var self = this;
    var chains = [ "" ];
    // collect unique names
        self.__rules__.forEach((function(rule) {
      if (!rule.enabled) {
        return;
      }
      rule.alt.forEach((function(altName) {
        if (chains.indexOf(altName) < 0) {
          chains.push(altName);
        }
      }));
    }));
    self.__cache__ = {};
    chains.forEach((function(chain) {
      self.__cache__[chain] = [];
      self.__rules__.forEach((function(rule) {
        if (!rule.enabled) {
          return;
        }
        if (chain && rule.alt.indexOf(chain) < 0) {
          return;
        }
        self.__cache__[chain].push(rule.fn);
      }));
    }));
  };
  /**
	 * Ruler.at(name, fn [, options])
	 * - name (String): rule name to replace.
	 * - fn (Function): new rule function.
	 * - options (Object): new rule options (not mandatory).
	 *
	 * Replace rule by name with new function & options. Throws error if name not
	 * found.
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * Replace existing typographer replacement rule with new one:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.at('replacements', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/  Ruler.prototype.at = function(name, fn, options) {
    var index = this.__find__(name);
    var opt = options || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + name);
    }
    this.__rules__[index].fn = fn;
    this.__rules__[index].alt = opt.alt || [];
    this.__cache__ = null;
  };
  /**
	 * Ruler.before(beforeName, ruleName, fn [, options])
	 * - beforeName (String): new rule will be added before this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain before one with given name. See also
	 * [[Ruler.after]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/  Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
    var index = this.__find__(beforeName);
    var opt = options || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + beforeName);
    }
    this.__rules__.splice(index, 0, {
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  /**
	 * Ruler.after(afterName, ruleName, fn [, options])
	 * - afterName (String): new rule will be added after this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain after one with given name. See also
	 * [[Ruler.before]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/  Ruler.prototype.after = function(afterName, ruleName, fn, options) {
    var index = this.__find__(afterName);
    var opt = options || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + afterName);
    }
    this.__rules__.splice(index + 1, 0, {
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  /**
	 * Ruler.push(ruleName, fn [, options])
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Push new rule to the end of chain. See also
	 * [[Ruler.before]], [[Ruler.after]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.push('my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/  Ruler.prototype.push = function(ruleName, fn, options) {
    var opt = options || {};
    this.__rules__.push({
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  /**
	 * Ruler.enable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to enable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
	 **/  Ruler.prototype.enable = function(list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [ list ];
    }
    var result = [];
    // Search by name and enable
        list.forEach((function(name) {
      var idx = this.__find__(name);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name);
      }
      this.__rules__[idx].enabled = true;
      result.push(name);
    }), this);
    this.__cache__ = null;
    return result;
  };
  /**
	 * Ruler.enableOnly(list [, ignoreInvalid])
	 * - list (String|Array): list of rule names to enable (whitelist).
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names, and disable everything else. If any rule name
	 * not found - throw Error. Errors can be disabled by second param.
	 *
	 * See also [[Ruler.disable]], [[Ruler.enable]].
	 **/  Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [ list ];
    }
    this.__rules__.forEach((function(rule) {
      rule.enabled = false;
    }));
    this.enable(list, ignoreInvalid);
  };
  /**
	 * Ruler.disable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Disable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
	 **/  Ruler.prototype.disable = function(list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [ list ];
    }
    var result = [];
    // Search by name and disable
        list.forEach((function(name) {
      var idx = this.__find__(name);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name);
      }
      this.__rules__[idx].enabled = false;
      result.push(name);
    }), this);
    this.__cache__ = null;
    return result;
  };
  /**
	 * Ruler.getRules(chainName) -> Array
	 *
	 * Return array of active functions (rules) for given chain name. It analyzes
	 * rules configuration, compiles caches if not exists and returns result.
	 *
	 * Default chain name is `''` (empty string). It can't be skipped. That's
	 * done intentionally, to keep signature monomorphic for high speed.
	 **/  Ruler.prototype.getRules = function(chainName) {
    if (this.__cache__ === null) {
      this.__compile__();
    }
    // Chain can be empty, if rules disabled. But we still have to return Array.
        return this.__cache__[chainName] || [];
  };
  var ruler = Ruler;
  // Normalize input string
  // https://spec.commonmark.org/0.29/#line-ending
    var NEWLINES_RE = /\r\n?|\n/g;
  var NULL_RE = /\0/g;
  var normalize = function normalize(state) {
    var str;
    // Normalize newlines
        str = state.src.replace(NEWLINES_RE, "\n");
    // Replace NULL characters
        str = str.replace(NULL_RE, "\ufffd");
    state.src = str;
  };
  var block = function block(state) {
    var token;
    if (state.inlineMode) {
      token = new state.Token("inline", "", 0);
      token.content = state.src;
      token.map = [ 0, 1 ];
      token.children = [];
      state.tokens.push(token);
    } else {
      state.md.block.parse(state.src, state.md, state.env, state.tokens);
    }
  };
  var inline = function inline(state) {
    var tokens = state.tokens, tok, i, l;
    // Parse inlines
        for (i = 0, l = tokens.length; i < l; i++) {
      tok = tokens[i];
      if (tok.type === "inline") {
        state.md.inline.parse(tok.content, state.md, state.env, tok.children);
      }
    }
  };
  var arrayReplaceAt = utils.arrayReplaceAt;
  function isLinkOpen(str) {
    return /^<a[>\s]/i.test(str);
  }
  function isLinkClose(str) {
    return /^<\/a\s*>/i.test(str);
  }
  var linkify = function linkify(state) {
    var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
    if (!state.md.options.linkify) {
      return;
    }
    for (j = 0, l = blockTokens.length; j < l; j++) {
      if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
        continue;
      }
      tokens = blockTokens[j].children;
      htmlLinkLevel = 0;
      // We scan from the end, to keep position when new tags added.
      // Use reversed logic in links start/end match
            for (i = tokens.length - 1; i >= 0; i--) {
        currentToken = tokens[i];
        // Skip content of markdown links
                if (currentToken.type === "link_close") {
          i--;
          while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
            i--;
          }
          continue;
        }
        // Skip content of html tag links
                if (currentToken.type === "html_inline") {
          if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
            htmlLinkLevel--;
          }
          if (isLinkClose(currentToken.content)) {
            htmlLinkLevel++;
          }
        }
        if (htmlLinkLevel > 0) {
          continue;
        }
        if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
          text = currentToken.content;
          links = state.md.linkify.match(text);
          // Now split string to nodes
                    nodes = [];
          level = currentToken.level;
          lastPos = 0;
          for (ln = 0; ln < links.length; ln++) {
            url = links[ln].url;
            fullUrl = state.md.normalizeLink(url);
            if (!state.md.validateLink(fullUrl)) {
              continue;
            }
            urlText = links[ln].text;
            // Linkifier might send raw hostnames like "example.com", where url
            // starts with domain name. So we prepend http:// in those cases,
            // and remove it afterwards.
            
                        if (!links[ln].schema) {
              urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
            } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
              urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
            } else {
              urlText = state.md.normalizeLinkText(urlText);
            }
            pos = links[ln].index;
            if (pos > lastPos) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos, pos);
              token.level = level;
              nodes.push(token);
            }
            token = new state.Token("link_open", "a", 1);
            token.attrs = [ [ "href", fullUrl ] ];
            token.level = level++;
            token.markup = "linkify";
            token.info = "auto";
            nodes.push(token);
            token = new state.Token("text", "", 0);
            token.content = urlText;
            token.level = level;
            nodes.push(token);
            token = new state.Token("link_close", "a", -1);
            token.level = --level;
            token.markup = "linkify";
            token.info = "auto";
            nodes.push(token);
            lastPos = links[ln].lastIndex;
          }
          if (lastPos < text.length) {
            token = new state.Token("text", "", 0);
            token.content = text.slice(lastPos);
            token.level = level;
            nodes.push(token);
          }
          // replace current node
                    blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
        }
      }
    }
  };
  // Simple typographic replacements
  // TODO:
  // - fractionals 1/2, 1/4, 3/4 -> , , 
  // - miltiplication 2 x 4 -> 2  4
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
  // Workaround for phantomjs - need regex without /g flag,
  // or root check will fail every second time
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
  var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/gi;
  var SCOPED_ABBR = {
    c: "\xa9",
    r: "\xae",
    p: "\xa7",
    tm: "\u2122"
  };
  function replaceFn(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  }
  function replace_scoped(inlineTokens) {
    var i, token, inside_autolink = 0;
    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === "text" && !inside_autolink) {
        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  function replace_rare(inlineTokens) {
    var i, token, inside_autolink = 0;
    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === "text" && !inside_autolink) {
        if (RARE_RE.test(token.content)) {
          token.content = token.content.replace(/\+-/g, "\xb1").replace(/\.{2,}/g, "\u2026").replace(/([?!])\u2026/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/gm, "$1\u2014").replace(/(^|\s)--(?=\s|$)/gm, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/gm, "$1\u2013");
        }
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  var replacements = function replace(state) {
    var blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline") {
        continue;
      }
      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
        replace_scoped(state.tokens[blkIdx].children);
      }
      if (RARE_RE.test(state.tokens[blkIdx].content)) {
        replace_rare(state.tokens[blkIdx].children);
      }
    }
  };
  var isWhiteSpace$1 = utils.isWhiteSpace;
  var isPunctChar$1 = utils.isPunctChar;
  var isMdAsciiPunct$1 = utils.isMdAsciiPunct;
  var QUOTE_TEST_RE = /['"]/;
  var QUOTE_RE = /['"]/g;
  var APOSTROPHE = "\u2019";
 /*  */  function replaceAt(str, index, ch) {
    return str.substr(0, index) + ch + str.substr(index + 1);
  }
  function process_inlines(tokens, state) {
    var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
    stack = [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      thisLevel = tokens[i].level;
      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) {
          break;
        }
      }
      stack.length = j + 1;
      if (token.type !== "text") {
        continue;
      }
      text = token.content;
      pos = 0;
      max = text.length;
      /*eslint no-labels:0,block-scoped-var:0*/      OUTER: while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);
        if (!t) {
          break;
        }
        canOpen = canClose = true;
        pos = t.index + 1;
        isSingle = t[0] === "'";
        // Find previous character,
        // default to space if it's the beginning of the line
        
                lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
 // lastChar defaults to 0x20
                        if (!tokens[j].content) continue;
 // should skip all tokens except 'text', 'html_inline' or 'code_inline'
                        lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        // Find next character,
        // default to space if it's the end of the line
        
                nextChar = 32;
        if (pos < max) {
          nextChar = text.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
 // nextChar defaults to 0x20
                        if (!tokens[j].content) continue;
 // should skip all tokens except 'text', 'html_inline' or 'code_inline'
                        nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
        isLastWhiteSpace = isWhiteSpace$1(lastChar);
        isNextWhiteSpace = isWhiteSpace$1(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 /* " */ && t[0] === '"') {
          if (lastChar >= 48 /* 0 */ && lastChar <= 57 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          // Replace quotes in the middle of punctuation sequence, but not
          // in the middle of the words, i.e.:
          // 1. foo " bar " baz - not replaced
          // 2. foo-"-bar-"-baz - replaced
          // 3. foo"bar"baz     - not replaced
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              // replace token.content *before* tokens[item.token].content,
              // because, if they are pointing at the same token, replaceAt
              // could mess up indices when quote length != 1
                            token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text = token.content;
              max = text.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
    }
  }
  var smartquotes = function smartquotes(state) {
    /*eslint max-depth:0*/
    var blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
        continue;
      }
      process_inlines(state.tokens[blkIdx].children, state);
    }
  };
  // Token class
  /**
	 * class Token
	 **/
  /**
	 * new Token(type, tag, nesting)
	 *
	 * Create new token and fill passed properties.
	 **/  function Token(type, tag, nesting) {
    /**
	   * Token#type -> String
	   *
	   * Type of the token (string, e.g. "paragraph_open")
	   **/
    this.type = type;
    /**
	   * Token#tag -> String
	   *
	   * html tag name, e.g. "p"
	   **/    this.tag = tag;
    /**
	   * Token#attrs -> Array
	   *
	   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
	   **/    this.attrs = null;
    /**
	   * Token#map -> Array
	   *
	   * Source map info. Format: `[ line_begin, line_end ]`
	   **/    this.map = null;
    /**
	   * Token#nesting -> Number
	   *
	   * Level change (number in {-1, 0, 1} set), where:
	   *
	   * -  `1` means the tag is opening
	   * -  `0` means the tag is self-closing
	   * - `-1` means the tag is closing
	   **/    this.nesting = nesting;
    /**
	   * Token#level -> Number
	   *
	   * nesting level, the same as `state.level`
	   **/    this.level = 0;
    /**
	   * Token#children -> Array
	   *
	   * An array of child nodes (inline and img tokens)
	   **/    this.children = null;
    /**
	   * Token#content -> String
	   *
	   * In a case of self-closing tag (code, html, fence, etc.),
	   * it has contents of this tag.
	   **/    this.content = "";
    /**
	   * Token#markup -> String
	   *
	   * '*' or '_' for emphasis, fence string for fence, etc.
	   **/    this.markup = "";
    /**
	   * Token#info -> String
	   *
	   * Additional information:
	   *
	   * - Info string for "fence" tokens
	   * - The value "auto" for autolink "link_open" and "link_close" tokens
	   * - The string value of the item marker for ordered-list "list_item_open" tokens
	   **/    this.info = "";
    /**
	   * Token#meta -> Object
	   *
	   * A place for plugins to store an arbitrary data
	   **/    this.meta = null;
    /**
	   * Token#block -> Boolean
	   *
	   * True for block-level tokens, false for inline tokens.
	   * Used in renderer to calculate line breaks
	   **/    this.block = false;
    /**
	   * Token#hidden -> Boolean
	   *
	   * If it's true, ignore this element when rendering. Used for tight lists
	   * to hide paragraphs.
	   **/    this.hidden = false;
  }
  /**
	 * Token.attrIndex(name) -> Number
	 *
	 * Search attribute index by name.
	 **/  Token.prototype.attrIndex = function attrIndex(name) {
    var attrs, i, len;
    if (!this.attrs) {
      return -1;
    }
    attrs = this.attrs;
    for (i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i][0] === name) {
        return i;
      }
    }
    return -1;
  };
  /**
	 * Token.attrPush(attrData)
	 *
	 * Add `[ name, value ]` attribute to list. Init attrs if necessary
	 **/  Token.prototype.attrPush = function attrPush(attrData) {
    if (this.attrs) {
      this.attrs.push(attrData);
    } else {
      this.attrs = [ attrData ];
    }
  };
  /**
	 * Token.attrSet(name, value)
	 *
	 * Set `name` attribute to `value`. Override old value if exists.
	 **/  Token.prototype.attrSet = function attrSet(name, value) {
    var idx = this.attrIndex(name), attrData = [ name, value ];
    if (idx < 0) {
      this.attrPush(attrData);
    } else {
      this.attrs[idx] = attrData;
    }
  };
  /**
	 * Token.attrGet(name)
	 *
	 * Get the value of attribute `name`, or null if it does not exist.
	 **/  Token.prototype.attrGet = function attrGet(name) {
    var idx = this.attrIndex(name), value = null;
    if (idx >= 0) {
      value = this.attrs[idx][1];
    }
    return value;
  };
  /**
	 * Token.attrJoin(name, value)
	 *
	 * Join value to existing attribute via space. Or create new attribute if not
	 * exists. Useful to operate with token classes.
	 **/  Token.prototype.attrJoin = function attrJoin(name, value) {
    var idx = this.attrIndex(name);
    if (idx < 0) {
      this.attrPush([ name, value ]);
    } else {
      this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
    }
  };
  var token = Token;
  function StateCore(src, md, env) {
    this.src = src;
    this.env = env;
    this.tokens = [];
    this.inlineMode = false;
    this.md = md;
 // link to parser instance
    }
  // re-export Token class to use in core rules
    StateCore.prototype.Token = token;
  var state_core = StateCore;
  var _rules$2 = [ [ "normalize", normalize ], [ "block", block ], [ "inline", inline ], [ "linkify", linkify ], [ "replacements", replacements ], [ "smartquotes", smartquotes ] ];
  /**
	 * new Core()
	 **/  function Core() {
    /**
	   * Core#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of core rules.
	   **/
    this.ruler = new ruler;
    for (var i = 0; i < _rules$2.length; i++) {
      this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
    }
  }
  /**
	 * Core.process(state)
	 *
	 * Executes core chain rules.
	 **/  Core.prototype.process = function(state) {
    var i, l, rules;
    rules = this.ruler.getRules("");
    for (i = 0, l = rules.length; i < l; i++) {
      rules[i](state);
    }
  };
  Core.prototype.State = state_core;
  var parser_core = Core;
  var isSpace$a = utils.isSpace;
  function getLine(state, line) {
    var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
    return state.src.substr(pos, max - pos);
  }
  function escapedSplit(str) {
    var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
    ch = str.charCodeAt(pos);
    while (pos < max) {
      if (ch === 124 /* | */) {
        if (!isEscaped) {
          // pipe separating cells, '|'
          result.push(current + str.substring(lastPos, pos));
          current = "";
          lastPos = pos + 1;
        } else {
          // escaped pipe, '\|'
          current += str.substring(lastPos, pos - 1);
          lastPos = pos;
        }
      }
      isEscaped = ch === 92 /* \ */;
      pos++;
      ch = str.charCodeAt(pos);
    }
    result.push(current + str.substring(lastPos));
    return result;
  }
  var table = function table(state, startLine, endLine, silent) {
    var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
    // should have at least two lines
        if (startLine + 2 > endLine) {
      return false;
    }
    nextLine = startLine + 1;
    if (state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    // first character of the second line should be '|', '-', ':',
    // and no other characters are allowed but spaces;
    // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    firstCh = state.src.charCodeAt(pos++);
    if (firstCh !== 124 /* | */ && firstCh !== 45 /* - */ && firstCh !== 58 /* : */) {
      return false;
    }
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    secondCh = state.src.charCodeAt(pos++);
    if (secondCh !== 124 /* | */ && secondCh !== 45 /* - */ && secondCh !== 58 /* : */ && !isSpace$a(secondCh)) {
      return false;
    }
    // if first character is '-', then second character must not be a space
    // (due to parsing ambiguity with list)
        if (firstCh === 45 /* - */ && isSpace$a(secondCh)) {
      return false;
    }
    while (pos < state.eMarks[nextLine]) {
      ch = state.src.charCodeAt(pos);
      if (ch !== 124 /* | */ && ch !== 45 /* - */ && ch !== 58 /* : */ && !isSpace$a(ch)) {
        return false;
      }
      pos++;
    }
    lineText = getLine(state, startLine + 1);
    columns = lineText.split("|");
    aligns = [];
    for (i = 0; i < columns.length; i++) {
      t = columns[i].trim();
      if (!t) {
        // allow empty columns before and after table, but not in between columns;
        // e.g. allow ` |---| `, disallow ` ---||--- `
        if (i === 0 || i === columns.length - 1) {
          continue;
        } else {
          return false;
        }
      }
      if (!/^:?-+:?$/.test(t)) {
        return false;
      }
      if (t.charCodeAt(t.length - 1) === 58 /* : */) {
        aligns.push(t.charCodeAt(0) === 58 /* : */ ? "center" : "right");
      } else if (t.charCodeAt(0) === 58 /* : */) {
        aligns.push("left");
      } else {
        aligns.push("");
      }
    }
    lineText = getLine(state, startLine).trim();
    if (lineText.indexOf("|") === -1) {
      return false;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    // header row will define an amount of columns in the entire table,
    // and align row should be exactly the same (the rest of the rows can differ)
        columnCount = columns.length;
    if (columnCount === 0 || columnCount !== aligns.length) {
      return false;
    }
    if (silent) {
      return true;
    }
    oldParentType = state.parentType;
    state.parentType = "table";
    // use 'blockquote' lists for termination because it's
    // the most similar to tables
        terminatorRules = state.md.block.ruler.getRules("blockquote");
    token = state.push("table_open", "table", 1);
    token.map = tableLines = [ startLine, 0 ];
    token = state.push("thead_open", "thead", 1);
    token.map = [ startLine, startLine + 1 ];
    token = state.push("tr_open", "tr", 1);
    token.map = [ startLine, startLine + 1 ];
    for (i = 0; i < columns.length; i++) {
      token = state.push("th_open", "th", 1);
      if (aligns[i]) {
        token.attrs = [ [ "style", "text-align:" + aligns[i] ] ];
      }
      token = state.push("inline", "", 0);
      token.content = columns[i].trim();
      token.children = [];
      token = state.push("th_close", "th", -1);
    }
    token = state.push("tr_close", "tr", -1);
    token = state.push("thead_close", "thead", -1);
    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      lineText = getLine(state, nextLine).trim();
      if (!lineText) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "") columns.shift();
      if (columns.length && columns[columns.length - 1] === "") columns.pop();
      if (nextLine === startLine + 2) {
        token = state.push("tbody_open", "tbody", 1);
        token.map = tbodyLines = [ startLine + 2, 0 ];
      }
      token = state.push("tr_open", "tr", 1);
      token.map = [ nextLine, nextLine + 1 ];
      for (i = 0; i < columnCount; i++) {
        token = state.push("td_open", "td", 1);
        if (aligns[i]) {
          token.attrs = [ [ "style", "text-align:" + aligns[i] ] ];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i] ? columns[i].trim() : "";
        token.children = [];
        token = state.push("td_close", "td", -1);
      }
      token = state.push("tr_close", "tr", -1);
    }
    if (tbodyLines) {
      token = state.push("tbody_close", "tbody", -1);
      tbodyLines[1] = nextLine;
    }
    token = state.push("table_close", "table", -1);
    tableLines[1] = nextLine;
    state.parentType = oldParentType;
    state.line = nextLine;
    return true;
  };
  // Code block (4 spaces padded)
    var code = function code(state, startLine, endLine /*, silent*/) {
    var nextLine, last, token;
    if (state.sCount[startLine] - state.blkIndent < 4) {
      return false;
    }
    last = nextLine = startLine + 1;
    while (nextLine < endLine) {
      if (state.isEmpty(nextLine)) {
        nextLine++;
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        nextLine++;
        last = nextLine;
        continue;
      }
      break;
    }
    state.line = last;
    token = state.push("code_block", "code", 0);
    token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
    token.map = [ startLine, state.line ];
    return true;
  };
  // fences (``` lang, ~~~ lang)
    var fence = function fence(state, startLine, endLine, silent) {
    var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (pos + 3 > max) {
      return false;
    }
    marker = state.src.charCodeAt(pos);
    if (marker !== 126 /* ~ */ && marker !== 96 /* ` */) {
      return false;
    }
    // scan marker length
        mem = pos;
    pos = state.skipChars(pos, marker);
    len = pos - mem;
    if (len < 3) {
      return false;
    }
    markup = state.src.slice(mem, pos);
    params = state.src.slice(pos, max);
    if (marker === 96 /* ` */) {
      if (params.indexOf(String.fromCharCode(marker)) >= 0) {
        return false;
      }
    }
    // Since start is found, we can report success here in validation mode
        if (silent) {
      return true;
    }
    // search end of block
        nextLine = startLine;
    for (;;) {
      nextLine++;
      if (nextLine >= endLine) {
        // unclosed block should be autoclosed by end of document.
        // also block seems to be autoclosed by end of parent
        break;
      }
      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos < max && state.sCount[nextLine] < state.blkIndent) {
        // non-empty line with negative indent should stop the list:
        // - ```
        //  test
        break;
      }
      if (state.src.charCodeAt(pos) !== marker) {
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        // closing fence should be indented less than 4 spaces
        continue;
      }
      pos = state.skipChars(pos, marker);
      // closing code fence must be at least as long as the opening one
            if (pos - mem < len) {
        continue;
      }
      // make sure tail has spaces only
            pos = state.skipSpaces(pos);
      if (pos < max) {
        continue;
      }
      haveEndMarker = true;
      // found!
            break;
    }
    // If a fence has heading spaces, they should be removed from its inner block
        len = state.sCount[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    token = state.push("fence", "code", 0);
    token.info = params;
    token.content = state.getLines(startLine + 1, nextLine, len, true);
    token.markup = markup;
    token.map = [ startLine, state.line ];
    return true;
  };
  var isSpace$9 = utils.isSpace;
  var blockquote = function blockquote(state, startLine, endLine, silent) {
    var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    // check the block quote marker
        if (state.src.charCodeAt(pos++) !== 62 /* > */) {
      return false;
    }
    // we know that it's going to be a valid blockquote,
    // so no point trying to find the end of it in silent mode
        if (silent) {
      return true;
    }
    // set offset past spaces and ">"
        initial = offset = state.sCount[startLine] + 1;
    // skip one optional space after '>'
        if (state.src.charCodeAt(pos) === 32 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 9 /* tab */) {
      spaceAfterMarker = true;
      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
      spaceAfterMarker = false;
    }
    oldBMarks = [ state.bMarks[startLine] ];
    state.bMarks[startLine] = pos;
    while (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (isSpace$9(ch)) {
        if (ch === 9) {
          offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }
      pos++;
    }
    oldBSCount = [ state.bsCount[startLine] ];
    state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
    lastLineEmpty = pos >= max;
    oldSCount = [ state.sCount[startLine] ];
    state.sCount[startLine] = offset - initial;
    oldTShift = [ state.tShift[startLine] ];
    state.tShift[startLine] = pos - state.bMarks[startLine];
    terminatorRules = state.md.block.ruler.getRules("blockquote");
    oldParentType = state.parentType;
    state.parentType = "blockquote";
    // Search the end of the block
    
    // Block ends with either:
    //  1. an empty line outside:
    //     ```
    //     > test
    
    //     ```
    //  2. an empty line inside:
    //     ```
    //     >
    //     test
    //     ```
    //  3. another tag:
    //     ```
    //     > test
    //      - - -
    //     ```
        for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
      // check if it's outdented, i.e. it's inside list item and indented
      // less than said list item:
      // ```
      // 1. anything
      //    > current blockquote
      // 2. checking this line
      // ```
      isOutdented = state.sCount[nextLine] < state.blkIndent;
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos >= max) {
        // Case 1: line is not inside the blockquote, and this line is empty.
        break;
      }
      if (state.src.charCodeAt(pos++) === 62 /* > */ && !isOutdented) {
        // This line is inside the blockquote.
        // set offset past spaces and ">"
        initial = offset = state.sCount[nextLine] + 1;
        // skip one optional space after '>'
                if (state.src.charCodeAt(pos) === 32 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 9 /* tab */) {
          spaceAfterMarker = true;
          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
          spaceAfterMarker = false;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (isSpace$9(ch)) {
            if (ch === 9) {
              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }
          pos++;
        }
        lastLineEmpty = pos >= max;
        oldBSCount.push(state.bsCount[nextLine]);
        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = offset - initial;
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      }
      // Case 2: line is not inside the blockquote, and the last line was empty.
            if (lastLineEmpty) {
        break;
      }
      // Case 3: another tag found.
            terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        // Quirk to enforce "hard termination mode" for paragraphs;
        // normally if you call `tokenize(state, startLine, nextLine)`,
        // paragraphs will look below nextLine for paragraph continuation,
        // but if blockquote is terminated by another tag, they shouldn't
        state.lineMax = nextLine;
        if (state.blkIndent !== 0) {
          // state.blkIndent was non-zero, we now set it to zero,
          // so we need to re-calculate all offsets to appear as
          // if indent wasn't changed
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] -= state.blkIndent;
        }
        break;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      oldBSCount.push(state.bsCount[nextLine]);
      oldTShift.push(state.tShift[nextLine]);
      oldSCount.push(state.sCount[nextLine]);
      // A negative indentation means that this is a paragraph continuation
      
            state.sCount[nextLine] = -1;
    }
    oldIndent = state.blkIndent;
    state.blkIndent = 0;
    token = state.push("blockquote_open", "blockquote", 1);
    token.markup = ">";
    token.map = lines = [ startLine, 0 ];
    state.md.block.tokenize(state, startLine, nextLine);
    token = state.push("blockquote_close", "blockquote", -1);
    token.markup = ">";
    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    lines[1] = state.line;
    // Restore original tShift; this might not be necessary since the parser
    // has already been here, but just to make sure we can do that.
        for (i = 0; i < oldTShift.length; i++) {
      state.bMarks[i + startLine] = oldBMarks[i];
      state.tShift[i + startLine] = oldTShift[i];
      state.sCount[i + startLine] = oldSCount[i];
      state.bsCount[i + startLine] = oldBSCount[i];
    }
    state.blkIndent = oldIndent;
    return true;
  };
  var isSpace$8 = utils.isSpace;
  var hr = function hr(state, startLine, endLine, silent) {
    var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    marker = state.src.charCodeAt(pos++);
    // Check hr marker
        if (marker !== 42 /* * */ && marker !== 45 /* - */ && marker !== 95 /* _ */) {
      return false;
    }
    // markers can be mixed with spaces, but there should be at least 3 of them
        cnt = 1;
    while (pos < max) {
      ch = state.src.charCodeAt(pos++);
      if (ch !== marker && !isSpace$8(ch)) {
        return false;
      }
      if (ch === marker) {
        cnt++;
      }
    }
    if (cnt < 3) {
      return false;
    }
    if (silent) {
      return true;
    }
    state.line = startLine + 1;
    token = state.push("hr", "hr", 0);
    token.map = [ startLine, state.line ];
    token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
    return true;
  };
  var isSpace$7 = utils.isSpace;
  // Search `[-+*][\n ]`, returns next pos after marker on success
  // or -1 on fail.
    function skipBulletListMarker(state, startLine) {
    var marker, pos, max, ch;
    pos = state.bMarks[startLine] + state.tShift[startLine];
    max = state.eMarks[startLine];
    marker = state.src.charCodeAt(pos++);
    // Check bullet
        if (marker !== 42 /* * */ && marker !== 45 /* - */ && marker !== 43 /* + */) {
      return -1;
    }
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (!isSpace$7(ch)) {
        // " -test " - is not a list item
        return -1;
      }
    }
    return pos;
  }
  // Search `\d+[.)][\n ]`, returns next pos after marker on success
  // or -1 on fail.
    function skipOrderedListMarker(state, startLine) {
    var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
    // List marker should have at least 2 chars (digit + dot)
        if (pos + 1 >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch < 48 /* 0 */ || ch > 57 /* 9 */) {
      return -1;
    }
    for (;;) {
      // EOL -> fail
      if (pos >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch >= 48 /* 0 */ && ch <= 57 /* 9 */) {
        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }
        continue;
      }
      // found valid marker
            if (ch === 41 /* ) */ || ch === 46 /* . */) {
        break;
      }
      return -1;
    }
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (!isSpace$7(ch)) {
        // " 1.test " - is not a list item
        return -1;
      }
    }
    return pos;
  }
  function markTightParagraphs(state, idx) {
    var i, l, level = state.level + 2;
    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
      if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
        state.tokens[i + 2].hidden = true;
        state.tokens[i].hidden = true;
        i += 2;
      }
    }
  }
  var list = function list(state, startLine, endLine, silent) {
    var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    // Special case:
    //  - item 1
    //   - item 2
    //    - item 3
    //     - item 4
    //      - this one is a paragraph continuation
        if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
      return false;
    }
    // limit conditions when list can interrupt
    // a paragraph (validation mode only)
        if (silent && state.parentType === "paragraph") {
      // Next list item should still terminate previous list item;
      // This code can fail if plugins use blkIndent as well as lists,
      // but I hope the spec gets fixed long before that happens.
      if (state.sCount[startLine] >= state.blkIndent) {
        isTerminatingParagraph = true;
      }
    }
    // Detect list type and position after marker
        if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
      isOrdered = true;
      start = state.bMarks[startLine] + state.tShift[startLine];
      markerValue = Number(state.src.slice(start, posAfterMarker - 1));
      // If we're starting a new ordered list right after
      // a paragraph, it should start with 1.
            if (isTerminatingParagraph && markerValue !== 1) return false;
    } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
      isOrdered = false;
    } else {
      return false;
    }
    // If we're starting a new unordered list right after
    // a paragraph, first line should not be empty.
        if (isTerminatingParagraph) {
      if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
    }
    // We should terminate list on style change. Remember first one to compare.
        markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
    // For validation mode we can terminate immediately
        if (silent) {
      return true;
    }
    // Start list
        listTokIdx = state.tokens.length;
    if (isOrdered) {
      token = state.push("ordered_list_open", "ol", 1);
      if (markerValue !== 1) {
        token.attrs = [ [ "start", markerValue ] ];
      }
    } else {
      token = state.push("bullet_list_open", "ul", 1);
    }
    token.map = listLines = [ startLine, 0 ];
    token.markup = String.fromCharCode(markerCharCode);
    
    // Iterate list items
    
        nextLine = startLine;
    prevEmptyEnd = false;
    terminatorRules = state.md.block.ruler.getRules("list");
    oldParentType = state.parentType;
    state.parentType = "list";
    while (nextLine < endLine) {
      pos = posAfterMarker;
      max = state.eMarks[nextLine];
      initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (ch === 9) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else if (ch === 32) {
          offset++;
        } else {
          break;
        }
        pos++;
      }
      contentStart = pos;
      if (contentStart >= max) {
        // trimming space in "-    \n  3" case, indent is 1 here
        indentAfterMarker = 1;
      } else {
        indentAfterMarker = offset - initial;
      }
      // If we have more than 4 spaces, the indent is 1
      // (the rest is just indented code block)
            if (indentAfterMarker > 4) {
        indentAfterMarker = 1;
      }
      // "  -  test"
      //  ^^^^^ - calculating total length of this thing
            indent = initial + indentAfterMarker;
      // Run subparser & write tokens
            token = state.push("list_item_open", "li", 1);
      token.markup = String.fromCharCode(markerCharCode);
      token.map = itemLines = [ startLine, 0 ];
      if (isOrdered) {
        token.info = state.src.slice(start, posAfterMarker - 1);
      }
      // change current state, then restore it after parser subcall
            oldTight = state.tight;
      oldTShift = state.tShift[startLine];
      oldSCount = state.sCount[startLine];
      //  - example list
      // ^ listIndent position will be here
      //   ^ blkIndent position will be here
      
            oldListIndent = state.listIndent;
      state.listIndent = state.blkIndent;
      state.blkIndent = indent;
      state.tight = true;
      state.tShift[startLine] = contentStart - state.bMarks[startLine];
      state.sCount[startLine] = offset;
      if (contentStart >= max && state.isEmpty(startLine + 1)) {
        // workaround for this case
        // (list item is empty, list terminates before "foo"):
        // ~~~~~~~~
        //   -
        //     foo
        // ~~~~~~~~
        state.line = Math.min(state.line + 2, endLine);
      } else {
        state.md.block.tokenize(state, startLine, endLine, true);
      }
      // If any of list item is tight, mark list as tight
            if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish
            prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
      state.blkIndent = state.listIndent;
      state.listIndent = oldListIndent;
      state.tShift[startLine] = oldTShift;
      state.sCount[startLine] = oldSCount;
      state.tight = oldTight;
      token = state.push("list_item_close", "li", -1);
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine = state.line;
      itemLines[1] = nextLine;
      contentStart = state.bMarks[startLine];
      if (nextLine >= endLine) {
        break;
      }
      
      // Try to check if list is terminated or continued.
      
            if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      // if it's indented more than 3 spaces, it should be a code block
            if (state.sCount[startLine] - state.blkIndent >= 4) {
        break;
      }
      // fail if terminating block found
            terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      // fail if list has another type
            if (isOrdered) {
        posAfterMarker = skipOrderedListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
        start = state.bMarks[nextLine] + state.tShift[nextLine];
      } else {
        posAfterMarker = skipBulletListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
      }
      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
        break;
      }
    }
    // Finalize list
        if (isOrdered) {
      token = state.push("ordered_list_close", "ol", -1);
    } else {
      token = state.push("bullet_list_close", "ul", -1);
    }
    token.markup = String.fromCharCode(markerCharCode);
    listLines[1] = nextLine;
    state.line = nextLine;
    state.parentType = oldParentType;
    // mark paragraphs tight if needed
        if (tight) {
      markTightParagraphs(state, listTokIdx);
    }
    return true;
  };
  var normalizeReference$2 = utils.normalizeReference;
  var isSpace$6 = utils.isSpace;
  var reference = function reference(state, startLine, _endLine, silent) {
    var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 91 /* [ */) {
      return false;
    }
    // Simple check to quickly interrupt scan on [link](url) at the start of line.
    // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
        while (++pos < max) {
      if (state.src.charCodeAt(pos) === 93 /* ] */ && state.src.charCodeAt(pos - 1) !== 92 /* \ */) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 58 /* : */) {
          return false;
        }
        break;
      }
    }
    endLine = state.lineMax;
    // jump line-by-line until empty one or EOF
        terminatorRules = state.md.block.ruler.getRules("reference");
    oldParentType = state.parentType;
    state.parentType = "reference";
    for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      // quirk for blockquotes, this line should already be checked by that rule
            if (state.sCount[nextLine] < 0) {
        continue;
      }
      // Some tags can terminate paragraph without empty line.
            terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    max = str.length;
    for (pos = 1; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 91 /* [ */) {
        return false;
      } else if (ch === 93 /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 10 /* \n */) {
        lines++;
      } else if (ch === 92 /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 10) {
          lines++;
        }
      }
    }
    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58 /* : */) {
      return false;
    }
    // [label]:   destination   'title'
    //         ^^^ skip optional whitespace here
        for (pos = labelEnd + 2; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 10) {
        lines++;
      } else if (isSpace$6(ch)) ; else {
        break;
      }
    }
    // [label]:   destination   'title'
    //            ^^^^^^^^^^^ parse this
        res = state.md.helpers.parseLinkDestination(str, pos, max);
    if (!res.ok) {
      return false;
    }
    href = state.md.normalizeLink(res.str);
    if (!state.md.validateLink(href)) {
      return false;
    }
    pos = res.pos;
    lines += res.lines;
    // save cursor state, we could require to rollback later
        destEndPos = pos;
    destEndLineNo = lines;
    // [label]:   destination   'title'
    //                       ^^^ skipping those spaces
        start = pos;
    for (;pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 10) {
        lines++;
      } else if (isSpace$6(ch)) ; else {
        break;
      }
    }
    // [label]:   destination   'title'
    //                          ^^^^^^^ parse this
        res = state.md.helpers.parseLinkTitle(str, pos, max);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      lines += res.lines;
    } else {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
    }
    // skip trailing spaces until the rest of the line
        while (pos < max) {
      ch = str.charCodeAt(pos);
      if (!isSpace$6(ch)) {
        break;
      }
      pos++;
    }
    if (pos < max && str.charCodeAt(pos) !== 10) {
      if (title) {
        // garbage at the end of the line after title,
        // but it could still be a valid reference if we roll back
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
        while (pos < max) {
          ch = str.charCodeAt(pos);
          if (!isSpace$6(ch)) {
            break;
          }
          pos++;
        }
      }
    }
    if (pos < max && str.charCodeAt(pos) !== 10) {
      // garbage at the end of the line
      return false;
    }
    label = normalizeReference$2(str.slice(1, labelEnd));
    if (!label) {
      // CommonMark 0.20 disallows empty labels
      return false;
    }
    // Reference can not terminate anything. This check is for safety only.
    /*istanbul ignore if*/    if (silent) {
      return true;
    }
    if (typeof state.env.references === "undefined") {
      state.env.references = {};
    }
    if (typeof state.env.references[label] === "undefined") {
      state.env.references[label] = {
        title: title,
        href: href
      };
    }
    state.parentType = oldParentType;
    state.line = startLine + lines + 1;
    return true;
  };
  // List of valid html blocks names, accorting to commonmark spec
    var html_blocks = [ "address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul" ];
  // Regexps to match html elements
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
  var unquoted = "[^\"'=<>`\\x00-\\x20]+";
  var single_quoted = "'[^']*'";
  var double_quoted = '"[^"]*"';
  var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
  var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
  var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
  var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  var comment = "\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e";
  var processing = "<[?][\\s\\S]*?[?]>";
  var declaration = "<![A-Z]+\\s+[^>]*>";
  var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
  var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
  var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
  var HTML_TAG_RE_1 = HTML_TAG_RE$1;
  var HTML_OPEN_CLOSE_TAG_RE_1 = HTML_OPEN_CLOSE_TAG_RE$1;
  var html_re = {
    HTML_TAG_RE: HTML_TAG_RE_1,
    HTML_OPEN_CLOSE_TAG_RE: HTML_OPEN_CLOSE_TAG_RE_1
  };
  var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
  // An array of opening and corresponding closing sequences for html tags,
  // last argument defines whether it can terminate a paragraph or not
  
    var HTML_SEQUENCES = [ [ /^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true ], [ /^<!--/, /-->/, true ], [ /^<\?/, /\?>/, true ], [ /^<![A-Z]/, />/, true ], [ /^<!\[CDATA\[/, /\]\]>/, true ], [ new RegExp("^</?(" + html_blocks.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true ], [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false ] ];
  var html_block = function html_block(state, startLine, endLine, silent) {
    var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (!state.md.options.html) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 60 /* < */) {
      return false;
    }
    lineText = state.src.slice(pos, max);
    for (i = 0; i < HTML_SEQUENCES.length; i++) {
      if (HTML_SEQUENCES[i][0].test(lineText)) {
        break;
      }
    }
    if (i === HTML_SEQUENCES.length) {
      return false;
    }
    if (silent) {
      // true if this sequence can be a terminator, false otherwise
      return HTML_SEQUENCES[i][2];
    }
    nextLine = startLine + 1;
    // If we are here - we detected HTML block.
    // Let's roll down till block end.
        if (!HTML_SEQUENCES[i][1].test(lineText)) {
      for (;nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max);
        if (HTML_SEQUENCES[i][1].test(lineText)) {
          if (lineText.length !== 0) {
            nextLine++;
          }
          break;
        }
      }
    }
    state.line = nextLine;
    token = state.push("html_block", "", 0);
    token.map = [ startLine, nextLine ];
    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
    return true;
  };
  var isSpace$5 = utils.isSpace;
  var heading = function heading(state, startLine, endLine, silent) {
    var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    ch = state.src.charCodeAt(pos);
    if (ch !== 35 /* # */ || pos >= max) {
      return false;
    }
    // count heading level
        level = 1;
    ch = state.src.charCodeAt(++pos);
    while (ch === 35 /* # */ && pos < max && level <= 6) {
      level++;
      ch = state.src.charCodeAt(++pos);
    }
    if (level > 6 || pos < max && !isSpace$5(ch)) {
      return false;
    }
    if (silent) {
      return true;
    }
    // Let's cut tails like '    ###  ' from the end of string
        max = state.skipSpacesBack(max, pos);
    tmp = state.skipCharsBack(max, 35, pos);
 // #
        if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
      max = tmp;
    }
    state.line = startLine + 1;
    token = state.push("heading_open", "h" + String(level), 1);
    token.markup = "########".slice(0, level);
    token.map = [ startLine, state.line ];
    token = state.push("inline", "", 0);
    token.content = state.src.slice(pos, max).trim();
    token.map = [ startLine, state.line ];
    token.children = [];
    token = state.push("heading_close", "h" + String(level), -1);
    token.markup = "########".slice(0, level);
    return true;
  };
  // lheading (---, ===)
    var lheading = function lheading(state, startLine, endLine /*, silent*/) {
    var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
    // if it's indented more than 3 spaces, it should be a code block
        if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    oldParentType = state.parentType;
    state.parentType = "paragraph";
 // use paragraph to match terminatorRules
    // jump line-by-line until empty one or EOF
        for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      
      // Check for underline in setext header
      
            if (state.sCount[nextLine] >= state.blkIndent) {
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max) {
          marker = state.src.charCodeAt(pos);
          if (marker === 45 /* - */ || marker === 61 /* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);
            if (pos >= max) {
              level = marker === 61 /* = */ ? 1 : 2;
              break;
            }
          }
        }
      }
      // quirk for blockquotes, this line should already be checked by that rule
            if (state.sCount[nextLine] < 0) {
        continue;
      }
      // Some tags can terminate paragraph without empty line.
            terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    if (!level) {
      // Didn't find valid underline
      return false;
    }
    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine + 1;
    token = state.push("heading_open", "h" + String(level), 1);
    token.markup = String.fromCharCode(marker);
    token.map = [ startLine, state.line ];
    token = state.push("inline", "", 0);
    token.content = content;
    token.map = [ startLine, state.line - 1 ];
    token.children = [];
    token = state.push("heading_close", "h" + String(level), -1);
    token.markup = String.fromCharCode(marker);
    state.parentType = oldParentType;
    return true;
  };
  // Paragraph
    var paragraph = function paragraph(state, startLine /*, endLine*/) {
    var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
    oldParentType = state.parentType;
    state.parentType = "paragraph";
    // jump line-by-line until empty one or EOF
        for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      // quirk for blockquotes, this line should already be checked by that rule
            if (state.sCount[nextLine] < 0) {
        continue;
      }
      // Some tags can terminate paragraph without empty line.
            terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine;
    token = state.push("paragraph_open", "p", 1);
    token.map = [ startLine, state.line ];
    token = state.push("inline", "", 0);
    token.content = content;
    token.map = [ startLine, state.line ];
    token.children = [];
    token = state.push("paragraph_close", "p", -1);
    state.parentType = oldParentType;
    return true;
  };
  var isSpace$4 = utils.isSpace;
  function StateBlock(src, md, env, tokens) {
    var ch, s, start, pos, len, indent, offset, indent_found;
    this.src = src;
    // link to parser instance
        this.md = md;
    this.env = env;
    
    // Internal state vartiables
    
        this.tokens = tokens;
    this.bMarks = [];
 // line begin offsets for fast jumps
        this.eMarks = [];
 // line end offsets for fast jumps
        this.tShift = [];
 // offsets of the first non-space characters (tabs not expanded)
        this.sCount = [];
 // indents for each line (tabs expanded)
    // An amount of virtual spaces (tabs expanded) between beginning
    // of each line (bMarks) and real beginning of that line.
    
    // It exists only as a hack because blockquotes override bMarks
    // losing information in the process.
    
    // It's used only when expanding tabs, you can think about it as
    // an initial tab length, e.g. bsCount=21 applied to string `\t123`
    // means first tab should be expanded to 4-21%4 === 3 spaces.
    
        this.bsCount = [];
    // block parser variables
        this.blkIndent = 0;
 // required block content indent (for example, if we are
    // inside a list, it would be positioned after list marker)
        this.line = 0;
 // line index in src
        this.lineMax = 0;
 // lines count
        this.tight = false;
 // loose/tight mode for lists
        this.ddIndent = -1;
 // indent of the current dd block (-1 if there isn't any)
        this.listIndent = -1;
 // indent of the current list block (-1 if there isn't any)
    // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
    // used in lists to determine if they interrupt a paragraph
        this.parentType = "root";
    this.level = 0;
    // renderer
        this.result = "";
    // Create caches
    // Generate markers.
        s = this.src;
    indent_found = false;
    for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
      ch = s.charCodeAt(pos);
      if (!indent_found) {
        if (isSpace$4(ch)) {
          indent++;
          if (ch === 9) {
            offset += 4 - offset % 4;
          } else {
            offset++;
          }
          continue;
        } else {
          indent_found = true;
        }
      }
      if (ch === 10 || pos === len - 1) {
        if (ch !== 10) {
          pos++;
        }
        this.bMarks.push(start);
        this.eMarks.push(pos);
        this.tShift.push(indent);
        this.sCount.push(offset);
        this.bsCount.push(0);
        indent_found = false;
        indent = 0;
        offset = 0;
        start = pos + 1;
      }
    }
    // Push fake entry to simplify cache bounds checks
        this.bMarks.push(s.length);
    this.eMarks.push(s.length);
    this.tShift.push(0);
    this.sCount.push(0);
    this.bsCount.push(0);
    this.lineMax = this.bMarks.length - 1;
 // don't count last fake line
    }
  // Push new token to "stream".
  
    StateBlock.prototype.push = function(type, tag, nesting) {
    var token$1 = new token(type, tag, nesting);
    token$1.block = true;
    if (nesting < 0) this.level--;
 // closing tag
        token$1.level = this.level;
    if (nesting > 0) this.level++;
 // opening tag
        this.tokens.push(token$1);
    return token$1;
  };
  StateBlock.prototype.isEmpty = function isEmpty(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
  };
  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for (var max = this.lineMax; from < max; from++) {
      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
        break;
      }
    }
    return from;
  };
  // Skip spaces from given position.
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    var ch;
    for (var max = this.src.length; pos < max; pos++) {
      ch = this.src.charCodeAt(pos);
      if (!isSpace$4(ch)) {
        break;
      }
    }
    return pos;
  };
  // Skip spaces from given position in reverse.
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (!isSpace$4(this.src.charCodeAt(--pos))) {
        return pos + 1;
      }
    }
    return pos;
  };
  // Skip char codes from given position
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
    for (var max = this.src.length; pos < max; pos++) {
      if (this.src.charCodeAt(pos) !== code) {
        break;
      }
    }
    return pos;
  };
  // Skip char codes reverse from given position - 1
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (code !== this.src.charCodeAt(--pos)) {
        return pos + 1;
      }
    }
    return pos;
  };
  // cut lines range from source.
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
    var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
    if (begin >= end) {
      return "";
    }
    queue = new Array(end - begin);
    for (i = 0; line < end; line++, i++) {
      lineIndent = 0;
      lineStart = first = this.bMarks[line];
      if (line + 1 < end || keepLastLF) {
        // No need for bounds check because we have fake entry on tail.
        last = this.eMarks[line] + 1;
      } else {
        last = this.eMarks[line];
      }
      while (first < last && lineIndent < indent) {
        ch = this.src.charCodeAt(first);
        if (isSpace$4(ch)) {
          if (ch === 9) {
            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
          } else {
            lineIndent++;
          }
        } else if (first - lineStart < this.tShift[line]) {
          // patched tShift masked characters to look like spaces (blockquotes, list markers)
          lineIndent++;
        } else {
          break;
        }
        first++;
      }
      if (lineIndent > indent) {
        // partially expanding tabs in code blocks, e.g '\t\tfoobar'
        // with indent=2 becomes '  \tfoobar'
        queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
      } else {
        queue[i] = this.src.slice(first, last);
      }
    }
    return queue.join("");
  };
  // re-export Token class to use in block rules
    StateBlock.prototype.Token = token;
  var state_block = StateBlock;
  var _rules$1 = [ 
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  [ "table", table, [ "paragraph", "reference" ] ], [ "code", code ], [ "fence", fence, [ "paragraph", "reference", "blockquote", "list" ] ], [ "blockquote", blockquote, [ "paragraph", "reference", "blockquote", "list" ] ], [ "hr", hr, [ "paragraph", "reference", "blockquote", "list" ] ], [ "list", list, [ "paragraph", "reference", "blockquote" ] ], [ "reference", reference ], [ "html_block", html_block, [ "paragraph", "reference", "blockquote" ] ], [ "heading", heading, [ "paragraph", "reference", "blockquote" ] ], [ "lheading", lheading ], [ "paragraph", paragraph ] ];
  /**
	 * new ParserBlock()
	 **/  function ParserBlock() {
    /**
	   * ParserBlock#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of block rules.
	   **/
    this.ruler = new ruler;
    for (var i = 0; i < _rules$1.length; i++) {
      this.ruler.push(_rules$1[i][0], _rules$1[i][1], {
        alt: (_rules$1[i][2] || []).slice()
      });
    }
  }
  // Generate tokens for input range
  
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
    var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
    while (line < endLine) {
      state.line = line = state.skipEmptyLines(line);
      if (line >= endLine) {
        break;
      }
      // Termination condition for nested calls.
      // Nested calls currently used for blockquotes & lists
            if (state.sCount[line] < state.blkIndent) {
        break;
      }
      // If nesting level exceeded - skip tail to the end. That's not ordinary
      // situation and we should not care about content.
            if (state.level >= maxNesting) {
        state.line = endLine;
        break;
      }
      // Try all possible rules.
      // On success, rule should:
      
      // - update `state.line`
      // - update `state.tokens`
      // - return true
            for (i = 0; i < len; i++) {
        ok = rules[i](state, line, endLine, false);
        if (ok) {
          break;
        }
      }
      // set state.tight if we had an empty line before current tag
      // i.e. latest empty line should not count
            state.tight = !hasEmptyLines;
      // paragraph might "eat" one newline after it in nested lists
            if (state.isEmpty(state.line - 1)) {
        hasEmptyLines = true;
      }
      line = state.line;
      if (line < endLine && state.isEmpty(line)) {
        hasEmptyLines = true;
        line++;
        state.line = line;
      }
    }
  };
  /**
	 * ParserBlock.parse(str, md, env, outTokens)
	 *
	 * Process input string and push block tokens into `outTokens`
	 **/  ParserBlock.prototype.parse = function(src, md, env, outTokens) {
    var state;
    if (!src) {
      return;
    }
    state = new this.State(src, md, env, outTokens);
    this.tokenize(state, state.line, state.lineMax);
  };
  ParserBlock.prototype.State = state_block;
  var parser_block = ParserBlock;
  // Skip text characters for text token, place those to pending buffer
  // Rule to skip pure text
  // '{}$%@~+=:' reserved for extentions
  // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
  // !!!! Don't confuse with "Markdown ASCII Punctuation" chars
  // http://spec.commonmark.org/0.15/#ascii-punctuation-character
    function isTerminatorChar(ch) {
    switch (ch) {
     case 10 /* \n */ :
     case 33 /* ! */ :
     case 35 /* # */ :
     case 36 /* $ */ :
     case 37 /* % */ :
     case 38 /* & */ :
     case 42 /* * */ :
     case 43 /* + */ :
     case 45 /* - */ :
     case 58 /* : */ :
     case 60 /* < */ :
     case 61 /* = */ :
     case 62 /* > */ :
     case 64 /* @ */ :
     case 91 /* [ */ :
     case 92 /* \ */ :
     case 93 /* ] */ :
     case 94 /* ^ */ :
     case 95 /* _ */ :
     case 96 /* ` */ :
     case 123 /* { */ :
     case 125 /* } */ :
     case 126 /* ~ */ :
      return true;

     default:
      return false;
    }
  }
  var text = function text(state, silent) {
    var pos = state.pos;
    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
      pos++;
    }
    if (pos === state.pos) {
      return false;
    }
    if (!silent) {
      state.pending += state.src.slice(state.pos, pos);
    }
    state.pos = pos;
    return true;
  };
  var isSpace$3 = utils.isSpace;
  var newline = function newline(state, silent) {
    var pmax, max, ws, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 10 /* \n */) {
      return false;
    }
    pmax = state.pending.length - 1;
    max = state.posMax;
    // '  \n' -> hardbreak
    // Lookup in pending chars is bad practice! Don't copy to other rules!
    // Pending string is stored in concat mode, indexed lookups will cause
    // convertion to flat mode.
        if (!silent) {
      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
          // Find whitespaces tail of pending chars.
          ws = pmax - 1;
          while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
          state.pending = state.pending.slice(0, ws);
          state.push("hardbreak", "br", 0);
        } else {
          state.pending = state.pending.slice(0, -1);
          state.push("softbreak", "br", 0);
        }
      } else {
        state.push("softbreak", "br", 0);
      }
    }
    pos++;
    // skip heading spaces for next line
        while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {
      pos++;
    }
    state.pos = pos;
    return true;
  };
  var isSpace$2 = utils.isSpace;
  var ESCAPED = [];
  for (var i = 0; i < 256; i++) {
    ESCAPED.push(0);
  }
  "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach((function(ch) {
    ESCAPED[ch.charCodeAt(0)] = 1;
  }));
  var _escape = function escape(state, silent) {
    var ch, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 92 /* \ */) {
      return false;
    }
    pos++;
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (ch < 256 && ESCAPED[ch] !== 0) {
        if (!silent) {
          state.pending += state.src[pos];
        }
        state.pos += 2;
        return true;
      }
      if (ch === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        // skip leading whitespaces from next line
                while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (!isSpace$2(ch)) {
            break;
          }
          pos++;
        }
        state.pos = pos;
        return true;
      }
    }
    if (!silent) {
      state.pending += "\\";
    }
    state.pos++;
    return true;
  };
  // Parse backticks
    var backticks = function backtick(state, silent) {
    var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
    if (ch !== 96 /* ` */) {
      return false;
    }
    start = pos;
    pos++;
    max = state.posMax;
    // scan marker length
        while (pos < max && state.src.charCodeAt(pos) === 96 /* ` */) {
      pos++;
    }
    marker = state.src.slice(start, pos);
    openerLength = marker.length;
    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
      if (!silent) state.pending += marker;
      state.pos += openerLength;
      return true;
    }
    matchStart = matchEnd = pos;
    // Nothing found in the cache, scan until the end of the line (or until marker is found)
        while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
      matchEnd = matchStart + 1;
      // scan marker length
            while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96 /* ` */) {
        matchEnd++;
      }
      closerLength = matchEnd - matchStart;
      if (closerLength === openerLength) {
        // Found matching closer length.
        if (!silent) {
          token = state.push("code_inline", "code", 0);
          token.markup = marker;
          token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
        }
        state.pos = matchEnd;
        return true;
      }
      // Some different length found, put it in cache as upper limit of where closer can be found
            state.backticks[closerLength] = matchStart;
    }
    // Scanned through the end, didn't find anything
        state.backticksScanned = true;
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  };
  // ~~strike through~~
  // Insert each marker as a separate text token, and add it to delimiter list
  
    var tokenize$1 = function strikethrough(state, silent) {
    var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 126 /* ~ */) {
      return false;
    }
    scanned = state.scanDelims(state.pos, true);
    len = scanned.length;
    ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      token = state.push("text", "", 0);
      token.content = ch;
      len--;
    }
    for (i = 0; i < len; i += 2) {
      token = state.push("text", "", 0);
      token.content = ch + ch;
      state.delimiters.push({
        marker: marker,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  };
  function postProcess$1(state, delimiters) {
    var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
    for (i = 0; i < max; i++) {
      startDelim = delimiters[i];
      if (startDelim.marker !== 126 /* ~ */) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      endDelim = delimiters[startDelim.end];
      token = state.tokens[startDelim.token];
      token.type = "s_open";
      token.tag = "s";
      token.nesting = 1;
      token.markup = "~~";
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = "s_close";
      token.tag = "s";
      token.nesting = -1;
      token.markup = "~~";
      token.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    // If a marker sequence has an odd number of characters, it's splitted
    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
    // start of the sequence.
    
    // So, we have to move all those markers after subsequent s_close tags.
    
        while (loneMarkers.length) {
      i = loneMarkers.pop();
      j = i + 1;
      while (j < state.tokens.length && state.tokens[j].type === "s_close") {
        j++;
      }
      j--;
      if (i !== j) {
        token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }
  // Walk through delimiter list and replace text tokens with tags
  
    var postProcess_1$1 = function strikethrough(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    postProcess$1(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess$1(state, tokens_meta[curr].delimiters);
      }
    }
  };
  var strikethrough = {
    tokenize: tokenize$1,
    postProcess: postProcess_1$1
  };
  // Process *this* and _that_
  // Insert each marker as a separate text token, and add it to delimiter list
  
    var tokenize = function emphasis(state, silent) {
    var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 95 /* _ */ && marker !== 42 /* * */) {
      return false;
    }
    scanned = state.scanDelims(state.pos, marker === 42);
    for (i = 0; i < scanned.length; i++) {
      token = state.push("text", "", 0);
      token.content = String.fromCharCode(marker);
      state.delimiters.push({
        // Char code of the starting marker (number).
        marker: marker,
        // Total length of these series of delimiters.
        length: scanned.length,
        // A position of the token this delimiter corresponds to.
        token: state.tokens.length - 1,
        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        end: -1,
        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  };
  function postProcess(state, delimiters) {
    var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
    for (i = max - 1; i >= 0; i--) {
      startDelim = delimiters[i];
      if (startDelim.marker !== 95 /* _ */ && startDelim.marker !== 42 /* * */) {
        continue;
      }
      // Process only opening markers
            if (startDelim.end === -1) {
        continue;
      }
      endDelim = delimiters[startDelim.end];
      // If the previous delimiter has the same marker and is adjacent to this one,
      // merge those into one strong delimiter.
      
      // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
      
            isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && 
      // check that first two markers match and adjacent
      delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && 
      // check that last two markers are adjacent (we can safely assume they match)
      delimiters[startDelim.end + 1].token === endDelim.token + 1;
      ch = String.fromCharCode(startDelim.marker);
      token = state.tokens[startDelim.token];
      token.type = isStrong ? "strong_open" : "em_open";
      token.tag = isStrong ? "strong" : "em";
      token.nesting = 1;
      token.markup = isStrong ? ch + ch : ch;
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = isStrong ? "strong_close" : "em_close";
      token.tag = isStrong ? "strong" : "em";
      token.nesting = -1;
      token.markup = isStrong ? ch + ch : ch;
      token.content = "";
      if (isStrong) {
        state.tokens[delimiters[i - 1].token].content = "";
        state.tokens[delimiters[startDelim.end + 1].token].content = "";
        i--;
      }
    }
  }
  // Walk through delimiter list and replace text tokens with tags
  
    var postProcess_1 = function emphasis(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    postProcess(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess(state, tokens_meta[curr].delimiters);
      }
    }
  };
  var emphasis = {
    tokenize: tokenize,
    postProcess: postProcess_1
  };
  var normalizeReference$1 = utils.normalizeReference;
  var isSpace$1 = utils.isSpace;
  var link = function link(state, silent) {
    var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
    if (state.src.charCodeAt(state.pos) !== 91 /* [ */) {
      return false;
    }
    labelStart = state.pos + 1;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
    // parser failed to find ']', so it's not a valid link
        if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {
      // Inline link
      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;
      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
            pos++;
      for (;pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace$1(code) && code !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
            start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
        // [link](  <href>  "title"  )
        //                ^^ skipping these spaces
                start = pos;
        for (;pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$1(code) && code !== 10) {
            break;
          }
        }
        // [link](  <href>  "title"  )
        //                  ^^^^^^^ parsing link title
                res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          // [link](  <href>  "title"  )
          //                         ^^ skipping these spaces
                    for (;pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace$1(code) && code !== 10) {
              break;
            }
          }
        }
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {
        // parsing a valid shortcut link failed, fallback to reference
        parseReference = true;
      }
      pos++;
    }
    if (parseReference) {
      // Link reference
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      // covers label === '' and label === undefined
      // (collapsed reference link and shortcut reference link respectively)
            if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference$1(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    
    // We found the end of the link, and know for a fact it's a valid link;
    // so all that's left to do is to call tokenizer.
    
        if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      token = state.push("link_open", "a", 1);
      token.attrs = attrs = [ [ "href", href ] ];
      if (title) {
        attrs.push([ "title", title ]);
      }
      state.md.inline.tokenize(state);
      token = state.push("link_close", "a", -1);
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
  var normalizeReference = utils.normalizeReference;
  var isSpace = utils.isSpace;
  var image = function image(state, silent) {
    var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 33 /* ! */) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 91 /* [ */) {
      return false;
    }
    labelStart = state.pos + 2;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
    // parser failed to find ']', so it's not a valid link
        if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {
      // Inline link
      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (;pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
            start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
      }
      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
            start = pos;
      for (;pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 10) {
          break;
        }
      }
      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
            res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
                for (;pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
      } else {
        title = "";
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {
        state.pos = oldPos;
        return false;
      }
      pos++;
    } else {
      // Link reference
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      // covers label === '' and label === undefined
      // (collapsed reference link and shortcut reference link respectively)
            if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    
    // We found the end of the link, and know for a fact it's a valid link;
    // so all that's left to do is to call tokenizer.
    
        if (!silent) {
      content = state.src.slice(labelStart, labelEnd);
      state.md.inline.parse(content, state.md, state.env, tokens = []);
      token = state.push("image", "img", 0);
      token.attrs = attrs = [ [ "src", href ], [ "alt", "" ] ];
      token.children = tokens;
      token.content = content;
      if (title) {
        attrs.push([ "title", title ]);
      }
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
  // Process autolinks '<protocol:...>'
  /*eslint max-len:0*/  var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
  var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
  var autolink = function autolink(state, silent) {
    var url, fullUrl, token, ch, start, max, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60 /* < */) {
      return false;
    }
    start = state.pos;
    max = state.posMax;
    for (;;) {
      if (++pos >= max) return false;
      ch = state.src.charCodeAt(pos);
      if (ch === 60 /* < */) return false;
      if (ch === 62 /* > */) break;
    }
    url = state.src.slice(start + 1, pos);
    if (AUTOLINK_RE.test(url)) {
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        token = state.push("link_open", "a", 1);
        token.attrs = [ [ "href", fullUrl ] ];
        token.markup = "autolink";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "autolink";
        token.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    if (EMAIL_RE.test(url)) {
      fullUrl = state.md.normalizeLink("mailto:" + url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        token = state.push("link_open", "a", 1);
        token.attrs = [ [ "href", fullUrl ] ];
        token.markup = "autolink";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "autolink";
        token.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    return false;
  };
  var HTML_TAG_RE = html_re.HTML_TAG_RE;
  function isLetter(ch) {
    /*eslint no-bitwise:0*/
    var lc = ch | 32;
 // to lower case
        return lc >= 97 /* a */ && lc <= 122 /* z */;
  }
  var html_inline = function html_inline(state, silent) {
    var ch, match, max, token, pos = state.pos;
    if (!state.md.options.html) {
      return false;
    }
    // Check start
        max = state.posMax;
    if (state.src.charCodeAt(pos) !== 60 /* < */ || pos + 2 >= max) {
      return false;
    }
    // Quick fail on second char
        ch = state.src.charCodeAt(pos + 1);
    if (ch !== 33 /* ! */ && ch !== 63 /* ? */ && ch !== 47 /* / */ && !isLetter(ch)) {
      return false;
    }
    match = state.src.slice(pos).match(HTML_TAG_RE);
    if (!match) {
      return false;
    }
    if (!silent) {
      token = state.push("html_inline", "", 0);
      token.content = state.src.slice(pos, pos + match[0].length);
    }
    state.pos += match[0].length;
    return true;
  };
  var has = utils.has;
  var isValidEntityCode = utils.isValidEntityCode;
  var fromCodePoint = utils.fromCodePoint;
  var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
  var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
  var entity = function entity(state, silent) {
    var ch, code, match, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 38 /* & */) {
      return false;
    }
    if (pos + 1 < max) {
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities, match[1])) {
            if (!silent) {
              state.pending += entities[match[1]];
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
    }
    if (!silent) {
      state.pending += "&";
    }
    state.pos++;
    return true;
  };
  // For each opening emphasis-like marker find a matching closing one
    function processDelimiters(state, delimiters) {
    var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
    if (!max) return;
    // headerIdx is the first delimiter of the current (where closer is) delimiter run
        var headerIdx = 0;
    var lastTokenIdx = -2;
 // needs any value lower than -1
        var jumps = [];
    for (closerIdx = 0; closerIdx < max; closerIdx++) {
      closer = delimiters[closerIdx];
      jumps.push(0);
      // markers belong to same delimiter run if:
      //  - they have adjacent tokens
      //  - AND markers are the same
      
            if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
        headerIdx = closerIdx;
      }
      lastTokenIdx = closer.token;
      // Length is only used for emphasis-specific "rule of 3",
      // if it's not defined (in strikethrough or 3rd party plugins),
      // we can default it to 0 to disable those checks.
      
            closer.length = closer.length || 0;
      if (!closer.close) continue;
      // Previously calculated lower bounds (previous fails)
      // for each marker, each delimiter length modulo 3,
      // and for whether this closer can be an opener;
      // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460
            if (!openersBottom.hasOwnProperty(closer.marker)) {
        openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];
      }
      minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
      openerIdx = headerIdx - jumps[headerIdx] - 1;
      newMinOpenerIdx = openerIdx;
      for (;openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
        opener = delimiters[openerIdx];
        if (opener.marker !== closer.marker) continue;
        if (opener.open && opener.end < 0) {
          isOddMatch = false;
          // from spec:
          
          // If one of the delimiters can both open and close emphasis, then the
          // sum of the lengths of the delimiter runs containing the opening and
          // closing delimiters must not be a multiple of 3 unless both lengths
          // are multiples of 3.
          
                    if (opener.close || closer.open) {
            if ((opener.length + closer.length) % 3 === 0) {
              if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                isOddMatch = true;
              }
            }
          }
          if (!isOddMatch) {
            // If previous delimiter cannot be an opener, we can safely skip
            // the entire sequence in future checks. This is required to make
            // sure algorithm has linear complexity (see *_*_*_*_*_... case).
            lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
            jumps[closerIdx] = closerIdx - openerIdx + lastJump;
            jumps[openerIdx] = lastJump;
            closer.open = false;
            opener.end = closerIdx;
            opener.close = false;
            newMinOpenerIdx = -1;
            // treat next token as start of run,
            // it optimizes skips in **<...>**a**<...>** pathological case
                        lastTokenIdx = -2;
            break;
          }
        }
      }
      if (newMinOpenerIdx !== -1) {
        // If match for this delimiter run failed, we want to set lower bound for
        // future lookups. This is required to make sure algorithm has linear
        // complexity.
        // See details here:
        // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
        openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
      }
    }
  }
  var balance_pairs = function link_pairs(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    processDelimiters(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        processDelimiters(state, tokens_meta[curr].delimiters);
      }
    }
  };
  // Clean up tokens after emphasis and strikethrough postprocessing:
    var text_collapse = function text_collapse(state) {
    var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
    for (curr = last = 0; curr < max; curr++) {
      // re-calculate levels after emphasis/strikethrough turns some text nodes
      // into opening/closing tags
      if (tokens[curr].nesting < 0) level--;
 // closing tag
            tokens[curr].level = level;
      if (tokens[curr].nesting > 0) level++;
 // opening tag
            if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        // collapse two adjacent text nodes
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  };
  var isWhiteSpace = utils.isWhiteSpace;
  var isPunctChar = utils.isPunctChar;
  var isMdAsciiPunct = utils.isMdAsciiPunct;
  function StateInline(src, md, env, outTokens) {
    this.src = src;
    this.env = env;
    this.md = md;
    this.tokens = outTokens;
    this.tokens_meta = Array(outTokens.length);
    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = "";
    this.pendingLevel = 0;
    // Stores { start: end } pairs. Useful for backtrack
    // optimization of pairs parse (emphasis, strikes).
        this.cache = {};
    // List of emphasis-like delimiters for current tag
        this.delimiters = [];
    // Stack of delimiter lists for upper level tags
        this._prev_delimiters = [];
    // backtick length => last seen position
        this.backticks = {};
    this.backticksScanned = false;
  }
  // Flush pending text
  
    StateInline.prototype.pushPending = function() {
    var token$1 = new token("text", "", 0);
    token$1.content = this.pending;
    token$1.level = this.pendingLevel;
    this.tokens.push(token$1);
    this.pending = "";
    return token$1;
  };
  // Push new token to "stream".
  // If pending text exists - flush it as text token
  
    StateInline.prototype.push = function(type, tag, nesting) {
    if (this.pending) {
      this.pushPending();
    }
    var token$1 = new token(type, tag, nesting);
    var token_meta = null;
    if (nesting < 0) {
      // closing tag
      this.level--;
      this.delimiters = this._prev_delimiters.pop();
    }
    token$1.level = this.level;
    if (nesting > 0) {
      // opening tag
      this.level++;
      this._prev_delimiters.push(this.delimiters);
      this.delimiters = [];
      token_meta = {
        delimiters: this.delimiters
      };
    }
    this.pendingLevel = this.level;
    this.tokens.push(token$1);
    this.tokens_meta.push(token_meta);
    return token$1;
  };
  // Scan a sequence of emphasis-like markers, and determine whether
  // it can start an emphasis sequence or end an emphasis sequence.
  
  //  - start - position to scan from (it should point at a valid marker);
  //  - canSplitWord - determine if these markers can be found inside a word
  
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
    var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
    // treat beginning of the line as a whitespace
        lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
    while (pos < max && this.src.charCodeAt(pos) === marker) {
      pos++;
    }
    count = pos - start;
    // treat end of the line as a whitespace
        nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
    isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
    isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
    isLastWhiteSpace = isWhiteSpace(lastChar);
    isNextWhiteSpace = isWhiteSpace(nextChar);
    if (isNextWhiteSpace) {
      left_flanking = false;
    } else if (isNextPunctChar) {
      if (!(isLastWhiteSpace || isLastPunctChar)) {
        left_flanking = false;
      }
    }
    if (isLastWhiteSpace) {
      right_flanking = false;
    } else if (isLastPunctChar) {
      if (!(isNextWhiteSpace || isNextPunctChar)) {
        right_flanking = false;
      }
    }
    if (!canSplitWord) {
      can_open = left_flanking && (!right_flanking || isLastPunctChar);
      can_close = right_flanking && (!left_flanking || isNextPunctChar);
    } else {
      can_open = left_flanking;
      can_close = right_flanking;
    }
    return {
      can_open: can_open,
      can_close: can_close,
      length: count
    };
  };
  // re-export Token class to use in block rules
    StateInline.prototype.Token = token;
  var state_inline = StateInline;
  ////////////////////////////////////////////////////////////////////////////////
  // Parser rules
    var _rules = [ [ "text", text ], [ "newline", newline ], [ "escape", _escape ], [ "backticks", backticks ], [ "strikethrough", strikethrough.tokenize ], [ "emphasis", emphasis.tokenize ], [ "link", link ], [ "image", image ], [ "autolink", autolink ], [ "html_inline", html_inline ], [ "entity", entity ] ];
  var _rules2 = [ [ "balance_pairs", balance_pairs ], [ "strikethrough", strikethrough.postProcess ], [ "emphasis", emphasis.postProcess ], [ "text_collapse", text_collapse ] ];
  /**
	 * new ParserInline()
	 **/  function ParserInline() {
    var i;
    /**
	   * ParserInline#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of inline rules.
	   **/    this.ruler = new ruler;
    for (i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }
    /**
	   * ParserInline#ruler2 -> Ruler
	   *
	   * [[Ruler]] instance. Second ruler used for post-processing
	   * (e.g. in emphasis-like rules).
	   **/    this.ruler2 = new ruler;
    for (i = 0; i < _rules2.length; i++) {
      this.ruler2.push(_rules2[i][0], _rules2[i][1]);
    }
  }
  // Skip single token by running all rules in validation mode;
  // returns `true` if any rule reported success
  
    ParserInline.prototype.skipToken = function(state) {
    var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
    if (typeof cache[pos] !== "undefined") {
      state.pos = cache[pos];
      return;
    }
    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        // Increment state.level and decrement it later to limit recursion.
        // It's harmless to do here, because no tokens are created. But ideally,
        // we'd need a separate private state variable for this purpose.
        state.level++;
        ok = rules[i](state, true);
        state.level--;
        if (ok) {
          break;
        }
      }
    } else {
      // Too much nesting, just skip until the end of the paragraph.
      // NOTE: this will cause links to behave incorrectly in the following case,
      //       when an amount of `[` is exactly equal to `maxNesting + 1`:
      //       [[[[[[[[[[[[[[[[[[[[[foo]()
      // TODO: remove this workaround when CM standard will allow nested links
      //       (we can replace it by preventing links from being parsed in
      //       validation mode)
      state.pos = state.posMax;
    }
    if (!ok) {
      state.pos++;
    }
    cache[pos] = state.pos;
  };
  // Generate tokens for input range
  
    ParserInline.prototype.tokenize = function(state) {
    var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
    while (state.pos < end) {
      // Try all possible rules.
      // On success, rule should:
      // - update `state.pos`
      // - update `state.tokens`
      // - return true
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          ok = rules[i](state, false);
          if (ok) {
            break;
          }
        }
      }
      if (ok) {
        if (state.pos >= end) {
          break;
        }
        continue;
      }
      state.pending += state.src[state.pos++];
    }
    if (state.pending) {
      state.pushPending();
    }
  };
  /**
	 * ParserInline.parse(str, md, env, outTokens)
	 *
	 * Process input string and push inline tokens into `outTokens`
	 **/  ParserInline.prototype.parse = function(str, md, env, outTokens) {
    var i, rules, len;
    var state = new this.State(str, md, env, outTokens);
    this.tokenize(state);
    rules = this.ruler2.getRules("");
    len = rules.length;
    for (i = 0; i < len; i++) {
      rules[i](state);
    }
  };
  ParserInline.prototype.State = state_inline;
  var parser_inline = ParserInline;
  var re = function(opts) {
    var re = {};
    // Use direct extract instead of `regenerate` to reduse browserified size
        re.src_Any = regex$3.source;
    re.src_Cc = regex$2.source;
    re.src_Z = regex.source;
    re.src_P = regex$4.source;
    // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
        re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join("|");
    // \p{\Z\Cc} (white spaces + control)
        re.src_ZCc = [ re.src_Z, re.src_Cc ].join("|");
    // Experimental. List of chars, completely prohibited in links
    // because can separate it from other part of text
        var text_separators = "[><\uff5c]";
    // All possible word characters (everything without punctuation, spaces & controls)
    // Defined via punctuation & spaces to save space
    // Should be something like \p{\L\N\S\M} (\w but without `_`)
        re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
    // The same as abothe but without [0-9]
    // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';
    ////////////////////////////////////////////////////////////////////////////////
        re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
    // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
        re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
    re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
    re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
    re.src_path = "(?:" + "[/?#]" + "(?:" + "(?!" + re.src_ZCc + "|" + text_separators + "|[()[\\]{}.,\"'?!\\-;]).|" + "\\[(?:(?!" + re.src_ZCc + "|\\]).)*\\]|" + "\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|" + "\\{(?:(?!" + re.src_ZCc + "|[}]).)*\\}|" + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + "|[-]).|" + // allow `I'm_king` if no pair found
    "\\.{2,}[a-zA-Z0-9%/&]|" + // google has many dots in "google search" links (#66, #81).
    // github has ... in commit range links,
    // Restrict to
    // - english
    // - percent-encoded
    // - parts of file path
    // - params separator
    // until more examples found.
    "\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|" + // allow `,,,` in paths
    ";(?!" + re.src_ZCc + ").|" + // allow `;` if not followed by space-like char
    "\\!+(?!" + re.src_ZCc + "|[!]).|" + // allow `!!!` in paths, but not at the end
    "\\?(?!" + re.src_ZCc + "|[?])." + ")+" + "|\\/" + ")?";
    // Allow anything in markdown spec, forbid quote (") at the first position
    // because emails enclosed in quotes are far more common
        re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
    re.src_xn = "xn--[a-z0-9\\-]{1,59}";
    // More to read about domain names
    // http://serverfault.com/questions/638260/
        re.src_domain_root = 
    // Allow letters & digits (http://test1)
    "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63}" + ")";
    re.src_domain = "(?:" + re.src_xn + "|" + "(?:" + re.src_pseudo_letter + ")" + "|" + "(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + ")" + ")";
    re.src_host = "(?:" + 
    // Don't need IP check, because digits are already allowed in normal domain names
    //   src_ip4 +
    // '|' +
    "(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain /*_root*/ + ")" + ")";
    re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|" + "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))" + ")";
    re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
    re.src_host_strict = re.src_host + re.src_host_terminator;
    re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
    re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
    re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
    re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
    ////////////////////////////////////////////////////////////////////////////////
    // Main rules
    // Rude test fuzzy links by host, for quick deny
        re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
    re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")" + "(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
    re.tpl_link_fuzzy = 
    // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|" + re.src_ZPCc + "))" + "((?![$+<=>^`|\uff5c])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
    re.tpl_link_no_ip_fuzzy = 
    // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|" + re.src_ZPCc + "))" + "((?![$+<=>^`|\uff5c])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
    return re;
  };
  ////////////////////////////////////////////////////////////////////////////////
  // Helpers
  // Merge objects
  
    function assign(obj /*from1, from2, from3, ...*/) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach((function(source) {
      if (!source) {
        return;
      }
      Object.keys(source).forEach((function(key) {
        obj[key] = source[key];
      }));
    }));
    return obj;
  }
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString(obj) {
    return _class(obj) === "[object String]";
  }
  function isObject(obj) {
    return _class(obj) === "[object Object]";
  }
  function isRegExp(obj) {
    return _class(obj) === "[object RegExp]";
  }
  function isFunction(obj) {
    return _class(obj) === "[object Function]";
  }
  function escapeRE(str) {
    return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  ////////////////////////////////////////////////////////////////////////////////
    var defaultOptions = {
    fuzzyLink: true,
    fuzzyEmail: true,
    fuzzyIP: false
  };
  function isOptionsObj(obj) {
    return Object.keys(obj || {}).reduce((function(acc, k) {
      return acc || defaultOptions.hasOwnProperty(k);
    }), false);
  }
  var defaultSchemas = {
    "http:": {
      validate: function(text, pos, self) {
        var tail = text.slice(pos);
        if (!self.re.http) {
          // compile lazily, because "host"-containing variables can change on tlds update.
          self.re.http = new RegExp("^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, "i");
        }
        if (self.re.http.test(tail)) {
          return tail.match(self.re.http)[0].length;
        }
        return 0;
      }
    },
    "https:": "http:",
    "ftp:": "http:",
    "//": {
      validate: function(text, pos, self) {
        var tail = text.slice(pos);
        if (!self.re.no_http) {
          // compile lazily, because "host"-containing variables can change on tlds update.
          self.re.no_http = new RegExp("^" + self.re.src_auth + 
          // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, "i");
        }
        if (self.re.no_http.test(tail)) {
          // should not be `://` & `///`, that protects from errors in protocol name
          if (pos >= 3 && text[pos - 3] === ":") {
            return 0;
          }
          if (pos >= 3 && text[pos - 3] === "/") {
            return 0;
          }
          return tail.match(self.re.no_http)[0].length;
        }
        return 0;
      }
    },
    "mailto:": {
      validate: function(text, pos, self) {
        var tail = text.slice(pos);
        if (!self.re.mailto) {
          self.re.mailto = new RegExp("^" + self.re.src_email_name + "@" + self.re.src_host_strict, "i");
        }
        if (self.re.mailto.test(tail)) {
          return tail.match(self.re.mailto)[0].length;
        }
        return 0;
      }
    }
  };
  /*eslint-disable max-len*/
  // RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
  // DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
  /*eslint-enable max-len*/
  ////////////////////////////////////////////////////////////////////////////////
    function resetScanCache(self) {
    self.__index__ = -1;
    self.__text_cache__ = "";
  }
  function createValidator(re) {
    return function(text, pos) {
      var tail = text.slice(pos);
      if (re.test(tail)) {
        return tail.match(re)[0].length;
      }
      return 0;
    };
  }
  function createNormalizer() {
    return function(match, self) {
      self.normalize(match);
    };
  }
  // Schemas compiler. Build regexps.
  
    function compile(self) {
    // Load & clone RE patterns.
    var re$1 = self.re = re(self.__opts__);
    // Define dynamic patterns
        var tlds = self.__tlds__.slice();
    self.onCompile();
    if (!self.__tlds_replaced__) {
      tlds.push(tlds_2ch_src_re);
    }
    tlds.push(re$1.src_xn);
    re$1.src_tlds = tlds.join("|");
    function untpl(tpl) {
      return tpl.replace("%TLDS%", re$1.src_tlds);
    }
    re$1.email_fuzzy = RegExp(untpl(re$1.tpl_email_fuzzy), "i");
    re$1.link_fuzzy = RegExp(untpl(re$1.tpl_link_fuzzy), "i");
    re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), "i");
    re$1.host_fuzzy_test = RegExp(untpl(re$1.tpl_host_fuzzy_test), "i");
    
    // Compile each schema
    
        var aliases = [];
    self.__compiled__ = {};
 // Reset compiled data
        function schemaError(name, val) {
      throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
    }
    Object.keys(self.__schemas__).forEach((function(name) {
      var val = self.__schemas__[name];
      // skip disabled methods
            if (val === null) {
        return;
      }
      var compiled = {
        validate: null,
        link: null
      };
      self.__compiled__[name] = compiled;
      if (isObject(val)) {
        if (isRegExp(val.validate)) {
          compiled.validate = createValidator(val.validate);
        } else if (isFunction(val.validate)) {
          compiled.validate = val.validate;
        } else {
          schemaError(name, val);
        }
        if (isFunction(val.normalize)) {
          compiled.normalize = val.normalize;
        } else if (!val.normalize) {
          compiled.normalize = createNormalizer();
        } else {
          schemaError(name, val);
        }
        return;
      }
      if (isString(val)) {
        aliases.push(name);
        return;
      }
      schemaError(name, val);
    }));
    
    // Compile postponed aliases
    
        aliases.forEach((function(alias) {
      if (!self.__compiled__[self.__schemas__[alias]]) {
        // Silently fail on missed schemas to avoid errons on disable.
        // schemaError(alias, self.__schemas__[alias]);
        return;
      }
      self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
      self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
    }));
    
    // Fake record for guessed links
    
        self.__compiled__[""] = {
      validate: null,
      normalize: createNormalizer()
    };
    
    // Build schema condition
    
        var slist = Object.keys(self.__compiled__).filter((function(name) {
      // Filter disabled & fake schemas
      return name.length > 0 && self.__compiled__[name];
    })).map(escapeRE).join("|");
    // (?!_) cause 1.5x slowdown
        self.re.schema_test = RegExp("(^|(?!_)(?:[><\uff5c]|" + re$1.src_ZPCc + "))(" + slist + ")", "i");
    self.re.schema_search = RegExp("(^|(?!_)(?:[><\uff5c]|" + re$1.src_ZPCc + "))(" + slist + ")", "ig");
    self.re.pretest = RegExp("(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@", "i");
    
    // Cleanup
    
        resetScanCache(self);
  }
  /**
	 * class Match
	 *
	 * Match result. Single element of array, returned by [[LinkifyIt#match]]
	 **/  function Match(self, shift) {
    var start = self.__index__, end = self.__last_index__, text = self.__text_cache__.slice(start, end);
    /**
	   * Match#schema -> String
	   *
	   * Prefix (protocol) for matched string.
	   **/    this.schema = self.__schema__.toLowerCase();
    /**
	   * Match#index -> Number
	   *
	   * First position of matched string.
	   **/    this.index = start + shift;
    /**
	   * Match#lastIndex -> Number
	   *
	   * Next position after matched string.
	   **/    this.lastIndex = end + shift;
    /**
	   * Match#raw -> String
	   *
	   * Matched string.
	   **/    this.raw = text;
    /**
	   * Match#text -> String
	   *
	   * Notmalized text of matched string.
	   **/    this.text = text;
    /**
	   * Match#url -> String
	   *
	   * Normalized url of matched string.
	   **/    this.url = text;
  }
  function createMatch(self, shift) {
    var match = new Match(self, shift);
    self.__compiled__[match.schema].normalize(match, self);
    return match;
  }
  /**
	 * class LinkifyIt
	 **/
  /**
	 * new LinkifyIt(schemas, options)
	 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Creates new linkifier instance with optional additional schemas.
	 * Can be called without `new` keyword for convenience.
	 *
	 * By default understands:
	 *
	 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
	 * - "fuzzy" links and emails (example.com, foo@bar.com).
	 *
	 * `schemas` is an object, where each key/value describes protocol/rule:
	 *
	 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
	 *   for example). `linkify-it` makes shure that prefix is not preceeded with
	 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
	 * - __value__ - rule to check tail after link prefix
	 *   - _String_ - just alias to existing rule
	 *   - _Object_
	 *     - _validate_ - validator function (should return matched length on success),
	 *       or `RegExp`.
	 *     - _normalize_ - optional function to normalize text & url of matched result
	 *       (for example, for @twitter mentions).
	 *
	 * `options`:
	 *
	 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
	 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
	 *   like version numbers. Default `false`.
	 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
	 *
	 **/  function LinkifyIt(schemas, options) {
    if (!(this instanceof LinkifyIt)) {
      return new LinkifyIt(schemas, options);
    }
    if (!options) {
      if (isOptionsObj(schemas)) {
        options = schemas;
        schemas = {};
      }
    }
    this.__opts__ = assign({}, defaultOptions, options);
    // Cache last tested result. Used to skip repeating steps on next `match` call.
        this.__index__ = -1;
    this.__last_index__ = -1;
 // Next scan position
        this.__schema__ = "";
    this.__text_cache__ = "";
    this.__schemas__ = assign({}, defaultSchemas, schemas);
    this.__compiled__ = {};
    this.__tlds__ = tlds_default;
    this.__tlds_replaced__ = false;
    this.re = {};
    compile(this);
  }
  /** chainable
	 * LinkifyIt#add(schema, definition)
	 * - schema (String): rule name (fixed pattern prefix)
	 * - definition (String|RegExp|Object): schema definition
	 *
	 * Add new rule definition. See constructor description for details.
	 **/  LinkifyIt.prototype.add = function add(schema, definition) {
    this.__schemas__[schema] = definition;
    compile(this);
    return this;
  };
  /** chainable
	 * LinkifyIt#set(options)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Set recognition options for links without schema.
	 **/  LinkifyIt.prototype.set = function set(options) {
    this.__opts__ = assign(this.__opts__, options);
    return this;
  };
  /**
	 * LinkifyIt#test(text) -> Boolean
	 *
	 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
	 **/  LinkifyIt.prototype.test = function test(text) {
    // Reset scan cache
    this.__text_cache__ = text;
    this.__index__ = -1;
    if (!text.length) {
      return false;
    }
    var m, ml, me, len, shift, next, re, tld_pos, at_pos;
    // try to scan for link with schema - that's the most simple rule
        if (this.re.schema_test.test(text)) {
      re = this.re.schema_search;
      re.lastIndex = 0;
      while ((m = re.exec(text)) !== null) {
        len = this.testSchemaAt(text, m[2], re.lastIndex);
        if (len) {
          this.__schema__ = m[2];
          this.__index__ = m.index + m[1].length;
          this.__last_index__ = m.index + m[0].length + len;
          break;
        }
      }
    }
    if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
      // guess schemaless links
      tld_pos = text.search(this.re.host_fuzzy_test);
      if (tld_pos >= 0) {
        // if tld is located after found link - no need to check fuzzy pattern
        if (this.__index__ < 0 || tld_pos < this.__index__) {
          if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
            shift = ml.index + ml[1].length;
            if (this.__index__ < 0 || shift < this.__index__) {
              this.__schema__ = "";
              this.__index__ = shift;
              this.__last_index__ = ml.index + ml[0].length;
            }
          }
        }
      }
    }
    if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
      // guess schemaless emails
      at_pos = text.indexOf("@");
      if (at_pos >= 0) {
        // We can't skip this check, because this cases are possible:
        // 192.168.1.1@gmail.com, my.in@example.com
        if ((me = text.match(this.re.email_fuzzy)) !== null) {
          shift = me.index + me[1].length;
          next = me.index + me[0].length;
          if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
            this.__schema__ = "mailto:";
            this.__index__ = shift;
            this.__last_index__ = next;
          }
        }
      }
    }
    return this.__index__ >= 0;
  };
  /**
	 * LinkifyIt#pretest(text) -> Boolean
	 *
	 * Very quick check, that can give false positives. Returns true if link MAY BE
	 * can exists. Can be used for speed optimization, when you need to check that
	 * link NOT exists.
	 **/  LinkifyIt.prototype.pretest = function pretest(text) {
    return this.re.pretest.test(text);
  };
  /**
	 * LinkifyIt#testSchemaAt(text, name, position) -> Number
	 * - text (String): text to scan
	 * - name (String): rule (schema) name
	 * - position (Number): text offset to check from
	 *
	 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
	 * at given position. Returns length of found pattern (0 on fail).
	 **/  LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
    // If not supported schema check requested - terminate
    if (!this.__compiled__[schema.toLowerCase()]) {
      return 0;
    }
    return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
  };
  /**
	 * LinkifyIt#match(text) -> Array|null
	 *
	 * Returns array of found link descriptions or `null` on fail. We strongly
	 * recommend to use [[LinkifyIt#test]] first, for best speed.
	 *
	 * ##### Result match description
	 *
	 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
	 *   protocol-neutral  links.
	 * - __index__ - offset of matched text
	 * - __lastIndex__ - index of next char after mathch end
	 * - __raw__ - matched text
	 * - __text__ - normalized text
	 * - __url__ - link, generated from matched text
	 **/  LinkifyIt.prototype.match = function match(text) {
    var shift = 0, result = [];
    // Try to take previous element from cache, if .test() called before
        if (this.__index__ >= 0 && this.__text_cache__ === text) {
      result.push(createMatch(this, shift));
      shift = this.__last_index__;
    }
    // Cut head if cache was used
        var tail = shift ? text.slice(shift) : text;
    // Scan string until end reached
        while (this.test(tail)) {
      result.push(createMatch(this, shift));
      tail = tail.slice(this.__last_index__);
      shift += this.__last_index__;
    }
    if (result.length) {
      return result;
    }
    return null;
  };
  /** chainable
	 * LinkifyIt#tlds(list [, keepOld]) -> this
	 * - list (Array): list of tlds
	 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
	 *
	 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
	 * to avoid false positives. By default this algorythm used:
	 *
	 * - hostname with any 2-letter root zones are ok.
	 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|
	 *   are ok.
	 * - encoded (`xn--...`) root zones are ok.
	 *
	 * If list is replaced, then exact match for 2-chars root zones will be checked.
	 **/  LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
    list = Array.isArray(list) ? list : [ list ];
    if (!keepOld) {
      this.__tlds__ = list.slice();
      this.__tlds_replaced__ = true;
      compile(this);
      return this;
    }
    this.__tlds__ = this.__tlds__.concat(list).sort().filter((function(el, idx, arr) {
      return el !== arr[idx - 1];
    })).reverse();
    compile(this);
    return this;
  };
  /**
	 * LinkifyIt#normalize(match)
	 *
	 * Default normalizer (if schema does not define it's own).
	 **/  LinkifyIt.prototype.normalize = function normalize(match) {
    // Do minimal possible changes by default. Need to collect feedback prior
    // to move forward https://github.com/markdown-it/linkify-it/issues/1
    if (!match.schema) {
      match.url = "http://" + match.url;
    }
    if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
      match.url = "mailto:" + match.url;
    }
  };
  /**
	 * LinkifyIt#onCompile()
	 *
	 * Override to modify basic RegExp-s.
	 **/  LinkifyIt.prototype.onCompile = function onCompile() {};
  var linkifyIt = LinkifyIt;
  /*! https://mths.be/punycode v1.4.1 by @mathias */
  /** Highest positive signed 32-bit float value */  var maxInt = 2147483647;
 // aka. 0x7FFFFFFF or 2^31-1
  /** Bootstring parameters */  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
 // 0x80
    var delimiter = "-";
 // '\x2D'
  /** Regular expressions */  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\x20-\x7E]/;
 // unprintable ASCII chars + non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
 // RFC 3490 separators
  /** Error messages */  var errors = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  /** Convenience shortcuts */  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  /*--------------------------------------------------------------------------*/
  /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */  function error(type) {
    throw new RangeError(errors[type]);
  }
  /**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */  function map(array, fn) {
    var length = array.length;
    var result = [];
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }
  /**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */  function mapDomain(string, fn) {
    var parts = string.split("@");
    var result = "";
    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + "@";
      string = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, ".");
    var labels = string.split(".");
    var encoded = map(labels, fn).join(".");
    return result + encoded;
  }
  /**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */  function ucs2decode(string) {
    var output = [], counter = 0, length = string.length, value, extra;
    while (counter < length) {
      value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          // low surrogate
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  /**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */  function ucs2encode(array) {
    return map(array, (function(value) {
      var output = "";
      if (value > 65535) {
        value -= 65536;
        output += stringFromCharCode(value >>> 10 & 1023 | 55296);
        value = 56320 | value & 1023;
      }
      output += stringFromCharCode(value);
      return output;
    })).join("");
  }
  /**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }
    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }
    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }
    return base;
  }
  /**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */  function decode(input) {
    // Don't use UCS-2
    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, 
    /** Cached calculation results */
    baseMinusT;
    // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.
        basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base; ;k += base) {
        if (index >= inputLength) {
          error("invalid-input");
        }
        digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error("overflow");
        }
        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w *= baseMinusT;
      }
      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
        error("overflow");
      }
      n += floor(i / out);
      i %= out;
      // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);
    }
    return ucs2encode(output);
  }
  /**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */  function encode(input) {
    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], 
    /** `inputLength` will hold the number of code points in `input`. */
    inputLength, 
    /** Cached calculation results */
    handledCPCountPlusOne, baseMinusT, qMinusT;
    // Convert the input in UCS-2 to Unicode
        input = ucs2decode(input);
    // Cache the length
        inputLength = input.length;
    // Initialize the state
        n = initialN;
    delta = 0;
    bias = initialBias;
    // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    handledCPCount = basicLength = output.length;
    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
      output.push(delimiter);
    }
    // Main encoding loop:
        while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base; ;k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  }
  /**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */  function toUnicode(input) {
    return mapDomain(input, (function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    }));
  }
  /**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */  function toASCII(input) {
    return mapDomain(input, (function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    }));
  }
  var version = "1.4.1";
  /**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */  var ucs2 = {
    decode: ucs2decode,
    encode: ucs2encode
  };
  var punycode$1 = {
    version: version,
    ucs2: ucs2,
    toASCII: toASCII,
    toUnicode: toUnicode,
    encode: encode,
    decode: decode
  };
  var punycode$2 =  Object.freeze({
    __proto__: null,
    decode: decode,
    encode: encode,
    toUnicode: toUnicode,
    toASCII: toASCII,
    version: version,
    ucs2: ucs2,
    default: punycode$1
  });
  // markdown-it default options
    var _default = {
    options: {
      html: false,
      // Enable HTML tags in source
      xhtmlOut: false,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      // For example, you can use '' for Russian, '' for German,
      // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
      quotes: "\u201c\u201d\u2018\u2019",
      /*  */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      // function (/*str, lang*/) { return ''; }
      highlight: null,
      maxNesting: 100
    },
    components: {
      core: {},
      block: {},
      inline: {}
    }
  };
  // "Zero" preset, with nothing enabled. Useful for manual configuring of simple
    var zero = {
    options: {
      html: false,
      // Enable HTML tags in source
      xhtmlOut: false,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      // For example, you can use '' for Russian, '' for German,
      // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
      quotes: "\u201c\u201d\u2018\u2019",
      /*  */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      // function (/*str, lang*/) { return ''; }
      highlight: null,
      maxNesting: 20
    },
    components: {
      core: {
        rules: [ "normalize", "block", "inline" ]
      },
      block: {
        rules: [ "paragraph" ]
      },
      inline: {
        rules: [ "text" ],
        rules2: [ "balance_pairs", "text_collapse" ]
      }
    }
  };
  // Commonmark default options
    var commonmark = {
    options: {
      html: true,
      // Enable HTML tags in source
      xhtmlOut: true,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      // For example, you can use '' for Russian, '' for German,
      // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
      quotes: "\u201c\u201d\u2018\u2019",
      /*  */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      // function (/*str, lang*/) { return ''; }
      highlight: null,
      maxNesting: 20
    },
    components: {
      core: {
        rules: [ "normalize", "block", "inline" ]
      },
      block: {
        rules: [ "blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph" ]
      },
      inline: {
        rules: [ "autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text" ],
        rules2: [ "balance_pairs", "emphasis", "text_collapse" ]
      }
    }
  };
  var punycode =  getAugmentedNamespace(punycode$2);
  var config = {
    default: _default,
    zero: zero,
    commonmark: commonmark
  };
  ////////////////////////////////////////////////////////////////////////////////
  
  // This validator can prohibit more than really needed to prevent XSS. It's a
  // tradeoff to keep code simple and to be secure by default.
  
  // If you need different setup - override validator method as you wish. Or
  // replace it with dummy function and use external sanitizer.
  
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
  var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
  function validateLink(url) {
    // url should be normalized at this point, and existing entities are decoded
    var str = url.trim().toLowerCase();
    return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
  }
  ////////////////////////////////////////////////////////////////////////////////
    var RECODE_HOSTNAME_FOR = [ "http:", "https:", "mailto:" ];
  function normalizeLink(url) {
    var parsed = mdurl.parse(url, true);
    if (parsed.hostname) {
      // Encode hostnames in urls like:
      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
      // We don't encode unknown schemas, because it's likely that we encode
      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toASCII(parsed.hostname);
        } catch (er) {}
      }
    }
    return mdurl.encode(mdurl.format(parsed));
  }
  function normalizeLinkText(url) {
    var parsed = mdurl.parse(url, true);
    if (parsed.hostname) {
      // Encode hostnames in urls like:
      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
      // We don't encode unknown schemas, because it's likely that we encode
      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toUnicode(parsed.hostname);
        } catch (er) {}
      }
    }
    // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
        return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
  }
  /**
	 * class MarkdownIt
	 *
	 * Main parser/renderer class.
	 *
	 * ##### Usage
	 *
	 * ```javascript
	 * // node.js, "classic" way:
	 * var MarkdownIt = require('markdown-it'),
	 *     md = new MarkdownIt();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // node.js, the same, but with sugar:
	 * var md = require('markdown-it')();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // browser without AMD, added to "window" on script load
	 * // Note, there are no dash.
	 * var md = window.markdownit();
	 * var result = md.render('# markdown-it rulezz!');
	 * ```
	 *
	 * Single line rendering, without paragraph wrap:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 * var result = md.renderInline('__markdown-it__ rulezz!');
	 * ```
	 **/
  /**
	 * new MarkdownIt([presetName, options])
	 * - presetName (String): optional, `commonmark` / `zero`
	 * - options (Object)
	 *
	 * Creates parser instanse with given config. Can be called without `new`.
	 *
	 * ##### presetName
	 *
	 * MarkdownIt provides named presets as a convenience to quickly
	 * enable/disable active syntax rules and options for common use cases.
	 *
	 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
	 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
	 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
	 *   similar to GFM, used when no preset name given. Enables all available rules,
	 *   but still without html, typographer & autolinker.
	 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
	 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
	 *   For example, when you need only `bold` and `italic` markup and nothing else.
	 *
	 * ##### options:
	 *
	 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
	 *   That's not safe! You may need external sanitizer to protect output from XSS.
	 *   It's better to extend features via plugins, instead of enabling HTML.
	 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
	 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
	 *   world you will need HTML output.
	 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
	 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
	 *   Can be useful for external highlighters.
	 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
	 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
	 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
	 *   quotes beautification (smartquotes).
	 * - __quotes__ - ``, String or Array. Double + single quotes replacement
	 *   pairs, when typographer enabled and smartquotes on. For example, you can
	 *   use `''` for Russian, `''` for German, and
	 *   `['\xA0', '\xA0', '\xA0', '\xA0']` for French (including nbsp).
	 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
	 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
	 *   return empty string if the source was not changed and should be escaped
	 *   externaly. If result starts with <pre... internal wrapper is skipped.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * // commonmark mode
	 * var md = require('markdown-it')('commonmark');
	 *
	 * // default mode
	 * var md = require('markdown-it')();
	 *
	 * // enable everything
	 * var md = require('markdown-it')({
	 *   html: true,
	 *   linkify: true,
	 *   typographer: true
	 * });
	 * ```
	 *
	 * ##### Syntax highlighting
	 *
	 * ```js
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;
	 *       } catch (__) {}
	 *     }
	 *
	 *     return ''; // use external default escaping
	 *   }
	 * });
	 * ```
	 *
	 * Or with full wrapper override (if you need assign class to `<pre>`):
	 *
	 * ```javascript
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * // Actual default values
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return '<pre class="hljs"><code>' +
	 *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
	 *                '</code></pre>';
	 *       } catch (__) {}
	 *     }
	 *
	 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
	 *   }
	 * });
	 * ```
	 *
	 **/  function MarkdownIt(presetName, options) {
    if (!(this instanceof MarkdownIt)) {
      return new MarkdownIt(presetName, options);
    }
    if (!options) {
      if (!utils.isString(presetName)) {
        options = presetName || {};
        presetName = "default";
      }
    }
    /**
	   * MarkdownIt#inline -> ParserInline
	   *
	   * Instance of [[ParserInline]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/    this.inline = new parser_inline;
    /**
	   * MarkdownIt#block -> ParserBlock
	   *
	   * Instance of [[ParserBlock]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/    this.block = new parser_block;
    /**
	   * MarkdownIt#core -> Core
	   *
	   * Instance of [[Core]] chain executor. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/    this.core = new parser_core;
    /**
	   * MarkdownIt#renderer -> Renderer
	   *
	   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
	   * rules for new token types, generated by plugins.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * function myToken(tokens, idx, options, env, self) {
	   *   //...
	   *   return result;
	   * };
	   *
	   * md.renderer.rules['my_token'] = myToken
	   * ```
	   *
	   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
	   **/    this.renderer = new renderer;
    /**
	   * MarkdownIt#linkify -> LinkifyIt
	   *
	   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
	   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
	   * rule.
	   **/    this.linkify = new linkifyIt;
    /**
	   * MarkdownIt#validateLink(url) -> Boolean
	   *
	   * Link validation function. CommonMark allows too much in links. By default
	   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
	   * except some embedded image types.
	   *
	   * You can change this behaviour:
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   * // enable everything
	   * md.validateLink = function () { return true; }
	   * ```
	   **/    this.validateLink = validateLink;
    /**
	   * MarkdownIt#normalizeLink(url) -> String
	   *
	   * Function used to encode link url to a machine-readable format,
	   * which includes url-encoding, punycode, etc.
	   **/    this.normalizeLink = normalizeLink;
    /**
	   * MarkdownIt#normalizeLinkText(url) -> String
	   *
	   * Function used to decode link url to a human-readable format`
	   **/    this.normalizeLinkText = normalizeLinkText;
    // Expose utils & helpers for easy acces from plugins
    /**
	   * MarkdownIt#utils -> utils
	   *
	   * Assorted utility functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
	   **/    this.utils = utils;
    /**
	   * MarkdownIt#helpers -> helpers
	   *
	   * Link components parser functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
	   **/    this.helpers = utils.assign({}, helpers);
    this.options = {};
    this.configure(presetName);
    if (options) {
      this.set(options);
    }
  }
  /** chainable
	 * MarkdownIt.set(options)
	 *
	 * Set parser options (in the same format as in constructor). Probably, you
	 * will never need it, but you can change options after constructor call.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .set({ html: true, breaks: true })
	 *             .set({ typographer, true });
	 * ```
	 *
	 * __Note:__ To achieve the best possible performance, don't modify a
	 * `markdown-it` instance options on the fly. If you need multiple configurations
	 * it's best to create multiple instances and initialize each with separate
	 * config.
	 **/  MarkdownIt.prototype.set = function(options) {
    utils.assign(this.options, options);
    return this;
  };
  /** chainable, internal
	 * MarkdownIt.configure(presets)
	 *
	 * Batch load of all options and compenent settings. This is internal method,
	 * and you probably will not need it. But if you will - see available presets
	 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
	 *
	 * We strongly recommend to use presets instead of direct config loads. That
	 * will give better compatibility with next versions.
	 **/  MarkdownIt.prototype.configure = function(presets) {
    var self = this, presetName;
    if (utils.isString(presets)) {
      presetName = presets;
      presets = config[presetName];
      if (!presets) {
        throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
      }
    }
    if (!presets) {
      throw new Error("Wrong `markdown-it` preset, can't be empty");
    }
    if (presets.options) {
      self.set(presets.options);
    }
    if (presets.components) {
      Object.keys(presets.components).forEach((function(name) {
        if (presets.components[name].rules) {
          self[name].ruler.enableOnly(presets.components[name].rules);
        }
        if (presets.components[name].rules2) {
          self[name].ruler2.enableOnly(presets.components[name].rules2);
        }
      }));
    }
    return this;
  };
  /** chainable
	 * MarkdownIt.enable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to enable
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable list or rules. It will automatically find appropriate components,
	 * containing rules with given names. If rule not found, and `ignoreInvalid`
	 * not set - throws exception.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .enable(['sub', 'sup'])
	 *             .disable('smartquotes');
	 * ```
	 **/  MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
    var result = [];
    if (!Array.isArray(list)) {
      list = [ list ];
    }
    [ "core", "block", "inline" ].forEach((function(chain) {
      result = result.concat(this[chain].ruler.enable(list, true));
    }), this);
    result = result.concat(this.inline.ruler2.enable(list, true));
    var missed = list.filter((function(name) {
      return result.indexOf(name) < 0;
    }));
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
    }
    return this;
  };
  /** chainable
	 * MarkdownIt.disable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * The same as [[MarkdownIt.enable]], but turn specified rules off.
	 **/  MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
    var result = [];
    if (!Array.isArray(list)) {
      list = [ list ];
    }
    [ "core", "block", "inline" ].forEach((function(chain) {
      result = result.concat(this[chain].ruler.disable(list, true));
    }), this);
    result = result.concat(this.inline.ruler2.disable(list, true));
    var missed = list.filter((function(name) {
      return result.indexOf(name) < 0;
    }));
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
    }
    return this;
  };
  /** chainable
	 * MarkdownIt.use(plugin, params)
	 *
	 * Load specified plugin with given params into current parser instance.
	 * It's just a sugar to call `plugin(md, params)` with curring.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var iterator = require('markdown-it-for-inline');
	 * var md = require('markdown-it')()
	 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
	 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
	 *             });
	 * ```
	 **/  MarkdownIt.prototype.use = function(plugin /*, params, ... */) {
    var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
    plugin.apply(plugin, args);
    return this;
  };
  /** internal
	 * MarkdownIt.parse(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Parse input string and return list of block tokens (special token type
	 * "inline" will contain list of inline tokens). You should not call this
	 * method directly, until you write custom renderer (for example, to produce
	 * AST).
	 *
	 * `env` is used to pass data between "distributed" rules and return additional
	 * metadata like reference info, needed for the renderer. It also can be used to
	 * inject data in specific cases. Usually, you will be ok to pass `{}`,
	 * and then pass updated object to renderer.
	 **/  MarkdownIt.prototype.parse = function(src, env) {
    if (typeof src !== "string") {
      throw new Error("Input data should be a String");
    }
    var state = new this.core.State(src, this, env);
    this.core.process(state);
    return state.tokens;
  };
  /**
	 * MarkdownIt.render(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Render markdown string into html. It does all magic for you :).
	 *
	 * `env` can be used to inject additional metadata (`{}` by default).
	 * But you will not need it with high probability. See also comment
	 * in [[MarkdownIt.parse]].
	 **/  MarkdownIt.prototype.render = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parse(src, env), this.options, env);
  };
  /** internal
	 * MarkdownIt.parseInline(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
	 * block tokens list with the single `inline` element, containing parsed inline
	 * tokens in `children` property. Also updates `env` object.
	 **/  MarkdownIt.prototype.parseInline = function(src, env) {
    var state = new this.core.State(src, this, env);
    state.inlineMode = true;
    this.core.process(state);
    return state.tokens;
  };
  /**
	 * MarkdownIt.renderInline(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
	 * will NOT be wrapped into `<p>` tags.
	 **/  MarkdownIt.prototype.renderInline = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parseInline(src, env), this.options, env);
  };
  var lib = MarkdownIt;
  var markdownIt = lib;
  return markdownIt;
}));

define('vellum/markdown',[
    'markdown-it',
    'underscore'
], function(
    markdownIt,
    _
) {
    var md = markdownIt('zero')
             .enable(['link', 'emphasis', 'strikethrough', 'heading', 'list', 'table']),
        defaultRender = md.renderer.rules.link_open || function(tokens, idx, options, env, self) {
            return self.renderToken(tokens, idx, options);
        };

    // https://github.com/markdown-it/markdown-it/blob/6db517357af5bb42398b474efd3755ad33245877/docs/architecture.md#renderer
    md.renderer.rules.link_open = function (tokens, idx, options, env, self) {
        // If you are sure other plugins can't add `target` - drop check below
        var aIndex = tokens[idx].attrIndex('target');

        if (aIndex < 0) {
            tokens[idx].attrPush(['target', '_blank']); // add new attribute
        } else {
            tokens[idx].attrs[aIndex][1] = '_blank';    // replace value of existing attr
        }

        // pass token to default renderer.
        return defaultRender(tokens, idx, options, env, self);
    };

    function markdown(text) {
        if (_.isString(text)) {
            text = text.replace(/\\\\n/g, '\n');
            return md.render(text);
        }
        return "";
    }

    return markdown;
});

/**
 * Functions for handling user-entered XML
 */
define('vellum/xml',[
    'jquery',
    'underscore'
], function (
    $,
    _
) {
    /**
     * Parse XML string and return jQuery-wrapped document object.
     */
    function parseXML(xmlStr) {
        if (!xmlStr) {
            return $();
        }
        // HACK convince jQuery Sizzle that this is XML, not HTML
        xmlStr = xmlStr
            .replace(/<(h:)?html\b/, "<h:xdoc")
            .replace(/<\/(h:)?html\b>/, "</h:xdoc>");
        return $($.parseXML(xmlStr));
    }

    /**
     * DOM-ify and wrap XML fragment (string) with jQuery
     *
     * Use jQuery in XML mode when possible. Fall back to HTML mode when
     * fragment is not valid XML.
     *
     * Use this to convert XML string to jQuery/DOM, manipulate, then
     * convert back to XML string.
     */
    function query(fragment) {
        // This is needed to avoid inconsistent parsing with parseXML
        fragment = fixEmptyTags(fragment);

        var xopen = '<xml xmlns="http://www.w3.org/1999/xhtml"' +
                    ' xmlns:vellum="http://commcarehq.org/xforms/vellum">',
            doc = xopen + fragment + "</xml>",
            xquery;
        try {
            xquery = $($.parseXML(doc));
        } catch (e) {
            // fall back to HTML, which deals with all kinds of malformed stuff
            xquery = $("<xml></xml>").html(fragment);
        }
        xquery.toString = function () {
            var xml = new XMLSerializer(),
                emptytag = /(<([\w:.-]+)(?:\s[^>]*|))><\/\2>/g,
                badOutput = /(<(output)(?:\s[^>]*|))>([\w\W]+)<\/output>/g;
            return xml.serializeToString(xquery[0])
                .replace(/^<xml\b[^>]*>/, "")   // remove <xml ...>
                .replace(/<\/xml>$/, "")        // remove </xml>
                .replace(emptytag, "$1 />")     // <tag></tag> to <tag />
                .replace(badOutput, "$1 />$3")   // <output> text</output> to <output /> text
                .replace(/"\/>/g, '" />')      // space before />
                .replace(/&nbsp;|\xa0/g, " ");  // &nbsp; is not a valid XML entity
        };
        return xquery;
    }

    /**
     * Convert XML string to HTML dom nodes to be manipulated with jQuery
     */
    function xhtml(xmlString, append=false) {
        var fixed = fixEmptyTags(xmlString || ""),
            node = document.implementation.createHTMLDocument().createElement('div');
        if (append) {
            return $(node).append(fixed);
        }
        return $(node).html(fixed);
    }

    /**
     * Normalize XML string
     *
     * Escapes < and > not used as tag delimiters as well as unescaped &.
     * The trick here is to use the browser to construct DOM nodes from
     * possibly sloppy hand-coded XML (modern browsers are very good at this),
     * and then use the XML serializer to produce valid XML.
     * This is lossy for some inputs. Example: '<output value="/path"' -> ''
     *
     * @param value - String or jQuery object.
     * @param inner - Optional, remove outer tag if true. The default is false.
     *                Ignored/always true for jQuery object.
     * @returns - Normalized XML string safe to be embedded in an XML document.
     */
    function normalize(value, inner) {
        if (!value) {
            return "";
        } else if (_.isString(value)) {
            if (!/[<>&]/.test(value)) {
                return value; // value contains no XML tags
            }
            value = fixGTBug(fixEmptyTags(value));
            value = inner ? $(value) : xhtml(value, true);
        }
        var xml = new XMLSerializer(),
            xmlns = / xmlns:vellum="http:\/\/commcarehq.org\/xforms\/vellum"([ \/>])/g,
            wrapper = /^<([\w:.-]+)(?:\s+[\w:.-]+=(["'])[^]*?\2)*\s*(?:\/>|>([^]*)<\/\1>)$/g,
            // emptytag does not match <tag attr="a > b"></tag>
            emptytag = /(<([\w:.-]+)(?:\s[^>]*|))><\/\2>/g,
            badOutput = /(<(output)(?:\s[^>]*|))>([\w\W]+)<\/output>/g,
            extra = / xmlns="http:\/\/www.w3.org\/1999\/xhtml"/g;
        var output = value[0];
        if (output === undefined) {
                output = value;
        }
        var serialized = xml.serializeToString(output);
        if (serialized.startsWith('<output')) {
            serialized = "<div>" + serialized + "</div>";
        }
        return serialized
            .replace(extra, "")             // remove xmlns from output tag
            .replace(wrapper, "$3")         // remove outer tag
            .replace(emptytag, "$1 />")     // <tag></tag> to <tag />
            .replace(badOutput, "$1 />$3")   // <output> text</output> to <output /> text
            .replace(/&nbsp;|\xa0/g, " ")   // &nbsp; is not a valid XML entity
            // HACK xmlns could match and remove text that is not XML (unlikely)
            .replace(xmlns, "$1");         // remove vellum namespace
    }

    /**
     * Make XML string more user-friendly
     *
     * Un-escapes &, < and > when not used as tag delimiters and convert
     * <tag attr="value"></tag> to <tag attr="value" />.
     * This does approximately the opposite of `normalize` for most sane cases.
     *
     * @param value - String or jQuery object.
     * @param inner - See `normalize()` parameter with the same name.
     * @returns - XML string ready for human editing.
     */
    function humanize(value, inner) {
        // emptytag does not match <tag attr="a > b"></tag>
        var emptytag = /<([\w:.-]+)(?:\s[^>]*|)><\/\1>/;
        if (!value) {
            return "";
        } else if (_.isString(value) && value.indexOf("&") === -1 && !emptytag.test(value)) {
            return value; // value contains no character entity references or empty tags.
        }
        var xml = normalize(value, inner),
            refs = /(?:&lt;(=?\s)|(\s)&gt;|&amp;([^&;\s]+;|.|$))/g;

        return xml.replace(refs, function (match, lt, gt, amp) {
            return lt ? ("<" + lt) : (gt ? (gt + ">") : amp.slice(amp.length-1) === ";" ? match : ("&" + amp));
        });
    }

    /**
     * Work around XML escaping bug in browser
     *
     * Buggy conversion:
     * '<tag attr="a > b" />tail' => '<tag attr="a > b">tail</tag>'
     *
     * Empty tags that do not end with /> do not have this problem:
     * '<tag attr="a > b"></tag>tail' => '<tag attr="a > b"></tag>tail'
     *
     * For the examples above, assume => is a funciton that does
     * xml.query(value).toString()
     *
     * NOTE: there are still edge cases (mainly malformed XML) that will not be
     * fixed by this. For example:
     *      <tag attr=a<b />
     *
     * Will mangle some (probably invalid) attribute values:
     * '<tag attr="../>.." />' => '<tag attr="..></attr>.." />'
     */
    function fixGTBug(value) {
        var empty = /<(([\w:.-]+)(?:\s[^<]*?|))\/>/g;
        return value.replace(empty, "<$1></$2>");
    }

    /**
     * Convert self-closing tag to empty tag
     *
     * HTML5 interprets self-closing tags as unclosed tags.
     *
     * Replace <tag.../> with <tag...></tag>
     */
    function fixEmptyTags(xmlString) {
        return xmlString.replace(/<(([\w:.-]+)(?:\s[^>]*|))\/>/g, "<$1></$2>");
    }

    return {
        humanize: humanize,
        normalize: normalize,
        parseXML: parseXML,
        query: query,
        xhtml: xhtml,
    };
});

define('vellum/jquery-extensions',[
    "jquery",
    "underscore",
    "jquery.bootstrap"
], function ($, _) {

    $.fn.popAttr = function (name) {
        var removed = false,
            val = this.xmlAttr(name);
        try {
            this.removeAttr(name);
            removed = true;
        } catch (e) {
            // catch InvalidCharacterError due to \: in attribute name
        }
        if (removed && !_.isUndefined(val)) {
            if (!this[0].poppedAttributes) {
                this[0].poppedAttributes = {};
            }
            this[0].poppedAttributes[name] = val;
        }
        return val;
    };

    /**
     * Get or set XML attribute value
     *
     * This should always be used instead of `$node.attr(...)` when getting
     * or setting form XML attributes. jQuery's `$.fn.attr()` returns the
     * wrong value for "Boolean Attributes" like "required".
     *
     * Supported forms:
     * - get: .xmlAttr(name)
     * - set: .xmlAttr(name, value)
     * - set: .xmlAttr(attributes)
     *
     * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#Boolean_Attributes
     */
    $.fn.xmlAttr = function (name, value) {
        if (_.isObject(name)) {
            var $node = this;
            _.each(name, function (value, key) {
                $node.xmlAttr(key, value);
            });
            return this;
        }
        var isSet = arguments.length > 1;
        if (name && name.indexOf(":") > -1) {
            return isSet ? this.attr(name, value) : this.attr(name);
        }
        var node = this.get(0),
            attr;
        if (node) {
            if (isSet) {
                if (value === null) {
                    this.removeAttr(name);
                } else if (value !== undefined) {
                    attr = document.createAttribute(name);
                    attr.value = value;
                    node.setAttributeNode(attr);
                }
                return this;
            }
            attr = node.attributes.getNamedItem(name);
            if (attr) {
                return attr.value;
            }
        }
        return isSet ? this : undefined;
    };

    $.fn.stopLink = function() {
        // stops anchor tags from clicking through
        this.click(function (e) {
            e.preventDefault();
        });
        return this;
    };

    $.fn.fdHelp = function () {
        // creates a help popover, requires twitter bootstrap
        this.append($('<i />').addClass('fa fa-question-circle'))
            .popover({
                trigger: 'focus',
                html: true,
                container: 'body',
                sanitize: false,
            }).click(function(e) {
                // If this help icon is inside a bigger click target, don't trigger the ancestor
                e.stopPropagation();
            });
        return this;
    };

    $.fn.clickExceptAfterDrag = function (callback) {
        var $el = $(this);
        callback.currentXY = [];
        function move(e) {
            callback.currentXY = [e.pageX, e.pageY];
            $el.off("mousemove", move);
        }
        function up(e) {
            var a = callback.currentXY[0] - e.pageX,
                b = callback.currentXY[1] - e.pageY,
                c = Math.sqrt(a*a + b*b);
            if (c < 3) {
                callback(e);
            }
            $el.off("mouseup", up);
        }
        $el.on("mousedown", function (e) {
            move(e);
            $el.on("mousemove", move).on("mouseup", up);
        });
    };

    if (!$.fn.disableSelection) {
        // stolen from jquery-ui
        // https://github.com/jquery/jquery-ui/blob/c2224bf/ui/core.js#L299-L315
        $.fn.extend( {
        	disableSelection: ( function() {
        		var eventType = "onselectstart" in document.createElement( "div" ) ?
        			"selectstart" :
        			"mousedown";

        		return function() {
        			return this.on( eventType + ".ui-disableSelection", function( event ) {
        				event.preventDefault();
        			} );
        		};
        	} )(),

        	enableSelection: function() {
        		return this.off( ".ui-disableSelection" );
        	}
        } );
    }

    // Delay popover closing so that user has time to move cursor
    // into popover and can then interact with popover content.
    // http://jsfiddle.net/hermanho/4886bozw/
    var popoverLeave = $.fn.popover.Constructor.prototype.leave;
    $.fn.popover.Constructor.prototype.leave = function(obj){
        var self = obj instanceof this.constructor ?
            obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type);
        var container,
            timeout;

        popoverLeave.call(this, obj);

        if (obj.currentTarget) {
            container = $('.popover');  // Works even if there are multiple popovers
            timeout = self.timeout;
            container.one('mouseenter', function() {
                // Entered the actual popover
                clearTimeout(timeout);
                // Monitor popover content instead
                container.one('mouseleave', function() {
                    $.fn.popover.Constructor.prototype.leave.call(self, self);
                });
            });
        }
    };
});

define('vellum/util',[
    'require',
    'json!langCodes',
    'underscore',
    'jsdiff',
    'vellum/markdown',
    'vellum/xml',
    'jquery',
    'vellum/jquery-extensions'
], function (
    require,
    langCodes,
    _,
    jsdiff,
    markdown,
    xml,
    $
) {
    RegExp.escape = function(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    };

    var that = {isMac: /Mac/.test(navigator.platform)},
        isMac = that.isMac,
        KEY_CODES = {
            // Firefox/Mac (maybe others?)
            ";": ";",
            "": "=",
            "": "-",
            // add these for good measure, not sure if needed
            "=": "=",
            "-": "-",
            // Chrome/Mac (maybe others?)
            "186": ';',
            "187": '=',
            "189": '-',
        };

    that.getKeyChord = function (e) {
        var ctrlKey = (isMac && e.metaKey) || (!isMac && e.ctrlKey),
            metaKey = (isMac && e.ctrlKey) || (!isMac && e.metaKey),
            key = String(e.key),
            code = e.which;
        if (KEY_CODES.hasOwnProperty(code)) {
            key = KEY_CODES[code];
        } else if (KEY_CODES.hasOwnProperty(key)) {
            key = KEY_CODES[key];
        } else if (key.length === 1 || key === "Unidentified") {
            // Work around Alt+<key> on Mac produces strange e.key values.
            // On MS Edge some keys are "Unidentified"
            if (code >= 48 && code <= 57 || code >= 65 && code <= 90) {
                // alphanumerics (0-9, A-Z)
                key = String.fromCharCode(code);
            } else if (code >= 96 && key <= 105) {
                // number pad (0-9)
                key = String.fromCharCode(code - 48);
            } else {
                // Fall back to numeric code. Not readable, but at least will
                // not crash. Please update KEY_CODES rather than using this.
                key = code;
            }
        }
        return (ctrlKey ? "Ctrl+" : "") +
               (e.altKey ? "Alt+" : "") +
               (e.shiftKey ? "Shift+" : "") +
               (metaKey ? "Meta+" : "") + key;
    };

    // deep extend
    that.extend = function () {
        var args = Array.prototype.slice.call(arguments);

        return $.extend.apply(null, [true, {}].concat(args));
    };

    that.langCodeToName = {};
    _.each(langCodes, function (lang) {
        var name = lang.names[0];
        that.langCodeToName[lang.three] = name;
        that.langCodeToName[lang.two] = name;
    });

    that.formatExc = function (error) {
        if (error && error.stack) {
            return error + "\n" + error.stack;
        }
        return String(error);
    };

    that.validAttributeRegex = /^[^<&'">]*$/;
    that.invalidAttributeRegex = /[<&'">]/;

    /**
     * Check if value is a valid XML attribute value (additionally disallow all
     * ' and ")
     */
    that.isValidAttributeValue = function (value) {
        return that.validAttributeRegex.test(value);
    };
    
    // Simple Event Framework
    // Just run your object through this function to make it event aware.
    // Adapted from 'JavaScript: The Good Parts' chapter 5
    that.eventuality = function (that) {
        var registry = {},
            unbinders = {};
        /**
         * Fire event, calling all registered handlers
         */
        that.fire = function (event) {
            var array,
                func,
                handler,
                i,
                type = typeof event === 'string' ? event : event.type;
            if (registry.hasOwnProperty(type)) {
                array = registry[type];
                for (i = 0; i < array.length; i += 1) {
                    handler = array[i];
                    func = handler.method;
                    if (typeof func === 'string') {
                        func = this[func];
                    }
                    func.apply(this, handler.parameters || [event]);
                }
            }
            return this;
        };
        /**
         * Register an event handler to be called each time an event is fired.
         *
         * @param type - Event type string.
         * @param method - Event handler method.
         * @param parameters - Parameters to be passed to method. If null
         *      or not provided, the event object itself will be passed.
         * @param unbindOn - (optional) Event type on which to unbind
         *      all handlers associated with `context`. To make a one-
         *      shot, use the same value for this parameter as for
         *      `type`.
         * @param context - (optional) Context for `unbind`. The
         *      default is `null`. The handler (and all other handlers
         *      bound to the same context) will be unbound the next time
         *      the `unbindOn` event fires or `this.unbind(context)` is
         *      called, whichever happens first.
         */
        that.on = function (type, method, parameters, unbindOn, context) {
            if (arguments.length < 5) {
                context = null;
            }
            var handler = {
                method: method,
                parameters: parameters,
                context: context
            };
            if (registry.hasOwnProperty(type)) {
                registry[type].push(handler);
            } else {
                registry[type] = [handler];
            }
            if (unbindOn) {
                if (!unbinders[unbindOn]) {
                    unbinders[unbindOn] = [];
                }
                if (unbinders[unbindOn].indexOf(context) === -1) {
                    unbinders[unbindOn].push(context);
                    that.on(unbindOn, function () {
                        that.unbind(context);
                        unbinders[unbindOn] = _.filter(unbinders[unbindOn], function (cx) {
                            return cx !== context;
                        });
                    }, null, null, context);
                }
            }
            return this;
        };
        /**
         * Unbind an event handler for a given binding context
         *
         * @param context - the binding context that was passed to `on`.
         * @param type - optional event type. If undefined, all handlers
         *        for the given binding context will be unbound.
         */
        that.unbind = function (context, type) {
            if (_.isUndefined(type)) {
                registry = _.object(_.map(registry, function (handlers, type, reg) {
                    handlers = _.filter(handlers, function (handler) {
                        return handler.context !== context;
                    });
                    return [type, handlers];
                }));
            } else if (registry.hasOwnProperty(type)) {
                registry[type] = _.filter(registry[type], function (handler) {
                    return handler.context !== context;
                });
            }
            return this;
        };
        return that;
    };

    /**
     * Escape string for use as HTML. May alter whitespace within string.
     */
    that.escape = function (string) {
        return $("<div>").text(string).html();
    };

    /* jshint bitwise: false */
    that.get_guid = function() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
        var S4 = function() {
            return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
        };
        return (S4()+S4()+S4()+S4()+S4()+S4()+S4()+S4());
    };

    that.generate_xmlns_uuid = function () {
        var CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        var uuid = [], r, i;

		// rfc4122 requires these characters
		uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
		uuid[14] = '4';

		// Fill in random data.  At i==19 set the high bits of clock sequence as
		// per rfc4122, sec. 4.1.5
		for (i = 0; i < 36; i++) {
			if (!uuid[i]) {
				r = Math.floor((Math.random()*16));
				uuid[i] = CHARS[(i === 19) ? (r & 0x3) | 0x8 : r & 0xf];
			}
		}
		return uuid.toString().replace(/,/g,'');
    };
    /* jshint bitwise: true */

    that.isValidElementName = function (name) {
        // HT: http://stackoverflow.com/questions/2519845/how-to-check-if-string-is-a-valid-xml-element-name
        var elementNameRegex = /^(?!XML)[a-zA-Z][\w-]*$/;
        return elementNameRegex.test(name);
    };
    

    /**
     * Converts true to 'true()' and false to 'false()'. Returns null for all else.
     * @param req
     */
    that.createXPathBoolFromJS = function(req) {
        if(req === true || req === 'true') {
            return 'true()';
        }else if (req === false || req === 'false') {
            return 'false()';
        } else {
            return null;
        }
    };
    
    that.getOneOrFail = function (list, infoMsg) {
        if (list.length === 0) {
            throw that.format(gettext("No match for {info} found!"), {info: infoMsg});
        } else if (list.length > 1) {
            throw that.format(gettext("Multiple matches for {info} found!"), {info: infoMsg});
        }
        return list[0];
    };
    
    that.reduceToOne = function (list, func, infoMsg) {
        return that.getOneOrFail(_(list).filter(func), infoMsg);
    };
    
    that.getCaretPosition = function (ctrl) {
        var pos = 0;
        if (ctrl.createTextRange) {
            ctrl.focus ();
            var sel = document.selection.createRange ();
            sel.moveStart ('character', -ctrl.value.length);
            pos = sel.text.length;
        } else if (typeof ctrl.selectionStart !== 'undefined') {
            pos = ctrl.selectionStart;
        }
        return pos;
    };

    that.setCaretPosition = function (ctrl, start, end){
        if (end === null || end === undefined) {
            end = start;
        }
        if (ctrl.setSelectionRange) {
            ctrl.focus();
            ctrl.setSelectionRange(start, end);
        } else if (ctrl.createTextRange) {
            var range = ctrl.createTextRange();
            range.collapse(true);
            range.moveStart('character', start);
            range.moveEnd('character', end);
            range.select();
        }
    };

    that.insertTextAtCursor = function (jqctrl, text, select) {
        var ctrl = jqctrl[0],
            pos = that.getCaretPosition(ctrl),
            front = ctrl.value.substring(0, pos),
            back = ctrl.value.substring(pos, ctrl.value.length),
            start = select ? pos : pos + text.length;
        jqctrl.val(front + text + back).change();
        pos = pos + text.length;
        that.setCaretPosition(ctrl, start, pos);
    };

    that.parseXML = xml.parseXML;

    that.xmlDiff = function (localForm, serverForm, opts) {
        function cleanForDiff (value) {
            // convert leading tabs to spaces
            value = value.replace(/^\t+/mg, function (match) {
                return match.replace(/\t/g, "  ");
            });
            // add newline at end of file if missing
            if (!value.match(/\n$/)) {
                value = value + "\n";
            }
            return value;
        }
        opts = opts || {};
        if (opts.normalize_xmlns) {
            var xmlns = $(xml.parseXML(serverForm)).find('data').xmlAttr('xmlns');
            localForm = localForm.replace(/(data[^>]+xmlns=")(.+?)"/,
                                    '$1' + xmlns + '"');
        }
        localForm = cleanForDiff(localForm);
        serverForm = cleanForDiff(serverForm);
        var patch = jsdiff.createPatch(
            "",
            serverForm,
            localForm,
            gettext("Server Form"),
            gettext("Local Form")
        );
        patch = patch.replace(/^Index:/,
            opts.not ? gettext("XML should not be equivalent") : gettext("XML mismatch")
        );
        return patch;
    };

    that.markdown = markdown;

    that.truncate = function (label, length) {
        length = length || 25;
        if (label && label.length > length) {
            return label.slice(0, length) + '&hellip;';
        }
        return label;
    };

    /**
     * Write xpath expression attribute(s)
     *
     * All expressions are stored as hashtag expressions internally and are
     * written to XML in two forms when rich text is enabled:
     *
     *   <bind ... vellum:calculate="#form/text" calculate="/data/text" />
     *
     * The vellum namespaced attribute is the hashtag form and is only written
     * when rich text is enabled and it is different from the XPath form. The
     * non namespaced attribute is XPath syntax (no hashtags) and is always
     * written.
     *
     * When rich text is enabled invalid XPaths are escaped in the vellum
     * namespaced attribute and best-effort no-hashtag XPath in non namespaced
     * attribute:
     *
     *   <bind ...
     *      vellum:calculate="#invalid/xpath (`#form/text`"
     *      calculate="(/data/text" />
     */
    that.writeHashtags = function (xmlWriter, key, hashtagOrXPath, mug) {
        if (!_.isString(hashtagOrXPath)) {
            // don't try to parse a value that doesn't exist
            return;
        } else if (hashtagOrXPath === "" || (mug.options && mug.options.ignoreHashtags)) {
            xmlWriter.writeAttributeString(key, hashtagOrXPath);
            return;
        }

        var form = mug.form,
            vellumKey = key.replace(':', '__'),
            xpath_, hashtag;
        try {
            var expr = form.xpath.parse(hashtagOrXPath);
            xpath_ = expr.toXPath();
            // TODO hashtag = hashtagOrXPath
            // (do not convert hand-typed xpaths to hashtags)
            hashtag = expr.toHashtag();
        } catch (err) {
            if (form.richText) {
                var richText = require('vellum/richText');
                hashtag = hashtagOrXPath;
                xpath_ = richText.unescapeXPath(hashtagOrXPath, form);
            } else {
                hashtag = xpath_ = hashtagOrXPath;
            }
        }

        if (hashtag !== xpath_) {
            if (form.richText) {
                xmlWriter.writeAttributeString('vellum:' + vellumKey, hashtag);
            }
            xmlWriter.writeAttributeString(key, xpath_);
        } else {
            xmlWriter.writeAttributeString(key, hashtagOrXPath);
        }
    };

    that.isRightToLeftLanguage = function (lang) {
        return _.contains([
            'ara', 'arc', 'div', 'fas', 'heb', 'pus', 'snd', 'uig', 'urd', 'yid',
        ], lang);
    };

    that.getReferenceName = function (value) {
        var ref = /^#([^\/]+)\//.exec(value);
        if (!ref) {
            return "Form Reference";
        }
        ref = ref[1][0].toUpperCase() + ref[1].substring(1).toLowerCase();
        return ref + " Reference";
    };

    /**
     * Simple string interpolation
     *
     * Usage: ``format("Across the {thing}", {thing: "Universe"})``
     *
     * Placeholder names must start with a letter and may contain
     * letters, numbers and underscores. Unmatched placeholders are
     * ignored.
     */
    that.format = function (string, map) {
        return string.replace(/\{([a-z][\w_]*)\}/ig, function (match, key) {
            if (map.hasOwnProperty(key)) {
                return map[key];
            }
            return match;
        });
    };

    that.checkForFormSubmissions = _.throttle(function (form) {
        if (!form.warnWhenChanged && !form.isCurrentlyCheckingForSubmissions) {
            form.isCurrentlyCheckingForSubmissions = true;
            $.ajax({
                url: form.submissionUrl,
                type: 'GET',
                dataType: 'json',
                success: function(data) {
                    if(data.form_has_submissions) {
                        form.warnWhenChanged = true;
                        form.walkMugs(function (mug) {
                            mug.validate();
                        });
                    }
                },
                complete: function() {
                    form.isCurrentlyCheckingForSubmissions = false;
                }
            });
        }
    }, 10000);

    return that;
});

define('vellum/tree',[
    'vellum/util',
    'underscore'
], function (
    util,
    _
) {
    /**
     * Children is a list of objects.
     * @param children - optional
     * @param value - that value object that this node should contain (should be a Mug)
     */
    function Node(children, value) {
        this.value = value;
        this.children = children || [];
        this.parent = null;
    }

    Node.prototype = {
        getChildren: function () {
            // DEPRECATED use 'children' directly
            return this.children;
        },
        getValue: function () {
            // DEPRECATED use 'value' directly
            return this.value;
        },
        /**
         * DOES NOT CHECK TO SEE IF NODE IS IN TREE ALREADY!
         * Adds child to END of children!
         */
        addChild: function (node) {
            node.parent = this;
            this.children.push(node);
        },
        /**
         * Insert child at the given index (0 means first)
         * if index > children.length, will insert at end.
         * -ve index will result in child being added to first of children list.
         */
        insertChild: function (node, index) {
            if (node === null) {
                return null;
            }

            if (index < 0) {
                index = 0;
            }
            node.parent = this;
            this.children.splice(index, 0, node);
        },
        getSingleMatchingNode: function (fn) {
            var thisVal = this.getValue(),
                retVal;

            if (fn(thisVal)) {
                return this;
            } else {
                for (var i = 0; i < this.children.length; i++) {
                    retVal = this.children[i].getSingleMatchingNode(fn);
                    if (retVal) {
                        return retVal;
                    }
                }
            }
            return null; //we haven't found what we're looking for
        },
        removeChild: function (node) {
            var childIdx = this.children.indexOf(node);
            if (childIdx !== -1) { //if arg node is a member of the children list
                this.children.splice(childIdx, 1); //remove it
            }
            node.parent = null;
            return node;
        },
        /**
         * An ID used during prettyPrinting of the Node. (a human readable value for the node)
         */
        getID: function () {
            if (this.isRootNode) {
                return this.rootNodeId;
            }
            return this.getValue().getNodeID();
        },
        /**
         * Get all children MUG TYPES of this node (not recursive, only the top level).
         * Return a list of Mug objects, or empty list for no children.
         */
        getChildrenMugs: function () {
            var i, retList = [];
            for (i in this.children) {
                if (this.children.hasOwnProperty(i)) {
                    retList.push(this.children[i].getValue());
                }
            }
            return retList;
        },
        getStructure: function () {
            var ret = {};
            ret[this.getID()] = _.map(this.children, function (c) {
                return c.getStructure();
            });
            return ret;
        },
        /**
         * calls the given function on each node (the node
         * is given as the only argument to the given function)
         * and appends the result (if any) to a flat list
         * (the store argument) which is then returned
         * @param nodeFunc
         * @param store
         */
        treeMap: function (nodeFunc, store, afterChildFunc) {
            var result = nodeFunc(this), // call on self
                children = this.getChildren(),
                child;
            if(result) {
                store.push(result);
            }
            for(child in children) {
                if(children.hasOwnProperty(child)){
                    // have each children also perform the func
                    children[child].treeMap(nodeFunc, store, afterChildFunc);
                }
            }
            if(afterChildFunc) {
                afterChildFunc(this, result);
            }
            return store;
        },
        walk: function (callback) {
            function processChildren(filter) {
                if (filter) {
                    children = filter(children, value);
                }
                for (var i = 0; i < children.length; i++) {
                    children[i].walk(callback);
                }
            }
            var value = this.getValue(),
                children = this.getChildren();
            callback(value, this.getID(), processChildren);
        },
        getAbsolutePath: function (excludeRoot) {
            if (this.isRootNode) {
                if (excludeRoot) {
                    return '';
                }
                return '/' + this.getID();
            }
            var mug = this.value,
                dataParent = mug.p.dataParent,
                parentPath;
            if (dataParent) {
                var dataParentMug = mug.form.getMugByPath(dataParent);
                if (!dataParentMug || dataParentMug === mug) {
                    if (excludeRoot) {
                        parentPath = '';
                    } else {
                        parentPath = '/' + this.getRootNode().rootNodeId;
                    }
                } else {
                    parentPath = mug.form.getAbsolutePath(dataParentMug, excludeRoot);
                }
            } else {
                parentPath = this.parent.getAbsolutePath(excludeRoot);
                if (parentPath === null) {
                    return null;
                }
            }
            var name = this.getID();
            if (mug.options.getPathName) {
                name = mug.options.getPathName(mug, name);
            }
            return (parentPath ? parentPath : '') + '/' + name;
        },
        validateTree: function (validateValue) {
            var i, childResult;
            if(!this.getValue()){
                throw 'Tree contains node with no values!';
            }
            if (!validateValue(this.getValue())) {
                return false;
            }

            for (i in this.getChildren()) {
                if (this.getChildren().hasOwnProperty(i)) {
                    childResult = this.getChildren()[i].validateTree(validateValue);
                    if(!childResult){
                        return false;
                    }
                }
            }

            //If we got this far, everything checks out.
            return true;
        },
        getRootNode: function () {
            if (this.isRootNode) {
                return this;
            }
            return this.parent.getRootNode();
        }
    };

    /**
     * A regular tree (with any amount of leafs per node)
     * @param treeType - is this a data or control tree
     * 'data' or 'control' for this argument, respectively)
     */
    function Tree(rootId, treeType) {
        util.eventuality(this);

        this.rootNode = new Node(null, null);
        this.rootNode.isRootNode = true;
        this.setRootID(rootId);
        this.treeType = treeType || 'data';
    }

    Tree.prototype = {
        setRootID: function (id) {
            this.rootNode.rootNodeId = id;
        },
        getParentNode: function (node) {
            if (this.rootNode === node) {
                //special case:
                return this.rootNode;
            }
            return node && node.parent;
        },
        getStructure: function () {
            return this.rootNode.getStructure();
        },
        /**
         * Given a mug, finds the node that the mug belongs to (in this tree).
         * Will return null if nothing is found.
         */
        getNodeFromMug: function (mug) {
            // gets set in insertMug()
            return mug['_node_' + this.treeType];
        },
        _removeNodeFromTree: function (node) {
            var parent = this.getParentNode(node);
            if (parent) {
                parent.removeChild(node);
                this.fire({
                    type: 'change'
                });
            }
        },
        /**
         * Insert a Mug as a child to the node containing parentMug.
         *
         * Will MOVE the mug to the new location in the tree if it is already present!
         * @param mug - the Mug to be inserted into the Tree
         * @param position - position relative to the refMug.
         *                   Can be null, 'before', 'after', 'first', 'last'
         *                   or 'into' (synonym for 'last')
         * @param refMug - reference Mug.
         * @returns - the tree node of the inserted mug.
         *
         * If refMug is null, will default to the last child of the root node.
         * If position is null, will default to 'after'.  If 'into' is
         * specified, mug will be inserted as last child of the refMug.
         *
         * If an invalid move is specified, no operation will occur.
         */
        insertMug: function (mug, position, refMug, index) {
            var refNode = refMug ? this.getNodeFromMug(refMug) : this.rootNode,
                node = this.getNodeFromMug(mug),
                refNodeIndex, refNodeParent;

            if (node && this.rootNode === node.getRootNode()) {
                this._removeNodeFromTree(node); 
            } else {
                node = new Node(null, mug);
                // store a reference to node in order to make getNodeFromMug()
                // lookup fast 
                mug['_node_' + this.treeType] = node;
            }

            switch (position) {
                case 'before':
                case 'inside': // for compatibility with JSTree
                    refNodeParent = this.getParentNode(refNode);
                    refNodeIndex = refNodeParent.children.indexOf(refNode);
                    refNodeParent.insertChild(node, refNodeIndex);
                break;
                case null:
                case 'after':
                    refNodeParent = this.getParentNode(refNode);
                    refNodeIndex = refNodeParent.children.indexOf(refNode);
                    refNodeParent.insertChild(node, refNodeIndex + 1);
                break;
                case 'into': // not officially supported by, but happens to work in JSTree
                case 'last':
                    refNode.addChild(node);
                break;
                case 'first':
                    refNode.insertChild(node, 0);
                break;
                case 'index':
                    refNode.insertChild(node, index);
                break;
                default:
                    throw "in insertMug() position argument MUST be null, " +
                          "'before', 'after', 'into', 'first' or 'last'. " +
                          "Argument was: " + position;
            }
            this.fire({
                type: 'change',
                mug: mug
            });
            return node;
        },
        getAbsolutePath: function (mug, excludeRoot) {
            var node = this.getNodeFromMug(mug);
            if (!node) {
                return null;
            }
            return node.getAbsolutePath(excludeRoot);
        },
        /**
         * Find the previous sibling of a mug
         *
         * First mug in a group - returns the group mug
         * first mug in form - returns root node
         * any other mug - returns the previous sibling
         */
        getPreviousSibling: function (mug) {
            var tree = this,
                node = tree.getNodeFromMug(mug),
                parentMug = mug.parentMug,
                parentNode = parentMug ? tree.getNodeFromMug(parentMug) : tree.getRootNode(),
                mugPosition = parentNode.children.indexOf(node);
            return (mugPosition === 0) ? parentMug : parentNode.children[mugPosition - 1].getValue();
        },
        /**
         * Find a sibling of refMug matching a predicate
         *
         * @param refMug
         * @param direction - Either 'before' or 'after'; the direction to
         *                    search from refMug among its siblings.
         * @param predicate - A function used to determine if any of refMug's
         *                    siblings are a suitable.
         * @returns The first sibling of refMug in the given direction matching
         *          predicate.
         * @throws An error if refMug is not found in the tree or if refMug
         *         is not found among its parent's children.
         */
        findSibling: function (refMug, direction, predicate) {
            var node = this.getNodeFromMug(refMug),
                children, start, i;
            if (!node) {
                throw "mug not found in " + this.treeType + " tree";
            }
            children = this.getParentNode(node).getChildrenMugs();
            start = children.indexOf(refMug);
            if (start === -1) {
                throw "mug not found in its parent's children";
            }
            if (direction === 'before') {
                for (i = start - 1; i >= 0; i--) {
                    if (predicate(children[i])) {
                        return children[i];
                    }
                }
            } else {
                for (i = start + 1; i < children.length; i++) {
                    if (predicate(children[i])) {
                        return children[i];
                    }
                }
            }
            return null;
        },
        /**
         * Removes the specified Mug from the tree. If it isn't in the tree
         * does nothing.  Does nothing if null is specified
         *
         * If the Mug is successfully removed, returns that Mug.
         */
        removeMug: function (mug) {
            this._removeNodeFromTree(this.getNodeFromMug(mug));
        },
        /**
         * Returns all the children Mugs (as a list) of the
         * root node in the tree.
         */
        getRootChildren: function () {
            return this.rootNode.getChildrenMugs();
        },
        /**
         * Performs the given func on each
         * node of the tree (the Node is given as the only argument to the function)
         * and returns the result as a list.
         * @param func - a function called on each node, the node is the only argument
         * @param afterChildFunc - a function called after the above function is called on each child of the current node.
         */
        treeMap: function (func, afterChildFunc) {
            return this.rootNode.treeMap(func, [], afterChildFunc);
        },
        /**
         * Call a function for each mug in the tree and allow each mug to
         * manipulate its tree of children.
         *
         * @param callback - A function that accepts three arguments:
         *  - mug : the node value (null for the root node).
         *  - nodeID : the ID of the mug's tree node.
         *  - processChildren : a function that processes the mug's children. If
         *          this function is not called the mug's children will not be
         *          visited. This function accepts one optional argument,  a
         *          filter function `filter(childTreeNodes, mug)` that may
         *          return a list of filtered tree nodes.
         */
        walk: function (callback) {
            this.rootNode.walk(callback);
        },
        isTreeValid: function(validateValue) {
            var rChildren = this.rootNode.getChildren(),
            i, retVal;
            for (i in rChildren){
                if(rChildren.hasOwnProperty(i)){
                    retVal = rChildren[i].validateTree(validateValue);
                    if(!retVal){
                        return false;
                    }
                }
            }
            return true;
        },
        getRootNode: function () {
            return this.rootNode;
        }
    };

    Tree.Node = Node; // exposed for walk filters
    return Tree;
});



define('tpl/tpl!vellum/templates/ui_element', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="widget">\n    <div class="form-group">\n        <div class="control-label col-sm-3">\n            <label>'+
((__t=( labelText ))==null?'':__t)+
'</label>\n            ';
 if (help) { 
__p+='\n                <div class="fd-help">\n                    <a tabindex="-1"\n                        data-title="'+
((__t=( labelText ))==null?'':_.escape(__t))+
'"\n                        data-content="'+
((__t=( help.text ))==null?'':_.escape(__t))+
'';
 if (help.url) { 
__p+='<p><a href=\''+
((__t=( help.url ))==null?'':_.escape(__t))+
'\' target=\'_blank\'>See more</a></p>';
 } 
__p+='"></a>\n                </div>\n            ';
 } 
__p+='\n        </div>\n        <div class="col-sm-9 controls">\n            <!-- input will go here -->\n            <div class="messages"></div>\n        </div>\n    </div>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/widget_control_keyvalue', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="well fd-kv">\n    ';
 pairs[""] = ""; 
__p+='\n    ';
 _.each(pairs, function (v, k) { _.each(_.isArray(v) ? v : [v], function (v) { 
__p+='\n        <div class="fd-kv-pair form-group">\n            <div class="col-sm-3">\n                <input class="fd-kv-key form-control" type="text" value="'+
((__t=(k))==null?'':__t)+
'" placeholder="'+
((__t=(gettext("key")))==null?'':_.escape(__t))+
'" />\n            </div>\n            <div class="col-sm-1 fd-kv-arrow"><i class="fa fa-arrow-right"></i></div>\n            <div class="col-sm-7"><input class="fd-kv-val form-control jstree-drop" type="text" value="'+
((__t=(v))==null?'':__t)+
'" placeholder="'+
((__t=(gettext("value")))==null?'':_.escape(__t))+
'" /></div>\n            <div class="col-sm-1">\n                <a class="btn fd-kv-remove-pair btn-sm btn-danger';
 if (k =='') { 
__p+=' hide';
 } 
__p+='">\n                    <i class="fa fa-remove"></i>\n                </a>\n            </div>\n        </div>\n    ';
 }); }); 
__p+='\n    <a class="btn btn-default fd-kv-add-pair hide"><i class="fa fa-plus"></i> '+
((__t=(gettext("Add Key&rarr;Value Pair")))==null?'':__t)+
'</a>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/widget_control_message', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-control-message alert alert-warning alert-block '+
((__t=( msg.level ))==null?'':__t)+
'">\n    <button type="button" class="close" data-dismiss="alert">&times;</button>\n    ';
 if (html) { 
__p+=''+
((__t=( html ))==null?'':__t)+
'';
 } else { 
__p+=''+
((__t=( msg.message ))==null?'':_.escape(__t))+
'';
 } 
__p+='\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/date_format_popover', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=' (<a class="jstree-hover" id="'+
((__t=( guid ))==null?'':__t)+
'">'+
((__t=( text ))==null?'':__t)+
'</a>)';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/easy_reference_popover', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<p>'+
((__t=( text ))==null?'':__t)+
'</p>\n';
 if (ufid) { 
__p+='\n    <p>\n        <a class="jstree-hover" data-ufid="'+
((__t=( ufid ))==null?'':__t)+
'">\n            '+
((__t=(gettext("show in question list")))==null?'':_.escape(__t))+
'\n        </a>\n    </p>\n';
 } 
__p+='\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/date_format_menu', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">\n    <li style="padding-left: 10px;"><strong>'+
((__t=(gettext("Date Format Options")))==null?'':_.escape(__t))+
'</strong></li>\n    ';
 _.each(formats, function (label, format) { 
__p+='\n        <li><a tabindex="-1" data-format="'+
((__t=( format ))==null?'':__t)+
'">'+
((__t=( label ))==null?'':__t)+
'</a></li>\n    ';
 }); 
__p+='\n</ul>\n';
}
return __p;
}; });

define('vellum/dateformats',[
    'jquery',
    'tpl!vellum/templates/date_format_menu'
], function(
    $,
    date_format_menu
){
    function showMenu(x, y, callback, hideOnLeave) {
        var formats = {
                "": gettext("No Formatting"),
                "%e/%n/%y": "d/m/yy e.g. 30/1/14",
                "%a, %b %e, %Y": "ddd, mmm d, yyyy e.g. Thu, Jan 30, 2014"
            };
        var menu = $(date_format_menu({formats: formats}));
        $('body').append(menu);
        menu.find('li a').click(function () {
            var format = $(this).data("format");
            try {
                callback(format);
            } finally {
                menu.remove();
            }
            return false;
        });
        menu.css({'top': y, 'left': x}).show();
        if (hideOnLeave) {
            menu.mouseleave(function () {
                menu.fadeOut(400, function () { menu.remove(); });
            });
        }
    }

    return {
        showMenu: showMenu,
    };
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('xpath',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.xpath = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
	JavaScript BigInteger library version 0.9
	http://silentmatt.com/biginteger/

	Copyright (c) 2009 Matthew Crumley <email@matthewcrumley.com>
	Copyright (c) 2010,2011 by John Tobey <John.Tobey@gmail.com>
	Licensed under the MIT license.

	Support for arbitrary internal representation base was added by
	Vitaly Magerya.
*/

/*
	File: biginteger.js

	Exports:

		<BigInteger>
*/
(function(exports) {
"use strict";
/*
	Class: BigInteger
	An arbitrarily-large integer.

	<BigInteger> objects should be considered immutable. None of the "built-in"
	methods modify *this* or their arguments. All properties should be
	considered private.

	All the methods of <BigInteger> instances can be called "statically". The
	static versions are convenient if you don't already have a <BigInteger>
	object.

	As an example, these calls are equivalent.

	> BigInteger(4).multiply(5); // returns BigInteger(20);
	> BigInteger.multiply(4, 5); // returns BigInteger(20);

	> var a = 42;
	> var a = BigInteger.toJSValue("0b101010"); // Not completely useless...
*/

var CONSTRUCT = {}; // Unique token to call "private" version of constructor

/*
	Constructor: BigInteger()
	Convert a value to a <BigInteger>.

	Although <BigInteger()> is the constructor for <BigInteger> objects, it is
	best not to call it as a constructor. If *n* is a <BigInteger> object, it is
	simply returned as-is. Otherwise, <BigInteger()> is equivalent to <parse>
	without a radix argument.

	> var n0 = BigInteger();      // Same as <BigInteger.ZERO>
	> var n1 = BigInteger("123"); // Create a new <BigInteger> with value 123
	> var n2 = BigInteger(123);   // Create a new <BigInteger> with value 123
	> var n3 = BigInteger(n2);    // Return n2, unchanged

	The constructor form only takes an array and a sign. *n* must be an
	array of numbers in little-endian order, where each digit is between 0
	and BigInteger.base.  The second parameter sets the sign: -1 for
	negative, +1 for positive, or 0 for zero. The array is *not copied and
	may be modified*. If the array contains only zeros, the sign parameter
	is ignored and is forced to zero.

	> new BigInteger([5], -1): create a new BigInteger with value -5

	Parameters:

		n - Value to convert to a <BigInteger>.

	Returns:

		A <BigInteger> value.

	See Also:

		<parse>, <BigInteger>
*/
function BigInteger(n, s, token) {
	if (token !== CONSTRUCT) {
		if (n instanceof BigInteger) {
			return n;
		}
		else if (typeof n === "undefined") {
			return ZERO;
		}
		return BigInteger.parse(n);
	}

	n = n || [];  // Provide the nullary constructor for subclasses.
	while (n.length && !n[n.length - 1]) {
		--n.length;
	}
	this._d = n;
	this._s = n.length ? (s || 1) : 0;
}

BigInteger._construct = function(n, s) {
	return new BigInteger(n, s, CONSTRUCT);
};

// Base-10 speedup hacks in parse, toString, exp10 and log functions
// require base to be a power of 10. 10^7 is the largest such power
// that won't cause a precision loss when digits are multiplied.
var BigInteger_base = 10000000;
var BigInteger_base_log10 = 7;

BigInteger.base = BigInteger_base;
BigInteger.base_log10 = BigInteger_base_log10;

var ZERO = new BigInteger([], 0, CONSTRUCT);
// Constant: ZERO
// <BigInteger> 0.
BigInteger.ZERO = ZERO;

var ONE = new BigInteger([1], 1, CONSTRUCT);
// Constant: ONE
// <BigInteger> 1.
BigInteger.ONE = ONE;

var M_ONE = new BigInteger(ONE._d, -1, CONSTRUCT);
// Constant: M_ONE
// <BigInteger> -1.
BigInteger.M_ONE = M_ONE;

// Constant: _0
// Shortcut for <ZERO>.
BigInteger._0 = ZERO;

// Constant: _1
// Shortcut for <ONE>.
BigInteger._1 = ONE;

/*
	Constant: small
	Array of <BigIntegers> from 0 to 36.

	These are used internally for parsing, but useful when you need a "small"
	<BigInteger>.

	See Also:

		<ZERO>, <ONE>, <_0>, <_1>
*/
BigInteger.small = [
	ZERO,
	ONE,
	/* Assuming BigInteger_base > 36 */
	new BigInteger( [2], 1, CONSTRUCT),
	new BigInteger( [3], 1, CONSTRUCT),
	new BigInteger( [4], 1, CONSTRUCT),
	new BigInteger( [5], 1, CONSTRUCT),
	new BigInteger( [6], 1, CONSTRUCT),
	new BigInteger( [7], 1, CONSTRUCT),
	new BigInteger( [8], 1, CONSTRUCT),
	new BigInteger( [9], 1, CONSTRUCT),
	new BigInteger([10], 1, CONSTRUCT),
	new BigInteger([11], 1, CONSTRUCT),
	new BigInteger([12], 1, CONSTRUCT),
	new BigInteger([13], 1, CONSTRUCT),
	new BigInteger([14], 1, CONSTRUCT),
	new BigInteger([15], 1, CONSTRUCT),
	new BigInteger([16], 1, CONSTRUCT),
	new BigInteger([17], 1, CONSTRUCT),
	new BigInteger([18], 1, CONSTRUCT),
	new BigInteger([19], 1, CONSTRUCT),
	new BigInteger([20], 1, CONSTRUCT),
	new BigInteger([21], 1, CONSTRUCT),
	new BigInteger([22], 1, CONSTRUCT),
	new BigInteger([23], 1, CONSTRUCT),
	new BigInteger([24], 1, CONSTRUCT),
	new BigInteger([25], 1, CONSTRUCT),
	new BigInteger([26], 1, CONSTRUCT),
	new BigInteger([27], 1, CONSTRUCT),
	new BigInteger([28], 1, CONSTRUCT),
	new BigInteger([29], 1, CONSTRUCT),
	new BigInteger([30], 1, CONSTRUCT),
	new BigInteger([31], 1, CONSTRUCT),
	new BigInteger([32], 1, CONSTRUCT),
	new BigInteger([33], 1, CONSTRUCT),
	new BigInteger([34], 1, CONSTRUCT),
	new BigInteger([35], 1, CONSTRUCT),
	new BigInteger([36], 1, CONSTRUCT)
];

// Used for parsing/radix conversion
BigInteger.digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

/*
	Method: toString
	Convert a <BigInteger> to a string.

	When *base* is greater than 10, letters are upper case.

	Parameters:

		base - Optional base to represent the number in (default is base 10).
		       Must be between 2 and 36 inclusive, or an Error will be thrown.

	Returns:

		The string representation of the <BigInteger>.
*/
BigInteger.prototype.toString = function(base) {
	base = +base || 10;
	if (base < 2 || base > 36) {
		throw new Error("illegal radix " + base + ".");
	}
	if (this._s === 0) {
		return "0";
	}
	if (base === 10) {
		var str = this._s < 0 ? "-" : "";
		str += this._d[this._d.length - 1].toString();
		for (var i = this._d.length - 2; i >= 0; i--) {
			var group = this._d[i].toString();
			while (group.length < BigInteger_base_log10) group = '0' + group;
			str += group;
		}
		return str;
	}
	else {
		var numerals = BigInteger.digits;
		base = BigInteger.small[base];
		var sign = this._s;

		var n = this.abs();
		var digits = [];
		var digit;

		while (n._s !== 0) {
			var divmod = n.divRem(base);
			n = divmod[0];
			digit = divmod[1];
			// TODO: This could be changed to unshift instead of reversing at the end.
			// Benchmark both to compare speeds.
			digits.push(numerals[digit.valueOf()]);
		}
		return (sign < 0 ? "-" : "") + digits.reverse().join("");
	}
};

// Verify strings for parsing
BigInteger.radixRegex = [
	/^$/,
	/^$/,
	/^[01]*$/,
	/^[012]*$/,
	/^[0-3]*$/,
	/^[0-4]*$/,
	/^[0-5]*$/,
	/^[0-6]*$/,
	/^[0-7]*$/,
	/^[0-8]*$/,
	/^[0-9]*$/,
	/^[0-9aA]*$/,
	/^[0-9abAB]*$/,
	/^[0-9abcABC]*$/,
	/^[0-9a-dA-D]*$/,
	/^[0-9a-eA-E]*$/,
	/^[0-9a-fA-F]*$/,
	/^[0-9a-gA-G]*$/,
	/^[0-9a-hA-H]*$/,
	/^[0-9a-iA-I]*$/,
	/^[0-9a-jA-J]*$/,
	/^[0-9a-kA-K]*$/,
	/^[0-9a-lA-L]*$/,
	/^[0-9a-mA-M]*$/,
	/^[0-9a-nA-N]*$/,
	/^[0-9a-oA-O]*$/,
	/^[0-9a-pA-P]*$/,
	/^[0-9a-qA-Q]*$/,
	/^[0-9a-rA-R]*$/,
	/^[0-9a-sA-S]*$/,
	/^[0-9a-tA-T]*$/,
	/^[0-9a-uA-U]*$/,
	/^[0-9a-vA-V]*$/,
	/^[0-9a-wA-W]*$/,
	/^[0-9a-xA-X]*$/,
	/^[0-9a-yA-Y]*$/,
	/^[0-9a-zA-Z]*$/
];

/*
	Function: parse
	Parse a string into a <BigInteger>.

	*base* is optional but, if provided, must be from 2 to 36 inclusive. If
	*base* is not provided, it will be guessed based on the leading characters
	of *s* as follows:

	- "0x" or "0X": *base* = 16
	- "0c" or "0C": *base* = 8
	- "0b" or "0B": *base* = 2
	- else: *base* = 10

	If no base is provided, or *base* is 10, the number can be in exponential
	form. For example, these are all valid:

	> BigInteger.parse("1e9");              // Same as "1000000000"
	> BigInteger.parse("1.234*10^3");       // Same as 1234
	> BigInteger.parse("56789 * 10 ** -2"); // Same as 567

	If any characters fall outside the range defined by the radix, an exception
	will be thrown.

	Parameters:

		s - The string to parse.
		base - Optional radix (default is to guess based on *s*).

	Returns:

		a <BigInteger> instance.
*/
BigInteger.parse = function(s, base) {
	// Expands a number in exponential form to decimal form.
	// expandExponential("-13.441*10^5") === "1344100";
	// expandExponential("1.12300e-1") === "0.112300";
	// expandExponential(1000000000000000000000000000000) === "1000000000000000000000000000000";
	function expandExponential(str) {
		str = str.replace(/\s*[*xX]\s*10\s*(\^|\*\*)\s*/, "e");

		return str.replace(/^([+\-])?(\d+)\.?(\d*)[eE]([+\-]?\d+)$/, function(x, s, n, f, c) {
			c = +c;
			var l = c < 0;
			var i = n.length + c;
			x = (l ? n : f).length;
			c = ((c = Math.abs(c)) >= x ? c - x + l : 0);
			var z = (new Array(c + 1)).join("0");
			var r = n + f;
			return (s || "") + (l ? r = z + r : r += z).substr(0, i += l ? z.length : 0) + (i < r.length ? "." + r.substr(i) : "");
		});
	}

	s = s.toString();
	if (typeof base === "undefined" || +base === 10) {
		s = expandExponential(s);
	}

	var prefixRE;
	if (typeof base === "undefined") {
		prefixRE = '0[xcb]';
	}
	else if (base == 16) {
		prefixRE = '0x';
	}
	else if (base == 8) {
		prefixRE = '0c';
	}
	else if (base == 2) {
		prefixRE = '0b';
	}
	else {
		prefixRE = '';
	}
	var parts = new RegExp('^([+\\-]?)(' + prefixRE + ')?([0-9a-z]*)(?:\\.\\d*)?$', 'i').exec(s);
	if (parts) {
		var sign = parts[1] || "+";
		var baseSection = parts[2] || "";
		var digits = parts[3] || "";

		if (typeof base === "undefined") {
			// Guess base
			if (baseSection === "0x" || baseSection === "0X") { // Hex
				base = 16;
			}
			else if (baseSection === "0c" || baseSection === "0C") { // Octal
				base = 8;
			}
			else if (baseSection === "0b" || baseSection === "0B") { // Binary
				base = 2;
			}
			else {
				base = 10;
			}
		}
		else if (base < 2 || base > 36) {
			throw new Error("Illegal radix " + base + ".");
		}

		base = +base;

		// Check for digits outside the range
		if (!(BigInteger.radixRegex[base].test(digits))) {
			throw new Error("Bad digit for radix " + base);
		}

		// Strip leading zeros, and convert to array
		digits = digits.replace(/^0+/, "").split("");
		if (digits.length === 0) {
			return ZERO;
		}

		// Get the sign (we know it's not zero)
		sign = (sign === "-") ? -1 : 1;

		// Optimize 10
		if (base == 10) {
			var d = [];
			while (digits.length >= BigInteger_base_log10) {
				d.push(parseInt(digits.splice(digits.length-BigInteger.base_log10, BigInteger.base_log10).join(''), 10));
			}
			d.push(parseInt(digits.join(''), 10));
			return new BigInteger(d, sign, CONSTRUCT);
		}

		// Do the conversion
		var d = ZERO;
		base = BigInteger.small[base];
		var small = BigInteger.small;
		for (var i = 0; i < digits.length; i++) {
			d = d.multiply(base).add(small[parseInt(digits[i], 36)]);
		}
		return new BigInteger(d._d, sign, CONSTRUCT);
	}
	else {
		throw new Error("Invalid BigInteger format: " + s);
	}
};

/*
	Function: add
	Add two <BigIntegers>.

	Parameters:

		n - The number to add to *this*. Will be converted to a <BigInteger>.

	Returns:

		The numbers added together.

	See Also:

		<subtract>, <multiply>, <quotient>, <next>
*/
BigInteger.prototype.add = function(n) {
	if (this._s === 0) {
		return BigInteger(n);
	}

	n = BigInteger(n);
	if (n._s === 0) {
		return this;
	}
	if (this._s !== n._s) {
		n = n.negate();
		return this.subtract(n);
	}

	var a = this._d;
	var b = n._d;
	var al = a.length;
	var bl = b.length;
	var sum = new Array(Math.max(al, bl) + 1);
	var size = Math.min(al, bl);
	var carry = 0;
	var digit;

	for (var i = 0; i < size; i++) {
		digit = a[i] + b[i] + carry;
		sum[i] = digit % BigInteger_base;
		carry = (digit / BigInteger_base) | 0;
	}
	if (bl > al) {
		a = b;
		al = bl;
	}
	for (i = size; carry && i < al; i++) {
		digit = a[i] + carry;
		sum[i] = digit % BigInteger_base;
		carry = (digit / BigInteger_base) | 0;
	}
	if (carry) {
		sum[i] = carry;
	}

	for ( ; i < al; i++) {
		sum[i] = a[i];
	}

	return new BigInteger(sum, this._s, CONSTRUCT);
};

/*
	Function: negate
	Get the additive inverse of a <BigInteger>.

	Returns:

		A <BigInteger> with the same magnatude, but with the opposite sign.

	See Also:

		<abs>
*/
BigInteger.prototype.negate = function() {
	return new BigInteger(this._d, (-this._s) | 0, CONSTRUCT);
};

/*
	Function: abs
	Get the absolute value of a <BigInteger>.

	Returns:

		A <BigInteger> with the same magnatude, but always positive (or zero).

	See Also:

		<negate>
*/
BigInteger.prototype.abs = function() {
	return (this._s < 0) ? this.negate() : this;
};

/*
	Function: subtract
	Subtract two <BigIntegers>.

	Parameters:

		n - The number to subtract from *this*. Will be converted to a <BigInteger>.

	Returns:

		The *n* subtracted from *this*.

	See Also:

		<add>, <multiply>, <quotient>, <prev>
*/
BigInteger.prototype.subtract = function(n) {
	if (this._s === 0) {
		return BigInteger(n).negate();
	}

	n = BigInteger(n);
	if (n._s === 0) {
		return this;
	}
	if (this._s !== n._s) {
		n = n.negate();
		return this.add(n);
	}

	var m = this;
	// negative - negative => -|a| - -|b| => -|a| + |b| => |b| - |a|
	if (this._s < 0) {
		m = new BigInteger(n._d, 1, CONSTRUCT);
		n = new BigInteger(this._d, 1, CONSTRUCT);
	}

	// Both are positive => a - b
	var sign = m.compareAbs(n);
	if (sign === 0) {
		return ZERO;
	}
	else if (sign < 0) {
		// swap m and n
		var t = n;
		n = m;
		m = t;
	}

	// a > b
	var a = m._d;
	var b = n._d;
	var al = a.length;
	var bl = b.length;
	var diff = new Array(al); // al >= bl since a > b
	var borrow = 0;
	var i;
	var digit;

	for (i = 0; i < bl; i++) {
		digit = a[i] - borrow - b[i];
		if (digit < 0) {
			digit += BigInteger_base;
			borrow = 1;
		}
		else {
			borrow = 0;
		}
		diff[i] = digit;
	}
	for (i = bl; i < al; i++) {
		digit = a[i] - borrow;
		if (digit < 0) {
			digit += BigInteger_base;
		}
		else {
			diff[i++] = digit;
			break;
		}
		diff[i] = digit;
	}
	for ( ; i < al; i++) {
		diff[i] = a[i];
	}

	return new BigInteger(diff, sign, CONSTRUCT);
};

(function() {
	function addOne(n, sign) {
		var a = n._d;
		var sum = a.slice();
		var carry = true;
		var i = 0;

		while (true) {
			var digit = (a[i] || 0) + 1;
			sum[i] = digit % BigInteger_base;
			if (digit <= BigInteger_base - 1) {
				break;
			}
			++i;
		}

		return new BigInteger(sum, sign, CONSTRUCT);
	}

	function subtractOne(n, sign) {
		var a = n._d;
		var sum = a.slice();
		var borrow = true;
		var i = 0;

		while (true) {
			var digit = (a[i] || 0) - 1;
			if (digit < 0) {
				sum[i] = digit + BigInteger_base;
			}
			else {
				sum[i] = digit;
				break;
			}
			++i;
		}

		return new BigInteger(sum, sign, CONSTRUCT);
	}

	/*
		Function: next
		Get the next <BigInteger> (add one).

		Returns:

			*this* + 1.

		See Also:

			<add>, <prev>
	*/
	BigInteger.prototype.next = function() {
		switch (this._s) {
		case 0:
			return ONE;
		case -1:
			return subtractOne(this, -1);
		// case 1:
		default:
			return addOne(this, 1);
		}
	};

	/*
		Function: prev
		Get the previous <BigInteger> (subtract one).

		Returns:

			*this* - 1.

		See Also:

			<next>, <subtract>
	*/
	BigInteger.prototype.prev = function() {
		switch (this._s) {
		case 0:
			return M_ONE;
		case -1:
			return addOne(this, -1);
		// case 1:
		default:
			return subtractOne(this, 1);
		}
	};
})();

/*
	Function: compareAbs
	Compare the absolute value of two <BigIntegers>.

	Calling <compareAbs> is faster than calling <abs> twice, then <compare>.

	Parameters:

		n - The number to compare to *this*. Will be converted to a <BigInteger>.

	Returns:

		-1, 0, or +1 if *|this|* is less than, equal to, or greater than *|n|*.

	See Also:

		<compare>, <abs>
*/
BigInteger.prototype.compareAbs = function(n) {
	if (this === n) {
		return 0;
	}

	if (!(n instanceof BigInteger)) {
		if (!isFinite(n)) {
			return(isNaN(n) ? n : -1);
		}
		n = BigInteger(n);
	}

	if (this._s === 0) {
		return (n._s !== 0) ? -1 : 0;
	}
	if (n._s === 0) {
		return 1;
	}

	var l = this._d.length;
	var nl = n._d.length;
	if (l < nl) {
		return -1;
	}
	else if (l > nl) {
		return 1;
	}

	var a = this._d;
	var b = n._d;
	for (var i = l-1; i >= 0; i--) {
		if (a[i] !== b[i]) {
			return a[i] < b[i] ? -1 : 1;
		}
	}

	return 0;
};

/*
	Function: compare
	Compare two <BigIntegers>.

	Parameters:

		n - The number to compare to *this*. Will be converted to a <BigInteger>.

	Returns:

		-1, 0, or +1 if *this* is less than, equal to, or greater than *n*.

	See Also:

		<compareAbs>, <isPositive>, <isNegative>, <isUnit>
*/
BigInteger.prototype.compare = function(n) {
	if (this === n) {
		return 0;
	}

	n = BigInteger(n);

	if (this._s === 0) {
		return -n._s;
	}

	if (this._s === n._s) { // both positive or both negative
		var cmp = this.compareAbs(n);
		return cmp * this._s;
	}
	else {
		return this._s;
	}
};

/*
	Function: isUnit
	Return true iff *this* is either 1 or -1.

	Returns:

		true if *this* compares equal to <BigInteger.ONE> or <BigInteger.M_ONE>.

	See Also:

		<isZero>, <isNegative>, <isPositive>, <compareAbs>, <compare>,
		<BigInteger.ONE>, <BigInteger.M_ONE>
*/
BigInteger.prototype.isUnit = function() {
	return this === ONE ||
		this === M_ONE ||
		(this._d.length === 1 && this._d[0] === 1);
};

/*
	Function: multiply
	Multiply two <BigIntegers>.

	Parameters:

		n - The number to multiply *this* by. Will be converted to a
		<BigInteger>.

	Returns:

		The numbers multiplied together.

	See Also:

		<add>, <subtract>, <quotient>, <square>
*/
BigInteger.prototype.multiply = function(n) {
	// TODO: Consider adding Karatsuba multiplication for large numbers
	if (this._s === 0) {
		return ZERO;
	}

	n = BigInteger(n);
	if (n._s === 0) {
		return ZERO;
	}
	if (this.isUnit()) {
		if (this._s < 0) {
			return n.negate();
		}
		return n;
	}
	if (n.isUnit()) {
		if (n._s < 0) {
			return this.negate();
		}
		return this;
	}
	if (this === n) {
		return this.square();
	}

	var r = (this._d.length >= n._d.length);
	var a = (r ? this : n)._d; // a will be longer than b
	var b = (r ? n : this)._d;
	var al = a.length;
	var bl = b.length;

	var pl = al + bl;
	var partial = new Array(pl);
	var i;
	for (i = 0; i < pl; i++) {
		partial[i] = 0;
	}

	for (i = 0; i < bl; i++) {
		var carry = 0;
		var bi = b[i];
		var jlimit = al + i;
		var digit;
		for (var j = i; j < jlimit; j++) {
			digit = partial[j] + bi * a[j - i] + carry;
			carry = (digit / BigInteger_base) | 0;
			partial[j] = (digit % BigInteger_base) | 0;
		}
		if (carry) {
			digit = partial[j] + carry;
			carry = (digit / BigInteger_base) | 0;
			partial[j] = digit % BigInteger_base;
		}
	}
	return new BigInteger(partial, this._s * n._s, CONSTRUCT);
};

// Multiply a BigInteger by a single-digit native number
// Assumes that this and n are >= 0
// This is not really intended to be used outside the library itself
BigInteger.prototype.multiplySingleDigit = function(n) {
	if (n === 0 || this._s === 0) {
		return ZERO;
	}
	if (n === 1) {
		return this;
	}

	var digit;
	if (this._d.length === 1) {
		digit = this._d[0] * n;
		if (digit >= BigInteger_base) {
			return new BigInteger([(digit % BigInteger_base)|0,
					(digit / BigInteger_base)|0], 1, CONSTRUCT);
		}
		return new BigInteger([digit], 1, CONSTRUCT);
	}

	if (n === 2) {
		return this.add(this);
	}
	if (this.isUnit()) {
		return new BigInteger([n], 1, CONSTRUCT);
	}

	var a = this._d;
	var al = a.length;

	var pl = al + 1;
	var partial = new Array(pl);
	for (var i = 0; i < pl; i++) {
		partial[i] = 0;
	}

	var carry = 0;
	for (var j = 0; j < al; j++) {
		digit = n * a[j] + carry;
		carry = (digit / BigInteger_base) | 0;
		partial[j] = (digit % BigInteger_base) | 0;
	}
	if (carry) {
		partial[j] = carry;
	}

	return new BigInteger(partial, 1, CONSTRUCT);
};

/*
	Function: square
	Multiply a <BigInteger> by itself.

	This is slightly faster than regular multiplication, since it removes the
	duplicated multiplcations.

	Returns:

		> this.multiply(this)

	See Also:
		<multiply>
*/
BigInteger.prototype.square = function() {
	// Normally, squaring a 10-digit number would take 100 multiplications.
	// Of these 10 are unique diagonals, of the remaining 90 (100-10), 45 are repeated.
	// This procedure saves (N*(N-1))/2 multiplications, (e.g., 45 of 100 multiplies).
	// Based on code by Gary Darby, Intellitech Systems Inc., www.DelphiForFun.org

	if (this._s === 0) {
		return ZERO;
	}
	if (this.isUnit()) {
		return ONE;
	}

	var digits = this._d;
	var length = digits.length;
	var imult1 = new Array(length + length + 1);
	var product, carry, k;
	var i;

	// Calculate diagonal
	for (i = 0; i < length; i++) {
		k = i * 2;
		product = digits[i] * digits[i];
		carry = (product / BigInteger_base) | 0;
		imult1[k] = product % BigInteger_base;
		imult1[k + 1] = carry;
	}

	// Calculate repeating part
	for (i = 0; i < length; i++) {
		carry = 0;
		k = i * 2 + 1;
		for (var j = i + 1; j < length; j++, k++) {
			product = digits[j] * digits[i] * 2 + imult1[k] + carry;
			carry = (product / BigInteger_base) | 0;
			imult1[k] = product % BigInteger_base;
		}
		k = length + i;
		var digit = carry + imult1[k];
		carry = (digit / BigInteger_base) | 0;
		imult1[k] = digit % BigInteger_base;
		imult1[k + 1] += carry;
	}

	return new BigInteger(imult1, 1, CONSTRUCT);
};

/*
	Function: quotient
	Divide two <BigIntegers> and truncate towards zero.

	<quotient> throws an exception if *n* is zero.

	Parameters:

		n - The number to divide *this* by. Will be converted to a <BigInteger>.

	Returns:

		The *this* / *n*, truncated to an integer.

	See Also:

		<add>, <subtract>, <multiply>, <divRem>, <remainder>
*/
BigInteger.prototype.quotient = function(n) {
	return this.divRem(n)[0];
};

/*
	Function: divide
	Deprecated synonym for <quotient>.
*/
BigInteger.prototype.divide = BigInteger.prototype.quotient;

/*
	Function: remainder
	Calculate the remainder of two <BigIntegers>.

	<remainder> throws an exception if *n* is zero.

	Parameters:

		n - The remainder after *this* is divided *this* by *n*. Will be
		    converted to a <BigInteger>.

	Returns:

		*this* % *n*.

	See Also:

		<divRem>, <quotient>
*/
BigInteger.prototype.remainder = function(n) {
	return this.divRem(n)[1];
};

/*
	Function: divRem
	Calculate the integer quotient and remainder of two <BigIntegers>.

	<divRem> throws an exception if *n* is zero.

	Parameters:

		n - The number to divide *this* by. Will be converted to a <BigInteger>.

	Returns:

		A two-element array containing the quotient and the remainder.

		> a.divRem(b)

		is exactly equivalent to

		> [a.quotient(b), a.remainder(b)]

		except it is faster, because they are calculated at the same time.

	See Also:

		<quotient>, <remainder>
*/
BigInteger.prototype.divRem = function(n) {
	n = BigInteger(n);
	if (n._s === 0) {
		throw new Error("Divide by zero");
	}
	if (this._s === 0) {
		return [ZERO, ZERO];
	}
	if (n._d.length === 1) {
		return this.divRemSmall(n._s * n._d[0]);
	}

	// Test for easy cases -- |n1| <= |n2|
	switch (this.compareAbs(n)) {
	case 0: // n1 == n2
		return [this._s === n._s ? ONE : M_ONE, ZERO];
	case -1: // |n1| < |n2|
		return [ZERO, this];
	}

	var sign = this._s * n._s;
	var a = n.abs();
	var b_digits = this._d;
	var b_index = b_digits.length;
	var digits = n._d.length;
	var quot = [];
	var guess;

	var part = new BigInteger([], 0, CONSTRUCT);
	part._s = 1;

	while (b_index) {
		part._d.unshift(b_digits[--b_index]);

		if (part.compareAbs(n) < 0) {
			quot.push(0);
			continue;
		}
		if (part._s === 0) {
			guess = 0;
		}
		else {
			var xlen = part._d.length, ylen = a._d.length;
			var highx = part._d[xlen-1]*BigInteger_base + part._d[xlen-2];
			var highy = a._d[ylen-1]*BigInteger_base + a._d[ylen-2];
			if (part._d.length > a._d.length) {
				// The length of part._d can either match a._d length,
				// or exceed it by one.
				highx = (highx+1)*BigInteger_base;
			}
			guess = Math.ceil(highx/highy);
		}
		do {
			var check = a.multiplySingleDigit(guess);
			if (check.compareAbs(part) <= 0) {
				break;
			}
			guess--;
		} while (guess);

		quot.push(guess);
		if (!guess) {
			continue;
		}
		var diff = part.subtract(check);
		part._d = diff._d.slice();
		if (part._d.length === 0) {
			part._s = 0;
		}
	}

	return [new BigInteger(quot.reverse(), sign, CONSTRUCT),
		   new BigInteger(part._d, this._s, CONSTRUCT)];
};

// Throws an exception if n is outside of (-BigInteger.base, -1] or
// [1, BigInteger.base).  It's not necessary to call this, since the
// other division functions will call it if they are able to.
BigInteger.prototype.divRemSmall = function(n) {
	var r;
	n = +n;
	if (n === 0) {
		throw new Error("Divide by zero");
	}

	var n_s = n < 0 ? -1 : 1;
	var sign = this._s * n_s;
	n = Math.abs(n);

	if (n < 1 || n >= BigInteger_base) {
		throw new Error("Argument out of range");
	}

	if (this._s === 0) {
		return [ZERO, ZERO];
	}

	if (n === 1 || n === -1) {
		return [(sign === 1) ? this.abs() : new BigInteger(this._d, sign, CONSTRUCT), ZERO];
	}

	// 2 <= n < BigInteger_base

	// divide a single digit by a single digit
	if (this._d.length === 1) {
		var q = new BigInteger([(this._d[0] / n) | 0], 1, CONSTRUCT);
		r = new BigInteger([(this._d[0] % n) | 0], 1, CONSTRUCT);
		if (sign < 0) {
			q = q.negate();
		}
		if (this._s < 0) {
			r = r.negate();
		}
		return [q, r];
	}

	var digits = this._d.slice();
	var quot = new Array(digits.length);
	var part = 0;
	var diff = 0;
	var i = 0;
	var guess;

	while (digits.length) {
		part = part * BigInteger_base + digits[digits.length - 1];
		if (part < n) {
			quot[i++] = 0;
			digits.pop();
			diff = BigInteger_base * diff + part;
			continue;
		}
		if (part === 0) {
			guess = 0;
		}
		else {
			guess = (part / n) | 0;
		}

		var check = n * guess;
		diff = part - check;
		quot[i++] = guess;
		if (!guess) {
			digits.pop();
			continue;
		}

		digits.pop();
		part = diff;
	}

	r = new BigInteger([diff], 1, CONSTRUCT);
	if (this._s < 0) {
		r = r.negate();
	}
	return [new BigInteger(quot.reverse(), sign, CONSTRUCT), r];
};

/*
	Function: isEven
	Return true iff *this* is divisible by two.

	Note that <BigInteger.ZERO> is even.

	Returns:

		true if *this* is even, false otherwise.

	See Also:

		<isOdd>
*/
BigInteger.prototype.isEven = function() {
	var digits = this._d;
	return this._s === 0 || digits.length === 0 || (digits[0] % 2) === 0;
};

/*
	Function: isOdd
	Return true iff *this* is not divisible by two.

	Returns:

		true if *this* is odd, false otherwise.

	See Also:

		<isEven>
*/
BigInteger.prototype.isOdd = function() {
	return !this.isEven();
};

/*
	Function: sign
	Get the sign of a <BigInteger>.

	Returns:

		* -1 if *this* < 0
		* 0 if *this* == 0
		* +1 if *this* > 0

	See Also:

		<isZero>, <isPositive>, <isNegative>, <compare>, <BigInteger.ZERO>
*/
BigInteger.prototype.sign = function() {
	return this._s;
};

/*
	Function: isPositive
	Return true iff *this* > 0.

	Returns:

		true if *this*.compare(<BigInteger.ZERO>) == 1.

	See Also:

		<sign>, <isZero>, <isNegative>, <isUnit>, <compare>, <BigInteger.ZERO>
*/
BigInteger.prototype.isPositive = function() {
	return this._s > 0;
};

/*
	Function: isNegative
	Return true iff *this* < 0.

	Returns:

		true if *this*.compare(<BigInteger.ZERO>) == -1.

	See Also:

		<sign>, <isPositive>, <isZero>, <isUnit>, <compare>, <BigInteger.ZERO>
*/
BigInteger.prototype.isNegative = function() {
	return this._s < 0;
};

/*
	Function: isZero
	Return true iff *this* == 0.

	Returns:

		true if *this*.compare(<BigInteger.ZERO>) == 0.

	See Also:

		<sign>, <isPositive>, <isNegative>, <isUnit>, <BigInteger.ZERO>
*/
BigInteger.prototype.isZero = function() {
	return this._s === 0;
};

/*
	Function: exp10
	Multiply a <BigInteger> by a power of 10.

	This is equivalent to, but faster than

	> if (n >= 0) {
	>     return this.multiply(BigInteger("1e" + n));
	> }
	> else { // n <= 0
	>     return this.quotient(BigInteger("1e" + -n));
	> }

	Parameters:

		n - The power of 10 to multiply *this* by. *n* is converted to a
		javascipt number and must be no greater than <BigInteger.MAX_EXP>
		(0x7FFFFFFF), or an exception will be thrown.

	Returns:

		*this* * (10 ** *n*), truncated to an integer if necessary.

	See Also:

		<pow>, <multiply>
*/
BigInteger.prototype.exp10 = function(n) {
	n = +n;
	if (n === 0) {
		return this;
	}
	if (Math.abs(n) > Number(MAX_EXP)) {
		throw new Error("exponent too large in BigInteger.exp10");
	}
	if (n > 0) {
		var k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);

		for (; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {
			k._d.unshift(0);
		}
		if (n == 0)
			return k;
		k._s = 1;
		k = k.multiplySingleDigit(Math.pow(10, n));
		return (this._s < 0 ? k.negate() : k);
	} else if (-n >= this._d.length*BigInteger_base_log10) {
		return ZERO;
	} else {
		var k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);

		for (n = -n; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {
			k._d.shift();
		}
		return (n == 0) ? k : k.divRemSmall(Math.pow(10, n))[0];
	}
};

/*
	Function: pow
	Raise a <BigInteger> to a power.

	In this implementation, 0**0 is 1.

	Parameters:

		n - The exponent to raise *this* by. *n* must be no greater than
		<BigInteger.MAX_EXP> (0x7FFFFFFF), or an exception will be thrown.

	Returns:

		*this* raised to the *nth* power.

	See Also:

		<modPow>
*/
BigInteger.prototype.pow = function(n) {
	if (this.isUnit()) {
		if (this._s > 0) {
			return this;
		}
		else {
			return BigInteger(n).isOdd() ? this : this.negate();
		}
	}

	n = BigInteger(n);
	if (n._s === 0) {
		return ONE;
	}
	else if (n._s < 0) {
		if (this._s === 0) {
			throw new Error("Divide by zero");
		}
		else {
			return ZERO;
		}
	}
	if (this._s === 0) {
		return ZERO;
	}
	if (n.isUnit()) {
		return this;
	}

	if (n.compareAbs(MAX_EXP) > 0) {
		throw new Error("exponent too large in BigInteger.pow");
	}
	var x = this;
	var aux = ONE;
	var two = BigInteger.small[2];

	while (n.isPositive()) {
		if (n.isOdd()) {
			aux = aux.multiply(x);
			if (n.isUnit()) {
				return aux;
			}
		}
		x = x.square();
		n = n.quotient(two);
	}

	return aux;
};

/*
	Function: modPow
	Raise a <BigInteger> to a power (mod m).

	Because it is reduced by a modulus, <modPow> is not limited by
	<BigInteger.MAX_EXP> like <pow>.

	Parameters:

		exponent - The exponent to raise *this* by. Must be positive.
		modulus - The modulus.

	Returns:

		*this* ^ *exponent* (mod *modulus*).

	See Also:

		<pow>, <mod>
*/
BigInteger.prototype.modPow = function(exponent, modulus) {
	var result = ONE;
	var base = this;

	while (exponent.isPositive()) {
		if (exponent.isOdd()) {
			result = result.multiply(base).remainder(modulus);
		}

		exponent = exponent.quotient(BigInteger.small[2]);
		if (exponent.isPositive()) {
			base = base.square().remainder(modulus);
		}
	}

	return result;
};

/*
	Function: log
	Get the natural logarithm of a <BigInteger> as a native JavaScript number.

	This is equivalent to

	> Math.log(this.toJSValue())

	but handles values outside of the native number range.

	Returns:

		log( *this* )

	See Also:

		<toJSValue>
*/
BigInteger.prototype.log = function() {
	switch (this._s) {
	case 0:	 return -Infinity;
	case -1: return NaN;
	default: // Fall through.
	}

	var l = this._d.length;

	if (l*BigInteger_base_log10 < 30) {
		return Math.log(this.valueOf());
	}

	var N = Math.ceil(30/BigInteger_base_log10);
	var firstNdigits = this._d.slice(l - N);
	return Math.log((new BigInteger(firstNdigits, 1, CONSTRUCT)).valueOf()) + (l - N) * Math.log(BigInteger_base);
};

/*
	Function: valueOf
	Convert a <BigInteger> to a native JavaScript integer.

	This is called automatically by JavaScipt to convert a <BigInteger> to a
	native value.

	Returns:

		> parseInt(this.toString(), 10)

	See Also:

		<toString>, <toJSValue>
*/
BigInteger.prototype.valueOf = function() {
	return parseInt(this.toString(), 10);
};

/*
	Function: toJSValue
	Convert a <BigInteger> to a native JavaScript integer.

	This is the same as valueOf, but more explicitly named.

	Returns:

		> parseInt(this.toString(), 10)

	See Also:

		<toString>, <valueOf>
*/
BigInteger.prototype.toJSValue = function() {
	return parseInt(this.toString(), 10);
};

var MAX_EXP = BigInteger(0x7FFFFFFF);
// Constant: MAX_EXP
// The largest exponent allowed in <pow> and <exp10> (0x7FFFFFFF or 2147483647).
BigInteger.MAX_EXP = MAX_EXP;

(function() {
	function makeUnary(fn) {
		return function(a) {
			return fn.call(BigInteger(a));
		};
	}

	function makeBinary(fn) {
		return function(a, b) {
			return fn.call(BigInteger(a), BigInteger(b));
		};
	}

	function makeTrinary(fn) {
		return function(a, b, c) {
			return fn.call(BigInteger(a), BigInteger(b), BigInteger(c));
		};
	}

	(function() {
		var i, fn;
		var unary = "toJSValue,isEven,isOdd,sign,isZero,isNegative,abs,isUnit,square,negate,isPositive,toString,next,prev,log".split(",");
		var binary = "compare,remainder,divRem,subtract,add,quotient,divide,multiply,pow,compareAbs".split(",");
		var trinary = ["modPow"];

		for (i = 0; i < unary.length; i++) {
			fn = unary[i];
			BigInteger[fn] = makeUnary(BigInteger.prototype[fn]);
		}

		for (i = 0; i < binary.length; i++) {
			fn = binary[i];
			BigInteger[fn] = makeBinary(BigInteger.prototype[fn]);
		}

		for (i = 0; i < trinary.length; i++) {
			fn = trinary[i];
			BigInteger[fn] = makeTrinary(BigInteger.prototype[fn]);
		}

		BigInteger.exp10 = function(x, n) {
			return BigInteger(x).exp10(n);
		};
	})();
})();

exports.BigInteger = BigInteger;
})(typeof exports !== 'undefined' ? exports : this);

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":4}],4:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
// Scheme numerical tower in JavaScript.  Described in README.
// Copyright (c) 2011 by John Tobey <John.Tobey@gmail.com>

/*
    File: schemeNumber.js

    Exports:

        <SchemeNumber>

    Depends:

        <biginteger.js> for <BigInteger>
 */

// Grab the BigInteger library.
var BigInteger;
if (!this.BigInteger && typeof require !== "undefined")
    BigInteger = require("biginteger").BigInteger;
else
    BigInteger = this.BigInteger;

if (!BigInteger) {
    if (typeof load !== "undefined")
        load("biginteger.js");
    else if (this.readFile)
        eval(this.readFile("biginteger.js"));
    else
        throw new Error("BigInteger is not defined.");
}

/*
    Class: SchemeNumber
    A number object as <defined by the Scheme language at
    http://www.r6rs.org/>.

    Scheme supports *exact* arithmetic and mixing exact with standard
    (*inexact*) numbers.  Several basic operations, including
    addition, subtraction, multiplication, and division, when given
    only exact arguments, must return an exact, numerically correct
    result.

    These operations are allowed to fail due to running out of memory,
    but they are not allowed to return approximations the way
    ECMAScript operators may, unless given one or more inexact
    arguments.

    For example, adding exact *1/100* to exact *0* one hundred times
    produces exactly *1*, not 1.0000000000000007 as in JavaScript.
    Raising exact *2* to the power of exact *1024* returns a 308-digit
    integer with complete precision, not *Infinity* as in ECMAScript.

    This implementation provides all functions listed in the <R6RS
    Scheme specification at http://www.r6rs.org/>, Section 11.7, along
    with <eqv?> from Section 11.5.  (<eqv?> uses JavaScript's *===* to
    compare non-numbers.)

    Exact numbers support the standard ECMA Number formatting methods
    (toFixed, toExponential, and toPrecision) without a fixed upper
    limit to precision.

    The schemeNumber.js file exports an object <SchemeNumber>.  It
    contains a property <fn>, which in turn contains the functions
    implementing the numeric types.

    The <SchemeNumber> object is in fact a function that converts its
    argument to a Scheme number: similar to a constructor, but it may
    not always return an object, let alone a unique object.

    Parameters:

        obj - Object to be converted to a Scheme number.

    *obj* may have any of the following
    types:

        Scheme number - returned unchanged.
        String        - converted as if by *string->number*.
        Native ECMAScript number - treated as an inexact real.

    Returns:

        A Scheme number.

    Exceptions:

        If *obj* can not be parsed, <SchemeNumber> will <raise> an
        exception with condition type *&assertion*.

    See Also:

        <fn>, <raise>, <R6RS Chapter 3: Numbers at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-6.html#node_chap_3>
*/
var SchemeNumber = (function() {

function assert(x) { if (!x) throw new Error("assertion failed"); }

var abs      = Math.abs;
var floor    = Math.floor;
var ceil     = Math.ceil;
var round    = Math.round;
var pow      = Math.pow;
var sqrt     = Math.sqrt;
var atan2    = Math.atan2;
var log      = Math.log;
var exp      = Math.exp;
var atan     = Math.atan;
var cos      = Math.cos;
var sin      = Math.sin;
var tan      = Math.tan;
var LN2      = Math.LN2;
var LN10     = Math.LN10;
var _isFinite = isFinite;
var _isNaN    = isNaN;
var _parseInt = parseInt;
var _parseFloat = parseFloat;

function retFalse()   { return false; }
function retTrue()    { return true;  }
function retFirst(a)  { return a; }
function retThis()    { return this; }

function unimpl() {
    throw new Error("BUG: unimplemented");
}
function pureVirtual() {
    throw new Error("BUG: Abstract method not overridden");
}

function N() {}   N.prototype = new Number();  // Scheme numbers.
function C() {}   C.prototype = new N();       // Complex numbers.
function R() {}   R.prototype = new C();       // Reals.
function ER() {} ER.prototype = new R();       // Exact reals.
function EQ() {} EQ.prototype = new ER();      // Exact rationals.
function EI() {} EI.prototype = new EQ();      // Exact integers.

// How to split a rectangular literal into real and imaginary components:
var decimalComplex = /^(.*[^a-zA-Z]|)([-+].*)i$/;
var radixComplex = /^(.*)([-+].*)i$/;

var nanInfPattern = /^[-+](nan|inf)\.0$/;
var exponentMarkerPattern = /[eEsSfFdDlL]/;
var decimal10Pattern = /^([0-9]+\.?|[0-9]*\.[0-9]+)([eEsSfFdDlL][-+]?[0-9]+)?$/;

var uintegerPattern = {
    2: /^[01]+$/, 8: /^[0-7]+$/, 10: /^[0-9]+$/, 16: /^[0-9a-fA-F]+$/
};

function retZero()    { return ZERO; }
function retOne()     { return ONE; }

function divisionByExactZero() {
    raise("&assertion", "division by exact zero");
}

// Is the Flonum class simply the native Number?  In that case we will
// add methods to Number.prototype.

var Flonum;

// Users who wish to optimize the library by stripping support for
// Number.prototype cleanliness may simply replace "toFlonum("
// globally with "(" and change false to true here.

if (false) {  // XXX Should expose a way to choose this branch.
    // Flonum is Number.
    Flonum = Number;
}
else {
    // Flonum is a regular class in the hierarchy.
    Flonum = function(x) {
        this._ = x;
    };
}

var toFlonum, isNumber;
var flo = {};
var FLO_FUNCS = [[],
                 ["log", "floor", "ceil", "sqrt", "abs", "atan",
                  "cos", "sin", "tan", "exp"],
                 ["pow", "atan2"]];

if (Flonum === Number) {
    toFlonum = retFirst;

    isNumber = function(x) {
        return x instanceof Number || typeof x === "number";
    };
    FLO_FUNCS[1].concat(FLO_FUNCS[2]).forEach(function(name) {
            flo[name] = Math[name];
        });
}
else {
    Flonum.prototype = new R();

    (function() {
        var inexactZero = new Flonum(0);
        toFlonum = function(x) {
            //assert(typeof x === "number");
            return (x === 0 ? inexactZero : new Flonum(x));
        };
    })();

    isNumber = function(x) {
        return x instanceof N;
    };
    FLO_FUNCS[1].forEach(function(name) {
            var math = Math[name];
            flo[name] = function(a) {
                return toFlonum(math(a));
            };
        });
    FLO_FUNCS[2].forEach(function(name) {
            var math = Math[name];
            flo[name] = function(a, b) {
                return toFlonum(math(a, b));
            };
        });
    ["toFixed", "toExponential", "toPrecision"].forEach(function(name) {
            var number = Number.prototype[name];
            Flonum.prototype[name] = function(a) {
                return number.call(this._, a);
            };
        });
    Flonum.prototype.valueOf = function() {
        return this._;
    };
}

/* Internal class hierarchy:

   Number
     ^
     N
     ^
     C  <----  Rectangular
                   |
                   `--  R  <----  Flonum[1]
                             |
                             `--  ER  <---  EQ  <----  EQFraction
                                                  |
                                                  `--  EI  <----  EINative
                                                             |
                                                             `--  EIBig

   [1] In some configurations, the Flonum class actually equals Number
   for reasons of efficiency.  Logically, Flonum should be a direct
   subclass of R.  Initialization code populates missing slots in
   Flonum.prototype as if that were the case.

   The concrete classes are:

   Flonum      - inexact real as a native number, possibly NaN or infinite.
   Rectangular - complex number as real and imaginary parts of same exactness.
   EQFraction  - exact rational as numerator and denominator in lowest terms.
   EINative    - exact integer as (wrapped) native number.
   EIBig       - exact integer as BigInteger.

   The abstract C, R, ER, EQ, and EI classes hold information about
   the respective number types (complex, real, exact real, exact
   rational, and exact integer) and stimulate thought about new
   concrete classes.

   Possible future classes:
   C <-- Polar - possibly exact complex number in polar coordinates;
   EQ <-- EQNative - exact rational as native number (power-of-2 denominator);
   EQ <-- EQDecimal - exact rational as BigInteger times a power of 10;
   R <-- BigFloat - inexact real of non-standard precision.
*/

// SN: private alias for the public SchemeNumber object.
function SN(obj) {
    if (obj instanceof N) {
        return obj;
    }

    var ret = obj;

    if (typeof ret !== "string") {
        if (typeof ret === "number") {
            return toFlonum(ret);
        }
        if (ret instanceof Number) {
            return toFlonum(+ret);
        }

        if (ret == null) {
            // XXX Rethink this.
            return (ret === null ? INEXACT_ZERO : NAN);
        }

        ret = ret.valueOf();
        if (typeof ret === "number") {
            return toFlonum(ret);
        }
        ret = String(ret);
    }
    ret = stringToNumber(ret);
    if (ret === false) {
        raise("&assertion", "not a number", obj);
    }
    return ret;
}
// For NaturalDocs:
var SchemeNumber = SN;

/*
    Property: VERSION
    Library version as an array of integers.

    For example, *[1,2,4]* corresponds to Version 1.2.4.
*/
SchemeNumber.VERSION = [1,1,4];

var floPow   = flo.pow;
var floLog   = flo.log;
var floFloor = flo.floor;
var floCeil  = flo.ceil;
var floSqrt  = flo.sqrt;
var floAtan2 = flo.atan2;
var floAbs   = flo.abs;
var floAtan  = flo.atan;
var floCos   = flo.cos;
var floSin   = flo.sin;
var floTan   = flo.tan;
var floExp   = flo.exp;

var HIERARCHY = {
    C: ["Rectangular", "R"],
    R: ["Flonum", "ER"],
    ER: ["EQ"],
    EQ: ["EQFraction", "EI"],
    EI: ["EINative", "EIBig"]
};

var CLASSES = {
    C:C, R:R, ER:ER, EQ:EQ, EI:EI,
    Rectangular:Rectangular, Flonum:Flonum,
    EQFraction:EQFraction, EINative:EINative, EIBig:EIBig
};

var DISP = {};
for (var className in CLASSES) {
    DISP[className] = {};  // Contents will go into class prototype.
}

//
// Input functions.
//

var PARSE_ERROR = new Object();

// Scheme number syntaxes, e.g. #e1.1@-2d19, 2/3
function stringToNumber(s, radix, exact) {
    function lose() {
        throw PARSE_ERROR;
    }
    function setExact(value) {
        if (exact !== undefined) lose();
        exact = value;
    }
    function setRadix(value) {
        if (radix) lose();
        radix = value;
    }
    function parseUinteger(s, sign) {
        if (!uintegerPattern[radix].test(s))
            lose();

        if (exact === false)
            return toFlonum(sign * _parseInt(s, radix));

        return parseEI(sign, s, radix);
    }
    function parseReal(s) {
        if (nanInfPattern.test(s)) {
            if (exact)
                lose();
            switch (s) {
            case "+inf.0": return INFINITY;
            case "-inf.0": return M_INFINITY;
            default: return NAN;
            }
        }

        var sign = 1;
        switch (s[0]) {
        case '-': sign = -1;  // fall through
        case '+': s = s.substring(1);
        }

        var slash = s.indexOf('/');
        if (slash != -1)
            return parseUinteger(s.substring(0, slash), sign)
                .SN_divide(parseUinteger(s.substring(slash + 1), 1));

        if (radix !== 10)
            lose();

        var pipe = s.indexOf('|');
        if (pipe !== -1) {

            // WHOA!!!  Explicit mantissa width!  Somebody really
            // cares about correctness.  However, I haven't got all
            // day, so execution speed loses.

            var afterPipe = s.substring(pipe + 1);
            if (!uintegerPattern[10].test(afterPipe))
                lose();

            s = s.substring(0, pipe);
            var precision = _parseInt(afterPipe);

            if (precision === 0)
                s = "0.0";
            else if (precision < 53)
                return parseWithWidth(s, precision, exact);
        }

        // We have only one floating point width.
        s = s.replace(exponentMarkerPattern, 'e');

        var dot = s.indexOf('.');
        var e = s.indexOf('e');
        if (dot === -1 && e === -1)
            return parseUinteger(s, sign);

        if (!decimal10Pattern.test(s))
            lose();

        if (!exact)
            return toFlonum(sign * _parseFloat(s));

        var integer = s.substring(0, dot === -1 ? e : dot);
        var exponent = 0;
        var fraction;

        if (e === -1)
            fraction = s.substring(dot + 1);
        else {
            if (dot === -1)
                fraction = "";
            else
                fraction = s.substring(dot + 1, e);
            exponent = _parseInt(s.substring(e + 1));
        }

        return parseDecimal(sign, integer + fraction,
                            exponent - fraction.length);
    }
    function parseComplex(s) {
        var a = s.indexOf('@');
        if (a !== -1) {
            var ret = makePolar(parseReal(s.substring(0, a)),
                                parseReal(s.substring(a + 1)));
            if (exact && ret.SN_isInexact())
                ret = ret.SN_toExact();  // XXX is this right?
            return ret;
        }

        if (s[s.length - 1] !== "i")
            return parseReal(s);

        if (s === "i") {
            if (exact === false)
                return inexactRectangular(INEXACT_ZERO, toFlonum(1));
            return I;
        }
        if (s === "-i") {
            if (exact === false)
                return inexactRectangular(INEXACT_ZERO, toFlonum(-1));
            return M_I;
        }

        var match = (radix === 10 ? decimalComplex : radixComplex).exec(s);
        var x, y;
        if (match) {
            x = match[1];
            y = match[2];
            x = (x ? parseReal(x) : (exact === false ? INEXACT_ZERO : ZERO));
            y = (y === "+" ? ONE : (y === "-" ? M_ONE : parseReal(y)));
        }
        else {
            // Could be "3i" for example.
            x = (exact === false ? INEXACT_ZERO : ZERO);
            y = parseReal(s.substring(0, s.length - 1));
        }

        return makeRectangular(x, y);
    }

    // Parse a real that had a |p attached.
    // See the second half of R6RS Section 4.2.8 and also
    // http://www.mail-archive.com/r6rs-discuss@lists.r6rs.org/msg01676.html.
    function parseWithWidth(s, precision) {

        // First, parse it as exact.
        var x = stringToNumber(s, radix, true);
        if (x === false || !x.SN_isReal())
            lose();

        if (!x.SN_isZero()) {
            var xabs = x.SN_abs();

            var shift = precision - floor(xabs.SN_log() / LN2) - 1;
            var scale = TWO.SN_expt(toEINative(abs(shift)));
            if (shift < 0)
                scale = scale.SN_reciprocal();
            var shifted = xabs.SN_multiply(scale);

            // Correct for log() imprecision.
            var denom = TWO.SN_expt(toEINative(precision));
            while (shifted.SN_ge(denom)) {
                shifted = shifted.SN_divide(TWO);
                scale = scale.SN_divide(TWO);
            }
            for (var twiceShifted = shifted.SN_add(shifted);
                 twiceShifted.SN_lt(denom);
                 twiceShifted = shifted.SN_add(shifted)) {
                shifted = twiceShifted;
                scale = scale.SN_add(scale);
            }

            // 0.5 <= shifted/denom < 1.
            var rounded = shifted.SN_round().SN_divide(scale);
            if (x.SN_isNegative())
                rounded = rounded.SN_negate();
            x = rounded;
        }

        // Then make it inexact unless there is #e.
        if (!exact)
            x = x.SN_toInexact();

        return x;
    }

    // Common cases first.
    if (!radix || radix == 10) {
        if (/^-?[0-9]{1,15}$/.test(s)) {
            if (exact === false)
                return toFlonum(_parseInt(s));
            return toEINative(_parseInt(s));
        }
        radix = 10;
    }

    var i = 0;

    try {
        while (s[i] === "#") {
            switch (s[i+1]) {
            case 'i': case 'I': setExact(false); break;
            case 'e': case 'E': setExact(true ); break;
            case 'b': case 'B': setRadix( 2); break;
            case 'o': case 'O': setRadix( 8); break;
            case 'd': case 'D': setRadix(10); break;
            case 'x': case 'X': setRadix(16); break;
            default: return false;
            }
            i += 2;
        }
        return parseComplex(s.substring(i));
    }
    catch (e) {
        if (e === PARSE_ERROR)
            return false;
        if (s == undefined)
            raise("&assertion", "missing argument");
        throw e;
    }
}

function makeRectangular(x, y) {
    if (x.SN_isExact() && y.SN_isExact())
        return exactRectangular(x, y);
    return inexactRectangular(x.SN_toInexact(), y.SN_toInexact());
}

function makePolar(r, theta) {
    return inexactRectangular(r.SN_multiply(theta.SN_cos()),
                              r.SN_multiply(theta.SN_sin()));
}

function assertReal(x) {
    if (!x.SN_isReal())
        raise("&assertion", "not a real number", x);
    return x;
}

function toReal(x) {
    x = SN(x);
    x.SN_isReal() || assertReal(x);
    return x;
}

function assertInteger(n) {
    n = SN(n);
    if (!n.SN_isInteger())
        raise("&assertion", "not an integer", n);
    return n;
}

function toInteger(n) {
    n = SN(n);
    n.SN_isInteger() || assertInteger(n);
    return n;
}

function assertRational(q) {
    if (!q.SN_isRational())
        raise("&assertion", "not a rational number", q);
    return q;
}

function assertNonNegative(n) {
    if (n.SN_isNegative())
        raise("&assertion", "negative number", n);
    return n;
}

function assertExact(z) {
    if (z.SN_isInexact())
        raise("&assertion", "inexact number", z);
    return z;
}

/*
    Property: raise
    Function that translates a Scheme exception to ECMAScript.

    When a library function encounters a situation where the Scheme
    specification requires it to raise an exception with a certain
    condition type, the function calls <SchemeNumber.raise>.

    Programs may assign a custom function to <SchemeNumber.raise> to
    intercept such exceptions.

    Parameters:

        conditionType - The specified condition, for example, "&assertion".
        message       - A string describing the error.
        irritants...  - Zero or more erroneous data arguments.

    Returns:

        The default <SchemeNumber.raise> function simply throws an
        *Error*.

    See Also:

        <fn>, <SchemeNumber>
*/
SchemeNumber.raise = defaultRaise;

function defaultRaise(conditionType, message, irritant) {
    var msg = "SchemeNumber: " + conditionType + ": " + message;
    if (arguments.length > 2) {
        if (isNumber(irritant))
            irritant = irritant.SN_numberToString();
        msg += ": " + irritant;
    }
    throw new Error(msg);
}

function raise() {
    var len = arguments.length;
    var args = new Array(len);
    while (len--)
        args[len] = arguments[len];

    // Call the exception hook.
    SN.raise.apply(SN, args);

    // Oops, it returned.  Fall back to our known good raiser.
    defaultRaise.apply(this, args);
}

/*
    Property: maxIntegerDigits
    Maximum size of integers created by the <fn.expt(z1, z2)>
    function.

    To avoid using up all system memory, exact results of a call to
    <fn.expt(z1, z2)> are capped at a configurable number of digits,
    by default one million.  <SchemeNumber.maxIntegerDigits> holds
    this limit.

    The size limit does *not* currently protect against other means of
    creating large exact integers.  For example, when passed
    "#e1e9999999", the <SchemeNumber> function tries to allocate 10
    million digits, regardless of <maxIntegerDigits>.

    In a future release, cases such as the preceeding example may be
    checked.  If there is any possibility of legitimately creating
    such large integers, either as number objects or components
    thereof, code should increase <maxIntegerDigits>.

    Default Value:

        - 1000000 (1e6 or 1 million)
*/

// Configurable maximum integer magnitude.
SN.maxIntegerDigits = 1e6;  // 1 million digits.

/*
    Method: toString(radix)
    Converts this Scheme number to a string.

    The *toString* method converts inexact numbers as in JavaScript
    and exact numbers as if by <fn["number->string"](z, radix)>.

    Method: toFixed(fractionDigits)
    Returns this Scheme number as a string with *fractionDigits*
    digits after the decimal point.

    Examples:

    > SchemeNumber("#e1.2").toFixed(2)  // "1.20"
    > SchemeNumber("1/7").toFixed(24)   // "0.142857142857142857142857"

    Specified by: <ECMA-262, 5th edition at http://www.ecma-international.org/publications/standards/Ecma-262.htm>

    Method: toExponential(fractionDigits)
    Converts this Scheme number to scientific "e" notation with
    *fractionDigits* digits after the decimal point.

    Examples:

    > SchemeNumber("1/11").toExponential(3)  // "9.091e-2"
    > SchemeNumber("1/2").toExponential(2)   // "5.00e-1"

    Specified by: <ECMA-262, 5th edition at http://www.ecma-international.org/publications/standards/Ecma-262.htm>

    Method: toPrecision(precision)
    Converts this Scheme number to decimal (possibly "e" notation)
    with *precision* significant digits.

    Examples:

    > SchemeNumber("12300").toPrecision(2)  // "1.2e+4"
    > SchemeNumber("12300").toPrecision(4)  // "1.230e+4"
    > SchemeNumber("12300").toPrecision(5)  // "12300"
    > SchemeNumber("12300").toPrecision(6)  // "12300.0"

    Specified by: <ECMA-262, 5th edition at http://www.ecma-international.org/publications/standards/Ecma-262.htm>
 */

/*
    Property: fn
    Container of <Scheme functions>.

    The <SchemeNumber> object contains a property, <SchemeNumber.fn>,
    which in turn contains the functions implementing the Scheme
    numeric types.

    These functions are stored in <fn> under their Scheme names, so
    ["quotation"] is needed where the names contain characters that
    are incompatible with dot.notation.  (In JavaScript, *X.Y* and
    *X["Y"]* are equivalent expressions where Y is a valid identifier.
    Not all Scheme function names are valid JavaScript identifiers, so
    one needs the second syntax to extract them from <fn>.)

    You may find it convenient to copy <SchemeNumber>, <fn>, and the
    output function <number->string> into short-named variables, by
    convention *sn*, *fn*, and *ns*.  The rest of this section assumes
    you have done this:

    > var sn = SchemeNumber;
    > var fn = sn.fn;
    > var ns = fn["number->string"];

    Functions that require a Scheme number argument automatically
    filter the argument through <SchemeNumber>.

    For example, *"2"* (string) would be exact (parsed as Scheme) but
    *2* (equal to *2.0*) would be inexact, as demonstrated:

    > a1 = fn["exact?"]("2");       // a1 === true
    > a1 = fn["exact?"](sn("2"));   // same
    > 
    > a2 = fn["exact?"](2);         // a2 === false
    > a2 = fn["exact?"]("2.0");     // same
    > a2 = fn["exact?"](sn("2.0")); // same

    Note that the following functions accept arguments of any type and
    therefore do not apply <SchemeNumber> to their arguments:

    - <eqv?>
    - <number?>
    - <complex?>
    - <real?>
    - <rational?>
    - <integer?>
    - <real-valued?>
    - <rational-valued?>
    - <integer-valued?>

    Here, for example, is 2 to the 1,024th power, as a decimal
    string:

    > a3 = ns(fn.expt("2", "1024"));

    Fractional
    arithmetic:

    > a4 = fn["+"]("1/3", "4/5");  // 17/15

    Numerator and denominator of a floating-point value,
    hexadecimal:

    > a5 = ns(fn.numerator(1/3), "16");    // "#i15555555555555"
    > a6 = ns(fn.denominator(1/3), "16");  // "#i40000000000000"

    The *#i* prefix denotes an inexact number, as detailed in <R6RS at
    http://www.r6rs.org/>.  Since 1/3 is a native JavaScript number,
    the library regards it as inexact, and operations such as
    numerator yield inexact integer results.  If we used *"1/3"*
    (quoted) instead of *1/3*, the numerator and denominator would be
    the mathematically correct 1 and 3.

    Functions specified to return two values (such as <div-and-mod>
    and <exact-integer-sqrt>) return a two-element array as per
    JavaScript conventions.

    Caveats:

      o Arcane features such as explicit mantissa widths or complex
        transcendental functions, while believed complete, are
        unoptimized.

      o The library exhibits other visible behaviors besides those
        described herein.  However, they are not part of its public
        API and may change or disappear from one release to the next.

      o In particular, Scheme numbers' *toString* property sometimes
        produces output that is incorrect in the Scheme sense.  (This
        stems from the decision to represent inexact reals as
        unadorned native numbers.)

    To serialize numbers as Scheme would, use
    <SchemeNumber.fn["number->string"]>.

    > "" + SchemeNumber(2);                  // "2"
    > SchemeNumber.fn["number->string"](2);  // "2."

    To test a Scheme number for numerical equality with another Scheme
    number or a native value, use <fn["="]>.  Likewise for <fn[">"]>
    etc.

    See Also:

        <Scheme functions>
*/
SchemeNumber.fn = {

/*
    About: Function list

    All <Scheme functions> are specified by <R6RS at
    http://www.r6rs.org/>.  In the list below, argument names indicate
    applicable types as follows:

    obj - any value
    z - any Scheme number
    x - a real number
    y - a real number
    q - a rational number (excludes infinities and NaN)
    n - an integer
    k - an exact, non-negative integer
    radix - an exact integer, either 2, 8, 10, or 16
    precision - an exact, positive integer

    Functions: Scheme functions
    Elements of <fn>.

    Refer to the argument type key under <Function list>.

    fn["number?"](obj)   - Returns true if *obj* is a Scheme number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_440>.

    fn["complex?"](obj)  - Returns true if *obj* is a Scheme complex number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_442>.

    fn["real?"](obj)     - Returns true if *obj* is a Scheme real number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_444>.

    fn["rational?"](obj) - Returns true if *obj* is a Scheme rational number.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_446>.

    fn["integer?"](obj)  - Returns true if *obj* is a Scheme integer.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_448>.

    fn["real-valued?"](obj) - Returns true if *obj* is a Scheme complex number
                              and *fn["imag-part"](obj)* is zero.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_450>.

    fn["rational-valued?"](obj) - Returns true if *obj* is real-valued and
                                  *fn["real-part"](obj)* is rational.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_452>.

    fn["integer-valued?"](obj)  - Returns true if *obj* is real-valued and
                                  *fn["real-part"](obj)* is an integer.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_454>.

    fn["exact?"](z)   - Returns true if *z* is exact.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_456>.

    fn["inexact?"](z) - Returns true if *z* is inexact.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_458>.

    fn.inexact(z) - Returns an inexact number equal to *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_460>.

    fn.exact(z)   - Returns an exact number equal to *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_462>.

    fn["eqv?"](obj1, obj2) - Returns true if *obj1 === obj2* or both arguments
                             are Scheme numbers and behave identically.
                             Specified by <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_428>.

    fn["="](z, z, z...) - Returns true if all arguments are mathematically
                          equal, though perhaps differing in exactness.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_464>.

    fn["<"](x, x, x...) - Returns true if arguments increase monotonically.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_466>.

    fn[">"](x, x, x...) - Returns true if arguments decrease monotonically.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_468>.

    fn["<="](x, x, x...) - Returns true if arguments are monotonically
                           nondecreasing.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_470>.

    fn[">="](x, x, x...) - Returns true if arguments are monotonically
                           nonincreasing.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_472>.

    fn["zero?"](z)      - Returns true if *z* equals zero.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_474>.

    fn["positive?"](x)  - Returns true if *x* is positive.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_476>.

    fn["negative?"](x)  - Returns true if *x* is negative.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_478>.

    fn["odd?"](n)       - Returns true if *n* is odd.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_480>.

    fn["even?"](n)      - Returns true if *n* is even.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_482>.

    fn["finite?"](x)    - Returns true if *x* is finite.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_484>.

    fn["infinite?"](x)  - Returns true if *x* is plus or minus infinity.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_486>.

    fn["nan?"](x)       - Returns true if *x* is a NaN.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_488>.

    fn.max(x, x...)     - Returns the greatest argument.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_490>.

    fn.min(x, x...)     - Returns the least argument.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_492>.

    fn["+"](z...)       - Returns the sum of the arguments.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_494>.

    fn["*"](z...)       - Returns the product of the arguments.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_496>.

    fn["-"](z)          - Returns the negation of *z* (-*z*).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_498>.

    fn["-"](z1, z2...)  - Returns *z1* minus the sum of the number(s) *z2*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_500>.

    fn["/"](z)          - Returns the reciprocal of *z* (1 / *z*).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_502>.

    fn["/"](z1, z2...)  - Returns *z1* divided by the product of the number(s)
    *z2*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_504>.

    fn.abs(x)           - Returns the absolute value of *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_506>.

    fn["div-and-mod"](x, y) - Returns *fn.div(x, y)* and *fn.mod(x, y)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_508>.

    fn.div(x, y)        - Returns the greatest integer less than or equal to
                          *x* / *y*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_510>.

    fn.mod(x, y)        - Returns *x* - (*y* * fn.div(*x*, *y*)).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_512>.

    fn["div0-and-mod0"](x, y) - Returns *fn.div0(x, y)* and *fn.mod0(x, y)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_514>.

    fn.div0(x, y)       - Returns the integer nearest *x* / *y*, ties go lower.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_516>.

    fn.mod0(x, y)       - Returns *x* - (*y* * fn.div0(*x*, *y*)).
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_518>.

    fn.gcd(n...) - Returns the arguments' greatest common non-negative divisor.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_520>.

    fn.lcm(n...) - Returns the arguments' least common positive multiple.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_522>.

    fn.numerator(q)     - Returns *q* * *fn.denominator(q)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_524>.

    fn.denominator(q)   - Returns the smallest positive integer which when
                          multiplied by *q* yields an integer.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_526>.

    fn.floor(x)         - Returns the greatest integer not greater than *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_528>.

    fn.ceiling(x)       - Returns the least integer not less than *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_530>.

    fn.truncate(x)      - Returns the closest integer between 0 and *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_532>.

    fn.round(x)         - Returns the closest integer to *x*, ties go even.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_534>.

    fn.rationalize(x, y) - Returns the simplest fraction within *y* of *x*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_536>.

    fn.exp(z)           - Returns e to the *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_540>.

    fn.log(z)           - Returns the natural logarithm of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_542>.

    fn.log(z1, z2)      - Returns the base-*z2* logarithm of *z1*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_544>.

    fn.sin(z)           - Returns the sine of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_546>.

    fn.cos(z)           - Returns the cosine of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_548>.

    fn.tan(z)           - Returns the tangent of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_550>.

    fn.asin(z)          - Returns a number whose sine is *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_552>.

    fn.acos(z)          - Returns a number whose cosine is *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_554>.

    fn.atan(z)          - Returns a number whose tangent is *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_556>.

    fn.atan(y, x)       - Returns the angle that passes through *(x,y)*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_558>.

    fn.sqrt(z)          - Returns the square root of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_560>.

    fn["exact-integer-sqrt"](k) - Returns maximal exact s and non-negative r
                                  such that s*s + r = *k*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_562>.

    fn.expt(z1, z2) - Returns *z1* to the power *z2*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_564>.

    fn["make-rectangular"](x, y) - Returns the complex number *x + iy*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_566>.

    fn["make-polar"](r, theta) - Returns the complex number with magnitude *r*
                                 and angle *theta*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_568>.

    fn["real-part"](z) - Returns x such that *z* = x + iy.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_570>.

    fn["imag-part"](z) - Returns y such that *z* = x + iy.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_572>.

    fn.magnitude(z)    - Returns the magnitude of *z*.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_574>.

    fn.angle(z)        - Returns *fn.atan(y,x)* where *z* = x + iy.
    Specified by: <R6RS at http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_576>.

    Function: fn["number->string"](z)
    Converts *z* to a string, base 10.

    For exact *z*, *number->string* retains full precision.  Exact
    fractions are expressed as numerator + "/" + denominator.
    Examples:

    > fn["number->string"](fn["string->number"]("#e1.2"))  // "6/5"
    > fn["number->string"](fn["/"]("12", "-8"))            // "-3/2"

    Infinities are "+inf.0" and "-inf.0".  NaN is "+nan.0".

    The result always yields a number equal to *z* (in the sense of
    <fn["eqv?"](obj1, obj2)>) when passed to
    <fn["string->number"](string)>.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_578>

    See Also: <fn["string->number"](string)>.

    Function: fn["number->string"](z, radix)
    Converts *z* to a string, base *radix*.
    *radix* must be exact 2, 8, 10, or 16.

    The output never contains an explicit radix prefix.

    The result always yields a value equal to *z* (in the sense of
    <fn["eqv?"](obj1, obj2)>) when converted back to a number by
    <fn["string->number"](string, radix)>.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_580>

    See Also: <fn["string->number"](string, radix)>.

    Function: fn["number->string"](z, radix, precision)
    Converts and suffixes *z* with a count of significant bits.

    Appends "|p" to each inexact real component of *z* where p is the
    smallest mantissa width not less than *precision* needed to
    represent the component exactly.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_582>

    Function: fn["string->number"](string)
    Parses *string* as a Scheme number.  Returns *false* if unable.

    Examples:

    > "1"       - exact 1.
    > "1."      - inexact 1, same as "1.0".
    > "1/2"     - exact one-half, same as "2/4" etc.
    > "0.5"     - inexact 0.5.
    > "12e3"    - inexact 12000.
    > "i"       - the imaginary unit.
    > "-2+1/2i" - exact complex number.
    > "2.@1"    - complex in polar coordinates, r=2.0, theta=1.0.
    > "+inf.0"  - positive infinity.
    > "-inf.0"  - negative infinity.
    > "+nan.0"  - IEEE NaN (not-a-number).
    > "#e0.5"   - exact one-half, forced exact by prefix #e.
    > "#i1/2"   - 0.5, inexact by prefix #i.
    > "#x22"    - exact 34; prefix #x hexadecimal.
    > "#o177"   - exact 127; prefix #o octal.
    > "#b101"   - exact 5; prefix #b binary.
    > "#i#b101" - inexact 5.0.
    > "#b#i101" - same.
    > "1.2345678|24" - rounded as if to single-precision (about 1.23456776).

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_584>

    See Also: <fn["number->string"](z)>, <R6RS section 4.2.8: Lexical
    syntax: Numbers at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-7.html#node_sec_4.2.8>

    Function: fn["string->number"](string, radix)
    Parses *string* as a Scheme number using *radix* as default radix.

    *radix* must be exact 2, 8, 10, or 16.  If *string* contains a
    radix prefix, the prefix takes precedence over *radix*.

    Specified by: <R6RS at
    http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_586>

    See Also: <fn["number->string"](z, radix)>.
*/

    "eqv?"      : fn_isEqv,
    "number?"   : fn_isNumber,
    "complex?"  : fn_isComplex,
    "real?"     : fn_isReal,
    "rational?" : fn_isRational,
    "integer?"  : fn_isInteger,
    "real-valued?"     : fn_isRealValued,
    "rational-valued?" : fn_isRationalValued,
    "integer-valued?"  : fn_isIntegerValued,

    "exact?"   : makeUnary("SN_isExact"),
    "inexact?" : makeUnary("SN_isInexact"),

    inexact : makeUnary("SN_toInexact"),
    exact   : makeUnary("SN_toExact"),

    "="  : fn_equals,
    "<"  : makeComparator("SN_lt"),
    ">"  : makeComparator("SN_gt"),
    "<=" : makeComparator("SN_le"),
    ">=" : makeComparator("SN_ge"),

    "zero?"     : makeUnary("SN_isZero"),
    "positive?" : makeUnary("SN_isPositive"),
    "negative?" : makeUnary("SN_isNegative"),
    "odd?"      : makeUnary("SN_isOdd"),
    "even?"     : makeUnary("SN_isEven"),
    "finite?"   : makeUnary("SN_isFinite"),
    "infinite?" : makeUnary("SN_isInfinite"),
    "nan?"      : makeUnary("SN_isNaN"),

    max : makeMaxMin("SN_gt"),
    min : makeMaxMin("SN_lt"),

    "+" : function() {
        var ret = ZERO;
        var len = arguments.length;
        var i = 0;
        while (i < len)
            ret = ret.SN_add(SN(arguments[i++]));
        return ret;
    },

    "*" : function() {
        var ret = ONE;
        var len = arguments.length;
        var i = 0;
        while (i < len)
            ret = ret.SN_multiply(SN(arguments[i++]));
        return ret;
    },

    "-" : function(a) {
        var len = arguments.length;

        switch (len) {
        case 0: args1plus(arguments);
        case 1: return SN(a).SN_negate();
        }
        var ret = SN(a);
        var i = 1;
        while (i < len)
            ret = ret.SN_subtract(SN(arguments[i++]));
        return ret;
    },

    "/" : function(a) {
        var len = arguments.length;

        switch (len) {
        case 0: args1plus(arguments);
        case 1: return SN(a).SN_reciprocal();
        case 2: return SN(a).SN_divide(SN(arguments[1]));
        }
        var product = ONE;
        var i = 1;
        while (i < len)
            product = product.SN_multiply(SN(arguments[i++]));
        return SN(a).SN_divide(product);
    },

    abs             : makeUnary("SN_abs"),
    "div-and-mod"   : makeDivMod(false, 2),
    div             : makeDivMod(false, 0),
    mod             : makeDivMod(false, 1),
    "div0-and-mod0" : makeDivMod(true, 2),
    div0            : makeDivMod(true, 0),
    mod0            : makeDivMod(true, 1),

    gcd : function() {
        var ret = ZERO;
        var len = arguments.length;
        var exact = true;
        for (var i = 0; i < len; i++) {
            var arg = toInteger(arguments[i]);
            exact = exact && arg.SN_isExact();
            ret = gcdNonneg(ret, arg.SN_abs().SN_toExact());
        }
        ret = ret.SN_abs();
        return (exact ? ret : ret.SN_toInexact());
    },

    lcm : function() {
        var ret = ONE;
        var len = arguments.length;
        var exact = true;
        for (var i = 0; i < len; i++) {
            var arg = toInteger(arguments[i]);
            exact = exact && arg.SN_isExact();
            arg = arg.SN_abs().SN_toExact();
            ret = ret.SN_multiply(arg).SN_divide(gcdNonneg(ret, arg.SN_abs()));
        }
        return (exact ? ret : ret.SN_toInexact());
    },

    numerator   : makeUnary("SN_numerator"),
    denominator : makeUnary("SN_denominator"),
    floor       : makeUnary("SN_floor"),
    ceiling     : makeUnary("SN_ceiling"),
    truncate    : makeUnary("SN_truncate"),
    round       : makeUnary("SN_round"),
    rationalize : rationalize,
    exp         : makeUnary("SN_exp"),

    log : function(z, base) {
        var ret = SN(z).SN_log();
        switch (arguments.length) {
        case 2: ret = ret.SN_divide(SN(base).SN_log());  // fall through
        case 1: return ret;
        default: wrongArgCount("1-2", arguments);
        }
    },

    sin  : makeUnary("SN_sin"),
    cos  : makeUnary("SN_cos"),
    tan  : makeUnary("SN_tan"),
    asin : makeUnary("SN_asin"),
    acos : makeUnary("SN_acos"),

    atan : function(y, x) {
        switch (arguments.length) {
        case 1: return SN(y).SN_atan();
        case 2: return toReal(y).SN_atan2(toReal(x));
        default: wrongArgCount("1-2", arguments);
        }
    },

    sqrt : makeUnary("SN_sqrt"),
    "exact-integer-sqrt" : makeUnary("SN_exactIntegerSqrt"),
    expt : makeBinary("SN_expt"),

    "make-rectangular" : function(x, y) {
        arguments.length === 2 || args2(arguments);
        return makeRectangular(toReal(x), toReal(y));
    },

    "make-polar" : function(r, theta) {
        arguments.length === 2 || args2(arguments);
        return makePolar(toReal(r), toReal(theta));
    },

    "real-part" : makeUnary("SN_realPart"),
    "imag-part" : makeUnary("SN_imagPart"),
    magnitude   : makeUnary("SN_magnitude"),
    angle       : makeUnary("SN_angle"),

    "number->string" : function(z, radix, precision) {
        var r = radix;
        switch (arguments.length) {
        case 3:
            precision = toInteger(precision);
            assertExact(precision);
            // fall through
        case 2:
            r = assertExact(toInteger(r)).valueOf();
            if (!uintegerPattern[r])
                raise("&assertion", "invalid radix", radix);
            // fall through
        case 1: break;
        default: wrongArgCount("1-3", arguments);
        }
        return SN(z).SN_numberToString(r, precision);
    },

    "string->number" : function(s, radix) {
        switch (arguments.length) {
        case 1:
        case 2: return stringToNumber(String(s), radix);
        default: wrongArgCount("1-2", arguments);
        }
    }
};

// Scheme function helpers.

function wrongArgCount(expected, a) {
    var msg = "Function"

    for (name in fn) {
        if (fn[name] === a.callee) {
            msg += " '" + name + "'";
            break;
        }
    }
    raise("&assertion", msg + " expected " + expected +
          " argument" + (expected == "1" ? "" : "s") + ", got " + a.length);
}

function args1(a) { a.length === 1 || wrongArgCount(1, a); }
function args2(a) { a.length === 2 || wrongArgCount(2, a); }

function args1plus(a) { a.length > 0 || wrongArgCount("1 or more", a); }
function args2plus(a) { a.length > 1 || wrongArgCount("2 or more", a); }

function fn_isEqv(a, b) {
    arguments.length === 2 || args2(arguments);
    if (a === b)
        return true;
    a = SN(a);
    b = SN(b);
    return (a.SN_eq(b) && a.SN_isExact() === b.SN_isExact());
}

function fn_isNumber(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x);
}

function fn_isComplex(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isComplex();
}

function fn_isReal(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isReal();
}

function fn_isRational(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isRational();
}

function fn_isInteger(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_isInteger();
}

function fn_isRealValued(x) {
    arguments.length === 1 || args1(arguments);
    return isNumber(x) && x.SN_imagPart().SN_isZero();
}

function fn_isRationalValued(x) {
    arguments.length === 1 || args1(arguments);
    return fn_isRealValued(x) && x.SN_realPart().SN_isRational();
}

function fn_isIntegerValued(x) {
    arguments.length === 1 || args1(arguments);
    return fn_isRealValued(x) && x.SN_realPart().SN_isInteger();
}

function fn_equals(a, b) {
    var len = arguments.length;
    len > 1 || args2plus(arguments);
    a = SN(a);
    for (var i = 1; i < len; i++) {
        if (!a.SN_eq(SN(arguments[i])))
            return false;
    }
    return true;
}

function makeUnary(method) {
    function unary(a) {
        arguments.length === 1 || args1(arguments);
        return SN(a)[method]();
    }
    return unary;
}

function makeBinary(method) {
    function binary(a, b) {
        arguments.length === 2 || args2(arguments);
        return SN(a)[method](SN(b));
    }
    return binary;
}

function makeComparator(cmp) {
    function comparator(a, b) {
        var len = arguments.length;
        len > 1 || args2plus(arguments);
        b = toReal(b);
        if (!toReal(a)[cmp](b))
            return false;
        for (var i = 2; i < len; i++) {
            var c = toReal(arguments[i]);
            if (!b[cmp](c))
                return false;
            b = c;
        }
        return true;
    }
    return comparator;
}

function makeMaxMin(cmp) {
    function maxMin(a) {
        var len = arguments.length;
        len > 0 || args1plus(arguments);

        var ret = toReal(a);
        var exact = ret.SN_isExact();

        for (var i = 1; i < len; i++) {
            var x = toReal(arguments[i]);
            if (x.SN_isNaN())
                return x;
            if (exact) {
                exact = x.SN_isExact();
                if (!exact)
                    ret = ret.SN_toInexact();  // XXX Cheaper comparisons?
            }
            if (x[cmp](ret) !== false) {
                ret = x;
            }
        }
        return exact ? ret : ret.SN_toInexact();
    }
    return maxMin;
}

function divModArg2Zero(arg) {
    raise("&assertion", "div/mod second argument is zero", arg);
}

function makeDivMod(is0, which) {
    function divMod(x, y) {
        arguments.length === 2 || args2(arguments);
        x = toReal(x);
        y = toReal(y);

        if (!x.SN_isFinite())
            raise("&assertion", "div/mod first argument is not finite", x);
        if (y.SN_isZero())
            divModArg2Zero(y);

        if (!is0) {
            switch (which) {
            case 0: return x.SN_div(y);
            case 1: return x.SN_mod(y);
            case 2: default: return x.SN_divAndMod(y);
            }
        }

        var dm = x.SN_divAndMod(y);
        var m = dm[1];
        var yabs = y.SN_abs();

        if (m.SN_add(m).SN_ge(yabs)) {
            switch (which) {
            case 0: return dm[0].SN_add(y.SN_isNegative() ? M_ONE : ONE);
            case 1: return m.SN_subtract(yabs);
            case 2: default: return [dm[0].SN_add(y.SN_isNegative() ?
                                                  M_ONE : ONE),
                                     m.SN_subtract(yabs)];
            }
        }
        switch (which) {
        case 0: return dm[0];
        case 1: return m;
        case 2: default: return dm;
        }
    }
    return divMod;
}

function rationalize(x, delta) {
    args2(arguments);
    x = SN(x);
    delta = SN(delta);

    // Handle weird cases first.
    if (!x.SN_isFinite() || !delta.SN_isFinite()) {
        assertReal(x);
        assertReal(delta);
        if (delta.SN_isInfinite())
            return (x.SN_isFinite() ? INEXACT_ZERO : NAN);
        if (delta.SN_isNaN())
            return delta;
        return x;
    }

    if (delta.SN_isZero())
        return x;

    delta = delta.SN_abs();  // It's what PLT and Mosh seem to do.

    var x0 = x.SN_subtract(delta);
    var x1 = x.SN_add(delta);
    var a = x0.SN_floor();
    var b = x1.SN_floor();

    if (a.SN_ne(b)) {
        var negative = a.SN_isNegative();
        if (b.SN_isNegative() != negative)
            return (a.SN_isExact() ? ZERO : INEXACT_ZERO);
        return (negative ? b : x0.SN_ceiling());
    }
    var cf = [];  // Continued fraction, b implied.

    while (true) {
        x0 = x0.SN_subtract(a);
        if (x0.SN_isZero())
            break;
        x1 = x1.SN_subtract(a);
        if (x1.SN_isZero())
            break;

        x0 = x0.SN_reciprocal();
        x1 = x1.SN_reciprocal();
        a = x0.SN_floor();

        switch (a.SN_compare(x1.SN_floor())) {
        case -1: cf.push(x0.SN_ceiling()); break;
        case  1: cf.push(x1.SN_ceiling()); break;
        case 0: default:
            cf.push(a);
            continue;
        }
        break;
    }
    var ret = ZERO;
    var i = cf.length;
    while (i--)
        ret = ret.SN_add(cf[i]).SN_reciprocal();
    return ret.SN_add(b);
}

//
// Flonum: Inexact real as a native number.
//

DISP.Flonum.SN_isExact    = retFalse;
DISP.Flonum.SN_isInexact  = retTrue;
DISP.Flonum.SN_isComplex  = retTrue;
DISP.Flonum.SN_isReal     = retTrue;

DISP.Flonum.SN_debug = function() {
    return "Flonum(" + this.SN_numberToString() + ")";
};

// Return a string of "0" and "1" characters, possibly including a "."
// and possibly a leading "-", that in base 2 equals x.  This works by
// calling Number.prototype.toString with a radix of 2.  Specification
// ECMA-262 Edition 5 (December 2009) does not strongly assert that
// this works.  As an alternative, should this prove non-portable,
// nativeDenominator could instead do:
// for (d = 1; x !== floor(x); d *= 2) { x *= 2; } return d;
function numberToBinary(x) {
    return x.toString(2);
}

function nativeDenominatorLog2(x) {
    //assert(typeof x === "number");
    //assert(_isFinite(x));
    var s = numberToBinary(abs(x));
    var i = s.indexOf(".");
    if (i === -1)
        return 0;
    return s.length - i - 1;
}

function nativeDenominator(x) {
    // Get the "denominator" of a floating point value.
    // The result will be a power of 2.
    //assert(_isFinite(x));
    return pow(2, nativeDenominatorLog2(x));
}

DISP.Flonum.SN_numberToString = function(radix, precision) {
    if (radix && radix != 10 && _isFinite(this))
        return "#i" + this.SN_toExact().SN_numberToString(radix);

    if (!_isFinite(this)) {
        if (_isNaN(this))
            return("+nan.0");
        return (this > 0 ? "+inf.0" : "-inf.0");
    }

    var s = (+this).toString();

    if (s.indexOf('.') === -1) {
        // Force the result to contain a decimal point as per R6RS.
        var e = s.indexOf('e');
        if (e === -1)
            s += ".";
        else
            s = s.substring(0, e) + "." + s.substring(e);
    }

    if (precision != undefined) {
        if (precision < 53) {
            var bits = numberToBinary(+this).replace(/[-+.]/g, "")
                .replace(/^0+/, "").replace(/0+$/, "").length;
            if (precision < bits)
                precision = bits;
        }
        s += "|" + precision;
    }

    return s;
};

DISP.Flonum.SN_realPart = retThis;

DISP.Flonum.SN_imagPart = function() {
    return ZERO;
};

DISP.Flonum.SN_denominator = function() {
    return floPow(2, nativeDenominatorLog2(+assertRational(this)));
};

DISP.Flonum.SN_numerator = function() {
    return toFlonum(this * nativeDenominator(+assertRational(this)));
};

DISP.Flonum.SN_isInteger = function() {
    return _isFinite(this) && this == floor(this);
};

DISP.Flonum.SN_isFinite = function() {
    return _isFinite(this);
};
DISP.Flonum.SN_isRational = DISP.Flonum.SN_isFinite;

DISP.Flonum.SN_isZero = function() {
    return this == 0;
};

DISP.Flonum.SN_isPositive = function() {
    return this > 0;
};

DISP.Flonum.SN_isNegative = function() {
    return this < 0;
};

DISP.Flonum.SN_sign = function() {
    return (this == 0 ? 0 : (this > 0 ? 1 : -1));
};

// XXX I think we can do without SN_isUnit.
DISP.Flonum.SN_isUnit = function() {
    return this == 1 || this == -1;
};

DISP.Flonum.SN_isInfinite = function() {
    return !_isFinite(this) && !_isNaN(this);
};

DISP.Flonum.SN_isNaN = function() {
    return _isNaN(this);
};

DISP.Flonum.SN_isEven = function() {
    //assert(this == floor(this));
    return (this & 1) === 0;
};

DISP.Flonum.SN_isOdd = function() {
    //assert(this == floor(this));
    return (this & 1) === 1;
};

DISP.Flonum.SN_eq = function(z) { return z.SN__eq_Flonum(this); };
DISP.Flonum.SN_ne = function(z) { return z.SN__ne_Flonum(this); };
DISP.Flonum.SN_gt = function(x) { return assertReal(x).SN__gt_Flonum(this); };
DISP.Flonum.SN_lt = function(x) { return assertReal(x).SN__lt_Flonum(this); };
DISP.Flonum.SN_ge = function(x) { return assertReal(x).SN__ge_Flonum(this); };
DISP.Flonum.SN_le = function(x) { return assertReal(x).SN__le_Flonum(this); };

// XXX I think we can do without SN_compare and SN__compare_*.
DISP.Flonum.SN_compare = function(x) {
    return assertReal(x).SN__compare_Flonum(this);
};

// Note operand order!
DISP.Flonum.SN__eq_R = function(x) { return +x == this; };
DISP.Flonum.SN__ne_R = function(x) { return +x != this; };
DISP.Flonum.SN__gt_R = function(x) { return x > this; };
DISP.Flonum.SN__lt_R = function(x) { return x < this; };
DISP.Flonum.SN__ge_R = function(x) { return x >= this; };
DISP.Flonum.SN__le_R = function(x) { return x <= this; };

DISP.Flonum.SN__compare_R = function(x) {
    if (+x == this) return 0;
    if (x < this) return -1;
    if (x > this) return 1;
    return NaN;
};

function numberToEI(n) {
    if (n < 9007199254740992 && n > -9007199254740992)
        return toEINative(n);
    return new EIBig(numberToBigInteger(n));
}

function nativeToExact(x) {
    if (!_isFinite(x))
        raise("&implementation-violation",
              "inexact argument has no reasonably close exact equivalent", x);

    var d = nativeDenominator(x);
    var n;

    if (d === 1)
        return numberToEI(x);

    if (_isFinite(d)) {
        n = x * d;
        d = numberToEI(d);
    }
    else {
        // Denormal x.
        var dl2 = nativeDenominatorLog2(x);
        n = x * 9007199254740992;
        n *= pow(2, dl2 - 53);
        d = TWO.SN_expt(toEINative(dl2));
    }
    //assert(_isFinite(n));
    return canonicalEQ(numberToEI(n), d);
}

DISP.Flonum.SN_toExact = function() {
    return nativeToExact(+this);
};

DISP.Flonum.SN_toInexact = retThis;

DISP.Flonum.SN_add = function(z) {
    return z.SN__add_Flonum(this);
};
DISP.Flonum.SN_subtract = function(z) {
    return z.SN__subtract_Flonum(this);
};
DISP.Flonum.SN_multiply = function(z) {
    return z.SN__multiply_Flonum(this);
};
DISP.Flonum.SN_divide = function(z) {
    return z.SN__divide_Flonum(this);
};

DISP.Flonum.SN__add_R = function(x) {
    return toFlonum(x + this);
};
DISP.Flonum.SN__subtract_R = function(x) {
    return toFlonum(x - this);
};
DISP.Flonum.SN__multiply_R = function(x) {
    return toFlonum(x * this);
};
DISP.Flonum.SN__divide_R = function(x) {
    return toFlonum(x / this);
};

DISP.Flonum.SN_negate = function() {
    return toFlonum(-this);
};

DISP.Flonum.SN_abs = function() {
    return (this < 0 ? toFlonum(-this) : this);
};

DISP.Flonum.SN_reciprocal = function() {
    return toFlonum(1 / this);
};

function div_Flonum_R(x, y) {
    if (y > 0)
        return floor(x / y);
    if (y < 0)
        return ceil(x / y);
    if (y == 0)
        divModArg2Zero(toFlonum(y));
    return NaN;
}
DISP.Flonum.SN_divAndMod = function(x) {
    x = +x;
    var div = div_Flonum_R(this, x);
    return [toFlonum(div), toFlonum(this - (x * div))];
};
DISP.Flonum.SN_div = function(x) {
    return toFlonum(div_Flonum_R(this, x));
};
DISP.Flonum.SN_mod = function(x) {
    return toFlonum(this - x * div_Flonum_R(this, x));
};

DISP.Flonum.SN_square = function() {
    return toFlonum(this * this);
};

DISP.Flonum.SN_round = function() {
    var ret = floor(this);
    var diff = this - ret;
    if (diff < 0.5) return toFlonum(ret);
    if (diff > 0.5) return toFlonum(ret + 1);
    return toFlonum(2 * round(this / 2));
};

DISP.Flonum.SN_truncate = function() {
    return this < 0 ? floCeil(this) : floFloor(this);
};

DISP.Flonum.SN_ceiling = function() {
    return floCeil(this);
};

function funcToMeth(fn) {
    return function() {
        return fn(this);
    };
}
DISP.Flonum.SN_abs   = funcToMeth(floAbs);
DISP.Flonum.SN_atan  = funcToMeth(floAtan);
DISP.Flonum.SN_cos   = funcToMeth(floCos);
DISP.Flonum.SN_exp   = funcToMeth(floExp);
DISP.Flonum.SN_floor = funcToMeth(floFloor);
DISP.Flonum.SN_sin   = funcToMeth(floSin);
DISP.Flonum.SN_tan   = funcToMeth(floTan);

function cplxFuncToMeth(mathFunc, complexFunc) {
    return function() {
        var ret = mathFunc(this);
        if (_isNaN(ret))
            return complexFunc(this);
        return toFlonum(ret);
    };
}
DISP.Flonum.SN_acos = cplxFuncToMeth(Math.acos, complexAcos);
DISP.Flonum.SN_asin = cplxFuncToMeth(Math.asin, complexAsin);

DISP.Flonum.SN_log = function() {
    if (this < 0)
        return complexLog(this);
    return floLog(this);
};

DISP.Flonum.SN_sqrt = function() {
    if (this >= 0)
        return toFlonum(sqrt(this));
    if (_isNaN(this))
        return this;
    return inexactRectangular(INEXACT_ZERO, floSqrt(-this));
};

DISP.Flonum.SN_atan2 = function(x) {
    return floAtan2(this, x);
};

DISP.Flonum.SN_expt = function(z) {
    return z.SN__expt_Flonum(this);
};

// Some famous flonums:

var INEXACT_ZERO = toFlonum(0);

var INFINITY     = toFlonum(Number.POSITIVE_INFINITY);
var M_INFINITY   = toFlonum(Number.NEGATIVE_INFINITY);
var NAN          = toFlonum(Number.NaN);

var PI           = toFlonum(Math.PI);

//
// C: Complex abstract base class.
//

DISP.C.SN_isReal     = retFalse;
DISP.C.SN_isRational = retFalse;
DISP.C.SN_isInteger  = retFalse;
DISP.C.SN_isZero     = retFalse;
DISP.C.SN_isUnit     = retFalse;

DISP.C.SN_isComplex  = retTrue;

DISP.C.SN_numberToString = pureVirtual;

DISP.C.toString = function(radix) {
    return this.SN_numberToString(radix);
};
DISP.C.valueOf = function() {
    if (this.SN_imagPart().SN_isZero())
        return this.SN_realPart().valueOf();
    return NaN;
};

DISP.C.toFixed = pureVirtual;
DISP.C.toExponential = pureVirtual;
DISP.C.toPrecision = pureVirtual;

DISP.C.toLocaleString = function() {
    return this.toString();
};

DISP.C.SN_debug = function() { return "C"; };

// vvvv You shouldn't need this if you use only real numbers. vvvv

DISP.C.SN_sqrt = function() {
    return makePolar(this.SN_magnitude().SN_sqrt(),
                     this.SN_angle().SN_divide(TWO));
};

// Complex transcendental functions here for completeness, not optimized.

function complexLog(z) {
    return makeRectangular(z.SN_magnitude().SN_log(), z.SN_angle());
};

function complexAsin(z) {
    return M_I.SN_multiply(I.SN_multiply(z)
                           .SN_add(ONE.SN_subtract(z.SN_square()).SN_sqrt())
                           .SN_log());
}

function complexAcos(z) {
    return PI.SN_divide(TWO).SN_subtract(complexAsin(z));
}

function complexAtan(z) {
    var iz = I.SN_multiply(z);
    return ONE.SN_add(iz).SN_log().SN_subtract(ONE.SN_subtract(iz).SN_log())
        .SN_divide(TWO).SN_divide(I);
}

DISP.C.SN_log  = function() { return complexLog (this); };
DISP.C.SN_asin = function() { return complexAsin(this); };
DISP.C.SN_acos = function() { return complexAcos(this); };
DISP.C.SN_atan = function() { return complexAtan(this); };

DISP.C.SN_sin = function() {
    var iz = I.SN_multiply(this);
    return iz.SN_exp().SN_subtract(iz.SN_negate().SN_exp())
        .SN_divide(TWO).SN_divide(I);
};

DISP.C.SN_cos = function() {
    var iz = I.SN_multiply(this);
    return iz.SN_exp().SN_add(iz.SN_negate().SN_exp()).SN_divide(TWO);
};

DISP.C.SN_tan = function() {
    return this.SN_sin().SN_divide(this.SN_cos());
};

// ^^^^ You shouldn't need this if you use only real numbers. ^^^^

//
// R: Real abstract base class.
//

DISP.R.SN_isReal = retTrue;

DISP.R.SN_debug = function() { return "R"; };

DISP.R.SN_realPart = retThis;

// Methods implemented generically using more basic operations.

DISP.R.SN_magnitude = function() {
    return this.SN_abs();
};

DISP.R.SN_angle = function() {
    return this.SN_isNegative() ? PI : ZERO;
};

// Commented because they are always overridden.
// DISP.R.SN_isPositive = function() {
//     return this.SN_sign() > 0;
// };
// DISP.R.SN_isNegative = function() {
//     return this.SN_sign() < 0;
// };
// DISP.R.SN_sign = function() {
//     return this.SN_compare(ZERO);
// };

// Dispatches.

DISP.R.SN__eq_Flonum = DISP.Flonum.SN__eq_R;
DISP.R.SN__ne_Flonum = DISP.Flonum.SN__ne_R;

DISP.R.SN__eq_Rectangular = function(z) {
    return z._y.SN_isZero() && z._x.SN_eq(this);
};
DISP.R.SN__ne_Rectangular = function(z) {
    return !z._y.SN_isZero() || z._x.SN_ne(this);
};

DISP.R.SN__gt_Flonum = DISP.Flonum.SN__gt_R;
DISP.R.SN__lt_Flonum = DISP.Flonum.SN__lt_R;
DISP.R.SN__ge_Flonum = DISP.Flonum.SN__ge_R;
DISP.R.SN__le_Flonum = DISP.Flonum.SN__le_R;
DISP.R.SN__compare_Flonum = DISP.Flonum.SN__compare_R;

DISP.R.SN_compare = pureVirtual;
DISP.R.SN_gt = function(x) { return this.SN_compare(x) > 0; };
DISP.R.SN_lt = function(x) { return this.SN_compare(x) < 0; };
DISP.R.SN_ge = function(x) { return this.SN_compare(x) >= 0; };
DISP.R.SN_le = function(x) { return this.SN_compare(x) <= 0; };

DISP.R.SN_add = function(z) {
    return z.SN__add_R(this);
};
DISP.R.SN__add_Flonum = DISP.Flonum.SN__add_R;

DISP.R.SN_subtract = function(z) {
    return z.SN__subtract_R(this);
};
DISP.R.SN__subtract_Flonum = DISP.Flonum.SN__subtract_R;

DISP.R.SN_multiply = function(z) {
    return z.SN__multiply_R(this);
};
DISP.R.SN__multiply_Flonum = DISP.Flonum.SN__multiply_R;

DISP.R.SN_divide = function(z) {
    return z.SN__divide_R(this);
};
DISP.R.SN__divide_Flonum = DISP.Flonum.SN__divide_R;

function complexExpt(b, p) {
    if (b.SN_isZero()) {
        if (p.SN_isZero())
            return toFlonum(1);
        if (p.SN_realPart().SN_isPositive())
            return INEXACT_ZERO;
        raise("&implementation-restriction", "invalid power for zero expt", p);
    }
    return b.SN_log().SN_multiply(p).SN_exp();
}

DISP.R.SN__expt_R = function(x) {
    // Return x to the power of this number.
    if (x.SN_isNegative())
        return complexExpt(x, this);
    return floPow(x, this);
};

DISP.R.SN__expt_EI = DISP.R.SN__expt_R;

DISP.R.SN__expt_EQ = function(q) {
    // Return q to the power of this number.
    if (q.SN_isNegative())
        return complexExpt(q, this);
    var num = q.SN_numerator().SN_expt(this);
    var den = q.SN_denominator().SN_expt(this);

    if (num.SN_isExact() && num.SN_isInteger() &&
        den.SN_isExact() && den.SN_isInteger())
        return new EQFraction(num, den);  // Known to be in lowest terms.

    return num.SN_divide(den);
};

function divAndMod_R_R(x, y) {
    var div = div_R_R(x, y);
    return [div, x.SN_subtract(div.SN_multiply(y))];
}
function div_R_R(x, y) {
    return (y.SN_isNegative()
            ? x.SN_divide(y).SN_ceiling()
            : x.SN_divide(y).SN_floor());
}
function mod_R_R(x, y) {
    return x.SN_subtract(div_R_R(x, y).SN_multiply(y));
}

DISP.R.SN_divAndMod = function(x) {
    return divAndMod_R_R(this, x);
};
DISP.R.SN_div = function(x) {
    return div_R_R(this, x);
};
DISP.R.SN_mod = function(x) {
    return mod_R_R(this, x);
};

DISP.R.SN__divAndMod_R = function(x) {
    return divAndMod_R_R(x, this);
};
DISP.R.SN__div_R = function(x) {
    return div_R_R(x, this);
};
DISP.R.SN__mod_R = function(x) {
    return mod_R_R(x, this);
};

// These functions are always allowed to return inexact.  We, however,
// override a few of these in ZERO and ONE.
["sqrt", "exp", "log", "sin", "cos", "tan", "asin", "acos", "atan", "atan2"]
.forEach(function(name) { DISP.R["SN_" + name] = DISP.Flonum["SN_" + name]; });

// vvvv You shouldn't need this if you use only real numbers. vvvv

//
// Rectangular: Complex numbers as xy-coordinate pairs.
//

function exactRectangular(x, y) {
    //assert(x.SN_isExact());
    //assert(y.SN_isExact());
    if (y.SN_isZero())
        return x;
    if (x.SN_isZero() && y.SN_isUnit())
        return (y.SN_isPositive() ? I : M_I);
    return new Rectangular(x, y);
}

function inexactRectangular(x, y) {
    //assert(x.SN_isInexact());
    //assert(y.SN_isInexact());
    return new Rectangular(x, y);
}

function toRectangular(x, y) {
    //assert(x.SN_isExact() === y.SN_isExact())
    if (x.SN_isExact())
        return exactRectangular(x, y);
    return new Rectangular(x, y);
}

function Rectangular(x, y) {
    this._x = x;
    this._y = y;
}

Rectangular.prototype = new C();

function xyToString(xString, yString) {
    if (yString[0] === '-' || yString[0] === '+')
        return xString + yString + "i";
    return xString + "+" + yString + "i";
}

DISP.Rectangular.SN_numberToString = function(radix, precision) {
    return xyToString(this._x.SN_numberToString(radix, precision),
                      this._y.SN_numberToString(radix, precision));
};

DISP.Rectangular.toString = function(radix) {
    radix = radix || 10;
    return xyToString(this._x.toString(radix), this._y.toString(radix));
};

DISP.Rectangular.SN_debug = function() {
    return "Rectangular(" + this._x.SN_debug()
        + ", " + this._y.SN_debug() + ")";
};

DISP.Rectangular.toFixed = function(dig) {
    return xyToString(this._x.toFixed(dig), this._y.toFixed(dig));
};
DISP.Rectangular.toExponential = function(dig) {
    return xyToString(this._x.toExponential(dig), this._y.toExponential(dig));
};
DISP.Rectangular.toPrecision = function(prec) {
    return xyToString(this._x.toPrecision(prec), this._y.toPrecision(prec));
};

DISP.Rectangular.SN_realPart = function() { return this._x; };
DISP.Rectangular.SN_imagPart = function() { return this._y; };

DISP.Rectangular.SN_isExact   = function() { return this._x.SN_isExact(); };
DISP.Rectangular.SN_isInexact = function() { return this._x.SN_isInexact(); };

DISP.Rectangular.SN_toInexact = function() {
    if (this._x.SN_isInexact())
        return this;
    return inexactRectangular(this._x.SN_toInexact(), this._y.SN_toInexact());
};

DISP.Rectangular.SN_toExact = function() {
    if (this._x.SN_isExact())
        return this;
    return exactRectangular(this._x.SN_toExact(), this._y.SN_toExact());
};

DISP.Rectangular.SN_isZero = function() {
    return this._x.SN_isZero() && this._y.SN_isZero();
};

function rectMagnitude2(z) {
    return z._x.SN_square().SN_add(z._y.SN_square());
}

DISP.Rectangular.SN_isUnit = function() {
    return rectMagnitude2(this).SN_eq(ONE);
};

DISP.Rectangular.SN_magnitude = function() {
    if (this._x.SN_isZero())
        return this._y.SN_abs();
    return rectMagnitude2(this).SN_sqrt();
};

DISP.Rectangular.SN_angle = function() {
    return this._y.SN_atan2(this._x);
};

DISP.C.SN__eq_Rectangular = pureVirtual;
DISP.Rectangular.SN_eq = function(z) {
    return z.SN__eq_Rectangular(this);
};
DISP.Rectangular.SN__eq_Rectangular = function(z) {
    return z._x.SN_eq(this._x) && z._y.SN_eq(this._y);
};
DISP.Rectangular.SN__eq_R = function(x) {
    return this._y.SN_isZero() && x.SN_eq(this._x);
};

DISP.C.SN__ne_Rectangular = pureVirtual;
DISP.Rectangular.SN_ne = function(z) {
    return z.SN__ne_Rectangular(this);
};
DISP.Rectangular.SN__ne_Rectangular = function(z) {
    return z._x.SN_ne(this._x) || z._y.SN_ne(this._y);
};
DISP.Rectangular.SN__ne_R = function(x) {
    return !this._y.SN_isZero() || x.SN_ne(this._x);
};

// Arithmetic where the left operand is Rectangular and the right is
// this Flonum.

DISP.Flonum.SN__add_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x + this), z._y.SN_toInexact());
};
DISP.Flonum.SN__subtract_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x - this), z._y.SN_toInexact());
};
DISP.Flonum.SN__multiply_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x * this), toFlonum(z._y * this));
};
DISP.Flonum.SN__divide_Rectangular = function(z) {
    return inexactRectangular(toFlonum(z._x / this), toFlonum(z._y / this));
};
DISP.Flonum.SN__expt_Rectangular = function(z) {
    // XXX Is this any cheaper than complexExpt??
    return makePolar(floPow(rectMagnitude2(z), this / 2),
                     toFlonum(atan2(z._y, z._x) * this));
};

// Arithmetic where the left operand is Rectangular and the right is
// this real number.

DISP.R.SN__add_Rectangular = function(z) {
    return makeRectangular(z._x.SN_add(this), z._y);
};

DISP.R.SN__subtract_Rectangular = function(z) {
    return makeRectangular(z._x.SN_subtract(this), z._y);
};

DISP.R.SN__multiply_Rectangular = function(z) {
    return toRectangular(z._x.SN_multiply(this), z._y.SN_multiply(this));
};

DISP.R.SN__divide_Rectangular = function(z) {
    return toRectangular(z._x.SN_divide(this), z._y.SN_divide(this));
};

DISP.C.SN__add_Rectangular = pureVirtual;
DISP.Rectangular.SN_add = function(z) {
    return z.SN__add_Rectangular(this);
};
DISP.Rectangular.SN__add_R = function(x) {
    return makeRectangular(x.SN_add(this._x), this._y);
};
DISP.Rectangular.SN__add_Rectangular = function(z) {
    var x = z._x.SN_add(this._x);
    var y = z._y.SN_add(this._y);
    return (x.SN_isExact() ? exactRectangular : inexactRectangular)(x, y);
};

DISP.Rectangular.SN_negate = function() {
    return toRectangular(this._x.SN_negate(), this._y.SN_negate());
};

DISP.C.SN__subtract_Rectangular = pureVirtual;
DISP.Rectangular.SN_subtract = function(z) {
    return z.SN__subtract_Rectangular(this);
};
DISP.Rectangular.SN__subtract_R = function(x) {
    return makeRectangular(x.SN_subtract(this._x), this._y.SN_negate());
};
DISP.Rectangular.SN__subtract_Rectangular = function(z) {
    var x = z._x.SN_subtract(this._x);
    var y = z._y.SN_subtract(this._y);
    return (x.SN_isExact() ? exactRectangular : inexactRectangular)(x, y);
};

DISP.C.SN__multiply_Rectangular = pureVirtual;
DISP.Rectangular.SN_multiply = function(z) {
    return z.SN__multiply_Rectangular(this);
};
DISP.Rectangular.SN__multiply_R = function(x) {
    return toRectangular(x.SN_multiply(this._x), x.SN_multiply(this._y));
};
function complexMultiply(ax, ay, bx, by) {
    return toRectangular(ax.SN_multiply(bx).SN_subtract(ay.SN_multiply(by)),
                         ax.SN_multiply(by).SN_add(ay.SN_multiply(bx)));
}
DISP.Rectangular.SN__multiply_Rectangular = function(z) {
    return complexMultiply(z._x, z._y, this._x, this._y);
};

DISP.Rectangular.SN_square = function() {
    return toRectangular(this._x.SN_square().SN_subtract(this._y.SN_square()),
                         this._x.SN_multiply(this._y).SN_multiply(TWO));
};

DISP.Rectangular.SN_reciprocal = function() {
    var m2 = rectMagnitude2(this);
    return toRectangular(this._x.SN_divide(m2),
                         this._y.SN_divide(m2).SN_negate());
};

DISP.C.SN__divide_Rectangular = pureVirtual;
DISP.Rectangular.SN_divide = function(z) {
    return z.SN__divide_Rectangular(this);
};
function complexDivide(x, y, z) {  // returns (x + iy) / z
    var m2 = rectMagnitude2(z);
    return complexMultiply(x, y,
                           z._x.SN_divide(m2),
                           z._y.SN_divide(m2).SN_negate());
}
DISP.Rectangular.SN__divide_R = function(x) {
    return complexDivide(x, x.SN_isExact() ? ZERO : INEXACT_ZERO, this);
};
DISP.Rectangular.SN__divide_Rectangular = function(z) {
    return complexDivide(z._x, z._y, this);
};

DISP.Rectangular.SN_expt = function(z) {
    return z.SN__expt_Rectangular(this);
};
DISP.Rectangular.SN__expt_C = function(z) {
    return complexExpt(z, this);
};
DISP.C.SN__expt_Rectangular = DISP.Rectangular.SN__expt_C;

DISP.Rectangular.SN_exp = function() {
    return makePolar(this._x.SN_exp(), this._y);
};

// ^^^^ You shouldn't need this if you use only real numbers. ^^^^

//
// ER: Exact real abstract base class.
//

DISP.ER.SN_isExact    = retTrue;
DISP.ER.SN_isInexact  = retFalse;

DISP.ER.SN_toExact    = retThis;
DISP.ER.SN_toInexact  = function() { return toFlonum(+this); };

DISP.ER.SN_isNaN      = retFalse;
DISP.ER.SN_isFinite   = retTrue;
DISP.ER.SN_isInfinite = retFalse;

DISP.ER.SN_imagPart   = retZero;

function zeroes(count) {
    var ret = "000000000000000".substring(0, count & 15);
    if (count > 15)
        ret += new Array((count >> 4) + 1).join("0000000000000000");
    return ret;
}

// Specified by ECMA-262, 5th edition, 15.7.4.5.
DISP.ER.toFixed = function(fractionDigits) {
    var f = (fractionDigits === undefined ? 0 : _parseInt(fractionDigits));
    if (f > SN.maxIntegerDigits)
        throw new RangeError("fractionDigits exceeds " +
                             "SchemeNumber.maxIntegerDigits: " +
                             fractionDigits);

    var x = this;
    var s = "";
    if (x.SN_isNegative()) {
        x = x.SN_negate();
        s = "-";
    }

    var p = ONE.SN__exp10(-f);
    var dm = x.SN_divAndMod(p);
    var n = dm[0];
    if (dm[1].SN_add(dm[1]).SN_ge(p))
        n = ONE.SN_add(n);
    if (n.SN_isZero())
        return s + "0" +
            (fractionDigits > 0 ? "." + zeroes(fractionDigits) : "");
    n = n.SN_numberToString();
    if (f === 0)
        return s + n;

    var z = f - n.length;
    if (f > 0) {
        if (z >= 0)
            n = zeroes(z + 1) + n;
        var point = n.length - f;
        return s + n.substring(0, point) + "." + n.substring(point);
    }
    return s + n + zeroes(-f);
};

DISP.ER.toExponential = function(fractionDigits) {
    var f = (fractionDigits === undefined ? 20 : _parseInt(fractionDigits));
    if (f < 0)
        throw new RangeError("SchemeNumber toExponential: negative " +
                             "argument: " + f);
    if (f > SN.maxIntegerDigits)
        throw new RangeError("fractionDigits exceeds " +
                             "SchemeNumber.maxIntegerDigits: " +
                             fractionDigits);

    var x = this;
    var s = "";
    if (x.SN_isNegative()) {
        x = x.SN_negate();
        s = "-";
    }
    else if (x.SN_isZero())
        return "0" + (fractionDigits > 0 ? "." + zeroes(f) : "") + "e+0";

    var e = floor(x.SN_log() / LN10);
    var p = ONE.SN__exp10(e - f);
    var dm = x.SN_divAndMod(p);
    var n = dm[0];
    if (dm[1].SN_add(dm[1]).SN_ge(p))
        n = ONE.SN_add(n);
    n = n.SN_numberToString();

    // Adjust for inaccuracy in log().
    if (n.length != f + 1) {
        //print("Guessed wrong length: " + n.length + " != " + (f + 1));
        e += n.length - (f + 1);
        p = ONE.SN__exp10(e - f);
        dm = x.SN_divAndMod(p);
        n = dm[0];
        if (dm[1].SN_add(dm[1]).SN_ge(p))
            n = ONE.SN_add(n);
        n = n.SN_numberToString();
        if (n.length != f + 1)
            throw new Error("Can not format as exponential: "
                            + this.SN_numberToString());
    }

    if (fractionDigits === undefined)
        n = n.replace(/(\d)0+$/, "$1");
    if (n.length > 1)
        n = n[0] + "." + n.substring(1);
    return s + n + "e" + (e < 0 ? "" : "+") + e;
};

DISP.ER.toPrecision = function(precision) {
    var p, x;
    if (precision === undefined) {
        x = this.SN_toInexact();
        if (x.SN_isFinite())
            return (+x).toString();
        p = 21;
    }
    else {
        p = _parseInt(precision);
        if (p < 1)
            throw new RangeError("SchemeNumber toPrecision: expected a " +
                                 "positive precision, got: " + precision);
        if (p > SN.maxIntegerDigits)
            throw new RangeError("precision exceeds " +
                                 "SchemeNumber.maxIntegerDigits: " +
                                 precision);
    }

    x = this;
    var s = "";
    if (x.SN_isNegative()) {
        x = x.SN_negate();
        s = "-";
    }
    else if (x.SN_isZero())
        return "0" + (p > 1 ? "." + zeroes(p - 1) : "");

    var ret = x.toExponential(p - 1);
    var eIndex = ret.indexOf('e');
    var exponent = _parseInt(ret.substring(eIndex + 1));
    if (exponent >= -6 && exponent < p) {
        if (exponent === 0)
            ret = ret.substring(0, eIndex);
        else {
            ret = ret.substring(0, 1)
                + (ret.indexOf('.') === -1 ? "" : ret.substring(2, eIndex));
            if (exponent < 0)
                ret = "0." + zeroes(-1 - exponent) + ret;
            else if (exponent < p - 1)
                ret = ret.substring(0, exponent + 1) + "." +
                    ret.substring(exponent + 1);
        }
    }
    else if (precision === undefined) {
        ret = ret.substring(0, eIndex).replace(/\.?0+/, "")
            + ret.substring(eIndex);
    }

    return s + ret;
};

//
// EQ: Exact rational abstract base class.
//

function parseDecimal(sign, significand, exponent) {
    return parseEI(sign, significand).SN__exp10(exponent);
}

DISP.EQ.SN_isRational = retTrue;

DISP.EQ.SN_eq = function(z) {
    return z.SN__eq_EQ(this);
};
DISP.EQ.SN__eq_EQ = pureVirtual;

DISP.EQ.SN_ne = function(z) {
    return z.SN__ne_EQ(this);
};
DISP.EQ.SN__ne_EQ = pureVirtual;

DISP.EQ.SN_compare = function(x) {
    return x.SN__compare_EQ(this);
};
DISP.EQ.SN__compare_EQ = pureVirtual;

DISP.EQ.SN_add = function(z) {
    return z.SN__add_EQ(this);
};
DISP.EQ.SN__add_EQ = pureVirtual;

DISP.EQ.SN_subtract = function(z) {
    return z.SN__subtract_EQ(this);
};
DISP.EQ.SN__subtract_EQ = pureVirtual;

DISP.EQ.SN_multiply = function(z) {
    return z.SN__multiply_EQ(this);
};
DISP.EQ.SN__multiply_EQ = pureVirtual;

DISP.EQ.SN_divide = function(z) {
    return z.SN__divide_EQ(this);
};
DISP.EQ.SN__divide_EQ = pureVirtual;

DISP.EQ.SN_expt = function(z) {
    return z.SN__expt_EQ(this);
};

function reduceEQ(n, d) {
    if (d.SN_isZero())
        divisionByExactZero();

    var g = gcdNonneg(n.SN_abs(), d.SN_abs());

    n = n.SN_div(g);
    d = d.SN_div(g);

    if (d.SN_isNegative())
        return canonicalEQ(n.SN_negate(), d.SN_negate());
    return canonicalEQ(n, d);
}

function canonicalEQ(n, d) {
    return (d === ONE ? n : new EQFraction(n, d));
}

//
// EQFraction: Exact rational as numerator (exact integer) and
// denominator (exact positive integer) with no factors in common.
//

function EQFraction(n, d) {
    //assert(d.SN_gt(ONE));
    //assert(gcdNonneg(n.SN_abs(), d).SN_eq(ONE));
    this._n = n;
    this._d = d;
}

EQFraction.prototype = new EQ();

DISP.EQFraction.SN_numberToString = function(radix, precision) {
    return (this._n.SN_numberToString(radix) +
            "/" + this._d.SN_numberToString(radix));
};

DISP.EQFraction.valueOf = function() {
    var n = this._n;
    var d = this._d;
    var ret = n / d;
    if (!_isNaN(ret))
        return ret;
    if (n.SN_isNegative())
        return -exp(n.SN_negate().SN_log() - d.SN_log());
    return exp(n.SN_log() - d.SN_log());
};

DISP.EQFraction.SN_debug = function() {
    return "EQFraction(" + this._n.SN_debug()
        + " / " + this._d.SN_debug() + ")";
};

DISP.EQFraction.SN_numerator = function () {
    return this._n;
};

DISP.EQFraction.SN_denominator = function() {
    return this._d;
};

DISP.EQFraction.SN_isPositive = function() {
    return this._n.SN_isPositive();
};

DISP.EQFraction.SN_isNegative = function() {
    return this._n.SN_isNegative();
};

DISP.EQFraction.SN__eq_EQ = function(q) {
    return (q.SN_numerator().SN_eq(this._n) &&
            q.SN_denominator().SN_eq(this._d));
};

DISP.EQFraction.SN__ne_EQ = function(q) {
    return (q.SN_numerator().SN_ne(this._n) ||
            q.SN_denominator().SN_ne(this._d));
};

DISP.EQFraction.SN__compare_EQ = function(q) {
    var qn = q.SN_numerator();
    var signDiff = q.SN_sign() - this._n.SN_sign();
    if (signDiff !== 0)
        return (signDiff > 0 ? 1 : -1);
    var qd = q.SN_denominator();
    if (qd === this._d)
        return qn.SN_compare(this._n);
    return qn.SN_multiply(this._d).SN_compare(qd.SN_multiply(this._n));
};

DISP.EQFraction.SN_negate = function() {
    return new EQFraction(this._n.SN_negate(), this._d);
};

DISP.EQFraction.SN_square = function() {
    return new EQFraction(this._n.SN_square(), this._d.SN_square());
};

DISP.EQFraction.SN_reciprocal = function() {
    switch (this._n.SN_sign()) {
    case -1: return canonicalEQ(this._d.SN_negate(), this._n.SN_negate());
    case 1: return canonicalEQ(this._d, this._n);
    case 0: default: divisionByExactZero();
    }
};

DISP.EQFraction.SN_floor = function() {
    return this._n.SN_div(this._d);
};

DISP.EQFraction.SN_ceiling = function() {
    //assert(this._d.SN_gt(ONE));
    return this._n.SN_div(this._d).SN_add(ONE);
};

DISP.EQFraction.SN_round = function() {
    if (this._d.SN_eq(TWO)) {
        var ret = this._n.SN_div(TWO);
        return ret.SN_isEven() ? ret : ret.SN_add(ONE);
    }
    var dm = this._n.SN_divAndMod(this._d);
    var mod = dm[1];
    if (mod.SN_add(mod).SN_lt(this._d))
        return dm[0];
    return dm[0].SN_add(ONE);
};

DISP.EQFraction.SN_truncate = function() {
    if (this._n.SN_isPositive())
        return this._n.SN_div(this._d);
    return this._d.SN_isUnit() ? this._n : this._n.SN_div(this._d).SN_add(ONE);
};

DISP.EQFraction.SN_sign = function() {
    return this._n.SN_sign();
};

DISP.EQFraction.SN_abs = function() {
    if (this._n.SN_sign() >= 0)
        return this;
    return this.SN_negate();
};

DISP.EQFraction.SN__add_EQ = function(q) {
    var n1 = q.SN_numerator();
    var d1 = q.SN_denominator();
    var n2 = this._n;
    var d2 = this._d;
    return reduceEQ(n1.SN_multiply(d2).SN_add(n2.SN_multiply(d1)),
                    d1.SN_multiply(d2));
};

DISP.EQFraction.SN__subtract_EQ = function(q) {
    var n1 = q.SN_numerator();
    var d1 = q.SN_denominator();
    var n2 = this._n;
    var d2 = this._d;
    return reduceEQ(n1.SN_multiply(d2).SN_subtract(n2.SN_multiply(d1)),
                    d1.SN_multiply(d2));
};

DISP.EQFraction.SN__multiply_EQ = function(q) {
    return reduceEQ(q.SN_numerator().SN_multiply(this._n),
                    q.SN_denominator().SN_multiply(this._d));
};

DISP.EQFraction.SN__divide_EQ = function(q) {
    return reduceEQ(q.SN_numerator().SN_multiply(this._d),
                    q.SN_denominator().SN_multiply(this._n));
};

DISP.EQFraction.SN__add_EI = function(n) {
    return canonicalEQ(n.SN_multiply(this._d).SN_add(this._n), this._d);
};

DISP.EQFraction.SN__subtract_EI = function(n) {
    return canonicalEQ(n.SN_multiply(this._d).SN_subtract(this._n), this._d);
};

DISP.EQFraction.SN__multiply_EI = function(n) {
    return reduceEQ(n.SN_multiply(this._n), this._d);
};

DISP.EQFraction.SN__divide_EI = function(n) {
    return reduceEQ(n.SN_multiply(this._d), this._n);
};

DISP.EQFraction.SN_sqrt = function() {
    // This EQ may be too big for toValue(), but its square root may not be.
    return this._n.SN_sqrt().SN_divide(this._d.SN_sqrt());
};

DISP.EQFraction.SN_log = function() {
    return this._n.SN_log().SN_subtract(this._d.SN_log());
};

//
// EI: Exact integer abstract base class.
//

function parseEI(sign, string, radix) {
    var n = _parseInt(string, radix);

    if (n < 9007199254740992)
        return toEINative(sign * n);

    return parseEIBig(string, sign, radix);
}

DISP.EI.SN_isInteger = retTrue;

DISP.EI.SN_debug = function() { return "EI"; };

DISP.EI.SN_numerator   = retThis;
DISP.EI.SN_denominator = function() { return ONE; };
DISP.EI.SN_floor       = retThis;
DISP.EI.SN_ceiling     = retThis;
DISP.EI.SN_round       = retThis;
DISP.EI.SN_truncate    = retThis;

DISP.EI.SN__toBigInteger = pureVirtual;

DISP.EI.SN_eq = function(z) {
    return z.SN__eq_EI(this);
};
DISP.EI.SN__eq_EI = function(n) {
    return n.SN__toBigInteger().compare(this.SN__toBigInteger()) === 0;
};
DISP.EI.SN__eq_EQ = function(q) {
    return q.SN_numerator().SN_eq(this) && q.SN_denominator().SN_eq(ONE);
};

DISP.EI.SN_ne = function(z) {
    return z.SN__ne_EI(this);
};
DISP.EI.SN__ne_EI = function(n) {
    return n.SN__toBigInteger().compare(this.SN__toBigInteger()) !== 0;
};
DISP.EI.SN__ne_EQ = function(q) {
    return q.SN_numerator().SN_ne(this) || q.SN_denominator().SN_ne(ONE);
};

DISP.EI.SN_compare = function(x) {
    return x.SN__compare_EI(this);
};
DISP.EI.SN__compare_EQ = function(q) {
    return q.SN_numerator().SN_compare(q.SN_denominator().SN_multiply(this));
};
DISP.EI.SN__compare_EI = function(n) {
    return n.SN__toBigInteger().compare(this.SN__toBigInteger());
};

DISP.EI.SN_add = function(z) {
    return z.SN__add_EI(this);
};
DISP.EI.SN_subtract = function(z) {
    return z.SN__subtract_EI(this);
};
DISP.EI.SN_multiply = function(z) {
    return z.SN__multiply_EI(this);
};
//DISP.EI.SN_divide = function(z) {
//    return z.SN__divide_EI(this);
//};

DISP.EI.SN_reciprocal = function() {
    if (this.SN_isNegative())
        return canonicalEQ(M_ONE, this.SN_negate());
    return canonicalEQ(ONE, this);
};

DISP.EI.SN_divAndMod = function(x) {
    return x.SN__divAndMod_EI(this);
};
DISP.EI.SN_div = function(x) {
    return x.SN__div_EI(this);
};
DISP.EI.SN_mod = function(x) {
    return x.SN__mod_EI(this);
};

DISP.EI.SN__add_EI = function(n) {
    return reduceBigInteger(n.SN__toBigInteger()
                            .add(this.SN__toBigInteger()));
};
DISP.EI.SN__subtract_EI = function(n) {
    return reduceBigInteger(n.SN__toBigInteger()
                            .subtract(this.SN__toBigInteger()));
};
DISP.EI.SN__multiply_EI = function(n) {
    return reduceBigInteger(n.SN__toBigInteger()
                            .multiply(this.SN__toBigInteger()));
};
DISP.EI.SN__divAndMod_EI = function(n) {
    var t = this.SN__toBigInteger();
    var dm = n.SN__toBigInteger().divRem(t);
    var div = dm[0];
    var mod = dm[1];

    if (mod.isNegative()) {
        mod = mod.add(t);
        div = div.prev();
    }
    return [reduceBigInteger(div), reduceBigInteger(mod)];
};
DISP.EI.SN__div_EI = function(n) {
    return this.SN__divAndMod_EI(n)[0];
};
DISP.EI.SN__mod_EI = function(n) {
    return this.SN__divAndMod_EI(n)[1];
};

DISP.EI.SN__add_EQ = function(q) {
    var d = q.SN_denominator();
    return canonicalEQ(q.SN_numerator().SN_add(d.SN_multiply(this)), d);
};

DISP.EI.SN__subtract_EQ = function(q) {
    var d = q.SN_denominator();
    return canonicalEQ(q.SN_numerator().SN_subtract(d.SN_multiply(this)), d);
};

DISP.EI.SN__multiply_EQ = function(q) {
    return reduceEQ(q.SN_numerator().SN_multiply(this), q.SN_denominator());
};

DISP.EI.SN__divide_EQ = function(q) {
    return reduceEQ(q.SN_numerator(), q.SN_denominator().SN_multiply(this));
};

DISP.EI.SN_expt = function(z) {
    return z.SN__expt_EI(this);
};

DISP.EI.SN__expt_EI = function(n) {
    // Return n to the power of this integer.

    var s = this.SN_sign();
    var p = this.SN_abs().valueOf();

    // If p != this due to inexactness, our result would exhaust memory,
    // since |n| is at least 2.  (expt is specialized for -1, 0, and 1.)
    //assert(n.SN_abs().SN_ge(2));

    var result = pow(n, p);
    var a;
    if (result > -9007199254740992 && result < 9007199254740992) {
        a = toEINative(result);
    }
    else {
        var newLog = n.SN_log() * p;
        if (newLog > SN.maxIntegerDigits * LN10)
            raise("&implementation-restriction",
                  "exact integer would exceed limit of " +
                  (+SN.maxIntegerDigits) +
                  " digits; adjust SchemeNumber.maxIntegerDigits",
                  newLog / LN10);

        a = new EIBig(n.SN__toBigInteger().pow(p));
    }
    return (s > 0 ? a : a.SN_reciprocal());
};

function expt_E_EI(z, n) {
    // Return z raised to the power of this integer.
    // We don't get here if either z or this is 0, 1, or -1.
    //assert(this.SN_abs().SN_gt(ONE));
    //assert(z.SN_magnitude().SN_gt(ONE) || !z.SN_isInteger());
    var bits = n.SN_abs();
    var squarer = z;
    var ret = ONE;
    while (bits.SN_isPositive()) {
        if (bits.SN_isOdd())
            ret = ret.SN_multiply(squarer);
        squarer = squarer.SN_square();
        bits = bits.SN_div(TWO);
    }
    return (n.SN_isNegative() ? ret.SN_reciprocal() : ret);
}

DISP.EI.SN__expt_ER = function(x) {
    return expt_E_EI(x, this);
};

DISP.EI.SN__expt_C = function(z) {
    if (z.SN_isExact())
        return expt_E_EI(z, this);
    return complexExpt(z, this);
};

//
// EINative: Exact integers as native numbers.
//

function EINative(x) {
    //assert(x === floor(x));
    this._ = x;
}

EINative.prototype = new EI();

var ZERO  = SN.ZERO  = new EINative(0);
var ONE   = SN.ONE   = new EINative(1);
var M_ONE = SN.M_ONE = new EINative(-1);
var TWO   = SN.TWO   = new EINative(2);

var EINativeSmall    = [ ZERO, ONE, TWO ];

var I     = SN.I   = new Rectangular(ZERO, ONE);
var M_I   = SN.M_I = new Rectangular(ZERO, M_ONE);

function toEINative(n) {
    //assert(floor(n) === n);
    return EINativeSmall[n] || (n == -1 ? M_ONE : new EINative(n));
}

ZERO.SN_isZero     = retTrue;
ZERO.SN_isPositive = retFalse;
ZERO.SN_isNegative = retFalse;

ZERO.SN_compare = function(x) {
    return -x.SN_sign();
};

ZERO.SN_add        = SN;
ZERO.SN_negate     = retThis;
ZERO.SN_abs        = retThis;
ZERO.SN_multiply   = retThis;
ZERO.SN_square     = retThis;
ZERO.SN_reciprocal = divisionByExactZero;

ZERO.SN_subtract = function(z) {
    return z.SN_negate();
};

ZERO.SN_divide   = function(z) {
    if (z.SN_isZero() && z.SN_isExact())
        divisionByExactZero();
    return this;
};

ZERO.SN_expt = function(z) {
    switch (z.SN_realPart().SN_sign()) {
    case 1: return this;
    case 0: return ONE;
    case -1: default: divisionByExactZero();
    }
};

ZERO.SN_sqrt = retThis;
ZERO.SN_exp = retOne;
ZERO.SN_sin = retThis;
ZERO.SN_cos = retOne;
ZERO.SN_tan = retThis;
ZERO.SN_asin = retThis;
ZERO.SN_atan = retThis;

ONE.SN_isUnit     = retTrue;
ONE.SN_abs        = retThis;
ONE.SN_multiply   = SN;
ONE.SN_reciprocal = retThis;
ONE.SN_square     = retThis;
ONE.SN_expt       = ZERO.SN_multiply;
ONE.SN_sqrt       = retThis;
ONE.SN_log        = retZero;
ONE.SN_acos       = retZero;

M_ONE.SN_isUnit     = retTrue;
M_ONE.SN_abs        = retOne;
M_ONE.SN_multiply   = ZERO.SN_subtract;
M_ONE.SN_reciprocal = retThis;
M_ONE.SN_square     = retOne;
M_ONE.SN_sqrt       = function() { return I; };

M_ONE.SN_expt = function(z) {
    if (!z.SN_isInteger())
        return complexExpt(this, z);
    var ret = (z.SN_isEven() ? ONE : M_ONE);
    if (z.SN_isExact())
        return ret;
    return ret.SN_toInexact();
}

function negate(z) {
    return z.SN_negate();
}
function reciprocal(z) {
    return z.SN_reciprocal();
}

for (className in CLASSES) {
    ZERO["SN__add_"      + className] = retFirst;
    ZERO["SN__subtract_" + className] = retFirst;
    ZERO["SN__multiply_" + className] = retThis;
    ZERO["SN__divide_"   + className] = divisionByExactZero;
    ZERO["SN__expt_"     + className] = retOne;
    ONE["SN__multiply_" + className] = retFirst;
    ONE["SN__divide_"   + className] = retFirst;
    ONE["SN__expt_"     + className] = retFirst;
    M_ONE["SN__multiply_" + className] = negate;
    M_ONE["SN__divide_"   + className] = negate;
    M_ONE["SN__expt_"     + className] = reciprocal;
}

DISP.EINative.valueOf = function() {
    return this._;
};

DISP.EINative.SN_numberToString = function(radix, precision) {
    return this._.toString(radix || 10);
};

DISP.EINative.SN_debug = function() {
    return "EINative(" + this._ + ")";
};

DISP.EINative.SN__toBigInteger = function() {
    return BigInteger(this._);
};

DISP.EINative.SN_isPositive = function() {
    return this._ > 0;
};

DISP.EINative.SN_isNegative = function() {
    return this._ < 0;
};

DISP.EINative.SN_sign = function() {
    return (this._ > 0 ? 1 : (this._ == 0 ? 0 : -1));
};

DISP.EINative.SN_isEven = function() {
    return (this._ & 1) === 0;
};

DISP.EINative.SN_isOdd = function() {
    return (this._ & 1) === 1;
};

DISP.EINative.SN_eq = function(z) {
    return z.SN__eq_EINative(this);
};
DISP.EINative.SN__eq_EINative = function(n) {
    return n._ === this._;
};

DISP.EINative.SN_ne = function(z) {
    return z.SN__ne_EINative(this);
};
DISP.EINative.SN__ne_EINative = function(n) {
    return n._ !== this._;
};

DISP.EINative.SN_compare = function(x) {
    return x.SN__compare_EINative(this);
};
DISP.EINative.SN__compare_EINative = function(n) {
    return (n._ === this._ ? 0 : (n._ > this._ ? 1 : -1));
};

function add_EINative_EINative(a, b) {
    var ret = a + b;
    if (ret > -9007199254740992 && ret < 9007199254740992)
        return toEINative(ret);
    return new EIBig(BigInteger.add(a, b));
}

DISP.EINative.SN_add = function(z) {
    return z.SN__add_EINative(this);
};
DISP.EINative.SN__add_EINative = function(n) {
    return add_EINative_EINative(n._, this._);
};

DISP.EINative.SN_negate = function() {
    return toEINative(-this._);
};

DISP.EINative.SN_abs = function() {
    return (this._ < 0 ? toEINative(-this._) : this);
};

DISP.EINative.SN_subtract = function(z) {
    return z.SN__subtract_EINative(this);
};
DISP.EINative.SN__subtract_EINative = function(n) {
    return add_EINative_EINative(n._, -this._);
};

DISP.EINative.SN_multiply = function(z) {
    return z.SN__multiply_EINative(this);
};
DISP.EINative.SN__multiply_EINative = function(n) {
    var ret = n._ * this._;
    if (ret > -9007199254740992 && ret < 9007199254740992)
        return toEINative(ret);
    return new EIBig(BigInteger(n._).multiply(this._));
};

DISP.EINative.SN_square = function() {
    var ret = this._ * this._;
    if (ret < 9007199254740992)
        return toEINative(ret);
    return new EIBig(BigInteger(this._).square());
};

DISP.EINative.SN_reciprocal = function() {
    var x = this._;
    assert(x !== 0);
    /*
    if (x === 0)  // Removed this check, since ZERO overrides.
        throw divisionByExactZero();
    if (x === 1 || x === -1)  // Removed this optimization, similar reason.
        return this;
    */
    if (x < 0)
        return canonicalEQ(M_ONE, toEINative(-x));
    return canonicalEQ(ONE, this);
};

function divAndMod_EINative(t, x, which) {
    if (x === 0)
        divisionByExactZero();

    var div = (x > 0 ? floor(t / x) : ceil(t / x));
    if (which === 0)
        return toEINative(div);

    var tmp = x * div;
    var mod;

    if (tmp > -9007199254740992)
        mod = t - tmp;
    else if (div > 0)
        mod = (t - x) - (x * (div - 1));
    else
        mod = (t + x) - (x * (div + 1));

    mod = toEINative(mod);
    if (which === 1)
        return mod;

    return [toEINative(div), mod];
};

DISP.EINative.SN_div = function(x) {
    return x.SN__div_EINative(this);
};
DISP.EINative.SN__div_EINative = function(n) {
    return divAndMod_EINative(n._, this._, 0);
};

DISP.EINative.SN_mod = function(x) {
    return x.SN__mod_EINative(this);
};
DISP.EINative.SN__mod_EINative = function(n) {
    return divAndMod_EINative(n._, this._, 1);
};

DISP.EINative.SN_divAndMod = function(x) {
    return x.SN__divAndMod_EINative(this);
};
DISP.EINative.SN__divAndMod_EINative = function(n) {
    return divAndMod_EINative(n._, this._, 2);
};

DISP.EINative.SN__exp10 = function(n) {
    if (this._ === 0 || n === 0)
        return this;

    if (n < 0) {
        var num = String(this._);
        var i = num.length - 1;

        if (num[i] === '0') {
            while (num[i] === '0' && n < 0) {
                n += 1;
                i -= 1;
            }
            num = toEINative(Number(num.substring(0, i + 1)));
            if (n === 0)
                return num;
        }
        else {
            num = this;
        }

        var den;
        if (n < -15)
            den = new EIBig(BigInteger.ONE.exp10(-n));
        else
            // Could make this an array lookup.
            den = toEINative(Number("1000000000000000".substring(0, 1 - n)));
        return reduceEQ(num, den);
    }
    if (n < 16) {
        // Could make substring+parseInt an array lookup.
        var result = _parseInt("1000000000000000".substring(0, n + 1)) * this._;
        if (result > -9007199254740992 && result < 9007199254740992)
            return toEINative(result);
    }
    return new EIBig(BigInteger(this._).exp10(n));
};

DISP.EINative.SN_exactIntegerSqrt = function() {
    var n = floor(sqrt(assertNonNegative(this)._));
    return [toEINative(n), toEINative(this._ - n * n)];
};

//
// EIBig: Exact integer as a BigInteger.
//

// 2 to the power 53, top of the range of consecutive integers
// representable exactly as native numbers.
var FIRST_BIG_INTEGER = BigInteger(9007199254740992);

function reduceBigInteger(n) {
    if (n.compareAbs(FIRST_BIG_INTEGER) >= 0)
        return new EIBig(n);
    return toEINative(n.toJSValue());
}

function EIBig(n) {
    this._ = n;
}

EIBig.prototype = new EI();

function parseEIBig(s, sign, radix) {
    n = BigInteger.parse(s, radix);
    if (sign < 0)
        n = n.negate();
    return new EIBig(n);
}

DISP.EIBig.SN_numberToString = function(radix) {
    return this._.toString(radix);
};

DISP.EIBig.valueOf = function() {
    return this._.valueOf();
};

["isZero", "isEven", "isOdd", "sign", "isUnit", "isPositive", "isNegative"]
    .forEach(function(fn) {
            DISP.EIBig["SN_" + fn] = function() {
                return this._[fn]();
            };
        });

DISP.EIBig.SN_log = function() {
    var x = toFlonum(this._.abs().log());
    return this._.isPositive() ? x : inexactRectangular(x, PI);
};

DISP.EIBig.SN_debug = function() {
    return "EIBig(" + this._.toString() + ")";
};

DISP.EIBig.SN__toBigInteger = function() {
    return this._;
};

DISP.EIBig.SN_add = function(z) {
    return z.SN__add_EIBig(this);
};

DISP.EIBig.SN_negate = function() {
    return new EIBig(this._.negate());
};

DISP.EIBig.SN_abs = function() {
    return new EIBig(this._.abs());
};

DISP.EIBig.SN_subtract = function(z) {
    return z.SN__subtract_EIBig(this);
};

DISP.EIBig.SN_multiply = function(z) {
    return z.SN__multiply_EIBig(this);
};

DISP.EIBig.SN_square = function() {
    return new EIBig(this._.square());
};

DISP.EIBig.SN__exp10 = function(n) {
    //assert(n === floor(n));
    if (n === 0)
        return this;
    if (n > 0)
        return new EIBig(this._.exp10(n));
    return reduceEQ(this, ONE.SN__exp10(-n));
};

DISP.EIBig.SN_sqrt = function() {
    //assert(!this.SN_isZero());
    var mag = toFlonum(exp(this._.abs().log() / 2));
    return (this._.isNegative() ? inexactRectangular(INEXACT_ZERO, mag) : mag);
};

DISP.EIBig.SN_exactIntegerSqrt = function() {

    // I know of no use cases for this.  Be stupid.  Be correct.

    //assert(this._.compareAbs(FIRST_BIG_INTEGER) >= 0);

    function doit(n, a) {
        while (true) {
            var dm = n.divRem(a);
            var b = dm[0];
            var diff = a.subtract(b); // n == b*b + b*diff + dm[1], dm[1] < b+1

            if (diff.isZero())
                return [ b, dm[1] ]; // n == b*b + dm[1]

            if (diff.isUnit()) {
                if (diff.isPositive())
                    // n == b*b + b + dm[1], dm[1] < b+1
                    return [ b, b.add(dm[1]) ];

                // n == b*b - b + dm[1] == (b-1)^2 + b - 1 + dm[1]
                return [ a, a.add(dm[1]) ];
            }

            a = b.add(diff.quotient(2));
        }
    }

    var l = assertNonNegative(this)._.log() / 2 / LN10;
    var a = BigInteger(pow(10, l - floor(l)).toString()
                       + "e" + floor(l));
    return doit(this._, a).map(reduceBigInteger);
};

function gcdNative(a, b) {
    //assert(a >= 0 && b >= 0)
    var c;
    while (a !== 0) {
        c = a;
        a = b % a;
        b = c;
    }
    return toEINative(b);
}

// a and b must be nonnegative, exact integers.
function gcdNonneg(a, b) {
    //assert(!a.SN_isNegative());
    //assert(!b.SN_isNegative());
    //assert(a instanceof EI);
    //assert(b instanceof EI);
    if (a instanceof EINative && b instanceof EINative)
        return gcdNative(a.valueOf(), b.valueOf());

    a = a.SN__toBigInteger();
    if (a.isZero())
        return b;

    b = b.SN__toBigInteger();
    var c;

    while (true) {
        c = a;
        a = b.remainder(a);
        if (a.isZero())
            return new EIBig(c);
        b = c;
        if (b.compareAbs(FIRST_BIG_INTEGER) < 0)
            return gcdNative(a.valueOf(), b.valueOf());
    }
}

function numberToBigInteger(n) {
    return BigInteger.parse(n.toString(16), 16);
}

//
// Inheritance plumbing.
//

/*
function showMethodClasses() {
    var map = {};
    for (var className in DISP)
        for (var methName in DISP[className])
            (map[methName] = map[methName] || {})[className] = DISP[className][methName];
    for (var methName in map)
        for (var className in map[methName])
            print(className + "." + methName + (map[methName][className] === pureVirtual ? " =0" : ""));
}
showMethodClasses();
*/

function resolveOverload(className) {
    var proto = DISP[className];
    var newMethods = {};

    function resolve(subclasses, prefix, method) {
        function resolveSub(subclass) {
            if (proto[prefix + subclass])
                return;
            //print(className + "." + prefix + subclass + " -> " + oldName);
            newMethods[prefix + subclass] = method;
            resolve(HIERARCHY[subclass], prefix, method);
        }
        if (subclasses)
            subclasses.forEach(resolveSub);
    }

    for (var oldName in proto) {
        if (!/^SN_/.test(oldName))
            continue;

        var underscore = oldName.lastIndexOf("_");
        if (underscore === -1)
            continue;

        var oldMethod = proto[oldName];
        if (!oldMethod) {
            //print("Bogus " + className + ".prototype." + oldName);
            continue;
        }

        var oldClass = oldName.substring(underscore + 1);

        resolve(HIERARCHY[oldClass],
                oldName.substring(0, underscore + 1),
                oldMethod);
    }

    for (var methodName in newMethods) {
        proto[methodName] = newMethods[methodName];
    }
}

for (var className in CLASSES)
    resolveOverload(className);

if (Flonum === Number) {
    // Workaround for Flonum not inheriting from R.
    for (var methodName in DISP.R) {
        if (/^SN_/.test(methodName) && !DISP.Flonum[methodName])
            DISP.Flonum[methodName] = DISP.R[methodName];
    }

    // Workaround for Flonum not inheriting from C.
    for (var methodName in DISP.C) {
        if (/^SN_/.test(methodName) && !DISP.Flonum[methodName])
            DISP.Flonum[methodName] = DISP.C[methodName];
    }

    // Workaround for C inheriting from Flonum.
    for (var methodName in DISP.Flonum) {
        if (!DISP.C[methodName])
            DISP.C[methodName] = unimpl;
    }
}

// Install methods.
for (var className in CLASSES) {
    for (var methodName in DISP[className]) {
        CLASSES[className].prototype[methodName] = DISP[className][methodName];
    }
}

function checkPureVirtual(handler) {
    var e = "";
    for (var className in CLASSES) {
        if (!/[a-z]/.test(className)) {
            // Not a concrete class.
            continue;
        }
        var proto = CLASSES[className].prototype;
        for (methodName in proto) {
            if (proto[methodName] === pureVirtual)
                e += "Pure virtual: " + className + "." + methodName + "\n";
        }
    }
    if (e) {
        handler(e);
    }
}
checkPureVirtual(this.alert || this.print || function(e) {throw e;});

return SN;

})();

if (typeof exports !== "undefined") {
    exports.SchemeNumber = SchemeNumber;
    for (var name in SchemeNumber.fn)
        exports[name] = SchemeNumber.fn[name];
}

// load for testing: load("biginteger.js");load("schemeNumber.js");sn=SchemeNumber;fn=sn.fn;ns=fn["number->string"];1

/*
  Export to plugins: N C R ER EQ EI pureVirtual <everything gotten from plugins>
  raise

  Get from plugins: toFlonum parseEI toEINative
  parseDecimal exactRectangular inexactRectangular makePolar
 */

},{"biginteger":1}],6:[function(require,module,exports){
var parser = require('./parser.js').parser,
    makeXPathModels = require('./models.js').makeXPathModels;

parser.makeXPathModels = makeXPathModels;

parser.setXPathModels = function(models) {
    parser.yy.xpathmodels = models;
};

parser.setXPathModels(makeXPathModels());

module.exports = parser;

},{"./models.js":7,"./parser.js":8}],7:[function(require,module,exports){

/*
 * These models are very heavily based on their JavaRosa counterparts, which live at:
 * https://bitbucket.org/javarosa/javarosa/src/tip/core/src/org/javarosa/xpath/expr/
 *
 */

var SchemeNumber = require('./lib/schemeNumber.js').SchemeNumber;

if (!Function.prototype.bind) {
    // PhantomJS doesn't support bind yet
    Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }

        var aArgs   = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP    = function() {},
            fBound  = function() {
                return fToBind.apply(this instanceof fNOP ? this : oThis,
                                     aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();

        return fBound;
    };
}

var defaultHashtagConfig = {
    // @param namespace - the namespace used in hashtag
    // @return - truthy value
    isValidNamespace: function (namespace) {
        return false;
    },
    // @param hashtagExpr - text of hashtag ex. #form/question
    // @return - the XPath or falsy value if no corresponding XPath found
    hashtagToXPath: function (hashtagExpr) {
        throw new Error("This should be overridden");
    },
    // @param xpath_ - XPath object (can be any of the objects defined in xpm
    // @returns - text representation of XPath in hashtag format (default
    //            implementation is to just return the XPath)
    toHashtag: function (xpath_) {
        return xpath_.toXPath();
    },
};

var makeXPathModels = function(hashtagConfig) {
    var xpm = {};
    xpm.DEBUG_MODE = false;
    hashtagConfig = hashtagConfig || defaultHashtagConfig;

    xpm.debuglog = function () {
        if (xpm.DEBUG_MODE) {
            var string = "";
            Array.prototype.slice.call(arguments).forEach(function (value) {
                string += value + ", ";
            });
            console.log(string);
        }
    };

    xpm.validateAxisName = function(name) {
        for (var i in xpm.XPathAxisEnum) {
            if (xpm.XPathAxisEnum.hasOwnProperty(i) && xpm.XPathAxisEnum[i] === name) {
                return xpm.XPathAxisEnum[i];
            }
        }
        throw name + " is not a valid axis name!";
    };

    // helper function
    var objToXPath = function(something) {
        return something.toXPath();
    };

    var objToHashtag = function (xpath_) {
        if (xpath_ instanceof xpm.HashtagExpr) {
            return xpath_.toHashtag();
        }
        return hashtagConfig.toHashtag(xpath_) || xpath_.toHashtag();
    };

    var objToHashtagWithCombine = function(self, combineFunc) {
        return function () {
            return hashtagConfig.toHashtag(self) || combineFunc(objToHashtag).bind(self)();
        };
    };

    xpm.XPathNumericLiteral = function(value) {
        /*
         * This is shockingly complicated for what should be simple thanks to
         * javascript number arithmetic.
         *
         * Use the big number library to hold the value, which will hold
         * large integers properly. For everything else, do the best rounding
         * we can when exporting, since xpath doesn't like scientific notation
         *
         */
        this.value = SchemeNumber(value);
        this.toString = function() {
            return "{num:" + this.value.toString() + "}";
        };
        this.toXPath = function() {
            // helper function
            var toFixed = function (x) {
              /*
               * Convert scientific notation formatted numbers to their decimal
               * counterparts
               *
               * HT: http://stackoverflow.com/questions/1685680/how-to-avoid-scientific-notation-for-large-numbers-in-javascript
               */
              var e;
              if (x < 1.0) {
                e = parseInt(x.toString().split('e-')[1]);
                if (e) {
                    x *= Math.pow(10,e-1);
                    x = '0.' + (new Array(e)).join('0') + x.toString().substring(2);
                }
              } else {
                e = parseInt(x.toString().split('+')[1]);
                if (e > 20) {
                    e -= 20;
                    x /= Math.pow(10,e);
                    x += (new Array(e+1)).join('0');
                }
              }
              return x;
            };
            return toFixed(this.value.toString());
        };
        this.toHashtag = this.toXPath;
        this.getChildren = function () {
           return [];
        };
        return this;
    };

    xpm.XPathStringLiteral = function(value) {
        var stringDelim = value[0];
        this.value = value = value.substr(1, value.length-2);
        this.stringDelim = stringDelim;

        var toXPathString = function(value) {
            return stringDelim + value + stringDelim;
        };

        this.valueDisplay = toXPathString(value);
        this.toString = function() {
            return "{str:" + this.valueDisplay + "}";
        };
        this.toXPath = function() {
            return this.valueDisplay;
        };
        this.toHashtag = this.toXPath;
        this.getChildren = function () {
           return [];
        };
        return this;
    };

    xpm.XPathVariableReference = function(value) {
        this.value = value;
        this.toString = function() {
            return "{var:" + String(this.value) + "}";
        };
        this.toXPath = function() {
            return "$" + String(this.value);
        };
        this.toHashtag = this.toXPath;
        this.getChildren = function () {
           return [];
        };
    };

    xpm.XPathAxisEnum = {
        CHILD: "child",
        DESCENDANT: "descendant",
        PARENT: "parent",
        ANCESTOR: "ancestor",
        FOLLOWING_SIBLING: "following-sibling",
        PRECEDING_SIBLING: "preceding-sibling",
        FOLLOWING: "following",
        PRECEDING: "preceding",
        ATTRIBUTE: "attribute",
        NAMESPACE: "namespace",
        SELF: "self",
        DESCENDANT_OR_SELF: "descendant-or-self",
        ANCESTOR_OR_SELF: "ancestor-or-self"
    };

    xpm.XPathTestEnum = {
        NAME: "name",
        NAME_WILDCARD: "*",
        NAMESPACE_WILDCARD: ":*",
        TYPE_NODE: "node()",
        TYPE_TEXT: "text()",
        TYPE_COMMENT: "comment()",
        TYPE_PROCESSING_INSTRUCTION: "processing-instruction"

    };

    xpm.XPathStep = function(definition) {
        /*
         * A step (part of a path)
         *
         */
        this.axis = definition.axis;
        this.test = definition.test;
        this.predicates = definition.predicates || [];
        this.name = definition.name;
        this.namespace = definition.namespace;
        this.literal = definition.literal;

        this.testString = function () {
             switch(this.test) {
                case xpm.XPathTestEnum.NAME:
                    return String(this.name);
                case xpm.XPathTestEnum.TYPE_PROCESSING_INSTRUCTION:
                    return "processing-instruction(" + (this.literal || "") + ")";
                case xpm.XPathTestEnum.NAMESPACE_WILDCARD:
                    return this.namespace + ":*";
                default:
                    return this.test || null;
             }
        };

        this.toString = function() {
            var stringArray = [];

            stringArray.push("{step:");
            stringArray.push(String(this.axis));
            stringArray.push(",");
            stringArray.push(this.testString());
            if (this.predicates.length > 0) {
                stringArray.push(",{");
                stringArray.push(this.predicates.join(","));
                stringArray.push("}");
            }

            stringArray.push("}");
            return stringArray.join("");
        };

        this.mainXPath = function () {
            var axisPrefix = this.axis + "::"; // this is the default
            // Use the abbreviated syntax to shorten the axis
            // or in some cases the whole thing
            switch (this.axis) {
                case xpm.XPathAxisEnum.DESCENDANT_OR_SELF:
                    if (this.test === xpm.XPathTestEnum.TYPE_NODE) {
                        return "//";
                    }
                    break;
                case xpm.XPathAxisEnum.CHILD:
                    axisPrefix = ""; // this is the default
                    break;
                case xpm.XPathAxisEnum.ATTRIBUTE:
                    axisPrefix = "@";
                    break;
                case xpm.XPathAxisEnum.SELF:
                    if (this.test === xpm.XPathTestEnum.TYPE_NODE) {
                        return ".";
                    }
                    break;
                case xpm.XPathAxisEnum.PARENT:
                    if (this.test === xpm.XPathTestEnum.TYPE_NODE) {
                        return "..";
                    }
                    break;
                default:
                   break;
            }
            return axisPrefix + this.testString();
        };
        this.predicateXPath = function (func) {
            if (this.predicates.length > 0) {
                return "[" + this.predicates.map(func).join("][") + "]";
            }
            return "";
        };
        function _combine (transFunc) {
            return function() {
                return this.mainXPath() + this.predicateXPath(transFunc);
            };
        }
        this.toXPath = _combine(objToXPath);
        this.toHashtag = objToHashtagWithCombine(this, _combine);
        this.getChildren = function () {
           return [];
        };

        return this;
    };

    xpm.XPathInitialContextEnum = {
        HASHTAG: "hashtag",
        ROOT: "abs",
        RELATIVE: "rel",
        EXPR: "expr"
    };

    xpm.XPathPathExpr = function(definition) {
        /**
         * an XPath path, which consists mainly of steps
         */
        var self = this;
        this.initial_context = definition.initial_context;
        this.steps = definition.steps || [];
        this.filter = definition.filter;
        this.toString = function() {
            var stringArray = [];
            stringArray.push("{path-expr:");
            stringArray.push(this.initial_context === xpm.XPathInitialContextEnum.EXPR ?
                             String(this.filter) : this.initial_context);
            stringArray.push(",{");
            stringArray.push(this.steps.join(","));
            stringArray.push("}}");
            return stringArray.join("");
        };
        var _combine = function (func) {
            return function () {
                // this helper function only exists so that
                // the two methods below it can call itx
                var parts = self.steps.map(func), ret = [], curPart, prevPart, sep;
                var root = (self.initial_context === xpm.XPathInitialContextEnum.ROOT) ? "/" : "";
                if (self.filter) {
                    parts.splice(0, 0, func(self.filter));
                }
                if (parts.length === 0) {
                    return root;
                }
                for (var i = 0; i < parts.length; i ++) {
                    curPart = parts[i];
                    if (curPart !== "//" && prevPart !== "//") {
                        // unless the current part starts with a slash, put slashes between
                        // parts. the only exception to this rule is at the beginning,
                        // when we only use a slash if it's an absolute path
                        sep = (i === 0) ? root : "/";
                        ret.push(sep);
                    }
                    ret.push(curPart);
                    prevPart = curPart;
                }
                return ret.join("");
            };
        };
        this.toXPath = _combine(objToXPath);
        this.toHashtag = objToHashtagWithCombine(this, _combine);
        // custom function to pull out any filters and just return the root path
        this.pathWithoutPredicates = _combine(function (step) { return step.mainXPath(); });

        this.getChildren = function () {
           return this.steps;
        };

        return this;
    };

    xpm.XPathFuncExpr = function (definition) {
        /**
         * Representation of an xpath function expression.
         */
        this.id = definition.id;                 //name of the function
        this.args = definition.args || [];       //argument list
        this.toString = function() {
            var stringArray = [];
            stringArray.push("{func-expr:", String(this.id), ",{");
            stringArray.push(this.args.join(","));
            stringArray.push("}}");
            return stringArray.join("");
        };
        function _combine (transFunc) {
            return function () {
                return this.id + "(" + this.args.map(transFunc).join(", ") + ")";
            };
        }
        this.toXPath = _combine(objToXPath);
        this.toHashtag = objToHashtagWithCombine(this, _combine);
        this.getChildren = function () {
           return this.args;
        };
        return this;
    };

    xpm.XPathFilterExpr = function (definition) {
        /**
         * Representation of an xpath filter expression.
         */
        this.expr = definition.expr;
        this.predicates = definition.predicates || [];
        this.toString = function() {
            var stringArray = [];
            stringArray.push("{filt-expr:", this.expr.toString(), ",{");
            stringArray.push(this.predicates.join(","));
            stringArray.push("}}");
            return stringArray.join("");
        };
        function _combine(transFunc) {
            return function() {
                var predicates = "";
                if (this.predicates.length > 0) {
                    predicates = "[" + this.predicates.map(transFunc).join("][") + "]";
                }
                var expr = objToXPath(this.expr);
                // FIXME should all non-function expressions be parenthesized?
                if (!(this.expr instanceof xpm.XPathFuncExpr)) {
                    expr = "(" + expr + ")";
                }
                return expr + predicates;
            };
        }
        this.toXPath = _combine(objToXPath);
        this.toHashtag = objToHashtagWithCombine(this, _combine);
        this.getChildren = function () {
           return this.predicates;
        };
        return this;
    };

    xpm.HashtagExpr = function (definition) {
        /**
         * an extension of xpath that's not really an xpath
         */
        var self = this;
        this.initial_context = definition.initial_context;
        if (!hashtagConfig.isValidNamespace(definition.namespace)) {
            throw new Error(definition.namespace + " is not a valid # expression");
        }
        this.namespace = definition.namespace;
        this.steps = definition.steps || [];
        this.toString = function() {
            var stringArray = [];
            stringArray.push("{hashtag-expr:");
            stringArray.push(this.namespace);
            stringArray.push(",{");
            stringArray.push(this.steps.join(","));
            stringArray.push("}}");
            return stringArray.join("");
        };
        var _combine = function () {
            var parts = [self.namespace].concat(self.steps),
                ret = [];
            for (var i = 0; i < parts.length; i ++) {
                // hashtag to start then /
                ret.push((i === 0) ? '#' : "/");
                ret.push(parts[i]);
            }
            return ret.join("");
        };
        this.toXPath = function () {
            return hashtagConfig.hashtagToXPath(this.toHashtag());
        };
        this.toHashtag = _combine;
        this.getChildren = function () {
           return [];
        };

        return this;
    };

    // expressions
    xpm.XPathExpressionTypeEnum = {
        /*
         * These aren't yet really used anywhere, but they are correct.
         * They correlate with the "type" field in the parser for ops.
         *
         */
        AND: "and",
        OR: "or",
        EQ: "==",
        NEQ: "!=",
        LT: "<",
        LTE: "<=",
        GT: ">",
        GTE: ">=",
        PLUS: "+",
        MINUS: "-",
        MULT: "*",
        DIV: "/",
        MOD: "%",
        UMINUS: "num-neg",
        UNION: "union"
    };

    var expressionTypeEnumToXPathLiteral = xpm.expressionTypeEnumToXPathLiteral = function (val) {
        switch (val) {
            case xpm.XPathExpressionTypeEnum.EQ:
                return "=";
            case xpm.XPathExpressionTypeEnum.MOD:
                return "mod";
            case xpm.XPathExpressionTypeEnum.DIV:
                return "div";
            case xpm.XPathExpressionTypeEnum.UMINUS:
                return "-";
            case xpm.XPathExpressionTypeEnum.UNION:
                return "|";
            default:
                return val;
        }
    };

    var binOpToString = function() {
        return "{binop-expr:" + this.type + "," + String(this.left) + "," + String(this.right) + "}";
    };

    var isOp = xpm.isOp = function(someToken) {
        /*
         * Whether something is an operation
         */
        // this is probably breaking an abstraction layer.
        var str = someToken.toString();
        return str.indexOf("{binop-expr:") === 0 || str.indexOf("{unop-expr:") === 0;
    };

    var isLiteral = xpm.isLiteral = function(someToken) {
        return (someToken instanceof xpm.XPathNumericLiteral ||
                someToken instanceof xpm.XPathStringLiteral ||
                someToken instanceof xpm.XPathPathExpr);
    };

    var isSimpleOp = xpm.isSimpleOp = function(someToken) {
        return isOp(someToken) && isLiteral(someToken.left) && isLiteral(someToken.right);
    };

    function printBinOp (func) {
        return function () {
            var ret = func(this.left) + " " + expressionTypeEnumToXPathLiteral(this.type) + " " + func(this.right);
            if (this.parens === true) {
                return "(" + ret + ")";
            }
            return ret;
        };
    }

    var binOpToXPath = printBinOp(objToXPath);
    var binOpToHashtag = printBinOp(objToHashtag);

    var binOpChildren = function () {
        return [this.left, this.right];
    };

    xpm.XPathBoolExpr = function(definition) {
        this.type = definition.type;
        this.left = definition.left;
        this.right = definition.right;
        this.toString = binOpToString;
        this.toXPath = binOpToXPath;
        this.toHashtag = binOpToHashtag.bind(this);
        this.getChildren = binOpChildren;
        return this;
    };

    xpm.XPathEqExpr = function(definition) {
        this.type = definition.type;
        this.left = definition.left;
        this.right = definition.right;
        this.toString = binOpToString;
        this.toXPath = binOpToXPath;
        this.toHashtag = binOpToHashtag.bind(this);
        this.getChildren = binOpChildren;
        return this;
    };

    xpm.XPathCmpExpr = function(definition) {
        this.type = definition.type;
        this.left = definition.left;
        this.right = definition.right;
        this.toString = binOpToString;
        this.toXPath = binOpToXPath;
        this.toHashtag = binOpToHashtag.bind(this);
        this.getChildren = binOpChildren;
        return this;
    };

    xpm.XPathArithExpr = function(definition) {
        this.type = definition.type;
        this.left = definition.left;
        this.right = definition.right;
        this.toString = binOpToString;
        this.toXPath = binOpToXPath;
        this.toHashtag = binOpToHashtag.bind(this);
        this.getChildren = binOpChildren;
        return this;
    };

    xpm.XPathUnionExpr = function(definition) {
        this.type = definition.type;
        this.left = definition.left;
        this.right = definition.right;
        this.toString = binOpToString;
        this.toXPath = binOpToXPath;
        this.toHashtag = binOpToHashtag.bind(this);
        this.getChildren = binOpChildren;
        return this;
    };

    xpm.XPathNumNegExpr = function(definition) {
        this.type = definition.type;
        this.value = definition.value;
        this.toString = function() {
            return "{unop-expr:" + this.type + "," + String(this.value) + "}";
        };
        function _combine(transFunc) {
            return function() {
                return "-" + transFunc(this.value);
            };
        }
        this.toXPath = _combine(objToXPath);
        this.toHashtag = _combine(objToHashtag);
        this.getChildren = function () {
           return [this.value];
        };
        return this;
    };

    return xpm;
};

if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
    exports.makeXPathModels = makeXPathModels;
}

},{"./lib/schemeNumber.js":5}],8:[function(require,module,exports){
(function (process){(function (){
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,8],$V1=[1,10],$V2=[1,12],$V3=[1,15],$V4=[1,19],$V5=[1,20],$V6=[1,14],$V7=[1,23],$V8=[1,24],$V9=[1,34],$Va=[1,28],$Vb=[1,29],$Vc=[1,30],$Vd=[1,31],$Ve=[1,32],$Vf=[1,33],$Vg=[1,16],$Vh=[1,17],$Vi=[1,36],$Vj=[1,37],$Vk=[1,38],$Vl=[1,39],$Vm=[1,40],$Vn=[1,41],$Vo=[1,42],$Vp=[1,43],$Vq=[1,44],$Vr=[1,45],$Vs=[1,46],$Vt=[1,47],$Vu=[1,48],$Vv=[1,49],$Vw=[5,12,16,17,18,19,20,21,22,23,24,25,26,27,28,29,32,41],$Vx=[1,53],$Vy=[5,12,16,17,18,19,20,21,22,23,24,25,26,27,28,29,32,34,36,40,41],$Vz=[2,58],$VA=[1,61],$VB=[1,62],$VC=[1,63],$VD=[1,65],$VE=[5,12,16,17,18,19,20,21,22,23,24,25,26,27,28,29,32,34,36,41],$VF=[30,51,52,53,54,55,56],$VG=[5,12,16,17,18,19,20,21,22,23,24,25,26,27,28,32,41],$VH=[5,12,16,17,18,19,32,41],$VI=[5,12,16,17,18,19,20,21,22,23,32,41],$VJ=[5,12,16,17,18,19,20,21,22,23,24,25,32,41],$VK=[12,32],$VL=[5,12,16,17,18,19,20,21,22,23,24,25,26,27,28,29,32,34,41];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"xpath_expr":3,"expr":4,"EOF":5,"base_expr":6,"op_expr":7,"path_expr":8,"filter_expr":9,"hashtag_expr":10,"LPAREN":11,"RPAREN":12,"func_call":13,"VAR":14,"literal":15,"OR":16,"AND":17,"EQ":18,"NEQ":19,"LT":20,"LTE":21,"GT":22,"GTE":23,"PLUS":24,"MINUS":25,"MULT":26,"DIV":27,"MOD":28,"UNION":29,"QNAME":30,"arg_list":31,"COMMA":32,"loc_path":33,"SLASH":34,"rel_loc_path":35,"DBL_SLASH":36,"predicate":37,"HASH":38,"hashtag_path":39,"LBRACK":40,"RBRACK":41,"step":42,"step_unabbr":43,"DOT":44,"DBL_DOT":45,"step_body":46,"node_test":47,"axis_specifier":48,"DBL_COLON":49,"AT":50,"WILDCARD":51,"NSWILDCARD":52,"NODETYPE_NODE":53,"NODETYPE_TEXT":54,"NODETYPE_COMMENT":55,"NODETYPE_PROCINSTR":56,"STR":57,"NUM":58,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",11:"LPAREN",12:"RPAREN",14:"VAR",16:"OR",17:"AND",18:"EQ",19:"NEQ",20:"LT",21:"LTE",22:"GT",23:"GTE",24:"PLUS",25:"MINUS",26:"MULT",27:"DIV",28:"MOD",29:"UNION",30:"QNAME",32:"COMMA",34:"SLASH",36:"DBL_SLASH",38:"HASH",40:"LBRACK",41:"RBRACK",44:"DOT",45:"DBL_DOT",49:"DBL_COLON",50:"AT",51:"WILDCARD",52:"NSWILDCARD",53:"NODETYPE_NODE",54:"NODETYPE_TEXT",55:"NODETYPE_COMMENT",56:"NODETYPE_PROCINSTR",57:"STR",58:"NUM"},
productions_: [0,[3,2],[4,1],[4,1],[4,1],[4,1],[4,1],[6,3],[6,1],[6,1],[6,1],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,2],[7,3],[13,4],[13,3],[31,3],[31,1],[8,1],[8,3],[8,3],[8,3],[8,3],[9,2],[9,2],[10,4],[10,2],[39,1],[39,3],[37,3],[33,1],[33,2],[33,2],[33,1],[35,1],[35,3],[35,3],[42,1],[42,1],[42,1],[43,2],[43,1],[46,1],[46,2],[48,2],[48,1],[47,1],[47,1],[47,1],[47,3],[47,3],[47,3],[47,3],[47,4],[15,1],[15,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2: case 3: case 4: case 5: case 6:
  this.$ = $$[$0]; 
break;
case 7:
 $$[$0-1].parens = true; this.$ = $$[$0-1]; 
break;
case 9:
 this.$ = new yy.xpathmodels.XPathVariableReference($$[$0]); 
break;
case 11:
 this.$ = new yy.xpathmodels.XPathBoolExpr({"type": "or", "left": $$[$0-2], "right": $$[$0]}); 
break;
case 12:
 this.$ = new yy.xpathmodels.XPathBoolExpr({"type": "and", "left": $$[$0-2], "right": $$[$0]}); 
break;
case 13:
 this.$ = new yy.xpathmodels.XPathEqExpr({"type": "==", "left": $$[$0-2], "right": $$[$0]}); 
break;
case 14:
 this.$ = new yy.xpathmodels.XPathEqExpr({"type": "!=", "left": $$[$0-2], "right": $$[$0]}); 
break;
case 15:
 this.$ = new yy.xpathmodels.XPathCmpExpr({"type": "<", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 16:
 this.$ = new yy.xpathmodels.XPathCmpExpr({"type": "<=", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 17:
 this.$ = new yy.xpathmodels.XPathCmpExpr({"type": ">", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 18:
 this.$ = new yy.xpathmodels.XPathCmpExpr({"type": ">=", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 19:
 this.$ = new yy.xpathmodels.XPathArithExpr({"type": "+", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 20:
 this.$ = new yy.xpathmodels.XPathArithExpr({"type": "-", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 21:
 this.$ = new yy.xpathmodels.XPathArithExpr({"type": "*", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 22:
 this.$ = new yy.xpathmodels.XPathArithExpr({"type": "/", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 23:
 this.$ = new yy.xpathmodels.XPathArithExpr({"type": "%", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 24:
 this.$ = new yy.xpathmodels.XPathNumNegExpr({"type": "num-neg", "value":$$[$0]}); 
break;
case 25:
 this.$ = new yy.xpathmodels.XPathUnionExpr({"type": "union", "left":$$[$0-2], "right": $$[$0]}); 
break;
case 26:
 this.$ = new yy.xpathmodels.XPathFuncExpr({id: $$[$0-3], args: $$[$0-1]}); 
break;
case 27:
 this.$ = new yy.xpathmodels.XPathFuncExpr({id: $$[$0-2], args: []}); 
break;
case 28:
 var args = $$[$0-2];
                                      args.push($$[$0]);
                                      this.$ = args; 
break;
case 29:
 this.$ = [$$[$0]]; 
break;
case 31:
 this.$ = new yy.xpathmodels.XPathPathExpr({
                                                                    initial_context: yy.xpathmodels.XPathInitialContextEnum.EXPR,
                                                                    filter: $$[$0-2], steps: $$[$0]}); 
break;
case 32:
 var steps = $$[$0];
                                                      steps.splice(0, 0, new yy.xpathmodels.XPathStep({
                                                                                axis: yy.xpathmodels.XPathAxisEnum.DESCENDANT_OR_SELF, 
                                                                                test: yy.xpathmodels.XPathTestEnum.TYPE_NODE}));
                                                      this.$ = new yy.xpathmodels.XPathPathExpr({
                                                                    initial_context: yy.xpathmodels.XPathInitialContextEnum.EXPR,
                                                                    filter: $$[$0-2], steps: steps}); 
break;
case 33:
 // could eliminate filterExpr wrapper, but this makes tests pass as-is
                                                      var filterExpr = new yy.xpathmodels.XPathFilterExpr({expr: $$[$0-2]});
                                                      this.$ = new yy.xpathmodels.XPathPathExpr({
                                                                    initial_context: yy.xpathmodels.XPathInitialContextEnum.EXPR,
                                                                    filter: filterExpr, steps: $$[$0]}); 
break;
case 34:
 var steps = $$[$0];
                                                      // could eliminate filterExpr wrapper, but this makes tests pass as-is
                                                      var filterExpr = new yy.xpathmodels.XPathFilterExpr({expr: $$[$0-2]});
                                                      steps.splice(0, 0, new yy.xpathmodels.XPathStep({
                                                                                axis: yy.xpathmodels.XPathAxisEnum.DESCENDANT_OR_SELF, 
                                                                                test: yy.xpathmodels.XPathTestEnum.TYPE_NODE}));
                                                      this.$ = new yy.xpathmodels.XPathPathExpr({
                                                                    initial_context: yy.xpathmodels.XPathInitialContextEnum.EXPR,
                                                                    filter: filterExpr, steps: steps}); 
break;
case 35:
 this.$ = new yy.xpathmodels.XPathFilterExpr({expr: $$[$0-1], predicates: [$$[$0]]}); 
break;
case 36:
 var filterExpr = $$[$0-1];
                                        filterExpr.predicates.push($$[$0]);
                                        this.$ = filterExpr; 
break;
case 37:
 this.$ = new yy.xpathmodels.HashtagExpr({initial_context: yy.xpathmodels.XPathInitialContextEnum.HASHTAG,
                                                                      namespace: $$[$0-2],
                                                                      steps: $$[$0]}); 
break;
case 38:
 this.$ = new yy.xpathmodels.HashtagExpr({initial_context: yy.xpathmodels.XPathInitialContextEnum.HASHTAG,
                                                                      namespace: $$[$0],
                                                                      steps: []}); 
break;
case 39:
this.$ = [$$[$0]];
break;
case 40:
var path = $$[$0-2]; path.push($$[$0]); this.$ = path;
break;
case 41:
 this.$ = $$[$0-1]; 
break;
case 42:
 this.$ = new yy.xpathmodels.XPathPathExpr({initial_context: yy.xpathmodels.XPathInitialContextEnum.RELATIVE,
                                                                      steps: $$[$0]}); 
break;
case 43:
 this.$ = new yy.xpathmodels.XPathPathExpr({initial_context: yy.xpathmodels.XPathInitialContextEnum.ROOT,
                                                                      steps: $$[$0]}); 
break;
case 44:
 var steps = $$[$0];
                                              // insert descendant step into beginning
                                              steps.splice(0, 0, new yy.xpathmodels.XPathStep({axis: yy.xpathmodels.XPathAxisEnum.DESCENDANT_OR_SELF, 
                                                                                test: yy.xpathmodels.XPathTestEnum.TYPE_NODE}));
                                              this.$ = new yy.xpathmodels.XPathPathExpr({initial_context: yy.xpathmodels.XPathInitialContextEnum.ROOT,
                                                                      steps: steps}); 
break;
case 45:
 this.$ = new yy.xpathmodels.XPathPathExpr({initial_context: yy.xpathmodels.XPathInitialContextEnum.ROOT,
                                                              steps: []});
break;
case 46:
 this.$ = [$$[$0]];
break;
case 47:
 var path = $$[$0-2];
                                            path.push($$[$0]);
                                            this.$ = path; 
break;
case 48:
 var path = $$[$0-2];
                                            path.push(new yy.xpathmodels.XPathStep({axis: yy.xpathmodels.XPathAxisEnum.DESCENDANT_OR_SELF, 
                                                                     test: yy.xpathmodels.XPathTestEnum.TYPE_NODE}));
                                            path.push($$[$0]);
                                            this.$ = path; 
break;
case 49: case 53:
 this.$ = $$[$0]; 
break;
case 50:
 this.$ = new yy.xpathmodels.XPathStep({axis: yy.xpathmodels.XPathAxisEnum.SELF, 
                                                          test: yy.xpathmodels.XPathTestEnum.TYPE_NODE}); 
break;
case 51:
 this.$ = new yy.xpathmodels.XPathStep({axis: yy.xpathmodels.XPathAxisEnum.PARENT, 
                                                          test: yy.xpathmodels.XPathTestEnum.TYPE_NODE}); 
break;
case 52:
 var step = $$[$0-1];
                                            step.predicates.push($$[$0]);
                                            this.$ = step; 
break;
case 54:
 var nodeTest = $$[$0]; // temporary dict with appropriate args
                                          nodeTest.axis = yy.xpathmodels.XPathAxisEnum.CHILD;
                                          this.$ = new yy.xpathmodels.XPathStep(nodeTest); 
break;
case 55:
 var nodeTest = $$[$0];  // temporary dict with appropriate args
                                          nodeTest.axis = $$[$0-1]; // add axis
                                          this.$ = new yy.xpathmodels.XPathStep(nodeTest); 
break;
case 56:
 this.$ = yy.xpathmodels.validateAxisName($$[$0-1]); 
break;
case 57:
 this.$ = yy.xpathmodels.XPathAxisEnum.ATTRIBUTE; 
break;
case 58:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.NAME, "name": $$[$0]}; 
break;
case 59:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.NAME_WILDCARD}; 
break;
case 60:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.NAMESPACE_WILDCARD, "namespace": $$[$0]}; 
break;
case 61:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.TYPE_NODE}; 
break;
case 62:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.TYPE_TEXT}; 
break;
case 63:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.TYPE_COMMENT}; 
break;
case 64:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.TYPE_PROCESSING_INSTRUCTION, "literal": null}; 
break;
case 65:
 this.$ = {"test": yy.xpathmodels.XPathTestEnum.TYPE_PROCESSING_INSTRUCTION, "literal": $$[$0-1]}; 
break;
case 66:
 this.$ = new yy.xpathmodels.XPathStringLiteral($$[$0]); 
break;
case 67:
 this.$ = new yy.xpathmodels.XPathNumericLiteral($$[$0]); 
break;
}
},
table: [{3:1,4:2,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{1:[3]},{5:[1,35],16:$Vi,17:$Vj,18:$Vk,19:$Vl,20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv},o($Vw,[2,2],{37:52,34:[1,50],36:[1,51],40:$Vx}),o($Vw,[2,3]),o($Vw,[2,4]),o($Vw,[2,5],{37:56,34:[1,54],36:[1,55],40:$Vx}),o($Vw,[2,6]),{4:57,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},o($Vy,[2,8]),o($Vy,[2,9]),o($Vy,[2,10]),{4:58,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},o($Vw,[2,30]),{30:[1,59]},o($Vy,$Vz,{11:[1,60],49:$VA}),o($Vy,[2,66]),o($Vy,[2,67]),o($Vw,[2,42],{34:$VB,36:$VC}),o($Vw,[2,45],{42:21,43:22,46:25,47:26,48:27,35:64,30:$VD,44:$V7,45:$V8,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf}),{30:$VD,35:66,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},o($VE,[2,46]),o($VE,[2,49],{37:67,40:$Vx}),o($VE,[2,50]),o($VE,[2,51]),o($Vy,[2,53]),o($Vy,[2,54]),{30:[1,69],47:68,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},o($Vy,[2,59]),o($Vy,[2,60]),{11:[1,70]},{11:[1,71]},{11:[1,72]},{11:[1,73]},o($VF,[2,57]),{1:[2,1]},{4:74,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:75,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:76,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:77,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:78,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:79,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:80,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:81,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:82,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:83,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:84,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:85,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:86,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{4:87,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{30:$VD,35:88,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},{30:$VD,35:89,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},o($Vy,[2,35]),{4:90,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},{30:$VD,35:91,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},{30:$VD,35:92,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},o($Vy,[2,36]),{12:[1,93],16:$Vi,17:$Vj,18:$Vk,19:$Vl,20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv},o($VG,[2,24],{29:$Vv}),o($Vw,[2,38],{34:[1,94]}),{4:97,6:3,7:4,8:5,9:6,10:7,11:$V0,12:[1,96],13:9,14:$V1,15:11,25:$V2,30:$V3,31:95,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},o($VF,[2,56]),{30:$VD,42:98,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},{30:$VD,42:99,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf},o($Vw,[2,43],{34:$VB,36:$VC}),o($Vy,$Vz,{49:$VA}),o($Vw,[2,44],{34:$VB,36:$VC}),o($Vy,[2,52]),o($Vy,[2,55]),o($Vy,$Vz),{12:[1,100]},{12:[1,101]},{12:[1,102]},{12:[1,103],57:[1,104]},o([5,12,32,41],[2,11],{16:$Vi,17:$Vj,18:$Vk,19:$Vl,20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o([5,12,16,32,41],[2,12],{17:$Vj,18:$Vk,19:$Vl,20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VH,[2,13],{20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VH,[2,14],{20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VI,[2,15],{24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VI,[2,16],{24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VI,[2,17],{24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VI,[2,18],{24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VJ,[2,19],{26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VJ,[2,20],{26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VG,[2,21],{29:$Vv}),o($VG,[2,22],{29:$Vv}),o($VG,[2,23],{29:$Vv}),o($Vw,[2,25]),o($Vw,[2,33],{34:$VB,36:$VC}),o($Vw,[2,34],{34:$VB,36:$VC}),{16:$Vi,17:$Vj,18:$Vk,19:$Vl,20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv,41:[1,105]},o($Vw,[2,31],{34:$VB,36:$VC}),o($Vw,[2,32],{34:$VB,36:$VC}),o($Vy,[2,7]),{30:[1,107],39:106},{12:[1,108],32:[1,109]},o($Vy,[2,27]),o($VK,[2,29],{16:$Vi,17:$Vj,18:$Vk,19:$Vl,20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VE,[2,47]),o($VE,[2,48]),o($Vy,[2,61]),o($Vy,[2,62]),o($Vy,[2,63]),o($Vy,[2,64]),{12:[1,110]},o($Vy,[2,41]),o($Vw,[2,37],{34:[1,111]}),o($VL,[2,39]),o($Vy,[2,26]),{4:112,6:3,7:4,8:5,9:6,10:7,11:$V0,13:9,14:$V1,15:11,25:$V2,30:$V3,33:13,34:$V4,35:18,36:$V5,38:$V6,42:21,43:22,44:$V7,45:$V8,46:25,47:26,48:27,50:$V9,51:$Va,52:$Vb,53:$Vc,54:$Vd,55:$Ve,56:$Vf,57:$Vg,58:$Vh},o($Vy,[2,65]),{30:[1,113]},o($VK,[2,28],{16:$Vi,17:$Vj,18:$Vk,19:$Vl,20:$Vm,21:$Vn,22:$Vo,23:$Vp,24:$Vq,25:$Vr,26:$Vs,27:$Vt,28:$Vu,29:$Vv}),o($VL,[2,40])],
defaultActions: {35:[2,1]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* ignore whitespace */ 
break;
case 1: yy.xpathmodels.debuglog("NODETYPE", yy_.yytext); return "NODETYPE_NODE"; 
break;
case 2: yy.xpathmodels.debuglog("NODETYPE", yy_.yytext); return "NODETYPE_TEXT"; 
break;
case 3: yy.xpathmodels.debuglog("NODETYPE", yy_.yytext); return "NODETYPE_COMMENT"; 
break;
case 4: yy.xpathmodels.debuglog("NODETYPE", yy_.yytext); return "NODETYPE_PROCINSTR"; 
break;
case 5: this.begin("OP_CONTEXT"); yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-1); yy.xpathmodels.debuglog("VAR", yy_.yytext); return "VAR"; 
break;
case 6: this.begin("OP_CONTEXT"); 
                                     yy_.yytext = yy_.yytext.substr(0, yy_.yyleng-2);
                                     yy.xpathmodels.debuglog("NSWILDCARD", yy_.yytext); return "NSWILDCARD"; 
break;
case 7: this.begin("OP_CONTEXT"); yy.xpathmodels.debuglog("QNAME", yy_.yytext); return "QNAME"; 
break;
case 8: this.begin("OP_CONTEXT"); yy.xpathmodels.debuglog("WILDCARD", yy_.yytext); return "WILDCARD"; 
break;
case 9: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("MULT", yy_.yytext); return "MULT"; 
break;
case 10: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("AND", yy_.yytext); return "AND"; 
break;
case 11: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("OR", yy_.yytext); return "OR"; 
break;
case 12: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("DIV", yy_.yytext); return "DIV"; 
break;
case 13: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("MOD", yy_.yytext); return "MOD"; 
break;
case 14: this.begin("OP_CONTEXT"); yy.xpathmodels.debuglog("NUM", yy_.yytext); return "NUM"; 
break;
case 15: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("EQ", yy_.yytext); return "EQ"; 
break;
case 16: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("NEQ", yy_.yytext); return "NEQ"; 
break;
case 17: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("LTE", yy_.yytext); return "LTE"; 
break;
case 18: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("LT", yy_.yytext); return "LT"; 
break;
case 19: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("GTE", yy_.yytext); return "GTE"; 
break;
case 20: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("GT", yy_.yytext); return "GT"; 
break;
case 21: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("PLUS", yy_.yytext); return "PLUS"; 
break;
case 22: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("MINUS", yy_.yytext); return "MINUS"; 
break;
case 23: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("UNION", yy_.yytext); return "UNION"; 
break;
case 24: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("DBL", yy_.yytext); return "DBL_SLASH"; 
break;
case 25: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("SLASH", yy_.yytext); return "SLASH"; 
break;
case 26: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("LBRACK", yy_.yytext); return "LBRACK"; 
break;
case 27: this.begin("OP_CONTEXT");  yy.xpathmodels.debuglog("RBRACK", yy_.yytext); return "RBRACK"; 
break;
case 28: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("LPAREN", yy_.yytext); return "LPAREN"; 
break;
case 29: this.begin("OP_CONTEXT");  yy.xpathmodels.debuglog("RPAREN", yy_.yytext); return "RPAREN"; 
break;
case 30: this.begin("OP_CONTEXT");  yy.xpathmodels.debuglog("DBL", yy_.yytext); return "DBL_DOT"; 
break;
case 31: this.begin("OP_CONTEXT");  yy.xpathmodels.debuglog("DOT", yy_.yytext); return "DOT"; 
break;
case 32: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("AT", yy_.yytext); return "AT"; 
break;
case 33: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("DBL", yy_.yytext); return "DBL_COLON"; 
break;
case 34: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("COMMA", yy_.yytext); return "COMMA"; 
break;
case 35: this.begin("VAL_CONTEXT"); yy.xpathmodels.debuglog("HASH", yy_.yytext); return "HASH"; 
break;
case 36: this.begin("OP_CONTEXT"); yy.xpathmodels.debuglog("STR", yy_.yytext); return "STR"; 
break;
case 37:return 5;
break;
}
},
rules: [/^(?:((\s+)))/,/^(?:node(?=(((\s+))?\()))/,/^(?:text(?=(((\s+))?\()))/,/^(?:comment(?=(((\s+))?\()))/,/^(?:processing-instruction(?=(((\s+))?\()))/,/^(?:\$([A-Za-z_][A-Za-z0-9._-]*(:[A-Za-z_][A-Za-z0-9._-]*)?))/,/^(?:([A-Za-z_][A-Za-z0-9._-]*):\*)/,/^(?:([A-Za-z_][A-Za-z0-9._-]*(:[A-Za-z_][A-Za-z0-9._-]*)?))/,/^(?:\*)/,/^(?:\*)/,/^(?:(and))/,/^(?:(or))/,/^(?:(div))/,/^(?:(mod))/,/^(?:(([0-9])+(\.([0-9])*)?|(\.([0-9])+)))/,/^(?:=)/,/^(?:!=)/,/^(?:<=)/,/^(?:<)/,/^(?:>=)/,/^(?:>)/,/^(?:\+)/,/^(?:-)/,/^(?:\|)/,/^(?:\/\/)/,/^(?:\/)/,/^(?:\[)/,/^(?:\])/,/^(?:\()/,/^(?:\))/,/^(?:\.\.)/,/^(?:\.)/,/^(?:@)/,/^(?:::)/,/^(?:,)/,/^(?:#)/,/^(?:("[^"\""]*"|'[^'\'']*'))/,/^(?:$)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37],"inclusive":true},"OP_CONTEXT":{"rules":[0,1,2,3,4,5,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37],"inclusive":true},"VAL_CONTEXT":{"rules":[0,1,2,3,4,5,6,7,8,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this)}).call(this,require('_process'))
},{"_process":4,"fs":2,"path":3}]},{},[6])(6)
});
define('vellum/xpath',[
    'underscore',
    'xpath',
], function (
    _,
    xpath
) {
    return {
        // hashtagInfo properties:
        //   hashtagMap: {hashtag expression: XPath expression}
        //   invertedHashtagMap: {XPath expression: hashtag expression}
        //   hashtagTransformations: {hashtag prefix: function to return property}
        //   hashtagNamespaces: {namespace: true}
        // NOTE hashtagInfo is not the same as hashtagConfig passed to
        // `xpath.makeXPathModels(hashtagConfig)`
        makeXPathModels: function (hashtagInfo, configDecorator) {
            configDecorator = configDecorator || function (v) { return v; };
            return xpath.makeXPathModels(configDecorator({
                isValidNamespace: function (namespace) {
                    return hashtagInfo.hashtagNamespaces.hasOwnProperty(namespace);
                },
                hashtagToXPath: function (hashtagExpr) {
                    var xpath_ = hashtagInfo.hashtagMap[hashtagExpr];
                    if (xpath_) {
                        return xpath_;
                    }

                    // If full hashtag isn't recognized, remove the property name and check
                    // if this is a recognizable type, just with a property we haven't heard of
                    var lastSlashIndex = hashtagExpr.lastIndexOf("/");
                    if (lastSlashIndex !== -1) {
                        var prefix = hashtagExpr.substring(0, lastSlashIndex + 1),
                            property = hashtagExpr.substring(lastSlashIndex + 1);
                        if (hashtagInfo.hashtagTransformations.hasOwnProperty(prefix)) {
                            return hashtagInfo.hashtagTransformations[prefix](property);
                        }
                    }
                    return hashtagExpr;
                },
                toHashtag: function (xpath_) {
                    var expr = xpath_.toXPath();
                    if (hashtagInfo.invertedHashtagMap.hasOwnProperty(expr)) {
                        return hashtagInfo.invertedHashtagMap[expr];
                    }
                    return null;
                }
            }));
        },
        createParser: function (xpathmodels) {
            var ret = new xpath.Parser();
            ret.yy.xpathmodels = xpathmodels;
            ret.models = ret.yy.xpathmodels;
            return ret;
        },
        parser: function (hashtagInfo, configDecorator) {
            var models = this.makeXPathModels(hashtagInfo, configDecorator);
            return this.createParser(models);
        },
    };
});

/**
 * This provides a robust parser for replacing hashtags with arbitrary derived
 * expressions (bubbles) as well as a light-weight delimit/transform system for
 * marking delimited ranges of text in a string that can later be transformed to
 * arbitrary derived expressions (bubbles).
 */
define('vellum/escapedHashtags',[
    'underscore',
    'vellum/xpath',
], function(
    _,
    xpath
) {
    var OUTSIDE_HASHTAG = 0,
        INSIDE_HASHTAG = 1,
        DELIMITER = "`",
        ID_CHAR = /^[\w.\-]/;

    /*
     * Escape delimiters in text
     *
     * Use to escape delimiters in an expression before escaping
     * sub-expressions with `escape`. `transform` can be used to
     * unescape the final result.
     *
     * example:
     *  expr = "{a} + {b}";
     *  subs = {a: "#form/a", b: "#form/b"};
     *  escapeDelimiters(expr).replace(/{(.*?)}/g, function (match, id) {
     *      return subs.hasOwnProperty(id) ? escape(subs[id]) : match;
     *  });  // -> "`#form/a` + `#form/b`"
     */
    function escapeDelimiters(text) {
        return text.replace(/`/g, "``");
    }

    /*
     * Wrap text with delimiters
     *
     * The given text must not contain the delimiter character.
     */
    function delimit(text) {
        if (text.indexOf(DELIMITER) !== -1) {
            throw new Error("cannot delimit: " + text);
        }
        return DELIMITER + text + DELIMITER;
    }

    /*
     * Transform delimited ranges based on transformFn
     *
     * Use to transform escaped (delimited) hashtags to bubbles in an
     * invalid xpath expression.
     *
     * transformFn -> function(input) where input will be text inside delimiters
     * and returns what you want that turned into without delimiters
     * allowRunOn -> If true, do not add extra space after transformed range
     * followed by identifier character. The default is false.
     *
     * example:
     * transform("(`#form/question` + 1", makeBubble);
     * // -> "(<bubble>question</bubble> + 1"
     */
    function transform(input, transformFn, allowRunOn) {
        if (!input) { return input; }
        var symbols = getSymbols(input);
        transformFn = transformFn || function (input) { return input; };
        var state = OUTSIDE_HASHTAG,
            strLen = symbols.length,
            text = "",
            currentReference = "";

        for (var i = 0; i < strLen; i++) {
            var current = symbols[i],
                next = symbols[i+1];

            if (state === OUTSIDE_HASHTAG) {
                if (current === DELIMITER && next === DELIMITER) {
                    text += DELIMITER;
                    i++;
                } else if (current === DELIMITER) {
                    state = INSIDE_HASHTAG;
                } else {
                    text += current;
                }
            } else if (state === INSIDE_HASHTAG) {
                if (current === DELIMITER) {
                    state = OUTSIDE_HASHTAG;
                    text += transformFn(currentReference);
                    if (!allowRunOn && next && ID_CHAR.test(next)) {
                        text += " ";
                    }
                    currentReference = "";
                } else if (next !== undefined) {
                    currentReference += current;
                }
            }
        }

        if (state === INSIDE_HASHTAG) {
            // end of string, shouldn't happen, but will not
            // overestimate users or Vellum devs
            text += DELIMITER + currentReference;
        }

        return text;
    }

    // handle 4 byte unicode properly. pulled from
    // https://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols
    function getSymbols(string) {
        var index = 0;
        var length = string.length;
        var output = [];
        for (; index < length - 1; ++index) {
            var charCode = string.charCodeAt(index);
            if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                charCode = string.charCodeAt(index + 1);
                if (charCode >= 0xDC00 && charCode <= 0xDFFF) {
                    output.push(string.slice(index, index + 2));
                    ++index;
                    continue;
                }
            }
            output.push(string.charAt(index));
        }
        output.push(string.charAt(index));
        return output;
    }

    /*
     * Get function to transform hashtags to arbitrary text
     *
     * Use to transform hashtags to bubbles in a valid xpath expression.
     *
     * example:
     * transform = makeHashtagTransform(form);
     * transform("#form/question + 1", makeBubble);
     * // -> "<bubble>question</bubble> + 1"
     */
    function makeHashtagTransform(hashtagInfo) {
        function decorateHashtagger(tagger) {
            var super_toHashtag = tagger.toHashtag;
            tagger.toHashtag = function (xpath_) {
                var expr = super_toHashtag(xpath_);
                return expr === null ? null : decorateHashtag(expr);
            };
            return tagger;
        }
        var escapingModels = xpath.makeXPathModels(hashtagInfo, decorateHashtagger),
            escapingParser = xpath.createParser(escapingModels),
            baseHashtagExpr = escapingModels.HashtagExpr,
            decorateHashtag = _.identity;

        escapingModels.HashtagExpr = function (definition) {
            baseHashtagExpr.call(this, definition);
            decorateHashtagger(this);
            return this;
        };

        return function (xpath, transformFn) {
            decorateHashtag = transformFn;
            try {
                return escapingParser.parse(xpath).toHashtag();
            } catch (err) {
                return xpath;
            } finally {
                decorateHashtag = _.identity;
            }
        };
    }

    return {
        escapeDelimiters: escapeDelimiters,
        delimit: delimit,
        transform: transform,
        makeHashtagTransform: makeHashtagTransform,
    };
});

define('vellum/logic',[
    'jquery',
    'underscore',
    'vellum/util',
], function (
    $,
    _,
    util
) {
    var EXTERNAL_REF = "#";

    function LogicExpression (exprText, xpathParser) {
        this._text = exprText || "";
        this._xpathParser = xpathParser;
        if ($.trim(exprText)) {
            try {
                this.parsed = this._xpathParser.parse(exprText);
            } catch (err) {
                this.parsed = null;
                this.error = err;
            }
        } else {
            this.parsed = null;
        }
    }
    LogicExpression.prototype = {
        analyze: function () {
            var paths = [],
                absolutePaths = [],
                topLevelPaths = [],
                hashtags = [],
                ROOT = this._xpathParser.models.XPathInitialContextEnum.ROOT,
                RELATIVE = this._xpathParser.models.XPathInitialContextEnum.RELATIVE,
                EXPR = this._xpathParser.models.XPathInitialContextEnum.EXPR,
                predicates;
            this.paths = paths;
            this.absolutePaths = absolutePaths;
            this.hashtags = hashtags;
            this.instanceRefs = {};
            this.referencesSelf = false;
            this.topLevelPaths = topLevelPaths;
            if (this.parsed) {
                var queue = [{xpath: this.parsed, insideFilter: false}],
                    node, i, children, j, k, insideFilter;
                while (queue.length > 0) {
                    k = queue.shift();
                    node = k.xpath;
                    insideFilter = k.insideFilter;
                    if (node instanceof this._xpathParser.models.XPathPathExpr) {
                        paths.push(node);
                        if (!insideFilter) {
                            topLevelPaths.push(node);
                        }

                        insideFilter = true;

                        if (node.initial_context === ROOT) {
                            absolutePaths.push(node);
                        } else if (node.initial_context === RELATIVE &&
                                   node.steps.length === 1 &&
                                   node.steps[0].axis === 'self') {
                            this.referencesSelf = true;
                        } else if (node.initial_context === EXPR) {
                            if (!this._addInstanceRef(node.filter.expr)) {
                                queue.push({
                                    xpath: node.filter.expr,
                                    insideFilter: insideFilter
                                });
                            }
                            predicates = node.filter.predicates;
                            for (i = 0; i < predicates.length; i++) {
                                queue.push({
                                    xpath: predicates[i],
                                    insideFilter: insideFilter
                                });
                            }
                        }
                    } else if (node instanceof this._xpathParser.models.XPathFuncExpr) {
                        this._addInstanceRef(node);
                    } else if (node instanceof this._xpathParser.models.HashtagExpr) {
                        hashtags.push(node);
                    }
                    children = node.getChildren();
                    for (i = 0; i < children.length; i++) {
                        queue.push({
                            xpath: children[i],
                            insideFilter: insideFilter
                        });
                        if (children[i].predicates && children[i].predicates.length) {
                            predicates = children[i].predicates;
                            for (j = 0; j < predicates.length; j++) {
                                queue.push({
                                    xpath: predicates[j],
                                    insideFilter: insideFilter
                                });
                            }
                        }
                    }
                }
            }
        },
        _addInstanceRef: function (expr) {
            if (expr.id === "instance" && expr.args.length === 1 &&
                    expr.args[0] instanceof this._xpathParser.models.XPathStringLiteral) {
                var id = expr.args[0].value;
                this.instanceRefs[id] = null;
                return true;
            }
            return false;
        },
        getPaths: function () {
            if (!this.paths) {
                this.analyze();
            }
            return this.paths;
        },
        getTopLevelPaths: function () {
            if (!this.topLevelPaths) {
                this.analyze();
            }
            return this.topLevelPaths;
        },
        getHashtags: function () {
            if (!this.hashtags) {
                this.analyze();
            }
            return this.hashtags;
        },
        updatePath: function (from, to) {
            var paths = this.getPaths().concat(this.getHashtags()),
                path, i;

            var replacePathInfo = function (source, destination) {
                // Copy methods from source to destination, resulting in
                // mutating destination while preserving the original
                // object reference. It is not enough to simply copy
                // state variables since source and destination types
                // may differ (HashtagExpr, XPathPathExpr).
                destination.toHashtag = source.toHashtag.bind(source);
                destination.toXPath = source.toXPath.bind(source);
            };
            
            for (i = 0; i < paths.length; i++) {
                path = paths[i];
                if (path.toHashtag() === from) {
                    replacePathInfo(this._xpathParser.parse(to), path);
                }
            }
        },
        getText: function () {
            if (this._text && this.parsed) {
                return this.parsed.toHashtag();
            } else {
                return this._text;
            }
        }
    };

    function LogicManager (form, opts) {
        opts.allowedDataNodeReferences = opts.allowedDataNodeReferences || {};

        this.opts = opts;
        this.form = form;
        // see this._addReferences for ref structure
        // refid is either refMug.ufid or EXTERNAL_REF
        this.forward = {};  // {mug.ufid: {property: [ref, ...], ...}, ...}
        this.reverse = {};  // {refid: {mug.ufid: [ref, ...], ...}, ...}
        this.errors = {};   // {mug.ufid: {property: true, ...}, ...}
    }

    LogicManager.prototype = {
        clearReferences: function (mug, property) {
            function _removeMugFromReverse(property, ref) {
                if (ref.ref) {
                    // assert ref.mug === mug.ufid
                    if (ref.mug !== mug.ufid) {
                        throw new Error([mug, ref]);
                    }
                    reverse[ref.ref][ref.mug] = _.filter(
                        reverse[ref.ref][ref.mug],
                        function (r) { return r.property !== property; }
                    );
                }
            }

            var reverse = this.reverse,
                forward = this.forward,
                errors = this.errors,
                removeMugFromReverse;
            mug.form.dropAllInstanceReferences(mug, property, true);
            if (forward.hasOwnProperty(mug.ufid)) {
                if (property) {
                    if (forward[mug.ufid].hasOwnProperty(property)) {
                        removeMugFromReverse = _.partial(_removeMugFromReverse, property);
                        _.each(forward[mug.ufid][property], removeMugFromReverse);
                    }
                    forward[mug.ufid][property] = [];
                } else {
                    _.each(forward[mug.ufid], function(refs, property) {
                        removeMugFromReverse = _.partial(_removeMugFromReverse, property);
                        _.each(refs, removeMugFromReverse);
                    });
                    forward[mug.ufid] = {};
                }
            } else {
                forward[mug.ufid] = {};
            }
            if (errors.hasOwnProperty(mug.ufid)) {
                if (property) {
                    delete this.errors[mug.ufid][property];
                } else {
                    delete this.errors[mug.ufid];
                }
            }
        },
        _addReferences: function (mug, property, value) {
            var _this = this,
                form = _this.form,
                expr = new LogicExpression(value || mug.p[property], form.xpath),
                unknowns = [],
                messages = [],
                warning = "",
                spec = mug.spec[property],
                propertyName = spec ? spec.lstring : property,
                reverse = this.reverse,
                refs;

            expr.analyze();
            if (expr.referencesSelf && !(spec && spec.mayReferenceSelf)) {
                warning = util.format(gettext("The {property} for a question " +
                    "is not allowed to reference the question itself. " +
                    "Please remove the . from the {property} " +
                    "or your form will have errors."),
                    {property: propertyName});
            }

            messages.push({
                key: "core-circular-reference-warning",
                level: mug.WARNING,
                message: warning
            });

            // append item for each mug referenced (by absolute path) in mug's
            // property value
            refs = expr.absolutePaths.concat(expr.hashtags).map(function (xobj) {
                var xpath = xobj.toHashtag(),
                    isHashtag = xpath.startsWith('#'),
                    pathString = isHashtag ? xpath : xobj.pathWithoutPredicates(),
                    pathWithoutRoot = isHashtag ? '' : pathString.substring(1 + pathString.indexOf('/', 1)),
                    refMug = form.getMugByPath(pathString),
                    isHashRef = form.hasValidHashtagPrefix(xpath),
                    knownHashtag = isHashRef && form.isValidHashtag(xpath);

                // last part is hack to allow root node in data parents
                if ((!refMug && !knownHashtag) &&
                    (!mug.options.ignoreReferenceWarning || !mug.options.ignoreReferenceWarning(mug)) &&
                    _this.opts.allowedDataNodeReferences.indexOf(pathWithoutRoot) === -1 &&
                    !(property === "dataParent" && pathString === form.getBasePath().slice(0,-1)))
                {
                    unknowns.push(xpath);
                } else if (!refMug && isHashRef && !knownHashtag) {
                    unknowns.push(xpath);
                }
                var refid = refMug ? refMug.ufid : (isHashRef ? EXTERNAL_REF : ""),
                    ref = {
                        mug: mug.ufid, // mug with property value referencing refMug
                        ref: refid, // referenced Mug or EXTERNAL_REF or ""
                        property: property,
                        path: xpath, // path to refMug
                        sourcePath: mug.hashtagPath
                    };
                if (refid) {
                    if (!reverse.hasOwnProperty(refid)) {
                        reverse[refid] = {};
                        reverse[refid][mug.ufid] = [];
                    } else if (!reverse[refid].hasOwnProperty(mug.ufid)) {
                        reverse[refid][mug.ufid] = [];
                    }
                    reverse[refid][mug.ufid].push(ref);
                }
                return ref;
            });
            this.forward[mug.ufid][property] = refs;
            _.each(expr.instanceRefs, function (ignore, id) {
                form.referenceInstance(id, mug, property);
            });
            _.each(expr.hashtags, function (hashtag) {
                form.referenceHashtag(hashtag.toHashtag(), mug, property);
            });
            if (unknowns.length > 0) {
                if (!this.errors[mug.ufid]) {
                    this.errors[mug.ufid] = {};
                }
                this.errors[mug.ufid][property] = true;
            } else if (this.errors[mug.ufid]) {
                delete this.errors[mug.ufid][property];
            }
            messages.push({
                key: "logic-bad-path-warning",
                level: mug.WARNING,
                message: (function () {
                    if (!unknowns.length) {
                        return "";
                    } else if (unknowns.length === 1) {
                        return gettext("Unknown question:") + " " + unknowns[0];
                    }
                    return gettext("Unknown questions:") + "\n- " + unknowns.join("\n- ");
                })()
            });
            return messages;
        },
        addReferences: function (mug, property, value) {
            // get absolute paths from mug property's value
            var _this = this,
                returned = {};
            this.clearReferences(mug, property);
            if (!value && mug.p[property] && _.isFunction(mug.p[property].mapLogicExpressions)) {
                return mug.p[property].mapLogicExpressions(function (expr) {
                    var messages = _this._addReferences(mug, property, expr);
                    return _.filter(messages, function (msg) {
                        if (!returned.hasOwnProperty(msg.key)) {
                            returned[msg.key] = msg;
                        } else if (!returned[msg.key].message || !msg.message) {
                            if (msg.message) {
                                _.extend(returned[msg.key], msg);
                            }
                            return false;
                        }
                        return true;
                    });
                });
            } else {
                return this._addReferences(mug, property, value);
            }
        },
        updateReferences: function (mug, property, value) {
            function update(property) {
                messages[property] = _this.addReferences(mug, property, value);
            }
            var _this = this,
                messages = {};
            if (property) {
                update(property);
            } else {
                _.each(mug.logicReferenceAttrs, update);
            }
            mug.addMessages(messages);
        },
        /**
         * Update references to a node with its new path. Used when a node is
         * moved or duplicated (with subtree).
         *
         * @param mugId - ufid of the mug to update references for
         * @param from - old absolute path of the mug
         * @param to - new absolute path of the mug
         * @param subtree - (optional) only replace references from nodes
         *        beginning with this path (no trailing /)
         */
        updatePath: function (mugId, from, to, subtree) {
            if (from === to) { return; }

            var data = {};
            data[mugId] = [from, to];

            this.updatePaths(data, subtree);
        },
        /**
         * Update references nodes with theirs new paths. Used when a node,
         * which may have sub-nodes, is moved or duplicated.
         *
         * @param data - an object with the following structure:
         *        { "<mug ufid>": ["/old/path", "/new/path"], ... }
         * @param subtree - (optional) only replace references from nodes
         *        beginning with this path (no trailing /)
         */
        updatePaths: function (data, subtree) {
            var seen = {},
                form = this.form;
            function updatePath(mug, property, paths) {
                function updateExpression(value) {
                    if (!value) {
                        return value;
                    }
                    var expr = new LogicExpression(value, form.xpath),
                        orig = expr.getText();
                    expr.updatePath(paths[0], paths[1]);
                    var updated = expr.getText();
                    return updated !== orig ? updated : value;
                }

                var pkey = mug.ufid + " " + property + " " + paths[0];
                if (seen.hasOwnProperty(pkey)) {
                    return;
                }
                seen[pkey] = null;
                var value = mug.p[property];
                if (value && _.isFunction(value.updateLogicExpressions)) {
                    value.updateLogicExpressions(updateExpression, mug);
                } else {
                    var result = updateExpression(value);
                    if (value !== result) {
                        // update without triggering validation/events
                        mug.p.set(property, result);
                    }
                }
            }
            this.forEachReferencingProperty(data, updatePath, subtree);
        },
        /**
         * Call a function for each mug with broken references
         *
         * The function is called with one argument or two arguments:
         * the mug with broken references and property if known.
         */
        forEachBrokenReference: function(func) {
            _.each(this.errors, function (props, ufid) {
                var mug = this.form.getMugByUFID(ufid);
                if (mug) {
                    if (props) {
                        _.each(props, function (v, prop) { func(mug, prop); });
                    } else {
                        func(mug);
                    }
                } else {
                    delete this.errors[ufid];
                }
            }, this);
        },
        hasBrokenReferences: function () {
            return _.find(this.errors, function (properties) {
                return _.some(properties);
            });
        },
        /**
         * Find and update invalid external references
         */
        validateExternalReferences: function () {
            var _this = this,
                invalid = _.chain(this.reverse[EXTERNAL_REF] || {})
                    .values()
                    .flatten(true)
                    .filter(function(ref) {
                        return !_this.form.isValidHashtag(ref.path);
                    })
                    .value();
            _.each(invalid, function(ref) {
                var mug = _this.form.getMugByUFID(ref.mug);
                _this.updateReferences(mug, ref.property);
            });
        },
        /**
         * Call function for each expression property that references a mug
         * identified by one of the given ufids
         *
         * @param ufids - a mapping (object) keyed by mug ufids.
         *        Example: {"mug-ufid": <mapValue>, ...}
         * @param func - a function to be called for each expression property that
         *        references one of the mugs. The function is called with
         *        three arguments: (mug, property, mapValue)
         *        - mug: the mug with an expression property referencing a mug
         *          identified by one of the given ufids ("mug-ufid").
         *        - property: the name of the expression property.
         *        - mapValue: the value from ufids (<mapValue>).
         * @param subtree - (optional) only visit references from nodes
         *        beginning with this path (no trailing /)
         */
        forEachReferencingProperty: function(ufids, func, subtree) {
            var form = this.form,
                reverse = this.reverse;
            _.each(ufids, function (mapValue, ufid) {
                if (reverse.hasOwnProperty(ufid)) {
                    _.each(reverse[ufid], function (refs, mugUfid) {
                        var mug = form.getMugByUFID(mugUfid);
                        _.each(refs, function (ref) {
                            if (!subtree ||
                                ref.sourcePath === subtree ||
                                ref.sourcePath.indexOf(subtree + '/') === 0)
                            {
                                func(mug, ref.property, mapValue);
                            }
                        });
                    });
                }
            });
        },
        /**
         * Find a mug that references the given mug
         *
         * @param predicate - predicate function used to find a match.
         * @returns Boolean
         */
        hasReferencingMug: function (mug, predicate) {
            var form = this.form;
            if (this.reverse.hasOwnProperty(mug.ufid)) {
                return _.find(this.reverse[mug.ufid], function (refs, ufid) {
                    var mug = form.getMugByUFID(ufid);
                    return refs.length && mug && predicate(mug);
                });
            }
            return false;
        },
        reset: function () {
            this.forward = {};
            this.reverse = {};
        },
        // This is to tell HQ's case summary what is referenced
        caseReferences: function () {
            var _this = this,
                load = {},
                save = {};
            _.each(_.flatten(_.values(this.reverse[EXTERNAL_REF] || {})), function(ref) {
                var path = _this.form.normalizeXPath(ref.sourcePath);
                if (path === null) {
                    // Choices have null path, use parent path.
                    // This is a little fragile. Currently all mug types
                    // that have a null path also have a parent that does
                    // not have a null path. If that ever changes this will
                    // likely need to change.
                    var parent = _this.form.getMugByUFID(ref.mug).parentMug;
                    if (parent) {
                        path = parent.absolutePath;
                    }
                }
                if (load.hasOwnProperty(path)) {
                    if (!_.contains(load[path], ref.path)) {
                        load[path].push(ref.path);
                    }
                } else {
                    load[path] = [ref.path];
                }
            });
            var saveToCaseQuestions = _.filter(this.form.getMugList(), function(mug) {
                return mug.options.getCaseSaveData !== undefined;
            });
            _.each(saveToCaseQuestions, function (mug) {
                var mugPath = _this.form.getAbsolutePath(mug);
                save[mugPath] = mug.options.getCaseSaveData(mug);
            });
            return {load: load, save: save};
        },
        // returns object of external references that are known to be valid
        knownExternalReferences: function () {
            var _this = this;
            return _.chain(this.reverse[EXTERNAL_REF] || {})
                .values()
                .flatten(true)
                .filter(function(ref) {
                    return _this.form.isValidHashtag(ref.path);
                })
                .map(function(ref) {
                    return [ref.path, null];
                }).object().value();
        },
        /*
         * Returns object describing references used in the logic manager
         *
         * {
         *   /path/of/referenced/mug: {
         *     /path/of/mug/referencing: property where ref occurs
         *   }
         * }
         *
         * Optionally can filter based on hashtag path
         */
        findUsages: function (path) {
            var _this = this,
                form = _this.form,
                tableData = {},
                formRefs = _.omit(_this.reverse, EXTERNAL_REF);

            _.each(formRefs, function (refsToUsedMug, usedMugUfid) {
                var usedMug = form.getMugByUFID(usedMugUfid),
                    mugReferences = {};
                if (!usedMug || path && path !== usedMug.hashtagPath) {
                    return;
                }
                _.each(refsToUsedMug, function (refs, usedInMugUfid) {
                    _.each(refs, function (ref) {
                        var usedInMug = form.getMugByUFID(usedInMugUfid),
                            usedInMugPath = usedInMug.hashtagPath,
                            readablePropName = usedInMug.spec[ref.property].lstring;
                        if (!usedInMugPath) {
                            usedInMugPath = usedInMug.parentMug.hashtagPath;
                        }
                        mugReferences[usedInMugPath] = readablePropName;
                    });
                });
                tableData[usedMug.hashtagPath] = mugReferences;
            });

            return tableData;
        },
    };

    return {
        LogicManager: LogicManager,
        LogicExpression: LogicExpression,
    };
});

define('vellum/hqAnalytics',[], function() {

    var noop = function() {};

    return {
        fbUsage: noop,
        usage: noop,
        workflow: noop,
    };
});

/*
 * expected structure of a richText widget:
 *
 * <div contenteditable="true" ... ckeditor stuff...>
 *   <p>
 *      User input text
 *   </p>
 * </div>
 *
 * Possible values for user's input text:
 *
 * text
 *
 * newline: <br />
 *
 * rich text "bubble":
 *   <span data-value="xpath">
 *     <i class="icon">&nbsp;</i>
 *     text to display inside bubble
 *   </span>
 *
 * Any other HTML has undefined behavior.
 *
 * Expression editng mode returns invalid xpath expressions with a special
 * "#invalid/xpath " prefix and bubbles are escaped with backticks. Example:
 *
 *   #invalid/xpath (`#form/text`
 */

(function () {
    // set CKEditor base path before loading ckeditor
    var path = window.requirejs.toUrl("vellum/../lib/ckeditor/").replace(/\?.*/, "");
    window.CKEDITOR_BASEPATH = path;
})();

define('vellum/richText',[
    'require',
    'underscore',
    'jquery',
    'tpl!vellum/templates/date_format_popover',
    'tpl!vellum/templates/easy_reference_popover',
    'vellum/dateformats',
    'vellum/escapedHashtags',
    'vellum/logic',
    'vellum/util',
    'vellum/xml',
    'vellum/hqAnalytics',
    'ckeditor',
    'ckeditor-jquery'
], function(
    require,
    _,
    $,
    date_format_popover,
    easy_reference_popover,
    dateformats,
    escapedHashtags,
    logic,
    util,
    xml,
    analytics,
    CKEDITOR
){
    var FORM_REF_REGEX = /^#form\//,
        INVALID_PREFIX = "#invalid/xpath ",
        // http://stackoverflow.com/a/16459606/10840
        bubbleWidgetDefinition = {
        template:
            '<span class="label label-datanode label-datanode-internal">' +
              '<i class="fa fa-question-circle">&nbsp;</i>' +
              'example widget, not used' +
            '</span>',
        upcast: function ( element ) {
            return element.name === 'span' && element.hasClass('label-datanode');
        },
        init: function() {
            // TODO: PR to ckeditor to make changing drag ui supported
            var $this = $(this.element.$),
                width = $this.innerWidth(),
                height = $this.outerHeight(),
                dragContainer = this.dragHandlerContainer,
                editor = this.editor;
            dragContainer.setStyles({
                width: width + 'px',
                height: height + 'px',
                left: '0px'
            });

            if (editor.commands.createPopover) {
                var _this = this;

                // Look for deleted bubbles
                editor.on('change', function(e) {
                    editor.widgets.checkWidgets({ initOnlyNew: 1 });
                });

                // if the editor is still being initialized then this command
                // won't be enabled until it is ready
                if (editor.status === "ready") {
                    editor.execCommand('createPopover', _this);
                } else {
                    editor.on('instanceReady', function () {
                        editor.execCommand('createPopover', _this);
                    });
                }
            }
        }
    };

    CKEDITOR.plugins.add('bubbles', {
        requires: 'widget',
        init: function (editor) {
            editor.widgets.add('bubbles', bubbleWidgetDefinition);
        }
    });

    CKEDITOR.config.allowedContent = true;
    CKEDITOR.config.customConfig = '';
    CKEDITOR.config.title = false;
    CKEDITOR.config.extraPlugins = 'bubbles';
    CKEDITOR.config.disableNativeSpellChecker = false;
    // We don't use Toolbar, however it is required by clipboard.
    // Once https://github.com/ckeditor/ckeditor4/issues/654 is resolved,
    // toolbar can be removed from the source(build).
    CKEDITOR.config.toolbar = [];

    /**
     * Get or create a rich text editor for the given element
     *
     * Only the first argument is needed to get the editor once an
     * editor has been created for a given jQuery object. Calling
     * this function with a single argument is a good way to get an
     * editor that you expect to already exist; an error will be thrown
     * if the editor does not exist.
     *
     * @param input - editor jQuery HTML element.
     * @param form - form object, functions used:
     *    normalizeHashtag - get expression with normalized hashtags
     *    isValidHashtag - boolean if hashtag translation exists
     *    getIconByPath - only used for mug.options.icon
     *    xpath - xpath parser
     * @param options -
     *    rtl - use right to left text
     *    isExpression - treat input as xpath or itext
     *    createPopover - function to create a popover on the bubble.
     *        arguments are editor, ckwidget
     */
    var editor = function(input, form, options) {
        // HACK use 1/4 em space to fix cursor movement/hiding near bubble
        var TRAILING_SPACE = "\u2005";
        function insertHtmlWithSpace(content) {
            editor.insertHtml(content + TRAILING_SPACE);
        }
        var wrapper = input.data("ckwrapper");
        if (wrapper) {
            return wrapper;
        }
        if (arguments.length === 1) {
            throw new Error("editor not initialized: " +
                            $("<div>").append(input).html());
        }
        if (input.length !== 1) {
            throw new Error("input should reference exactly one element, " +
                            "got " + input.length);
        }
        options = options || {};
        if (!options.createPopover && !form.vellum.opts().features.disable_popovers) {
            options.createPopover = createPopover;
        }
        var NOTSET = {},
            newval = NOTSET,  // HACK work around async get/set
            editor = input.ckeditor({
                contentsLangDirection: options.rtl ? 'rtl' : 'ltr',
                disableNativeSpellChecker: options.disableNativeSpellChecker,
                placeholder: ' ',
            }).editor;
        wrapper = {
            getValue: function (callback) {
                if (callback) {
                    input.promise.then(function() {
                        callback(fromRichText(editor.getData()));
                    });
                } else if (newval !== NOTSET) {
                    return newval;
                } else {
                    var data;
                    try {
                        data = editor.getData();
                    } catch (err) {
                        if (err.name !== "IndexSizeError") {
                            throw err;
                        }
                        // HACK work around Chrome/CKEditor bug
                        // https://dev.ckeditor.com/ticket/13903
                        wrapper.select(0);
                        data = editor.getData();
                    }
                    return fromRichText(data, form, options.isExpression);
                }
            },
            setValue: function (value, callback) {
                newval = value;
                value = toRichText(value, form, options);
                editor.setData(value, {
                    callback: function () {
                        newval = NOTSET;
                        if (callback) { callback(); }
                    },
                    noSnapshot: true,
                });
                return wrapper;
            },
            insertExpression: function (xpath) {
                if (options.isExpression) {
                    insertHtmlWithSpace(bubbleExpression(xpath, form));
                } else {
                    var output = makeBubble(form, xpath);
                    insertHtmlWithSpace($('<p>').append(output).html());
                }
                return wrapper;
            },
            insertOutput: function (xpath) {
                if (options.isExpression) {
                    throw new Error("cannot insert output into expression editor");
                }
                insertHtmlWithSpace(bubbleOutputs(xpath, form));
                return wrapper;
            },
            change: function () {
                editor.fire("saveSnapshot");
                return wrapper;
            },
            focus: function() {
                if (editor.status === "ready") {
                    editor.focus();
                } else {
                    editor.removeListener('instanceReady', editor.focus);
                    editor.on('instanceReady', editor.focus);
                }
            },
            select: function (index, length) {
                ckSelect.call(null, editor, index, length);
                return wrapper;
            },
            on: function () {
                var args = Array.prototype.slice.call(arguments);
                editor.on.apply(editor, args);
                return wrapper;
            },
            destroy: function () {
                if (input !== null) {
                    input.removeData("ckwrapper");
                    input.promise.then(function () {
                        editor.destroy();
                        editor = null;
                    });
                    input = null;
                }
            },
        };

        editor.on('focus', function (e) {
            // workaround for https://code.google.com/p/chromium/issues/detail?id=313082
            editor.setReadOnly(false);
            // remove any placeholder text that may be in the text area
            var editable = e.editor.editable();
            if (editable.hasClass('placeholder')) {
                editable.removeClass('placeholder');
                editable.setHtml('');
            }
            // set the cursor to the end of text
            var selection = editor.getSelection();
            var range = selection.getRanges()[0];
            if (range) {
                var pCon = range.startContainer.getAscendant({p:2},true);
                if (pCon) {
                    var newRange = new CKEDITOR.dom.range(range.document);
                    newRange.moveToPosition(pCon, CKEDITOR.POSITION_BEFORE_END);
                    newRange.select();
                }
            }
        });

        editor._vellum_fromRichText = function (html) {
            return fromRichText(html, form, options.isExpression);
        };

        editor.on('paste', function(event) {
            var data = event.data;
            if (data.dataTransfer && data.dataTransfer.getData("Text")) {
                // Get plain text instead of HTML because HTML encoded
                // content from applications like Word or your text
                // editor often contains unwanted styling information.
                //
                // Insert HTML-ified plain text rather than HTML with
                // bubbles because we cannot reliably find hashtags in
                // text fragments that are not valid XPath expressions.
                // We need to know where the text is being pasted (is it
                // inside a string?), and finally put the cursor at the
                // end of the pasted content. It's hard, but maybe
                // possible? For now this tries to follow the law of
                // least surprise by inserting plain text. Unfortunately
                // a surprising thing happens later: hashtags are
                // automatically converted to bubbles the next time the
                // expression is loaded in a rich text editor.
                var text = data.dataTransfer.getData("Text");
                data.type = 'html';
                data.dataValue = $('<div />').text(text).html()
                    .replace(/\n/g, "<br />")
                    .replace(/  /g, " &nbsp;");
            } else {
                // fall back to HTML
                // Adapted from http://www.keyvan.net/2012/11/clean-up-html-on-paste-in-ckeditor/
                var style = /<style type="text\/css">.*?<\/style>/g;
                data.dataValue = data.dataValue.replace(style, "");
            }
        }, null, null, 2);

        if (_.isFunction(options.createPopover)) {
            editor.addCommand('createPopover', {
                exec: options.createPopover,
                editorFocus: false,
                canUndo: false,
            });
        }

        input.data("ckwrapper", wrapper);
        return wrapper;
    };

    function richTextDataTransfer(nativeDataTransfer, editor) {
        realDataTransfer.call(this, nativeDataTransfer);

        if (editor) {
            this.sourceEditor = editor;

            var html = editor.getSelectedHtml(1);
            if (html) {
                var text = editor._vellum_fromRichText(html);
                if (isInvalid(text)) {
                    text = escapedHashtags.transform(
                        text.slice(INVALID_PREFIX.length),
                        function (v) { return v; }
                    );
                }
                // always copy plain text, not HTML
                this.setData('text/plain', text);
            }
        }
    }
    // monkeypatch clipboard plugin to transform easy reference
    // bubbles to hashtags on copy/cut.
    var realDataTransfer = CKEDITOR.plugins.clipboard.dataTransfer;
    richTextDataTransfer.prototype = realDataTransfer.prototype;
    CKEDITOR.plugins.clipboard.dataTransfer = richTextDataTransfer;

    /**
     * Set selection in CKEditor
     */
    function ckSelect(editor, index, length) {
        function iterNodes(parent) {
            var i = 0,
                children = parent.getChildren(),
                count = children.count(),
                inner = null;
            function next() {
                var child;
                if (inner) {
                    child = inner();
                    if (child !== null) {
                        return child;
                    }
                    inner = null;
                }
                if (i >= count) {
                    return null;
                }
                child = children.getItem(i);
                i++;
                if (child.type === CKEDITOR.NODE_ELEMENT) {
                    var name = child.getName().toLowerCase();
                    if (name === "p") {
                        inner = iterNodes(child);
                        return next();
                    }
                    if (name === "span" || name === "br") {
                        return {node: child, length: 1, isText: false};
                    }
                    throw new Error("not implemented: " + name);
                } else if (child.type === CKEDITOR.NODE_TEXT) {
                    return {
                        node: child,
                        length: child.getText().length,
                        isText: true,
                    };
                }
                throw new Error("unhandled element type: " + child.type);
            }
            return next;
        }
        function getNodeOffset(index, nextNode) {
            var offset = index,
                node = nextNode();
            while (node) {
                if (node.length >= offset) {
                    return {
                        node: node.node,
                        offset: offset,
                        isText: node.isText,
                    };
                }
                offset -= node.length;
                node = nextNode();
            }
            throw new Error("index is larger than content: " + index);
        }
        editor.focus();
        var sel = editor.getSelection(),
            nextNode = iterNodes(sel.root),
            node = getNodeOffset(index, nextNode),
            range = sel.getRanges()[0];
        if (node.isText) {
            range.setStart(node.node, node.offset);
        } else {
            range.setStartAfter(node.node);
        }
        if (length) {
            nextNode = iterNodes(sel.root);
            node = getNodeOffset(index + length, nextNode);
            if (node.isText) {
                range.setEnd(node.node, node.offset);
            } else {
                range.setEndAfter(node.node);
            }
        } else {
            range.collapse(true);
        }
        sel.selectRanges([range]);
    }

    /*
     * formats specifies the serialization for different formats that can be
     * applied to bubbles.
     *
     * Notes:
     *   uses outputValue as that's what $el.data() transforms data-output-value
     *
     * For now, ordering matters.
     * TODO: should each bubble contain the correct ordering?
     */
    var formats = {
            'dateFormat': {
                serialize: function(currentValue, dataAttrs) {
                    return _.template("format-date(date(<%=xpath%>), '<%=dateFormat%>')")({
                        xpath: currentValue,
                        dateFormat: dataAttrs.dateFormat
                    });
                },
            },
            'value': {
                serialize: function(currentValue) {
                    return _.template('&lt;output value="<%=xpath%>" /&gt;')({
                        xpath: currentValue
                    });
                },
            }
        },
        formatOrdering = ['dateFormat', 'value'];

    /**
     * Takes in data attributes from a "bubble"
     *
     * Example
     *   serializing the rich text
     *     <span data-value='/data/value' ... />
     *   with
     *     applyFormats($bubble.data())
     *   would return
     *     <output value="/data/value" />
     */
    function applyFormats(dataAttrs) {
        var currentValue = dataAttrs.value;
        _.each(formatOrdering, function(format) {
            if (dataAttrs[format]) {
                currentValue = formats[format].serialize(currentValue, dataAttrs);
            }
        });
        return currentValue;
    }

    /**
     * @param path can be:
     *   form: /data/group/text
     *   instance: instance('blah')/blah_list/blah
     */
    function getBubbleDisplayValue(path, xpathParser) {
        var parsed = new logic.LogicExpression(path, xpathParser),
            topLevelPaths = parsed.getTopLevelPaths(),
            hashtags = parsed.getHashtags(),
            steps, dispValue;

        if (topLevelPaths.length) {
            steps = topLevelPaths[0].steps;
            dispValue = steps[steps.length-1].name;
        } else {
            steps = hashtags[0].toHashtag().split('/');
            dispValue = steps[steps.length-1];
        }
        return dispValue;
    }

    /**
     * Make a xpath bubble
     *
     * @param xpath - xpath expression to set as the bubble value.
     * @returns jquery object of the bubble
     */
    function makeBubble(form, xpath) {
        function _parseXPath(xpath, form) {
            if (!FORM_REF_REGEX.test(xpath)) {
                if (form.isValidHashtag(xpath)) {
                    return {
                        classes: ['label-datanode-external', 'fcc fcc-fd-case-property']
                    };
                } else if (form.hasValidHashtagPrefix(form.normalizeHashtag(xpath))) {
                    return {
                        classes: ['label-datanode-external-unknown', 'fa-solid fa-triangle-exclamation']
                    };
                }
            }

            var icon = form.getIconByPath(xpath);
            if (icon) {
                return {classes: ['label-datanode-internal', icon]};
            }
            return {classes: ['label-datanode-unknown', 'fcc fcc-help']};
        }

        var xpathInfo = _parseXPath(xpath, form),
            bubbleClasses = xpathInfo.classes[0],
            iconClasses = xpathInfo.classes[1],
            dispValue = getBubbleDisplayValue(xpath, form.xpath),
            icon = $('<i>').addClass(iconClasses).html('&nbsp;');
        return $('<span>')
            .addClass('label label-datanode ' + bubbleClasses)
            .attr('data-value', xpath)
            .append(icon)
            .append(dispValue);
    }

    /**
     * @param output - <output ...> DOM element
     * @returns - jquery object of xpath bubble or string
     */
    function outputToBubble(form, output) {
        var info = extractXPathInfo($(output)),
            xpath = form.normalizeHashtag(info.value, true),
            attrs = _.omit(info, 'value'),
            startsWithRef = xpath && (FORM_REF_REGEX.test(xpath) ||
                                      form.hasValidHashtagPrefix(xpath)),
            containsWhitespace = /\s/.test(xpath);

        if (!startsWithRef || (startsWithRef && containsWhitespace)) {
            return $('<span>').text(xml.normalize(output)).html();
        }
        return $('<div>').append(makeBubble(form, xpath).attr(attrs)).html();
    }

    /**
     * Replace <output> tags with bubble markup
     *
     * @param escape - If true, escape HTML except for bubble markup.
     */
    function bubbleOutputs(text, form, escape) {
        var el = xml.xhtml(text),
            places = {},
            replacer, result;

        if (escape) {
            replacer = function () {
                var id = util.get_guid();
                places[id] = outputToBubble(form, this);
                return "{" + id + "}";
            };
        } else {
            replacer = function () {
                return outputToBubble(form, this);
            };
        }
        el.find('output').replaceWith(replacer);
        result = el.html();
        if (escape) {
            result = escapeReplace(result, places);
        }
        return result;
    }

    /**
     * Preserve <output> tag while encoding other HTML before saving to source XML
     * Similar to bubbleOutputs, without converting to bubble markup
     *
     * Regex matches any tags EXCEPT if it's an output tag (e.g. <output/>),
     * or if the '<' character is followed by a space (to avoid matching with
     * '<' or '>' characters used as attributes)
     */
    function sanitizeInput (text) {
        var regex = /<(?!output| )/g;
        if (!regex.test(text)) {
            return text;
        }

        var el = xml.xhtml(text),
            places = {};

        function replacer() {
            var id = util.get_guid();
            places[id] = this;
            return "{" + id + "}";
        }
        el.find('output').replaceWith(replacer);
        return escapeReplace(el.html(), places);
    }

    function escapeReplace(text, places) {
        text = $('<div />').text(xml.humanize(text)).html();
        text = text.replace(/{(.+?)}/g, function (match, id) {
            return places.hasOwnProperty(id) ?
                    $("<div>").append(places[id]).html() : match;
        });
        return text;
    }

    /**
     * Wrap top-level expression nodes with bubble markup
     */
    function bubbleExpression(text, form) {
        var transform;
        if (isInvalid(text)) {
            text = text.slice(INVALID_PREFIX.length);
            transform = escapedHashtags.transform;
        } else {
            transform = form.transformHashtags;
        }
        function bubble(hashtag) {
            return makeBubble(form, hashtag).prop('outerHTML');
        }
        return transform(text, bubble, true);
    }

    function unwrapBubbles(text, form, isExpression) {
        var el = xml.xhtml(text),
            places = {},
            bubbles = el.find('.label-datanode'),
            replacer, result, expr;
        if (!bubbles.length) {
            return el.text();
        }
        if (isExpression) {
            replacer = function () {
                var id = util.get_guid();
                places[id] = $(this).data("value");
                return "{" + id + "}";
            };
        } else {
            replacer = function () {
                return applyFormats($(this).data());
            };
        }
        bubbles.replaceWith(replacer);
        result = el.text();
        if (isExpression) {
            expr = result.replace(/{(.+?)}([\w.\-]?)/g, function (match, id, after) {
                // `after` is a character following {id} that would fuse with
                // the bubble expression if we did not put a space between them
                return places.hasOwnProperty(id) ?
                    places[id] + (after ? " " + after : "") : match;
            });
            try {
                form.xpath.parse(expr);
            } catch (e) {
                expr = INVALID_PREFIX + escapedHashtags.escapeDelimiters(result)
                    .replace(/{(.+?)}/g, function (match, id) {
                        return places.hasOwnProperty(id) ?
                            escapedHashtags.delimit(places[id]) : match;
                    });
            }
            result = expr;
        }
        return result;
    }

    /**
     * Check for escaped invalid hashtag expression
     */
    function isInvalid(value) {
        return value.startsWith(INVALID_PREFIX);
    }

    /**
     * Convert escaped hashtag expression to xpath
     *
     * @return - unescaped expression with hashtags converted to
     *      equivalent xpath if the given value is marked with the
     *      invalid xpath prefix, otherwise the given value
     */
    function unescapeXPath(value, form) {
        if (isInvalid(value)) {
            value = escapedHashtags.transform(
                value.slice(INVALID_PREFIX.length),
                form.normalizeXPath.bind(form)
            );
        }
        return value;
    }

    /**
     * Convert plain text to HTML to be edited in CKEditor
     *
     * Replace line breaks with <p> tags and preserve contiguous spaces.
     */
    function toHtml(text) {
        text = text.replace(/\n/g, "</p><p>")
                   .replace(/  /g, " &nbsp;");
        return "<p>" + text + "</p>";
    }

    /**
     * Convert CKEditor HTML to plain text
     *
     * Replace <p> tags with newlines.
     */
    function fromHtml(html) {
        return html.replace(/<p>&nbsp;<\/p>/ig, "\n")
                   .replace(/<p>/ig,"")
                   .replace(/<\/p>/ig, "\n")
                   .replace(/<br \/>/ig, "\n")
                   .replace(/(&nbsp;|\xa0|\u2005)/ig, " ")
                   // While copying widgets with text, CKEditor adds these html elements
                   .replace(/<span\b[^>]*?id="?cke_bm_\d+\w"?\b[^>]*?>.*?<\/span>/ig, "")
                   .replace(/<span\b[^>]*?data-cke-copybin-(start|end)[^<]*?<\/span>/ig, "")
                   // CKEditor uses zero-width spaces as markers
                   // and sometimes they leak out (on copy/paste?)
                   .replace(/\u200b+/ig, " ")
                   // fixup final </p>, which is is not a newline
                   .replace(/\n$/, "");
    }

    /**
     * Takes a value from xml and replaces xpaths with bubbles to display in the
     * editor
     *
     * @param options - An object containing options for the conversion:
     *      - isExpression - Convert all top-level path elements to bubbles
     *          if true; otherwise convert <output ... /> elements to bubbles.
     * @returns - html string to be displayed in editor
     */
    function toRichText(text, form, options) {
        if (!text) {return "";}
        options = options || {};
        var bubble = options.isExpression ? bubbleExpression : bubbleOutputs;
        return toHtml(bubble(text, form));
    }

    /**
     * Deconstructs html strings that have bubbles in them
     * This should preserve whitespace as it appears in the editor
     *
     * Dependent on CKEditor, which uses p and &nbsp; to format content
     *
     * Expects the html to only be at most two levels deep (considering a
     * bubble span as one level):
     *   <p>
     *     <br />
     *     <span /> (info)
     *   </p>
     *
     * @param html - HTML string that may or may not have bubble
     * @returns - string with bubbles deconstructed into plain text
     */
    function fromRichText(html, form, isExpression) {
        return unwrapBubbles(fromHtml(html), form, isExpression);
    }

    /**
     * @param output - jQuery <output ...> element
     * @returns - object with value and maybe data-date-format
     */
    function extractXPathInfo(output) {
        var value = output.xmlAttr('vellum:value') ||
                output.xmlAttr('value') ||
                output.xmlAttr('ref'),
            dateMatch = /^format-date\(date\(([^)]+)\),\s*'([^']+)'\)$/.exec(value);
        if (dateMatch) {
            return {value: dateMatch[1], 'data-date-format': dateMatch[2]};
        }
        return {value: value};
    }

    var DATE_FORMATS = {
        // See format-date(date value, string format) at:
        // http://dimagi.github.io/xform-spec/#xpath-functions
        Y: "yyyy",  // 4-digit year
        y: "yy",    // 2-digit year
        m: "mm",    // 0-padded month
        n: "m",     // numeric month
        b: "mmm",   // short text month (Jan, Feb, etc)
        d: "dd",    // 0-padded day of month
        e: "d",     // day of month
        H: "HH",    // 0-padded hour (24-hr time)
        h: "H",     // hour (24-hr time)
        M: "MM",    // 0-padded minute
        S: "SS",    // 0-padded second
        3: "msec",  // 0-padded millisecond ticks
        a: "ddd",   // short text day (Sun, Mon, etc)
    };

    function getHumanReadableDateFormat(format) {
        // ""               -> "no format"
        // "%e/%n/%y"       -> "d/m/yy"
        // "%a, %b %e, %Y"  -> "ddd, mmm d, yyyy"
        if (!format) {
            return gettext("no formatting");
        }
        return format.replace(/(%[YymnbdeHhMS3a])/g, function (match, fmt) {
            return DATE_FORMATS.hasOwnProperty(fmt[1]) ? DATE_FORMATS[fmt[1]] : fmt;
        });
    }

    function createPopover(editor, ckwidget) {
        var $this = $(ckwidget.element.$),
            dragContainer = ckwidget.dragHandlerContainer;
        // Setup popover
        var xpath = $this.data('value'),
            getWidget = require('vellum/widgets').util.getWidget,
            // TODO find out why widget is sometimes null (tests only?)
            widget = getWidget($this);
        if (widget) {
            var isFormRef = FORM_REF_REGEX.test(xpath),
                isText = function () { return this.nodeType === 3; },
                displayId = $this.contents().filter(isText)[0].nodeValue,
                hashtag = widget.mug.form.normalizeHashtag(xpath),
                title = util.escape(hashtag),
                labelMug = widget.mug.form.getMugByPath(xpath),
                description = labelMug && labelMug.p.labelItext ?
                            labelMug.p.labelItext.get() : "",
                isDate = labelMug && labelMug.__className.indexOf("Date") === 0,
                $dragContainer = $(dragContainer.$),
                $imgs = $dragContainer.children("img"),
                dateFormatID = util.get_guid(),
                getTitle = function () {
                    var title_ = title,
                        format = $this.attr("data-date-format");
                    if (isDate || format) {
                        title_ += date_format_popover({
                            guid: dateFormatID,
                            text: util.escape(getHumanReadableDateFormat(format)),
                        });
                    }
                    return '<h3>' + util.escape(displayId) + '</h3>' +
                        '<div class="text-muted">' + title_ + '</div>';
                };
            if (!labelMug) {
                var datasources = widget.mug.form.vellum.datasources;
                description = datasources.getNode(hashtag, {}).description || "";
            }
            description = xml.xhtml(description);
            description.find('output').replaceWith(function () {
                var xpath = extractXPathInfo($(this)).value;
                return widget.mug.form.normalizeHashtag(xpath);
            });
            description = xml.normalize(description);

            // Remove ckeditor-supplied title attributes, which will otherwise override popover title
            $imgs.removeAttr("title");

            $imgs.popover({
                trigger: 'hover',
                container: 'body',
                placement: 'bottom',
                title: getTitle,
                html: true,
                sanitize: false,  // bootstrap, don't remove data-ufid attribute
                content: easy_reference_popover({
                    text: description,
                    ufid: labelMug ? labelMug.ufid : "",
                }),
                template: '<div contenteditable="false" class="popover rich-text-popover">' +
                    '<div class="popover-inner">' +
                    '<div class="popover-title"></div>' +
                    (labelMug || description ?
                        '<div class="popover-content"><p></p></div>' : '') +
                    '</div></div>',
                delay: {
                    show: 350,  // be less annoying
                    hide: 200,  // allow time for user to move cursor into popover
                },
            }).on('shown.bs.popover', function() {
                var type = isFormRef ? 'form' : 'case';
                analytics.fbUsage("Hovered over easy " + type + " reference");
                analytics.workflow("Hovered over easy reference");
                if (isDate || $this.attr("data-date-format")) {
                    var pos = $(this).offset(),
                        x = pos.left,
                        y = pos.top + $(this).height();
                    $("#" + dateFormatID).click(function () {
                        $imgs.popover('hide');
                        dateformats.showMenu(x, y, function (format) {
                            $this.attr("data-date-format", format);
                            editor.fire("saveSnapshot");
                        }, true);
                        return false;
                    });
                }
            });

            ckwidget.on('destroy', function (e)  {
                try {
                    $imgs.popover('destroy');
                } catch(err) {
                    // sometimes these are already destroyed
                }
            });
        }
    }

    return {
        applyFormats: applyFormats,
        bubbleOutputs: bubbleOutputs,
        sanitizeInput: sanitizeInput,
        editor: editor,
        fromRichText: fromRichText,
        toRichText: toRichText,
        isInvalid: isInvalid,
        unescapeXPath: unescapeXPath,
    };
});


define('tpl/tpl!vellum/templates/atwho_display', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li>\n  <i class="'+
((__t=( icon ))==null?'':__t)+
'" /> '+
((__t=( displayPath ))==null?'':__t)+
'\n    ';
 if (displayLabel) { 
__p+='\n      <br />\n      <span class="atwho-jrtext">'+
((__t=( displayLabel ))==null?'':__t)+
'</span>\n    ';
 } 
__p+='\n</li>,\n';
}
return __p;
}; });

define('vellum/atwho',[
    'underscore',
    'jquery',
    'vellum/richText',
    'vellum/hqAnalytics',
    'vellum/util',
    'tpl!vellum/templates/atwho_display',
    'vellum/core',
], function (
    _,
    $,
    richText,
    analytics,
    util,
    atwhoDisplay
) {
    var that = {};

    /**
     * Add autocomplete to the given input.
     *
     * Does nothing if the atwho plugin is not enabled.
     *
     * @param $input - jQuery object, the input to modify
     * @param mug - current mug
     * @param options - Options object. If "choices" are present add a
     *      "dropdown" autocmoplete with the given choices. Otherwise
     *      add "question" autocomplete.
     */
    that.autocomplete = function ($input, mug, options) {
        if (!mug.form.vellum.data.atwho) {
            // do nothing if plugin is not enabled
            return;
        }
        if (options && options.choices) {
           that._dropdownAutocomplete($input, options.choices);
        } else {
            that._questionAutocomplete($input, mug, options);
        }
        mug.on("teardown-mug-properties", function () {
            if ($input.data('atwho')) {
                $input.atwho('destroy');
            }
        }, null, "teardown-mug-properties");
    };

    /**
     * Turn a given input into an autocomplete, which will be populated
     * with a given set of choices and will also accept free text.
     *
     * @param $input - jQuery object, the input to turn into an autocomplete
     * @param choices - An array of strings with which to populate the autocomplete
     */
    that._dropdownAutocomplete = function ($input, choices) {
        var options = {
            at: "",
            data: choices,
            maxLen: Infinity,
            suffix: "",
            tabSelectsMatch: false,
            callbacks: {
                filter: function(query, data, searchKey) {
                    return _.filter(data, function(item) {
                        return item.name.indexOf(query) !== -1;
                    });
                },
                matcher: function(flag, subtext, should_startWithSpace) {
                    return $input.val();
                },
                beforeInsert: function(value, $li) {
                    $input.data("selected-value", value);
                },
            }
        };

        $input.one('focus', function () {
            $input.atwho(options).on("inserted.atwho", function(event, $li, otherEvent) {
                $(this).find('.atwho-inserted').children().unwrap();
                if ($input.attr("contenteditable")) {
                    richText.editor($input)
                        .setValue($input.data("selected-value"))
                        .change();
                } else {
                    $input.val($input.data("selected-value")).change();
                }
            });
        });
    };

    /**
     * Alter a given input so that when a user enters the string "/data/",
     * they get an autocomplete of all questions in the form.
     *
     * @param $input - jQuery object, the input to modify
     * @param mug - current mug
     * @param options - Hash of options for autocomplete behavior:
     *                  insertTpl: string to add to input when question is selected
     *                  property: sent to analytics
     *                  useRichText: use rich text editor insert method
     *                  useHashtags: autocomplete hashtags (always on with useRichText)
     *                  outputValue: use output value in the template
     */
    that._questionAutocomplete = function ($input, mug, options) {
        options = _.defaults(options || {}, {
            insertTpl: '${name}',
            property: '',
            outputValue: false,
            useRichText: false,
            useHashtags: false,
            tabSelectsMatch: false,
            functionOverrides: {},
        });

        if (options.useRichText) {
            options.useHashtags = true;
            options.functionOverrides.insert = function(content, $li) {
                // this references internal At.js object
                this.query.el.remove();

                richText.editor($input).insertExpression(content);
                if (!this.$inputor.is(':focus')) {
                    this.$inputor.focus();
                }
            };
        }
        if (options.useHashtags) {
            options.insertTpl = '${hashtagPath}';
        }

        function addAtWhoToInput() {
            $input.one('focus', function () {
                $input.atwho(_atWhoOptions(mug.form.getBasePath(), mug, options));
                if (options.useHashtags) {
                    $input.atwho(_atWhoOptions('#', mug, options));
                }
            });
        }

        addAtWhoToInput();

        $input.on("inserted.atwho", function(event, $li, otherEvent) {
            $(this).find('.atwho-inserted').children().unwrap();
        });

        mug.form.on("change-display-language", function() {
            if ($input.data('atwho')) {
                $input.atwho('destroy');
                addAtWhoToInput();
            }
        });
    };

    function _atWhoOptions(atKey, mug, options) {
        var form = mug.form;

        return {
            at: atKey,
            displayTpl: atwhoDisplay,
            insertTpl: options.insertTpl,
            limit: 10,
            maxLen: 30,
            startWithSpace: false,
            tabSelectsMatch: options.tabSelectsMatch,
            callbacks: {
                matcher: function(flag, subtext) {
                    var match, regexp;
                    // Match text that starts with the flag and then looks like a path.
                    // CKEditor reserves the right to insert arbitrary zero-width spaces, so watch for those.
                    regexp = new RegExp('([\\s\u200b]+|^)' + RegExp.escape(flag) + '([\\w/-]*)$', 'gi');
                    match = regexp.exec(subtext);
                    return match ? match[2] : null;
                },
                filter: function (query, data, searchKey) {
                    // filters the mug that is currently selected
                    // and choice mugs/other mugs taht don't have
                    // absolute paths
                    function filterDropdown (list) {
                        return _.filter(list, function(mug_) {
                            return (mug.ufid !== mug_.id) &&
                                (mug_.name && !_.isUndefined(mug_.displayLabel));
                        });
                    }

                    if (!query) { return filterDropdown(form.fuse.list()); }
                    return filterDropdown(form.fuse.search(query));
                },
                sorter: function (query, items, searchKey) {
                    return _.map(items, function(item, idx) {
                        item.atwho_order = idx;
                        return item;
                    });
                },
                beforeInsert: function(value, $li) {
                    var category = util.getReferenceName(value);
                    analytics.usage(category, "Autocomplete", options.property);
                    return value;
                },
                afterMatchFailed: function(at, $el) {
                    if (options.useRichText && $el.html()) {
                        // If user typed out a full legitimate hashtag, or something that isn't
                        // legit but looks like a valid hashtag reference, turn it into a bubble.
                        var content = $el.html().trim().replace(/^.*\s/, ""),
                            shouldBubble = form.isValidHashtag(content) ||
                                           form.hasValidHashtagPrefix(content);

                        if (shouldBubble) {
                            options.functionOverrides.insert.call(this, content);
                        }

                        // After this callback, atwho will attempt to remove the query string and
                        // properly set cursor position. However, its logic breaks if we've already
                        // replaced the query with a bubble. Handle the removal and cursor logic
                        // ourselves, and return false from this function so the atwho logic doesn't run.
                        var node = this._unwrap($el.text($el.text()).contents().first());
                        if (!shouldBubble) {
                            this._setRange("after", node);
                        }
                    }

                    return false;
                },
            },
            functionOverrides: options.functionOverrides,
        };
    }

    $.vellum.plugin("atwho", {}, {});

    return that;
});

define('vellum/widgets',[
    'tpl!vellum/templates/ui_element',
    'tpl!vellum/templates/widget_control_keyvalue',
    'tpl!vellum/templates/widget_control_message',
    'underscore',
    'jquery',
    'vellum/atwho',
    'vellum/util',
    'vellum/richText',
    'vellum/hqAnalytics',
], function (
    ui_element,
    widget_control_keyvalue,
    widget_control_message,
    _,
    $,
    atwho,
    util,
    richTextUtils,
    analytics
) {
    var base = function(mug, options) {
        // set properties shared by all widgets
        var widget = {};
        options.richText = true;
        widget.options = options;
        widget.mug = mug;
        widget.id = options.id;
        util.eventuality(widget);

        widget.isDisabled = function () {
            // requires widget.path to be set.  This only happens in
            // normal.  Need to change widgets that inherit directly from
            // base to use the path/property system.
            if (!widget.path) {
                return false;
            }

            if (_.isFunction(mug.spec[widget.path].enabled)) {
                return !mug.spec[widget.path].enabled(mug);
            }

            return mug.form.vellum.isPropertyLocked(mug.hashtagPath,
                                                    widget.path);
        };

        widget.getDisplayName = function () {
            // use the display text, or the property name if none found
            return this.definition.lstring ? this.definition.lstring : this.path;
        };

        widget.getControl = function () {
            throw ("must be overridden");
        };

        widget.setValue = function (val) {
            // noop
        };

        widget.getValue = function () {
            // noop
        };

        widget.getHelp = function () {
            if (this.definition && this.definition.help) {
                return {
                    text: this.definition.help,
                    url: this.definition.helpURL
                };
            }
            return null;
        };

        widget.refreshMessages = function () {
            // placeholder to be overridden by widgets that inherit from base
        };

        widget.handleChange = function () {
            widget.updateValue();
            mug.showChangedMsg = true;
            // TODO make all widgets that inherit from base set path
            if (widget.path) {
                // Widget change events, in addition to mug property
                // setters, trigger mug validation because some mug
                // property values have sub-properties that do not
                // trigger mug property change events when they are
                // changed. 
                mug.validate(widget.path);
            }
            widget.fire("change");
        };

        widget.updateValue = function () {
            // When a widget's value changes, do whatever work you need to in 
            // the model/UI to make sure we are in a consistent state.
            widget.save();
        };

        widget.save = function () {
            throw 'Not Implemented';
        };

        widget.getUIElement = function () {
            return getUIElement(widget.getControl(), widget.getDisplayName(),
                                !!widget.isDisabled(), widget.getHelp());
        };

        widget.addInstanceRef = function (attrs, property) {
            if (!property) {
                property = widget.path;
                if (!property) {
                    throw new Error("widget has no path: " + widget);
                }
            }
            return mug.form.addInstanceIfNotExists(attrs, mug, property);
        };

        return widget;
    };

    var normal = function(mug, options) {
        var path = options.widgetValuePath || options.path,
            inputID = options.id || 'property-' + path,
            disabled = options.disabled || false,
            widget = base(mug, options);

        widget.mugValue = options.mugValue || function (mug, value) {
            if (arguments.length === 1) {
                return mug.p[path];
            }
            mug.p[path] = value;
        };

        widget.path = path;
        widget.definition = mug.p.getDefinition(options.path);
        widget.currentValue = widget.mugValue(mug);
        widget.id = inputID;
        widget.saving = false;

        widget.input = $("<input />")
            .attr("name", inputID)
            .attr("id", inputID)
            .prop('disabled', disabled);

        widget.getControl = function () {
            return widget.input; 
        };

        widget.getMessagesContainer = function () {
            return widget.getControl()
                    .closest(".widget")
                    .find(".messages:last");
        };

        widget.getMessages = function (mug, path) {
            return getMessages(mug, path);
        };

        widget.refreshMessages = function () {
            var messages = widget.getMessages(mug, path);
            var $container = widget.getMessagesContainer();
            $container.empty();
            if (messages.length) {
                $container.append(messages);
                $container.removeClass("hide");
            } else {
                $container.addClass("hide");
            }
        };

        mug.on("messages-changed",
               function () { widget.refreshMessages(); }, null, "teardown-mug-properties");

        widget.save = function () {
            widget.saving = true;
            try {
                widget.mugValue(mug, widget.getValue());
            } finally {
                widget.saving = false;
            }
        };

        return widget;
    };

    var text = function (mug, options) {
        var widget = normal(mug, options),
            input = widget.input;
        input.attr("type", "text").addClass('form-control');

        if (options.placeholder) {
            input.attr('placeholder', options.placeholder);
        }

        if (util.isRightToLeftLanguage(options.language)) {
            input.attr('dir', 'rtl');
        }

        widget.setValue = function (value) {
            if (value) {
                // <input> converts newlines to spaces; this preserves them
                value = value.replace(/\n/g, '&#10;');
            }

            var position = util.getCaretPosition(input[0]);
            var oldvalue = input.val();
            if (value && widget.hasLogicReferences) {
                input.val(mug.form.normalizeXPath(value));
            } else {
                input.val(value);
            }

            // If this input has focus and value hasn't changed much,
            // keep the cursor in the same position
            if (input.is(":focus") && oldvalue.length === value.length) {
                util.setCaretPosition(input[0], position, position);
            }
        };

        widget.getValue = function() {
            var ret = input.val().replace(/&#10;/g, '\n');

            if (ret && widget.hasLogicReferences) {
                // TODO should not be using hashtags when rich text is off
                return mug.form.normalizeHashtag(ret);
            } else {
                return ret;
            }
        };

        input.on("change input", function () {
            widget.handleChange();
        });
        return widget;
    };

    var multilineText = function (mug, options) {
        var widget = normal(mug, options);

        widget.input = $("<textarea></textarea>")
            .attr("name", widget.id)
            .attr("id", widget.id)
            .attr("rows", "2")
            .addClass('form-control')
            .on('change input', function (e) { widget.handleChange(); })
            .keyup(function (e) {
                // workaround for webkit: http://stackoverflow.com/a/12114908
                if (e.which === 9) {
                    this.select();
                }
            });

        if (util.isRightToLeftLanguage(options.language)) {
            widget.input.attr('dir', 'rtl');
        }

        widget.getControl = function () { 
            return widget.input;
        };

        widget.setValue = function (val) {
            widget.input.val(val);
        };

        widget.getValue = function () {
            return widget.input.val();
        };

        return widget;
    };

    var richText = function(mug, options) {
        var widget = normal(mug, options);

        widget.input = $("<div />")
            .attr("contenteditable", true)
            .attr("name", widget.id)
            .addClass('form-control jstree-drop')
            .addClass(options.singleLine ? 'fd-input' : 'fd-textarea');

        var opts = {
                isExpression: options.widget === xPath || options.widget === droppableText,
                disableNativeSpellChecker: options.disableNativeSpellChecker,
                rtl: util.isRightToLeftLanguage(options.language),
            },
            editor = richTextUtils.editor(widget.input, mug.form, opts);

        mug.on('teardown-mug-properties', editor.destroy, null, "teardown-mug-properties");
        editor.on('change', function () { widget.handleChange(); });

        widget.input.on('inserted.atwho', function(atwhoEvent, $li, browserEvent) {
            // gets rid of atwho wrapper
            // tod: find out why this is needed and move elsewhere
            $(this).find('.atwho-inserted').children().unwrap();
        });

        widget.getControl = function () {
            return widget.input;
        };

        widget.setValue = editor.setValue;
        widget.getValue = editor.getValue;

        return widget;
    };

    var richInput = function(mug, options) {
        if (mug.form.richText) {
            options.singleLine = true;
            return richText(mug, options);
        } else {
            return text(mug, options);
        }
    };

    var richTextarea = function(mug, options) {
        if (mug.form.richText) {
            options.singleLine = false;
            return richText(mug, options);
        } else {
            return multilineText(mug, options);
        }
    };

    var identifier = function (mug, options) {
        var widget = text(mug, options),
            super_updateValue = widget.updateValue,
            super_handleChange = widget.handleChange;

        function updatePlaceholder() {
            // If the user doesn't provide an ID, we're going to
            // auto-generate it (eventually). Show the user what it will be.
            var proposedId = mug.form.vellum.nodeIDFromLabel(mug);
            widget.input.attr("placeholder", proposedId);
        }

        widget.updateValue = function () {
            var val = widget.getValue();

            if (val.indexOf(' ') !== -1) {
                // attempt to sanitize nodeID and choice values
                // TODO, still may allow some bad values
                widget.setValue(val.replace(/\s/g, '_'));
            }

            if (val === "") {
                updatePlaceholder();
            }

            super_updateValue();
        };

        widget._setURLHash = _.debounce(function(mug) {
            mug.form.vellum._setURLHash(mug);
        }, 500);

        widget.handleChange = function () {
            super_handleChange();
            widget._setURLHash(mug);            
            if (!mug.p.nodeID) {
                // HACK drop errors; nodeID will be set automatically on save
                mug.dropMessage("nodeID", "mug-nodeID-error");
            }
        };

        mug.on("property-changed", function (e) {
            if (e.property === "conflictedNodeId" && !widget.saving) {
                widget.setValue(widget.mugValue(mug));
            }
        }, null, "teardown-mug-properties");

        mug.form.on('question-label-text-change', function (e) {
            if (!mug.p.nodeID) {
                updatePlaceholder();
            }
        }, null, null, widget);

        mug.on("teardown-mug-properties", function () {
            mug.form.unbind(widget);
        }, null, "teardown-mug-properties");

        return widget;
    };

    var droppableText = function (mug, options) {
        var widget = richInput(mug, options);
        widget.input.addClass('jstree-drop')
            .attr('placeholder', 'Drag question here')
            .change(function () {
                widget.handleChange();
            });

        widget.hasLogicReferences = true;

        return widget;
    };
    droppableText.trackLogicReferences = true;

    var checkbox = function (mug, options) {
        var widget = normal(mug, options),
            input = widget.input;
        input.attr("type", "checkbox");

        widget.setValue = function (value) {
            input.prop("checked", value);
        };

        widget.getValue = function() {
            return input.prop("checked");
        };

        input.change(function () {
            widget.handleChange();
        });
        return widget;
    };

    var xPath = function (mug, options) {
        options.disableNativeSpellChecker = true;
        var widget = richInput(mug, options),
            super_getValue = widget.getValue,
            super_setValue = widget.setValue;

        widget.getValue = function() {
            return $.trim(super_getValue());
        };

        widget.getUIElement = function () {
            var control = widget.getControl(),
                elem = getUIElement(
                    control,
                    widget.getDisplayName(),
                    !!widget.isDisabled(),
                    widget.getHelp()
                ),
                autocompleteChoices;
            control.addClass('jstree-drop');
            if (options.autocompleteChoices) {
                autocompleteChoices = function () {
                    return options.autocompleteChoices(mug);
                };
            }
            return getUIElementWithEditButton(elem, function () {
                widget.options.displayXPathEditor({
                    leftPlaceholder: options.leftPlaceholder,
                    rightPlaceholder: options.rightPlaceholder,
                    leftAutocompleteChoices: autocompleteChoices,
                    value: super_getValue(),
                    xpathType: widget.definition.xpathType,
                    onLoad: function ($ui) {
                        setWidget($ui, widget);
                        $ui.find(".property-name").text(options.lstring || "Expression");
                    },
                    done: function (val) {
                        if (val !== false) {
                            super_setValue(val);
                            widget.handleChange();
                        }
                    },
                    mug: mug,
                });
                analytics.fbUsage('Logic', options.lstring);
            }, !!widget.isDisabled());
        };

        atwho.autocomplete(widget.input, mug, {
            property: options.path,
            useRichText: mug.form.richText,
        });

        widget.hasLogicReferences = true;

        return widget;
    };
    xPath.trackLogicReferences = true;

    var baseKeyValue = function (mug, options) {
        // todo: make this inherit from normal
        var widget = base(mug, options),
            path = options.widgetValuePath || options.path,
            id = options.id || 'property-' + path;
        widget.definition = mug.p.getDefinition(options.path);
        options.richText = false;

        widget.mugValue = options.mugValue || function (mug, value) {
            if (arguments.length === 1) {
                return mug.p[path];
            }
            mug.p[path] = value;
        };

        widget.currentValue = widget.mugValue(mug);

        // todo make a style for this when vellum gets a facelift
        widget.kvInput = $('<div class="control-row" />').attr('name', id);

        widget.getControl = function () {
            if (widget.isDisabled()) {
                // todo
            }
            return widget.kvInput;
        };

        widget.setValue = function (value) {
            widget.kvInput.html(widget_control_keyvalue({
                pairs: _.clone(value)
            }));
            widget.kvInput.find('input').on('change keyup', function () {
                widget.handleChange();
            });
            widget.kvInput.find('.fd-kv-add-pair').click(function (e) {
                widget.refreshControl();
                e.preventDefault();
            });
            widget.kvInput.find('.fd-kv-remove-pair').click(function (e) {
                $(this).parent().parent().remove();
                widget.refreshControl();
                widget.save();
                e.preventDefault();
            });
        };

        function getValues() {
            var currentValues = {};
            _.each(widget.kvInput.find('.fd-kv-pair'), function (kvPair) {
                var $pair = $(kvPair),
                    key = $pair.find('.fd-kv-key').val(),
                    value = $pair.find('.fd-kv-val').val();
                if (currentValues.hasOwnProperty(key)) {
                    if (_.isArray(currentValues[key])) {
                        currentValues[key].push(value);
                    } else {
                        currentValues[key] = [currentValues[key], value];
                    }
                } else {
                    currentValues[key] = value;
                }
            });
            return currentValues;
        }

        widget.getValue = function() {
            return _.omit(getValues(), "");
        };

        widget.updateValue = function () {
            if (!getValues().hasOwnProperty("")) {
                widget.kvInput.find('.btn').removeClass('hide');
                widget.kvInput.find('.fd-kv-remove-pair').removeClass('hide');
            }
            widget.save();
        };

        widget.refreshControl = function () {
            widget.setValue(widget.getValue());
        };

        widget.save = function () {
            widget.saving = true;
            try {
                widget.mugValue(mug, widget.getValue());
            } finally {
                widget.saving = false;
            }
        };

        return widget;
    };

    var dropdown = function (mug, options) {
        var widget = normal(mug, options);
        widget.dropdown = widget.input = $("<select />")
            .attr("name", widget.id)
            .addClass('form-control');

        var input = widget.input;

        widget.setValue = function (value) {
            var val = widget.equivalentOption(value);
            if (val) {
                input.val(val.value);
            } else if (options.noCustom) {
                input.prop('selectedIndex', -1);
            } else {
                widget.addCustomIfNeeded(value);
                input.val(value);
            }
        };

        widget.getValue = function () {
            return input.val();
        };

        widget.updateValue = function () {
            widget.save();
        };

        input.change(function () {
            widget.handleChange();
        });

        widget.addOption = function (value, text) {
            var option = $('<option />')
                .attr('value', value)
                .text(text);
            this.dropdown.append(option);
        };

        widget.addOptions = function (options) {
            var _this = this;
            _.forEach(options, function(option) {
                _this.addOption(option.value, option.text);
            });
        };

        widget.clearOptions = function () {
            this.dropdown.empty();
        };

        widget.getOptions = function () {
            return _.map(widget.dropdown.find('option'), function(option) {
                return {
                    value: option.value,
                    text: option.text
                };
            });
        };

        widget.equivalentOption = function (val) {
            function parseValue (val) {
                try {
                    return JSON.parse(val);
                } catch(err) {
                    return  val;
                }
            }

            val = parseValue(val);
            return _.find(widget.getOptions(), function (option) {
                return _.isEqual(parseValue(option.value), val);
            });
        };

        widget.addCustomIfNeeded = function (value) {
            var customOption = $('[name=property-androidIntentAppId]')
                .find('option')
                .filter(function () { return $(this).text() === gettext("Custom"); });
            if (customOption.length === 0) {
                widget.addOption(value, gettext("Custom"));
            } else {
                customOption.val(value);
            }
        };

        if (options.defaultOptions) {
            widget.addOptions(options.defaultOptions);
        }

        return widget;
    };

    var dropdownWithInput = function (mug, options) {
        var widget = dropdown(mug, options),
            super_handleChange = widget.handleChange;
        widget.input = widget.text = $('<input />')
            .addClass('form-control')
            .attr({
                type: 'text',
                name: widget.id + '-text',
            });

        var control = $('<div class="control-row row">')
                .append($("<div class='col-sm-4'>").append(widget.dropdown))
                .append($("<div class='col-sm-8'>").append(widget.text));

        widget.setValue = function (value) {
            var val = widget.equivalentOption(value);
            widget.addCustomIfNeeded(value);
            if (val) {
                widget.dropdown.val(val.value);
                widget.text.attr('readonly', true);
                widget.text.val(val.value);
            }  else {
                widget.dropdown.val(value);
                widget.text.attr('readonly', false);
                widget.text.val(value);
            }
        };

        widget.getValue = function () {
            return widget.text.val();
        };

        widget.getControl = function () {
            return control;
        };

        widget.dropdown.change(function () {
            var selectedOption = widget.dropdown.find(':selected');
            widget.text.attr('readonly', selectedOption.text() !== gettext("Custom"));
            widget.text.val(selectedOption.val());
            super_handleChange();
        });

        widget.text.change(function () {
            var selectedOption = widget.dropdown.find(':selected');
            widget.text.attr('readonly', false);
            selectedOption.val(widget.text.val());
            super_handleChange();
        });

        return widget;
    };

    var readOnlyControl = function (mug, options) {
        options.id = "readonly-control";
        var widget = base(mug, options);
        widget.definition = {};
        widget.currentValue = $('<div>').append(mug.p.rawControlXML).clone().html();

        widget.getControl = function () {
            var control = $("<p />").text(this.currentValue);
            return control;
        };

        return widget;
    };

    var abstractMediaWidget = function (mug, options) {
        var widget = normal(mug, options);
        widget.form = "text";

        widget.getValue = function() {
            return widget.input.val();
        };

        widget.setValue = function(val) {
            return widget.input.val(val);
        };

        /**
         * Get media path without file type extension
         *
         * Example: jr://file/commcare/text/name
         *
         * This is an abstract method; it must be overridden.
         */
        widget.getBaseMediaPath = function () {
            throw new Error("abstract method not implemented: " +
                            "widget.getBaseMediaPath()");
        };

        widget.mug.form.vellum.initMediaUploaderWidget(widget);
        return widget;
    };

    var getUIElementWithEditButton = function($uiElem, editFn, isDisabled) {
        var input = $uiElem.find('input');
        if (_.isUndefined(isDisabled)) {
            isDisabled = input ? input.prop('disabled') : false;
        }

        var button = $('<button />')
            .addClass("fd-edit-button")
            .html("<i class='fa fa-edit'></i>")
            .stopLink()
            .addClass('btn btn-default btn-block')
            .attr('type', 'button')
            .prop('disabled', isDisabled)
            .click(editFn),
            buttonContainer = $("<div />")
            .addClass("col-sm-1")
            .append(button);

        $uiElem.css('position', 'relative');
        $uiElem.find('.controls')
            .removeClass("col-sm-9").addClass("col-sm-8")
            .after(buttonContainer);
        return $uiElem;
    };
    
    var getUIElement = function($input, labelText, isDisabled, help) {
        var $uiElem = $(ui_element({
            labelText: labelText,
            help: help,
        }));

        // Disable anything that can be disabled
        $input.find("*").addBack().prop('disabled', !!isDisabled);

        $uiElem.find(".controls").prepend($input);

        if (help && !help.url) {
            $uiElem.find(".fd-help a").click(function (e) { e.preventDefault(); });
        }

        return $uiElem;
    };

    function getMessages(mug, path) {
        var $messages = $(),
            seen = {};
        mug.messages.each(path, function (msg) {
            if (seen.hasOwnProperty(msg.message)) { return; }
            seen[msg.message] = true;
            var html = $(widget_control_message({
                    msg: msg,
                    html: /\n/.test(msg.message) ?
                            util.markdown(msg.message) : ""
                }));
            html.find("button.close").click(function () {
                mug.dropMessage(path, msg.key);
                if (msg.key === "mug-nodeID-changed-warning") {
                    mug.showChangedMsg = false;
                }
            });
            $messages = $messages.add(html);
        });
        return $messages;
    }

    function getWidget(input, vellum) {
        var obj = input,
            widget;
        while (obj && obj.length) {
            widget = obj.data("vellum_widget");
            if (widget && (!vellum || vellum === obj.vellum("get"))) {
                return widget;
            }
            obj = obj.parent();
        }
        return null;
    }

    function setWidget($el, widget) {
        $el.data("vellum_widget", widget);
        return $el;
    }

    return {
        base: base,
        normal: normal,
        text: text,
        multilineText: multilineText,
        richTextarea: richTextarea,
        identifier: identifier,
        droppableText: droppableText,
        checkbox: checkbox,
        dropdown: dropdown,
        dropdownWithInput: dropdownWithInput,
        xPath: xPath,
        baseKeyValue: baseKeyValue,
        readOnlyControl: readOnlyControl,
        abstractMediaWidget: abstractMediaWidget,
        util: {
            getWidget: getWidget,
            setWidget: setWidget,
            getMessages: getMessages,
            getUIElementWithEditButton: getUIElementWithEditButton,
            getUIElement: getUIElement
        }
    };
});

/**
 * A mug is a question, containing data, bind, and control elements.
 *
 * Main Properties
 *  nodeID
 *  label
 *  readOnlyControl
 *  imageSize: Images only. Options to reduce image size before sending form.
 *
 * Data Source Properties
 *
 * Media Properties
 *  mediaItext: Multimedia (image, audio, video, inline video) attached to the question.
 *
 * Logic Properties
 *  calculateAttr: Hidden questions only. The calculation that generates the question's value.
 *  requiredAttr: Boolean. Whether or not user must enter a value for the question.
 *  relevantAttr: Boolean expression that determines whether or not to display a question to the end user.
 *  constraintAttr: Boolean expression that, if false, will prevent the user from proceeding past the question.
 *  repeat_count: Repeat groups only. An integer expression that determines the number of groups to generate.
 *
 * Advanced Properties
 *  dataSource
 *  dataValue: Deprecated.
 *  defaultValue: An expression that will be assigned to a question before/until a user changes the value.
 *  xmlnsAttr
 *  label
 *  hintLabel
 *  constraintMsgAttr: Message to display if question fails validation (constraintAttr evaluates to false).
 *  dataParent
 *  appearance
 *  comment: User-entered comment to help other users understand the purpose or implementation of the question.
 */
define('vellum/mugs',[
    'jquery',
    'underscore',
    'vellum/tree',
    'vellum/widgets',
    'vellum/logic',
    'vellum/util',
], function (
    $,
    _,
    Tree,
    widgets,
    logic,
    util
) {
    function Mug(options, form, baseSpec, attrs) {
        var properties = null;
        util.eventuality(this);

        if (attrs) {
            properties = _.object(_.map(attrs, function (val, key) {
                if (val && typeof val === "object") {
                    // avoid potential duplicate references (e.g., itext items)
                    if ($.isPlainObject(val)) {
                        val = _.clone(val);
                    } else {
                        // All non-plain objects must provide a clone method,
                        // otherwise there could be circular references.  It can
                        // simply return the same object if it's safe.
                        // This is not really fleshed out.
                        val = val.clone();
                    }
                }
                return [key, val];
            }));
        }

        this.ufid = util.get_guid();
        this.form = form;
        this.messages = new MugMessages();
        this._baseSpec = baseSpec;
        this.setOptionsAndProperties(options, properties);
    }
    Mug.prototype = {
        // set or change question type
        setOptionsAndProperties: function (options, properties) {
            var _this = this,
                currentAttrs = properties || (this.p && this.p.getAttrs()) || {};

            // These could both be calculated once for each type instead of
            // each instance.
            this.logicReferenceAttrs = [];
            this.options = util.extend(defaultOptions, options);
            this.__className = this.options.__className;
            this.showChangedMsg = true;
            this.spec = copyAndProcessSpec(this._baseSpec, this.options.spec, this.options);

            // Reset any properties that are part of the question type
            // definition.
            _.each(this.spec, function (spec, name) {
                if (spec.deleteOnCopy) {
                    delete currentAttrs[name];
                }
                var allowed = _this.getPresence(name) !== 'notallowed';
                if (allowed && spec.widget && spec.widget.trackLogicReferences) {
                    _this.logicReferenceAttrs.push(name);
                }
            });

            this.p = new MugProperties({
                spec: this.spec,
                mug: this,
            });
            this.options.init(this, this.form);
            this.p.setAttrs(currentAttrs);
            this.p.shouldChange = this.form.shouldMugPropertyChange.bind(this.form);
        },
        getAppearanceAttribute: function () {
            return this.options.getAppearanceAttribute(this);
        },
        getIcon: function () {
            return this.options.getIcon(this);
        },
        /**
         * Validate mug
         *
         * This method may fire a "messages-changed" event.
         *
         * @param attr - The property to validate. All properties will
         *      be validated if this argument is omitted.
         * @returns - True if validation messages changed else false.
         */
        validate: function (attr) {
            var mug = this;

            util.checkForFormSubmissions(mug.form);

            return this._withMessages(function () {
                var changed = false;
                mug.form.updateLogicReferences(mug, attr);
                if (attr) {
                    changed = mug._validate(attr);
                } else {
                    _.each(_.keys(mug.p.__data), function (attr) {
                        changed = mug._validate(attr) || changed;
                    });
                }
                return changed;
            });
        },
        _validate: function (attr) {
            var mug = this,
                spec = mug.spec[attr];
            if (!spec) {
                // should throw error?
                window.console.log("unexpected property: " + attr);
                return false;
            }
            var value = mug.p[attr],
                presence = mug.getPresence(attr),
                label = spec.lstring || attr,
                message = "";

            // TODO use data.hasOwnProperty(attr) rather than !value?
            if (!value && presence === 'required') {
                // can the user always fix this error?
                message = gettext('{question} is required.');
            } else if (value && presence === 'notallowed') {
                // can the user always fix this error?
                message = gettext('{question} is not allowed.');
            } else if (spec.validationFunc) {
                try {
                    message = spec.validationFunc(mug);
                } catch (err) {
                    // this should never happen
                    message = gettext("{question} validation failed") +
                        "\n" + util.formatExc(err);
                }
                if (message === "pass") {
                    message = "";
                }
            }

            return this.messages.update(attr, {
                key: "mug-" + attr + "-error",
                level: this.ERROR,
                message: util.format(message || "", {question: label})
            });
        },
        // message levels
        ERROR: "error",
        WARNING: "warning",
        INFO: "info",
        /**
         * Add a message for a property. Returns true if mug changed.
         *
         * Adding a message object with the same key as an existing
         * message will replace the existing message.
         * See `MugMessages.update` for more about message objects.
         *
         * This method may fire a "messages-changed" event.
         *
         * @param attr - The property to which the message pertains.
         * @param msg - The message object. If omitted, all messages
         *          for the given property will be removed.
         */
        addMessage: function (attr, msg) {
            var messages = this.messages;
            return this._withMessages(function () {
                return messages.update(attr, msg);
            });
        },
        dropMessage: function (attr, key) {
            var spec = this.spec[attr];
            var changed = this.addMessage(attr, {key: key});
            if (spec && spec.dropMessage) {
                spec.dropMessage(this, attr, key);
            }
            return changed;
        },
        /**
         * Add many messages for many properties at once
         *
         * @param messages - An object mapping property names to lists
         *          of message objects.
         */
        addMessages: function (messages) {
            var mug = this;
            this._withMessages(function () {
                return _.reduce(messages, function (m1, list, attr) {
                    return _.reduce(list, function (m2, msg) {
                        return mug.messages.update(attr, msg) || m2;
                    }, false) || m1;
                }, false);
            });
        },
        _withMessages: function (func) {
            var unset = _.isUndefined(this._messagesChanged),
                changed = false;
            if (unset) {
                this._messagesChanged = false;
            }
            try {
                changed = func() || this._messagesChanged;
                if (changed) {
                    if (unset) {
                        this.fire({type: "messages-changed", mug: this});
                    } else {
                        this._messagesChanged = true;
                    }
                }
            } finally {
                if (unset) {
                    delete this._messagesChanged;
                }
            }
            return changed;
        },
        /**
         * Get a list of error and warning message strings
         */
        getErrors: function () {
            var errors = [];
            this.messages.each(function(msg) {
                if (msg.level !== "info") {
                    errors.push(msg.message);
                }
            });
            return _.uniq(errors);
        },
        hasErrors: function () {
            return this.getErrors().length !== 0;
        },
        /**
         * Get a list of form serialization warnings
         *
         * All warnings returned by this function should also be reported
         * by the normal mug validation process. Serialization warnings
         * can be ignored or fixed automatically, but the user may
         * prefer to fix them manually.
         *
         * @returns - A list of warning objects, each having a `message`
         * attribute describing the warning. This list can be passed to
         * `fixSerializationWarnings` to automatically fix the warnings.
         */
        getSerializationWarnings: function () {
            var warnings = [];
            this.messages.each(function (msg) {
                if (msg.fixSerializationWarning) {
                    warnings.push(msg);
                }
            });
            return warnings;
        },
        /**
         * Automatically fix serialization warnings
         *
         * No warnings should be reported by `getSerializationWarnings`
         * after calling this function with the list of warnings
         * returned by `getSerializationWarnings`.
         *
         * @param warnings - The list of warnings returned by
         *                 `getSerializationWarnings`.
         */
        fixSerializationWarnings: function (warnings) {
            var mug = this;
            _.each(warnings, function (warning) {
                warning.fixSerializationWarning(mug);
            });
        },
        /*
         * Gets the actual label, either from the control element or an empty
         * string if not found.
         */
        getLabelValue: function () {
            return this.p.label || "";
        },
        /**
         * deprecated
         */
        getNodeID: function () {
            return this.p.nodeID;
        },
        /**
         * Get property presence (does this mug have the given property)
         *
         * Valid spec presence values are:
         *  - 'required'
         *  - 'optional'
         *  - 'notallowed'
         *  - a function returning one of the above values.
         */
        getPresence: function (property) {
            var spec = this.spec[property];
            if (_.isUndefined(spec)) {
                throw new Error("unknown property: $1.spec.$2"
                    .replace("$1", this.__className)
                    .replace("$2", property));
            }
            if (_.isFunction(spec.presence)) {
                return spec.presence(this);
            }
            return spec.presence;
        },
        /**
         * Is the given property displayed with the mug's properties?
         *
         * Valid spec visibility values are:
         *  - 'visible'
         *  - 'visible_if_present'
         *  - 'hidden'
         *  - a function returning true (visible) or false (hidden)
         *  - the name of another property, which means the given property
         *    has the same visibility as the named property
         *
         * Properties with 'notallowed' presence are always hidden.
         */
        isVisible: function (property) {
            if (this.getPresence(property) === "notallowed") {
                // Suspect: prior to refactor, 'notallowed' presence translated
                // to hidden only if the property value was undefined,
                // meaning 'notallowed' was the same as 'visible_if_present'.
                // This comment can be removed when we find that nothing broke.
                return false;
            }
            var spec = this.spec[property],
                vis = spec.visibility;
            if (vis === "visible") {
                return true;
            }
            if (vis === "visible_if_present") {
                return !_.isUndefined(this.p[property]);
            }
            if (vis === "hidden") {
                return false;
            }
            if (_.isFunction(vis)) {
                return vis(this, spec);
            }
            if (this.spec.hasOwnProperty(vis)) {
                // Suspect: prior to refactor, dependent visibility did not
                // apply if the property had a value (i.e., was not undefined).
                // This comment can be removed when we find that nothing broke.
                return this.isVisible(vis);
            }
            throw new Error("unknown visibility: $1.spec.$2 = $3"
                .replace("$1", this.__className)
                .replace("$2", property)
                .replace("$3", String(vis)));
        },
        getDisplayName: function (lang, escape) {
            if (escape === undefined) { escape = true; }
            var itextItem = this.p.labelItext,
                Itext = this.form.vellum.data.javaRosa.Itext,
                defaultLang = Itext.getDefaultLanguage(),
                disp,
                defaultDisp,
                nodeID = this.p.conflictedNodeId || this.p.nodeID;

            if (this.__className === "ReadOnly") {
                return gettext("Unknown (read-only) question type");
            }
            if (this.__className === "Itemset") {
                return gettext("Lookup Table Data");
            }

            if (!itextItem || lang === '_ids') {
                return nodeID;
            }
            lang = lang || defaultLang;

            if(!lang) {
                return gettext('No Translation Data');
            }

            defaultDisp = itextItem.get("default", defaultLang);
            disp = itextItem.get("default", lang) || defaultDisp;

            if (disp && disp !== nodeID) {
                if (lang !== defaultLang && disp === defaultDisp) {
                    disp += " [" + defaultLang + "]";
                }
                return escape ? $('<div>').text(disp).html() : disp;
            }

            return nodeID;
        },
        serialize: function () {
            var mug = this,
                data = {type: mug.__className};
            _.each(mug.spec, function (spec, key) {
                if (mug.getPresence(key) === "notallowed") {
                    return;
                }
                var value = mug.p[key];
                if (spec.serialize) {
                    value = spec.serialize(value, key, mug, data);
                    if (!_.isUndefined(value)) {
                        data[key] = value;
                    }
                } else if (value && !(_.isEmpty(value) &&
                                      (_.isObject(value) || _.isArray(value))
                          )) {
                    data[key] = value;
                }
            });
            return data;
        },
        /**
         * Deserialize mug property data
         *
         * @param data - An object containing mug property data.
         * @param context - Paste context.
         */
        deserialize: function (data, context) {
            var mug = this;
            _.each(mug.spec, function (spec, key) {
                if (mug.getPresence(key) !== 'notallowed') {
                    if (spec.deserialize) {
                        var value = spec.deserialize(data, key, mug, context);
                        if (!_.isUndefined(value)) {
                            mug.p[key] = value;
                        }
                    } else if (data.hasOwnProperty(key)) {
                        mug.p[key] = data[key];
                    }
                }
            });
        },
        teardownProperties: function () {
            this.fire({type: "teardown-mug-properties", mug: this});
        },
        isInRepeat: function() {
            if (this.__className === "Repeat") { // HACK hard-coded class name
                return true;
            }
            return this.parentMug && this.parentMug.isInRepeat();
        },
        /**
         * Check if mug is referenced by other mugs
         *
         * @param except - Array of mugs to exclude when looking for references.
         * @returns Boolean
         */
        isReferencedByOtherMugs: function (except) {
            return this.form.isReferencedByOtherMugs(this, except);
        },
    };

    Object.defineProperty(Mug.prototype, "absolutePath", {
        get: function () {
            return this.form.getAbsolutePath(this);
        }
    });

    Object.defineProperty(Mug.prototype, "absolutePathNoRoot", {
        get: function () {
            return this.form.getAbsolutePath(this, true);
        }
    });

    Object.defineProperty(Mug.prototype, "hashtagPath", {
        get: function () {
            // commtrack isn't hashtaggable (ex. /data/trans[type=trans1])
            if (this.options.isHashtaggable && this.absolutePathNoRoot) {
                return '#form' + this.absolutePathNoRoot;
            }
            return this.absolutePath;
        }
    });

    Object.defineProperty(Mug.prototype, "parentMug", {
        get: function () {
            var node = this.form.tree.getNodeFromMug(this);
            if (node && node.parent) {
                return node.parent.value;
            } else {
                return null;
            }
        }
    });

    Object.defineProperty(Mug.prototype, "previousSibling", {
        get: function () {
            return this.form.tree.getPreviousSibling(this);
        }
    });

    function copyAndProcessSpec(baseSpec, mugSpec, mugOptions) {
        var control = baseSpec.control,
            databind = baseSpec.databind;

        if (mugOptions.isDataOnly) {
            control = {};
        } else if (mugOptions.isControlOnly) {
            databind = {};
        }

        var spec = $.extend(true, {}, databind, control, mugSpec);

        _.each(spec, function (propertySpec, name) {
            if (_.isFunction(propertySpec)) {
                propertySpec = propertySpec(mugOptions);
            }
            if (!propertySpec) {
                delete spec[name];
                return;
            }
            spec[name] = propertySpec;
        });

        return spec;
    }

    function MugMessages() {
        this.messages = {};
    }
    MugMessages.prototype = {
        /**
         * Update message for property
         *
         * @param attr - The attribute to which the message applies.
         *      This may be a falsey value (typically `null`) for
         *      messages that are not associated with a property.
         * @param msg - A message object. A message object with a blank
         *      message will cause an existing message with the same
         *      key to be discarded.
         *
         *      {
         *          key: <message type key>,
         *          level: <"warning", or "error">,
         *          message: <message string>
         *      }
         *
         * @returns - true if changed else false
         */
        update: function (attr, msg) {
            attr = attr || "";
            if (arguments.length === 1) {
                if (this.messages.hasOwnProperty(attr)) {
                    delete this.messages[attr];
                    return true;
                }
                return false;
            }
            if (!this.messages.hasOwnProperty(attr) && !msg.message) {
                return false;
            }
            if (!msg.key) {
                // should never happen
                throw new Error("missing key: " + JSON.stringify(msg));
            }
            var messages = this.messages[attr] || [],
                removed = false;
            for (var i = messages.length - 1; i >= 0; i--) {
                var obj = messages[i];
                if (obj.key === msg.key) {
                    if (obj.level === msg.level && obj.message === msg.message) {
                        // message already exists (no change)
                        return false;
                    }
                    messages.splice(i, 1);
                    removed = true;
                    break;
                }
            }
            if (msg.message) {
                messages.push(msg);
            } else if (!removed) {
                return false;
            }
            if (messages.length) {
                this.messages[attr] = messages;
            } else {
                delete this.messages[attr];
            }
            return true;
        },
        /**
         * Get messages
         *
         * @param attr - The attribute for which to get messages.
         * @param key - (optional) The key of the message to get.
         *      If this is given then the entire message object will be
         *      returned; otherwise only message strings are returned.
         * @returns - An array of message strings, or if the `key` param
         *      is provided, the message object for the given key; null
         *      if no message is found with the given key.
         */
        get: function (attr, key) {
            if (arguments.length) {
                if (key) {
                    return _.find(this.messages[attr || ""], function (msg) {
                        return msg.key === key;
                    }) || null;
                }
                return _.pluck(this.messages[attr || ""], "message");
            }
            return _.flatten(_.map(this.messages, function (messages) {
                return _.pluck(messages, "message");
            }));
        },
        /**
         * Execute a function for each message
         *
         * @param attr - Optional property limiting the messages visited.
         *          The callback signature is `callback(msg)` if
         *          this argument is provided, and otherwise
         *          `callback(msg, property)`. In all cases the first
         *          argument `msg` is a message object.
         * @param callback - A function to be called for each message object.
         */
        each: function () {
            var attr, callback;
            if (arguments.length > 1) {
                attr = arguments[0] || "";
                callback = arguments[1];
                _.each(this.messages[attr], callback);
            } else {
                callback = arguments[0];
                _.each(this.messages, function (messages, attr) {
                    _.each(messages, function (msg) {
                        callback(msg, attr);
                    });
                });
            }
        },
        /**
         * Check if this messages object is empty
         */
        isEmpty: function() {
            return _.isEmpty(this.messages);
        },
    };

    function MugProperties (options) {
        this.__data = {};
        this.__spec = options.spec;
        this.__mug = options.mug;
        this.shouldChange = function () { return function () {}; };
    }
    MugProperties.setBaseSpec = function (baseSpec) {
        _.each(baseSpec, function (spec, name) {
            Object.defineProperty(MugProperties.prototype, name, {
                get: function () {
                    return this._get(name);
                },
                set: function (value) {
                    this._set(name, value);
                },
                // Allow properties to be redefined.  This should not be
                // necessary, but if we don't do this then if vellum.init() is
                // called a second time (i.e., when reloading Vellum on the test
                // page), we get an error.  This is an easy and harmless
                // alternative, but properties should never need to be redefined
                // otherwise.
                configurable: true
            });
        });
    };
    MugProperties.prototype = {
        getDefinition: function (name) {
            return this.__spec[name];
        },
        getAttrs: function () {
            return _.clone(this.__data);
        },
        has: function (attr) {
            return this.__data.hasOwnProperty(attr);
        },
        set: function (attr, val) {
            // set or clear property without triggering events, unlike _set
            if (arguments.length > 1) {
                this.__data[attr] = val;
            } else {
                delete this.__data[attr];
            }
        },
        _get: function (attr) {
            return this.__data[attr];
        },
        _set: function (attr, val) {
            var spec = this.__spec[attr],
                prev = this.__data[attr],
                mug = this.__mug;

            if (!spec || val === prev ||
                // only set attr if spec allows this attr, except if mug is a
                // DataBindOnly (which all mugs are before the control block has
                // been parsed).
                (mug.getPresence(attr) === 'notallowed' &&
                 mug.__className !== 'DataBindOnly'))
            {
                return;
            }

            var callback = this.shouldChange(mug, attr, val, prev);
            if (callback) {
                if (spec.setter) {
                    spec.setter(mug, attr, val);
                } else {
                    this.__data[attr] = val;
                }
                callback();
            }
        },
        setAttrs: function (attrs) {
            var _this = this;
            _(attrs).each(function (val, attr) {
                _this[attr] = val;
            });
        }
    };

    /**
     * Add instances referenced to serialized data
     */
    function serializeXPath(value, key, mug, data) {
        if (value && /\binstance\(/.test(value)) {
            data.instances = _.extend(data.instances || {},
                                      mug.form.parseInstanceRefs(value));
        }
        try {
            if (value) {
                value = mug.form.xpath.parse(value.toString()).toHashtag();
            }
        } catch (err) {
            if (_.isString(value) && !value.startsWith('#invalid/')) {
                value = '#invalid/xpath ' + value;
            }
        }
        return value || undefined;
    }

    function deserializeXPath(data, key, mug, context) {
        updateInstances(data, mug);
        var value = data[key];
        if (value) {
            try {
                value = mug.form.xpath.parse(value).toHashtag();
                context.later(function () {
                    mug.p[key] = context.transformHashtags(value);
                });
            } catch (err) {
                if (_.isString(value) && !value.startsWith('#invalid/')) {
                    value = '#invalid/xpath ' + value;
                }
            }
        } else if (value === null) {
            value = undefined;
        }
        return value;
    }

    function updateInstances(data, mug) {
        if (data.hasOwnProperty("instances") && !_.isEmpty(data.instances)) {
            mug.form.updateKnownInstances(data.instances);
        }
    }

    function resolveConflictedNodeId(mug) {
        // clear warning; mug already has copy-N-of-... ID
        mug.p.conflictedNodeId = null;
    }

    var RESERVED_NAMES = {"case": true, "registration": true, "script": true};
    var baseSpecs = {
        databind: {
            // DATA ELEMENT
            nodeID: {
                visibility: 'visible',
                presence: 'required',
                lstring: gettext('Question ID'),
                setter: function (mug, attr, value) {
                    mug.form.moveMug(mug, "rename", value);
                },
                mugValue: function (mug, value) {
                    if (arguments.length === 1) {
                        if (mug.p.has("conflictedNodeId")) {
                            return mug.p.conflictedNodeId;
                        }
                        return mug.p.nodeID;
                    }
                    mug.p.nodeID = value;
                },
                widget: widgets.identifier,
                validationFunc: function (mug) {
                    var lcid = mug.p.nodeID.toLowerCase(),
                        nameWarning = {
                            key: "mug-nodeID-reserved-name-warning",
                            level: mug.WARNING,
                        },
                        changedQuestionIDWarning = {
                            key: "mug-nodeID-changed-warning",
                            level: mug.INFO
                        },
                        return_value = "pass";

                    if (RESERVED_NAMES.hasOwnProperty(lcid)) {
                        nameWarning.message = util.format(
                            gettext("The ID '{nodeID}' may cause problems " +
                            "with form parsing. It is recommended to pick " +
                            "a different Question ID."),
                            {nodeID: mug.p.nodeID}
                        );
                    }
                    mug.addMessage("nodeID", nameWarning);

                    if (!util.isValidElementName(mug.p.nodeID)) {
                        return_value = util.format(gettext(
                            "{nodeID} is not a valid Question ID. " +
                            "It must start with a letter and contain only " +
                            "letters, numbers, and '-' or '_' characters."),
                            {nodeID: mug.p.nodeID});
                    } else if (mug.p.nodeID.toLowerCase() === "meta") {
                        return_value = gettext("'meta' is not a valid Question ID.");
                    } else if (mug.form.warnWhenChanged && mug.showChangedMsg &&
                        mug.__originalNodeID && mug.p.nodeID !== mug.__originalNodeID) {
                        changedQuestionIDWarning.message = gettext(
                            "Making this change will create a new Question ID (and a new column in exports).");
                    }
                    mug.addMessage("nodeID", changedQuestionIDWarning);
                    return return_value;
                },
                dropMessage: function (mug, attr, key) {
                    if (attr === "nodeID" && key === "mug-conflictedNodeId-warning") {
                        resolveConflictedNodeId(mug);
                    }
                },
                serialize: function (value, key, mug, data) {
                    data.id = mug.absolutePathNoRoot;
                },
                deserialize: function (data, key, mug, context) {
                    if (data.id && data.id !== mug.p.nodeID) {
                        mug.p.nodeID = data.id.slice(data.id.lastIndexOf("/") + 1) ||
                                       mug.form.generate_question_id(null, mug);
                        if (data.conflictedNodeId) {
                            // Obscure edge case: if mug.p.nodeID conflicts with
                            // an existing question then expressions will be
                            // associated with that question and this later
                            // assignment will not restore those connections to
                            // this mug.
                            return context.later(function () {
                                // after all other properties are deserialized,
                                // assign conflicted ID to convert expressions
                                // or setup new conflict
                                mug.p.nodeID = data.conflictedNodeId;
                            });
                        }
                    }
                    return context.later(function () {
                        if (mug.p.conflictedNodeId) {
                            resolveConflictedNodeId(mug);
                        }
                    });
                }
            },
            conflictedNodeId: {
                visibility: 'hidden',
                presence: 'optional',
                setter: function (mug, attr, value) {
                    var message = null;
                    if (value) {
                        mug.p.set(attr, value);
                        message = gettext("This question has the same " +
                            "Question ID as another question in the same " +
                            "group. Please choose a unique Question ID.");
                    } else {
                        mug.p.set(attr);
                    }
                    mug.addMessage("nodeID", {
                        key: "mug-conflictedNodeId-warning",
                        level: mug.WARNING,
                        message: message,
                        fixSerializationWarning: resolveConflictedNodeId
                    });
                },
                deserialize: function () {
                    // deserialization is done by nodeID
                }
            },
            dataValue: {
                visibility: 'visible_if_present',
                presence: 'optional',
                lstring: gettext('Default Data Value'),
            },
            xmlnsAttr: {
                visibility: 'visible',
                presence: 'notallowed',
                lstring: gettext("Special Hidden Value XMLNS attribute")
            },
            rawDataAttributes: {
                presence: 'optional',
                lstring: gettext('Extra Data Attributes'),
            },

            // BIND ELEMENT
            relevantAttr: {
                visibility: 'visible',
                presence: 'optional',
                widget: widgets.xPath,
                xpathType: "bool",
                serialize: serializeXPath,
                deserialize: deserializeXPath,
                lstring: gettext('Display Condition')
            },
            calculateAttr: {
                // only show calculate condition for non-data nodes if it already
                // exists.  It's a highly discouraged use-case because the user will
                // think they can edit an input when they really can't, but we
                // shouldn't break existing forms doing this.
                visibility: 'visible_if_present',
                presence: 'optional',
                widget: widgets.xPath,
                xpathType: "generic",
                serialize: serializeXPath,
                deserialize: deserializeXPath,
                lstring: gettext('Calculate Condition')
            },
            constraintAttr: {
                visibility: 'visible',
                presence: 'optional',
                validationFunc: function (mug) {
                    return baseSpecs.databind.constraintMsgAttr.validationFunc(mug);
                },
                widget: widgets.xPath,
                xpathType: "bool",
                mayReferenceSelf: true,
                serialize: serializeXPath,
                deserialize: deserializeXPath,
                lstring: gettext('Validation Condition')
            },
            // non-itext constraint message
            constraintMsgAttr: {
                visibility: 'visible',
                presence: 'optional',
                validationFunc : function (mug) {
                    if (mug.p.constraintMsgAttr && !mug.p.constraintAttr) {
                        return gettext('You cannot have a Validation Error Message with no Validation Condition!');
                    } else {
                        return 'pass';
                    }
                },
                lstring: gettext('Validation Error Message')
            },
            requiredAttr: {
                visibility: 'visible',
                presence: 'optional',
                lstring: gettext("Required"),
                widget: widgets.checkbox,
                validationFunc: function(mug) {
                    return baseSpecs.databind.requiredCondition.validationFunc(mug);
                }
            },
            requiredCondition: {
                visibility: 'requiredAttr',
                presence: 'optional',
                lstring: gettext("Required Condition"),
                widget: widgets.xPath,
                xpathType: "bool",
                serialize: serializeXPath,
                deserialize: deserializeXPath,
                validationFunc: function (mug) {
                    var warningKey = "mug-requiredCondition-warning",
                        warningAttrs = ["requiredAttr", "requiredCondition"];
                    if (mug.p.requiredCondition && !mug.p.requiredAttr) {
                        var message = gettext("The condition will be ignored unless you mark the question required.");
                        _.each(warningAttrs, function (attr) {
                            mug.addMessage(attr, {
                                key: warningKey,
                                level: mug.WARNING,
                                message: message
                            });
                        });
                    } else {
                        _.each(warningAttrs, function (attr) {
                            mug.dropMessage(attr, warningKey);
                        });
                    }
                    return 'pass';
                }
            },
            nodeset: {
                visibility: 'hidden',
                presence: 'optional' //if not present one will be generated... hopefully.
            },
            // could use a key-value widget for this in the future
            rawBindAttributes: {
                presence: 'optional',
                lstring: gettext('Extra Bind Attributes')
            },
            defaultValue: {
                visibility: 'visible',
                presence: 'optional',
                lstring: gettext('Default Value'),
                widget: widgets.xPath,
                xpathType: 'generic',
                serialize: serializeXPath,
                deserialize: deserializeXPath,
                validationFunc: function (mug) {
                    var form = mug.form;
                    if (!form.vellum.opts().features.allow_data_reference_in_setvalue) {
                        var paths = mug.form.getHashtagsInXPath(mug.p.defaultValue);
                        paths =  _.filter(paths, function(path) { return path.namespace === 'form'; });
                        if (paths.length) {
                            return gettext(
                                "You are referencing a node in this form. " +
                                "This can cause errors in the form");
                        }
                    }
                    return 'pass';
                }
            },
            comment: {
                lstring: gettext('Comment'),
                visibility: 'visible',
                widget: widgets.multilineText,
            }
        },

        control: {
            appearance: {
                deleteOnCopy: true,
                visibility: 'visible',
                presence: 'optional',
                lstring: gettext('Appearance Attribute')
            },
            label: {
                visibility: 'visible',
                presence: 'optional',
                lstring: gettext("Default Display Text"),
                validationFunc: function (mug) {
                    if (!mug.p.label && mug.getPresence("label") === 'required') {
                        return gettext('Default Display Text is required');
                    }
                    return 'pass';
                }
            },
            hintLabel: {
                visibility: 'visible',
                presence: 'optional',
                lstring: gettext("Hint Display Text")
            },
            rawControlAttributes: {
                presence: 'optional',
                lstring: gettext("Extra Control Attributes"),
            },
            rawControlXML: {
                presence: 'optional',
                lstring: gettext('Raw XML')
            },
            dataParent: {
                lstring: gettext('Data Parent'),
                visibility: 'visible',
                presence: 'optional',
                setter: function (mug, attr, value) {
                    var oldPath = mug.hashtagPath;
                    mug.p.set(attr, value);
                    mug.form._updateMugPath(mug, oldPath);
                },
                widget: widgets.droppableText,
                validationFunc: function(mug) {
                    function limitingParent(mug) {
                        if (!mug) {
                            return null;
                        } else if (mug.options.possibleDataParent === 'limited') {
                            return mug;
                        }
                        return limitingParent(mug.parentMug);
                    }
                    var dataParent = mug.p.dataParent,
                        form = mug.form,
                        parent;

                    if (dataParent) {
                        parent = form.getMugByPath(dataParent);
                        if (!parent) {
                            if (form.getBasePath().slice(0, -1) !== dataParent) {
                                return gettext("Must be valid path");
                            }
                        } else if (parent === mug || !parent.options.possibleDataParent) {
                            return util.format(
                                gettext("{path} is not a valid data parent"),
                                {path: parent.hashtagPath}
                            );
                        } else if (limitingParent(mug) !== limitingParent(parent)) {
                            return gettext("Data parent of question in repeat " +
                                "group must be (in) the same repeat group");
                        }
                    }

                    return "pass";
                }
            },
        }
    };

    // question-type specific properties, gets reset when you change the
    // question type
    var defaultOptions = {
        typeName: "Base",
        tagName: "input",
        isDataOnly: false,
        isControlOnly: false,
        // whether you can change to or from this question's type in the UI
        isTypeChangeable: true,
        /**
         * Determine if this mug can have its type changed to typeName
         *
         * Note: this method will also be called to verify that the reverse
         * type change is possible, in which case `mug`'s type will be the
         * same as `typeName`. This works for all current question types, but
         * could conceivably be wrong for some type that does not yet exist.
         *
         * @param mug - The mug object.
         * @param typeName - The name of the new type for mug (e.g., 'MSelect').
         * @returns - Empty string if the mug can change to type, otherwise error message.
         */
        typeChangeError: function (mug, typeName) {
            return '';
        },
        changeTypeTransform: function (mug) {
            return;
        },
        // controls whether delete button shows up - you can still delete a
        // mug's ancestor even if it's not removeable
        isRemoveable: true,
        isCopyable: true,
        canOutputValue: true,
        maxChildren: -1,
        icon: null,
        // whether it can be created during data node parsing
        // due to presence of vellum:role="TypeName" attribute
        supportsDataNodeRole: false,
        /**
         * Parser integration: get children from data node
         *
         * Additionally, this may perform extra mug initialization. It is
         * called before the mug is inserted into the data tree/mug hierarchy.
         *
         * @param mug - The mug object.
         * @param node - This mug's data node, a jQuery object.
         * @returns - A jquery collection of child nodes which will be passed through the parser in turn.
         */
        parseDataNode: function (mug, $node) {
            return $node.children();
        },
        controlNodeChildren: null,

        /**
         * Get data node path name.
         *
         * Use this to override the default path name.
         *
         * @param mug - The mug.
         * @param name - The default path name.
         * @returns - the name used in data node paths. It should
         *      uniquely identify the data node among its siblings.
         */
        getPathName: null,
        /**
         * Get data node tag name.
         *
         * Use this to override the default tag name.
         *
         * @param mug - The mug.
         * @param name - The default tag name.
         * @returns - the tag name used by the writer.
         */
        getTagName: null,

        /**
         * Filter function for data node children.
         *
         * This allows integration into the XForm writer. It can be used to filter out
         * child elements or generate additional child elements.
         *
         * The writer passes these filter functions to `processChildren` of
         * `Tree.walk`. See `Tree.walk` documentation for more details.
         *
         *  @param treeNodes - The list of child nodes.
         *  @param parentMug - The parent mug.
         *  @returns {Array<Tree.Node>} - The list of child nodes to add to the form XML data element.
         */
        dataChildFilter: null,
        controlChildFilter: null,

        /**
         * Get extra data node attributes to write to the XML.
         *
         * @param {Mug} mug - The mug.
         * @returns {Object} - An object containing extra attributes to write to the XML.
         */
        getExtraDataAttributes: null,
        writeDataNodeXML: null,       // function (xmlWriter, mug) { ... }

        /**
         * Returns a list of objects containing bind element attributes which will
         * be written to the form XML.
         */
        getBindList: function (mug) {
            var constraintMsgItext = mug.p.constraintMsgItext,
                constraintMsg;
            if (constraintMsgItext && !constraintMsgItext.isEmpty()) {
                constraintMsg = "jr:itext('" + constraintMsgItext.id + "')";
            } else {
                constraintMsg = mug.p.constraintMsgAttr;
            }

            var required;
            if (mug.p.requiredAttr) {
                required = mug.p.requiredCondition || util.createXPathBoolFromJS(mug.p.requiredAttr);
            } else {
                required = util.createXPathBoolFromJS(mug.p.requiredAttr);
            }

            var attrs = {
                nodeset: mug.hashtagPath,
                type: mug.options.dataType,
                constraint: mug.p.constraintAttr,
                "jr:constraintMsg": constraintMsg,
                relevant: mug.p.relevantAttr,
                required: required,
                requiredCondition: mug.p.requiredCondition,
                calculate: mug.p.calculateAttr,
            };
            _.each(mug.p.rawBindAttributes, function (value, key) {
                if (!attrs.hasOwnProperty(key) || _.isUndefined(attrs[key])) {
                    attrs[key] = value;
                }
            });
            return attrs.nodeset ? [attrs] : [];
        },

        /**
         * Returns a list of objects containing `setvalue` element attributes which will
         * be written to the form XML.
         */
        getSetValues: function (mug) {
            var ret = [];

            if (mug.p.defaultValue) {
                ret = [{
                    value: mug.p.defaultValue,
                    event: mug.isInRepeat() ? 'jr-insert' : 'xforms-ready',
                    ref: mug.hashtagPath
                }];
            }

            return ret;
        },

        // control node writer options
        writeControlLabel: true,
        writeControlHint: true,
        writeControlHelp: true,
        writeControlAlert: true,
        writeControlRefAttr: 'ref',
        // a function with signature `(xmlWriter, mug)` to write custom XML
        writeCustomXML: null,
        writesOnlyCustomXML: false,

        afterInsert: function (form, mug) {},
        getAppearanceAttribute: function (mug) {
            return mug.p.appearance;
        },
        getIcon: function (mug) {
            return mug.options.icon;
        },
        isHashtaggable: true,
        /**
         * Init function called when adding a mug to a form. Typically used ot initialize
         * mug properties.
         *
         * @param {Mug} mug
         * @param {Form} form
         */
        init: function (mug, form) {},

        /**
         * Attribute spec for the mug. Each attribute on the object
         * defines the attribute spec for that attribute. The attribute
         * spec is an object with the following properties:
         * - visibility: 'visible', 'hidden', 'visible_if_present', 'visible_if_not_present'
         * - presence: 'required', 'optional', 'notallowed'
         * - lstring: The label string to use for the attribute on the UI
         * - widget: The widget to use for the attribute. See `widgets.js`.
         * - defaultOptions: The default options for the widget
         * - validationFunc: A function to validate the attribute.
         *      // (mug) => isValid ? "pass" : gettext("Error message")
         * - mayReferenceSelf: Whether the attribute may reference the mug itself
         * - enabled: A function to determine whether the attribute is enabled
         *      // (mug) => true/false
         * - help: Help text for the attribute
         * - serialize: A function to serialize the attribute e.g. `mug.serializeXPath`
         * - deserialize: A function to deserialize the attribute e.g. `mug.deserializeXPath`
         */
        spec: {}
    };

    var DataBindOnly = util.extend(defaultOptions, {
        isDataOnly: true,
        typeName: gettext('Hidden Value'),
        icon: 'fcc fcc-fd-variable',
        isTypeChangeable: false,
        spec: {
            xmlnsAttr: { presence: "optional" },
            requiredAttr: { presence: "notallowed" },
            constraintAttr: { presence : "notallowed" },
            calculateAttr: { visibility: "visible" }
        }
    });

    var ReadOnly = util.extend(defaultOptions, {
        writesOnlyCustomXML: true,
        writeCustomXML: function (xmlWriter, mug) {
            return xmlWriter.writeXML($('<div>').append(mug.p.rawControlXML).clone().html());
        },
        spec: {
            readOnlyControl: {
                visibility: "visible",
                widget: widgets.readOnlyControl
            }
        }
    });

    var Text = util.extend(defaultOptions, {
        typeName: gettext("Text"),
        dataType: "xsd:string",
        icon: "fcc fcc-fd-text",
        init: function (mug, form) {
        }
    });

    var PhoneNumber = util.extend(Text, {
        typeName: gettext('Phone Number or Numeric ID'),
        icon: 'fa fa-signal',
        init: function (mug, form) {
            Text.init(mug, form);
            mug.p.appearance = "numeric";
        },
        changeTypeTransform: function (mug) {
            mug.p.appearance = undefined;
        },
    });

    var Secret = util.extend(defaultOptions, {
        typeName: gettext('Password'),
        dataType: 'xsd:string',
        tagName: 'secret',
        icon: 'fa fa-key',
        canOutputValue: false,
        init: function (mug, form) {
        }
    });

    var Int = util.extend(defaultOptions, {
        typeName: gettext('Integer'),
        dataType: 'xsd:int',
        icon: 'fcc fcc-fd-numeric',
        init: function (mug, form) {
        }
    });

    var Audio = util.extend(defaultOptions, {
        typeName: gettext('Audio Capture'),
        dataType: 'binary',
        tagName: 'upload',
        icon: 'fcc fcc-fd-audio-capture',
        mediaType: "audio/*", /* */
        canOutputValue: false,
        writeCustomXML: function (xmlWriter, mug) {
            xmlWriter.writeAttributeString("mediatype", mug.options.mediaType);
        },
    });

    var Image = util.extend(Audio, {
        typeName: gettext('Image Capture'),
        icon: 'fa fa-camera',
        mediaType: "image/*", /* */
        spec: {
            imageSize: {
                lstring: gettext("Image Size"),
                visibility: 'visible',
                widget: widgets.dropdown,
                enabled: function(mug) {
                    return mug.options.resize_enabled;
                },
                defaultOptions: [
                    { text: gettext("Small"), value: "250" },
                    { text: gettext("Medium"), value: "500" },
                    { text: gettext("Large"), value: "1000" },
                    { text: gettext("Original"), value: "" },
                ],
                help: gettext("This will resize the image before sending the form. " +
                    "Use this option to send smaller images in areas of poor " +
                    "connectivity.<ul><li>Small - 0.1 megapixels</li><li>" +
                    "Medium - 0.2 megapixels</li><li>Large - 0.5 megapixels</li></ul>"),
            }
        },
        writeCustomXML: function (xmlWriter, mug) {
            Audio.writeCustomXML(xmlWriter, mug);
            if (mug.__className === "Image" && mug.p.imageSize) {
                xmlWriter.writeAttributeString("jr:imageDimensionScaledMax", mug.p.imageSize + "px");
            }
        },
        init: function (mug, form) {
            Audio.init(mug, form);
            if (mug.p.imageSize !== "") {
                mug.p.imageSize = mug.p.imageSize || 250;
            }
        }
    });

    var MicroImage = util.extend(Audio, {
        typeName: gettext('Micro-Image'),
        isTypeChangeable: false,
        icon: 'fa fa-camera',
        tagName: 'input',
        mediaType: "image/*", /* */
        init: function (mug, form) {
            Audio.init(mug, form);
            mug.p.appearance = "micro-image";
        }
    });

    var Video = util.extend(Audio, {
        typeName: gettext('Video Capture'),
        icon: 'fa fa-video-camera',
        mediaType: "video/*", /* */
    });

    var Signature = util.extend(Image, {
        typeName: gettext('Signature Capture'),
        icon: 'fcc fcc-fd-signature',
        spec: {
            imageSize: {
                visibility: 'hidden',
            }
        },
        init: function (mug, form) {
            Image.init(mug, form);
            mug.p.appearance = "signature";
        },
        changeTypeTransform: function (mug) {
            mug.p.appearance = undefined;
        },
    });

    var Geopoint = util.extend(defaultOptions, {
        typeName: gettext('GPS'),
        dataType: 'geopoint',
        icon: 'fa-solid fa-location-dot',
        init: function (mug, form) {
        }
    });

    var Barcode = util.extend(defaultOptions, {
        typeName: gettext('Barcode Scan'),
        dataType: 'barcode',
        icon: 'fa fa-barcode',
        init: function (mug, form) {
        }
    });

    var Date = util.extend(defaultOptions, {
        typeName: gettext('Date'),
        dataType: 'xsd:date',
        icon: 'fa-solid fa-calendar-days',
        init: function (mug, form) {
        }
    });

    var DateTime = util.extend(defaultOptions, {
        typeName: gettext('Date and Time'),
        dataType: 'xsd:dateTime',
        icon: 'fcc fcc-fd-datetime',
        init: function (mug, form) {
        }
    });

    var Time = util.extend(defaultOptions, {
        typeName: gettext('Time'),
        dataType: 'xsd:time',
        icon: 'fa-regular fa-clock',
        init: function (mug, form) {
        }
    });

    // Deprecated. Users may not add new longs to forms,
    // but must be able to view forms already containing longs.
    var Long = util.extend(Int, {
        typeName: gettext('Long'),
        dataType: 'xsd:long',
        icon: 'fcc fcc-fd-long',
        init: function (mug, form) {
        }
    });

    var Double = util.extend(Int, {
        typeName: gettext('Decimal'),
        dataType: 'xsd:double',
        icon: 'fcc fcc-fd-decimal',
        init: function (mug, form) {
        }
    });

    var Choice = util.extend(defaultOptions, {
        isControlOnly: true,
        typeName: gettext('Choice'),
        tagName: 'item',
        icon: 'fcc fcc-fd-single-circle',
        isTypeChangeable: false,
        canOutputValue: false,
        getIcon: function (mug) {
            if (mug.parentMug.__className === "Select") {
                return 'fcc fcc-fd-single-circle';
            } else {
                return 'fcc fcc-fd-multi-box';
            }
        },
        writeControlHint: false,
        writeControlHelp: false,
        writeControlAlert: false,
        writeControlRefAttr: null,
        writeCustomXML: function (xmlWriter, mug) {
            var value = mug.p.nodeID;
            if (value) {
                xmlWriter.writeStartElement('value');
                xmlWriter.writeString(value);
                xmlWriter.writeEndElement();
            }
        },
        init: function (mug, form) {
        },
        spec: {
            nodeID: {
                lstring: gettext('Choice Value'),
                visibility: 'visible',
                presence: 'required',
                widget: widgets.identifier,
                setter: null,
                validationFunc: function (mug) {
                    if (/\s/.test(mug.p.nodeID)) {
                        return gettext("Whitespace in values is not allowed.");
                    }
                    if (mug.parentMug) {
                        var siblings = mug.form.getChildren(mug.parentMug),
                            dup = _.any(siblings, function(ele) {
                                return ele !== mug && ele.p.nodeID === mug.p.nodeID;
                            });
                        if (dup) {
                            return gettext("This choice value has been used in the same question");
                        }
                    }
                    return "pass";
                },
                serialize: function (value, key, mug, data) {
                    var path = mug.parentMug.absolutePathNoRoot;
                    data.id = path + "/" + value;
                },
                deserialize: function (data) {
                    return data.id && data.id.slice(data.id.lastIndexOf("/") + 1);
                }
            },
            labelItext: { presence: 'required' },
            conflictedNodeId: { presence: 'notallowed' },
            hintLabel: { presence: 'notallowed' },
            hintItext: { presence: 'notallowed' },
            helpItext: { presence: 'notallowed' },
            defaultValue: { presence: 'optional', visibility: 'hidden' },
        }
    });

    var Trigger = util.extend(defaultOptions, {
        typeName: gettext('Label'),
        tagName: 'trigger',
        icon: 'fa fa-tag',
        init: function (mug, form) {
            mug.p.appearance = "minimal";
        },
        changeTypeTransform: function (mug) {
            mug.p.appearance = undefined;
        },
        spec: {
            dataValue: { presence: 'optional' },
            defaultValue: { presence: 'optional', visibility: 'hidden' },
            requiredAttr: {
                deleteOnCopy: true,
                visibility: function (mug) {
                    return mug.p.appearance !== "minimal";
                },
            },
        }
    });

    var BaseSelect = util.extend(defaultOptions, {
        validChildTypes: ["Choice"],
        controlNodeChildren: function ($node) {
            return $node.children().not('label, value, hint, help, alert');
        },
        typeChangeError: function (mug, typeName) {
            if (mug.form.getChildren(mug).length > 0 && !typeName.match(/^M?Select$/)) {
                return gettext("Cannot change a Multiple/Single Choice " +
                      "question to a non-Choice question if it has Choices. " +
                      "Please remove all Choices and try again.");
            }
            return '';
        },
        canAddChoices: true,
        spec: {
            appearance: {
                deleteOnCopy: false,
            }
        },
        dataType: "",
    });

    var MSelect = util.extend(BaseSelect, {
        typeName: gettext('Checkbox'),
        tagName: 'select',
        icon: 'fcc fcc-fd-multi-select',
        defaultOperator: "selected"
    });

    var Select = util.extend(BaseSelect, {
        typeName: gettext('Multiple Choice'),
        tagName: 'select1',
        icon: 'fcc fcc-fd-single-select',
        defaultOperator: null
    });

    var Group = util.extend(defaultOptions, {
        typeName: gettext('Group'),
        tagName: 'group',
        icon: 'fa fa-folder-open',
        isSpecialGroup: true,
        isNestableGroup: true,
        isTypeChangeable: false,
        possibleDataParent: true,
        canOutputValue: false,
        controlNodeChildren: function ($node) {
            return $node.children().not('label, value, hint, help, alert');
        },
        init: function (mug, form) {
        },
        spec: {
            hintLabel: { presence: "notallowed" },
            hintItext: { presence: "notallowed" },
            helpItext: { presence: "notallowed" },
            calculateAttr: { presence: "notallowed" },
            constraintAttr: { presence: "notallowed" },
            constraintMsgAttr: { presence: "notallowed" },
            dataValue: { presence: "notallowed" },
            requiredAttr: { presence: "notallowed" },
            defaultValue: { presence: 'optional', visibility: 'hidden' },
        }
    });

    // This is just a group, but appearance = 'field-list' displays it as a list
    // of grouped questions.  It's a separate question type because it can't
    // nest other group types and it has a very different end-user functionality
    var FieldList = util.extend(Group, {
        typeName: gettext('Question List'),
        icon: 'fa fa-reorder',
        init: function (mug, form) {
            Group.init(mug, form);
            mug.p.appearance = 'field-list';
        },
        changeTypeTransform: function (mug) {
            mug.p.appearance = undefined;
        },
    });

    var Repeat = util.extend(Group, {
        typeName: gettext('Repeat Group'),
        icon: 'fa fa-retweet',
        possibleDataParent: 'limited',
        controlNodeChildren: function ($node) {
            var repeatChildren = $node.children('repeat').children();
            return repeatChildren.not('jr\\:addEmptyCaption, jr\\:addCaption');
        },
        getExtraDataAttributes: function (mug) {
            return {"jr:template": ""};
        },
        controlChildFilter: function (children, mug) {
            var hashtag = mug.hashtagPath,
                r_count = mug.p.repeat_count,
                attrs = _.object(_.filter(_.map(mug.p.rawRepeatAttributes, function (val, key) {
                    return key.toLowerCase() !== "jr:noaddremove" ? [key, val] : null;
                }), _.identity));
            return [new Tree.Node(children, {
                getNodeID: function () {},
                getAppearanceAttribute: function () {},
                form: mug.form,
                p: {
                    rawControlAttributes: attrs,
                    addEmptyCaptionItext: mug.p.addEmptyCaptionItext,
                    addCaptionItext: mug.p.addCaptionItext,
                },
                options: {
                    tagName: 'repeat',
                    writeRepeatItexts: mug.options.customRepeatButtonText,
                    writeControlLabel: false,
                    writeControlHint: false,
                    writeControlHelp: false,
                    writeControlAlert: false,
                    writeControlRefAttr: null,
                    writeCustomXML: function (xmlWriter, mug) {
                        if (r_count) {
                            util.writeHashtags(xmlWriter, 'jr:count', String(r_count));
                            xmlWriter.writeAttributeString("jr:noAddRemove", "true()");
                        }
                        util.writeHashtags(xmlWriter, 'nodeset', hashtag, mug);
                    },
                }
            })];
        },
        writeControlRefAttr: null,
        init: function (mug, form) {
            mug.p.repeat_count = null;
        },
        spec: {
            repeat_count: {
                lstring: gettext('Repeat Count'),
                visibility: 'visible_if_present',
                presence: 'optional',
                widget: widgets.droppableText,
                validationFunc: function (mug) {
                    function insideFieldList(mug) {
                        if (!mug) { return false; }

                        var parentMug = mug.parentMug;

                        if (parentMug && parentMug.__className === 'FieldList') {
                            return true;
                        }

                        return insideFieldList(parentMug);
                    }

                    if (!$.trim(mug.p.repeat_count) && insideFieldList(mug)) {
                        return gettext("Repeat Count is required.");
                    }

                    return "pass";
                },
            },
            rawRepeatAttributes: {
                presence: 'optional',
                lstring: gettext("Extra Repeat Attributes"),
            }
        }
    });

    function MugTypesManager(baseSpec, mugTypes, opts) {
        var _this = this,
            // Nestable Field List not supported in CommCare before v2.16
            group_in_field_list = opts.features.group_in_field_list;
        Image.resize_enabled = opts.features.image_resize;

        this.auxiliaryTypes = mugTypes.auxiliary;
        this.normalTypes = mugTypes.normal;
        this.baseSpec = baseSpec;

        MugProperties.setBaseSpec(
            util.extend.apply(null,
                [baseSpec.databind, baseSpec.control].concat(_.filter(
                    _.pluck(
                        util.extend(this.normalTypes, this.auxiliaryTypes),
                        'spec'),
                    _.identity))));

        this.allTypes = $.extend({}, this.auxiliaryTypes, this.normalTypes);

        var allTypeNames = _.keys(this.allTypes),
            innerChildTypeNames = _.without.apply(_,
                  [allTypeNames].concat(_.keys(this.auxiliaryTypes)));

        if (!group_in_field_list) {
            this.normalTypes.FieldList.validChildTypes = _.without.apply(_,
                [innerChildTypeNames].concat(_.without(_.map(this.allTypes,
                    function (type, name) {
                        return type.isNestableGroup ? name : null;
                    }
                ), null))
            );
        }

        _.each(this.auxiliaryTypes, function (type) {
            type.validChildTypes = [];
        });

        _.each(this.normalTypes, function (Mug, name) {
            if (Mug.validChildTypes) {
                return; // do nothing if validChildTypes is already set
            }
            var validChildTypes;
            if (Mug.isNestableGroup) {
                validChildTypes = innerChildTypeNames;
            } else {
                validChildTypes = [];
            }
            Mug.validChildTypes = validChildTypes;
        });

        _.each(this.allTypes, function (Mug, name) {
            Mug.__className = name;

            // set on this for easy access
            _this[name] = Mug;
        });
    }
    MugTypesManager.prototype = {
        make: function (typeName, form, copyFrom) {
            var mugType = this.allTypes[typeName];
            var attrs = copyFrom ? copyFrom.p.getAttrs() : null;
            return new Mug(mugType, form, this.baseSpec, attrs);
        },
        changeType: function (mug, typeName) {
            var form = mug.form,
                children = form.getChildren(mug);

            var message = this.allTypes[mug.__className].typeChangeError(mug, typeName);
            if (message) {
                throw new Error(message);
            }
            this.allTypes[mug.__className].changeTypeTransform(mug);

            mug.setOptionsAndProperties(this.allTypes[typeName]);

            if (typeName.indexOf("Select") !== -1) {
                _.each(children, function (childMug) {
                    form.fire({
                        type: 'parent-question-type-change',
                        childMug: childMug
                    });
                });
            }

            mug.validate();
            form.fire({
                type: 'question-type-change',
                qType: typeName,
                mug: mug
            });
            form.fireChange(mug);
        }
    };

    return {
        defaultOptions: defaultOptions,
        baseMugTypes: {
            normal: {
                "Audio": Audio,
                "Barcode": Barcode,
                "DataBindOnly": DataBindOnly,
                "Date": Date,
                "DateTime": DateTime,
                "Double": Double,
                "FieldList": FieldList,
                "Geopoint": Geopoint,
                "Group": Group,
                "Image": Image,
                "MicroImage": MicroImage,
                "Int": Int,
                "Long": Long,
                "MSelect": MSelect,
                "PhoneNumber": PhoneNumber,
                "ReadOnly": ReadOnly,
                "Repeat": Repeat,
                "Secret": Secret,
                "Select": Select,
                "Signature": Signature,
                "Text": Text,
                "Time": Time,
                "Trigger": Trigger,
                "Video": Video
            },
            auxiliary: {
                "Choice": Choice
            }
        },
        MugTypesManager: MugTypesManager,
        MugMessages: MugMessages,
        WARNING: Mug.WARNING,
        ERROR: Mug.ERROR,
        baseSpecs: baseSpecs,
        deserializeXPath: deserializeXPath,
        serializeXPath: serializeXPath,
        updateInstances: updateInstances,
    };
});

/**
 * @license
 * Fuse - Lightweight fuzzy-search
 *
 * Copyright (c) 2012-2016 Kirollos Risk <kirollos@gmail.com>.
 * All Rights Reserved. Apache Software License 2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
;(function (global) {
  'use strict'

  /** @type {function(...*)} */
  function log () {
    console.log.apply(console, arguments)
  }

  var defaultOptions = {
    // The name of the identifier property. If specified, the returned result will be a list
    // of the items' dentifiers, otherwise it will be a list of the items.
    id: null,

    // Indicates whether comparisons should be case sensitive.

    caseSensitive: false,

    // An array of values that should be included from the searcher's output. When this array
    // contains elements, each result in the list will be of the form `{ item: ..., include1: ..., include2: ... }`.
    // Values you can include are `score`, `matchedLocations`
    include: [],

    // Whether to sort the result list, by score
    shouldSort: true,

    // The search function to use
    // Note that the default search function ([[Function]]) must conform to the following API:
    //
    //  @param pattern The pattern string to search
    //  @param options The search option
    //  [[Function]].constructor = function(pattern, options)
    //
    //  @param text: the string to search in for the pattern
    //  @return Object in the form of:
    //    - isMatch: boolean
    //    - score: Int
    //  [[Function]].prototype.search = function(text)
    searchFn: BitapSearcher,

    // Default sort function
    sortFn: function (a, b) {
      return a.score - b.score
    },

    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: deepValue,

    // List of properties that will be searched. This also supports nested properties.
    keys: [],

    // Will print to the console. Useful for debugging.
    verbose: false,

    // When true, the search algorithm will search individual words **and** the full string,
    // computing the final score as a function of both. Note that when `tokenize` is `true`,
    // the `threshold`, `distance`, and `location` are inconsequential for individual tokens.
    tokenize: false,

    // When true, the result set will only include records that match all tokens. Will only work
    // if `tokenize` is also true.
    matchAllTokens: false,

    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.
    tokenSeparator: / +/g,

    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1,

    // When true, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    findAllMatches: false
  }

  /**
   * @constructor
   * @param {!Array} list
   * @param {!Object<string, *>} options
   */
  function Fuse (list, options) {
    var key

    this.list = list
    this.options = options = options || {}

    for (key in defaultOptions) {
      if (!defaultOptions.hasOwnProperty(key)) {
        continue;
      }
      // Add boolean type options
      if (typeof defaultOptions[key] === 'boolean') {
        this.options[key] = key in options ? options[key] : defaultOptions[key];
      // Add all other options
      } else {
        this.options[key] = options[key] || defaultOptions[key]
      }
    }
  }

  Fuse.VERSION = '2.7.3'

  /**
   * Sets a new list for Fuse to match against.
   * @param {!Array} list
   * @return {!Array} The newly set list
   * @public
   */
  Fuse.prototype.set = function (list) {
    this.list = list
    return list
  }

  Fuse.prototype.search = function (pattern) {
    if (this.options.verbose) log('\nSearch term:', pattern, '\n')

    this.pattern = pattern
    this.results = []
    this.resultMap = {}
    this._keyMap = null

    this._prepareSearchers()
    this._startSearch()
    this._computeScore()
    this._sort()

    var output = this._format()
    return output
  }

  Fuse.prototype._prepareSearchers = function () {
    var options = this.options
    var pattern = this.pattern
    var searchFn = options.searchFn
    var tokens = pattern.split(options.tokenSeparator)
    var i = 0
    var len = tokens.length

    if (this.options.tokenize) {
      this.tokenSearchers = []
      for (; i < len; i++) {
        this.tokenSearchers.push(new searchFn(tokens[i], options))
      }
    }
    this.fullSeacher = new searchFn(pattern, options)
  }

  Fuse.prototype._startSearch = function () {
    var options = this.options
    var getFn = options.getFn
    var list = this.list
    var listLen = list.length
    var keys = this.options.keys
    var keysLen = keys.length
    var key
    var weight
    var item = null
    var i
    var j

    // Check the first item in the list, if it's a string, then we assume
    // that every item in the list is also a string, and thus it's a flattened array.
    if (typeof list[0] === 'string') {
      // Iterate over every item
      for (i = 0; i < listLen; i++) {
        this._analyze('', list[i], i, i)
      }
    } else {
      this._keyMap = {}
      // Otherwise, the first item is an Object (hopefully), and thus the searching
      // is done on the values of the keys of each item.
      // Iterate over every item
      for (i = 0; i < listLen; i++) {
        item = list[i]
        // Iterate over every key
        for (j = 0; j < keysLen; j++) {
          key = keys[j]
          if (typeof key !== 'string') {
            weight = (1 - key.weight) || 1
            this._keyMap[key.name] = {
              weight: weight
            }
            if (key.weight <= 0 || key.weight > 1) {
              throw new Error('Key weight has to be > 0 and <= 1')
            }
            key = key.name
          } else {
            this._keyMap[key] = {
              weight: 1
            }
          }
          this._analyze(key, getFn(item, key, []), item, i)
        }
      }
    }
  }

  Fuse.prototype._analyze = function (key, text, entity, index) {
    var options = this.options
    var words
    var scores
    var exists = false
    var existingResult
    var averageScore
    var finalScore
    var scoresLen
    var mainSearchResult
    var tokenSearcher
    var termScores
    var word
    var tokenSearchResult
    var hasMatchInText
    var checkTextMatches
    var i
    var j

    // Check if the text can be searched
    if (text === undefined || text === null) {
      return
    }

    scores = []

    var numTextMatches = 0

    if (typeof text === 'string') {
      words = text.split(options.tokenSeparator)

      if (options.verbose) log('---------\nKey:', key)

      if (this.options.tokenize) {
        for (i = 0; i < this.tokenSearchers.length; i++) {
          tokenSearcher = this.tokenSearchers[i]

          if (options.verbose) log('Pattern:', tokenSearcher.pattern)

          termScores = []
          hasMatchInText = false

          for (j = 0; j < words.length; j++) {
            word = words[j]
            tokenSearchResult = tokenSearcher.search(word)
            var obj = {}
            if (tokenSearchResult.isMatch) {
              obj[word] = tokenSearchResult.score
              exists = true
              hasMatchInText = true
              scores.push(tokenSearchResult.score)
            } else {
              obj[word] = 1
              if (!this.options.matchAllTokens) {
                scores.push(1)
              }
            }
            termScores.push(obj)
          }

          if (hasMatchInText) {
            numTextMatches++
          }

          if (options.verbose) log('Token scores:', termScores)
        }

        averageScore = scores[0]
        scoresLen = scores.length
        for (i = 1; i < scoresLen; i++) {
          averageScore += scores[i]
        }
        averageScore = averageScore / scoresLen

        if (options.verbose) log('Token score average:', averageScore)
      }

      mainSearchResult = this.fullSeacher.search(text)
      if (options.verbose) log('Full text score:', mainSearchResult.score)

      finalScore = mainSearchResult.score
      if (averageScore !== undefined) {
        finalScore = (finalScore + averageScore) / 2
      }

      if (options.verbose) log('Score average:', finalScore)

      checkTextMatches = (this.options.tokenize && this.options.matchAllTokens) ? numTextMatches >= this.tokenSearchers.length : true

      if (options.verbose) log('Check Matches', checkTextMatches)

      // If a match is found, add the item to <rawResults>, including its score
      if ((exists || mainSearchResult.isMatch) && checkTextMatches) {
        // Check if the item already exists in our results
        existingResult = this.resultMap[index]

        if (existingResult) {
          // Use the lowest score
          // existingResult.score, bitapResult.score
          existingResult.output.push({
            key: key,
            score: finalScore,
            matchedIndices: mainSearchResult.matchedIndices
          })
        } else {
          // Add it to the raw result list
          this.resultMap[index] = {
            item: entity,
            output: [{
              key: key,
              score: finalScore,
              matchedIndices: mainSearchResult.matchedIndices
            }]
          }

          this.results.push(this.resultMap[index])
        }
      }
    } else if (isArray(text)) {
      for (i = 0; i < text.length; i++) {
        this._analyze(key, text[i], entity, index)
      }
    }
  }

  Fuse.prototype._computeScore = function () {
    var i
    var j
    var keyMap = this._keyMap
    var totalScore
    var output
    var scoreLen
    var score
    var weight
    var results = this.results
    var bestScore
    var nScore

    if (this.options.verbose) log('\n\nComputing score:\n')

    for (i = 0; i < results.length; i++) {
      totalScore = 0
      output = results[i].output
      scoreLen = output.length

      bestScore = 1

      for (j = 0; j < scoreLen; j++) {
        score = output[j].score
        weight = keyMap ? keyMap[output[j].key].weight : 1

        nScore = score * weight

        if (weight !== 1) {
          bestScore = Math.min(bestScore, nScore)
        } else {
          totalScore += nScore
          output[j].nScore = nScore
        }
      }

      if (bestScore === 1) {
        results[i].score = totalScore / scoreLen
      } else {
        results[i].score = bestScore
      }

      if (this.options.verbose) log(results[i])
    }
  }

  Fuse.prototype._sort = function () {
    var options = this.options
    if (options.shouldSort) {
      if (options.verbose) log('\n\nSorting....')
      this.results.sort(options.sortFn)
    }
  }

  Fuse.prototype._format = function () {
    var options = this.options
    var getFn = options.getFn
    var finalOutput = []
    var i
    var len
    var results = this.results
    var replaceValue
    var getItemAtIndex
    var include = options.include

    if (options.verbose) log('\n\nOutput:\n\n', results)

    // Helper function, here for speed-up, which replaces the item with its value,
    // if the options specifies it,
    replaceValue = options.id ? function (index) {
      results[index].item = getFn(results[index].item, options.id, [])[0]
    } : function () {}

    getItemAtIndex = function (index) {
      var record = results[index]
      var data
      var j
      var output
      var _item
      var _result

      // If `include` has values, put the item in the result
      if (include.length > 0) {
        data = {
          item: record.item
        }
        if (include.indexOf('matches') !== -1) {
          output = record.output
          data.matches = []
          for (j = 0; j < output.length; j++) {
            _item = output[j]
            _result = {
              indices: _item.matchedIndices
            }
            if (_item.key) {
              _result.key = _item.key
            }
            data.matches.push(_result)
          }
        }

        if (include.indexOf('score') !== -1) {
          data.score = results[index].score
        }

      } else {
        data = record.item
      }

      return data
    }

    // From the results, push into a new array only the item identifier (if specified)
    // of the entire item.  This is because we don't want to return the <results>,
    // since it contains other metadata
    for (i = 0, len = results.length; i < len; i++) {
      replaceValue(i)
      finalOutput.push(getItemAtIndex(i))
    }

    return finalOutput
  }

  // Helpers

  function deepValue (obj, path, list) {
    var firstSegment
    var remaining
    var dotIndex
    var value
    var i
    var len

    if (!path) {
      // If there's no path left, we've gotten to the object we care about.
      list.push(obj)
    } else {
      dotIndex = path.indexOf('.')

      if (dotIndex !== -1) {
        firstSegment = path.slice(0, dotIndex)
        remaining = path.slice(dotIndex + 1)
      } else {
        firstSegment = path
      }

      value = obj[firstSegment]
      if (value !== null && value !== undefined) {
        if (!remaining && (typeof value === 'string' || typeof value === 'number')) {
          list.push(value)
        } else if (isArray(value)) {
          // Search each item in the array.
          for (i = 0, len = value.length; i < len; i++) {
            deepValue(value[i], remaining, list)
          }
        } else if (remaining) {
          // An object. Recurse further.
          deepValue(value, remaining, list)
        }
      }
    }

    return list
  }

  function isArray (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]'
  }

  /**
   * Adapted from "Diff, Match and Patch", by Google
   *
   *   http://code.google.com/p/google-diff-match-patch/
   *
   * Modified by: Kirollos Risk <kirollos@gmail.com>
   * -----------------------------------------------
   * Details: the algorithm and structure was modified to allow the creation of
   * <Searcher> instances with a <search> method which does the actual
   * bitap search. The <pattern> (the string that is searched for) is only defined
   * once per instance and thus it eliminates redundant re-creation when searching
   * over a list of strings.
   *
   * Licensed under the Apache License, Version 2.0 (the "License")
   * you may not use this file except in compliance with the License.
   *
   * @constructor
   */
  function BitapSearcher (pattern, options) {
    options = options || {}
    this.options = options
    this.options.location = options.location || BitapSearcher.defaultOptions.location
    this.options.distance = 'distance' in options ? options.distance : BitapSearcher.defaultOptions.distance
    this.options.threshold = 'threshold' in options ? options.threshold : BitapSearcher.defaultOptions.threshold
    this.options.maxPatternLength = options.maxPatternLength || BitapSearcher.defaultOptions.maxPatternLength

    this.pattern = options.caseSensitive ? pattern : pattern.toLowerCase()
    this.patternLen = pattern.length

    if (this.patternLen <= this.options.maxPatternLength) {
      this.matchmask = 1 << (this.patternLen - 1)
      this.patternAlphabet = this._calculatePatternAlphabet()
    }
  }

  BitapSearcher.defaultOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,

    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100,

    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,

    // Machine word size
    maxPatternLength: 32
  }

  /**
   * Initialize the alphabet for the Bitap algorithm.
   * @return {Object} Hash of character locations.
   * @private
   */
  BitapSearcher.prototype._calculatePatternAlphabet = function () {
    var mask = {},
      i = 0

    for (i = 0; i < this.patternLen; i++) {
      mask[this.pattern.charAt(i)] = 0
    }

    for (i = 0; i < this.patternLen; i++) {
      mask[this.pattern.charAt(i)] |= 1 << (this.pattern.length - i - 1)
    }

    return mask
  }

  /**
   * Compute and return the score for a match with `e` errors and `x` location.
   * @param {number} errors Number of errors in match.
   * @param {number} location Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  BitapSearcher.prototype._bitapScore = function (errors, location) {
    var accuracy = errors / this.patternLen,
      proximity = Math.abs(this.options.location - location)

    if (!this.options.distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy
    }
    return accuracy + (proximity / this.options.distance)
  }

  /**
   * Compute and return the result of the search
   * @param {string} text The text to search in
   * @return {{isMatch: boolean, score: number}} Literal containing:
   *                          isMatch - Whether the text is a match or not
   *                          score - Overall score for the match
   * @public
   */
  BitapSearcher.prototype.search = function (text) {
    var options = this.options
    var i
    var j
    var textLen
    var findAllMatches
    var location
    var threshold
    var bestLoc
    var binMin
    var binMid
    var binMax
    var start, finish
    var bitArr
    var lastBitArr
    var charMatch
    var score
    var locations
    var matches
    var isMatched
    var matchMask
    var matchedIndices
    var matchesLen
    var match

    text = options.caseSensitive ? text : text.toLowerCase()

    if (this.pattern === text) {
      // Exact match
      return {
        isMatch: true,
        score: 0,
        matchedIndices: [[0, text.length - 1]]
      }
    }

    // When pattern length is greater than the machine word length, just do a a regex comparison
    if (this.patternLen > options.maxPatternLength) {
      matches = text.match(new RegExp(this.pattern.replace(options.tokenSeparator, '|')))
      isMatched = !!matches

      if (isMatched) {
        matchedIndices = []
        for (i = 0, matchesLen = matches.length; i < matchesLen; i++) {
          match = matches[i]
          matchedIndices.push([text.indexOf(match), match.length - 1])
        }
      }

      return {
        isMatch: isMatched,
        // TODO: revisit this score
        score: isMatched ? 0.5 : 1,
        matchedIndices: matchedIndices
      }
    }

    findAllMatches = options.findAllMatches

    location = options.location
    // Set starting location at beginning text and initialize the alphabet.
    textLen = text.length
    // Highest score beyond which we give up.
    threshold = options.threshold
    // Is there a nearby exact match? (speedup)
    bestLoc = text.indexOf(this.pattern, location)

    // a mask of the matches
    matchMask = []
    for (i = 0; i < textLen; i++) {
      matchMask[i] = 0
    }

    if (bestLoc != -1) {
      threshold = Math.min(this._bitapScore(0, bestLoc), threshold)
      // What about in the other direction? (speed up)
      bestLoc = text.lastIndexOf(this.pattern, location + this.patternLen)

      if (bestLoc != -1) {
        threshold = Math.min(this._bitapScore(0, bestLoc), threshold)
      }
    }

    bestLoc = -1
    score = 1
    locations = []
    binMax = this.patternLen + textLen

    for (i = 0; i < this.patternLen; i++) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      binMin = 0
      binMid = binMax
      while (binMin < binMid) {
        if (this._bitapScore(i, location + binMid) <= threshold) {
          binMin = binMid
        } else {
          binMax = binMid
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin)
      }

      // Use the result from this iteration as the maximum for the next.
      binMax = binMid
      start = Math.max(1, location - binMid + 1)
      if (findAllMatches) {
        finish = textLen;
      } else {
        finish = Math.min(location + binMid, textLen) + this.patternLen
      }

      // Initialize the bit array
      bitArr = Array(finish + 2)

      bitArr[finish + 1] = (1 << i) - 1

      for (j = finish; j >= start; j--) {
        charMatch = this.patternAlphabet[text.charAt(j - 1)]

        if (charMatch) {
          matchMask[j - 1] = 1
        }

        bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch

        if (i !== 0) {
          // Subsequent passes: fuzzy match.
          bitArr[j] |= (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1]
        }
        if (bitArr[j] & this.matchmask) {
          score = this._bitapScore(i, j - 1)

          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (score <= threshold) {
            // Indeed it is
            threshold = score
            bestLoc = j - 1
            locations.push(bestLoc)

            // Already passed loc, downhill from here on in.
            if (bestLoc <= location) {
              break
            }

            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * location - bestLoc)
          }
        }
      }

      // No hope for a (better) match at greater error levels.
      if (this._bitapScore(i + 1, location) > threshold) {
        break
      }
      lastBitArr = bitArr
    }

    matchedIndices = this._getMatchedIndices(matchMask)

    // Count exact matches (those with a score of 0) to be "almost" exact
    return {
      isMatch: bestLoc >= 0,
      score: score === 0 ? 0.001 : score,
      matchedIndices: matchedIndices
    }
  }

  BitapSearcher.prototype._getMatchedIndices = function (matchMask) {
    var matchedIndices = []
    var start = -1
    var end = -1
    var i = 0
    var match
    var len = matchMask.length
    for (; i < len; i++) {
      match = matchMask[i]
      if (match && start === -1) {
        start = i
      } else if (!match && start !== -1) {
        end = i - 1
        if ((end - start) + 1 >= this.options.minMatchCharLength) {
            matchedIndices.push([start, end])
        }
        start = -1
      }
    }
    if (matchMask[i - 1]) {
      if ((i-1 - start) + 1 >= this.options.minMatchCharLength) {
        matchedIndices.push([start, i - 1])
      }
    }
    return matchedIndices
  }

  // Export to Common JS Loader
  if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = Fuse
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('fusejs',[],function () {
      return Fuse
    })
  } else {
    // Browser globals (root is window)
    global.Fuse = Fuse
  }

})(this);

define('vellum/fuse',[
    'underscore',
    'fusejs',
    'vellum/util',
], function (
    _,
    fusejs,
    util
) {
    var FUSE_CONFIG = {
        keys: ['displayPath'],
        tokenize: true,
        tokenSeparator: /\/+/g,
        threshold: 0.4,
    };

    function Fuse(form) {
        var _this = this;
        this.form = form;

        form.vellum.datasources.on("change", function() {
            _this.dataset = generateNewFuseData(form);
            _this.fusejs.set(_this.dataset);
        }, null, null, form);  // context=form for form.disconnectDataSources()

        form.on("change", function(event) {
            if (event.mug === undefined) {
                _this.dataset = generateNewFuseData(form);
                _this.fusejs.set(_this.dataset);
            }
        });

        if (!this.dataset) {
            this.dataset = generateNewFuseData(form);
        }

        this.fusejs = new fusejs(this.dataset, FUSE_CONFIG);


        function addToDataset(e) {
            removeFromDataset(e);
            _this.dataset.push(mugToData(e.mug));
            _this.fusejs.set(_this.dataset);
        }

        function removeFromDataset(e) {
            _this.dataset = _.filter(_this.dataset, function (mug) {
                return mug.id !== e.mug.ufid;
            });
        }


        this.form.on('mug-property-change', function (e) {
            if (e.property === 'nodeID') {
                addToDataset(e);
            }
        }).on('question-label-text-change', addToDataset)
        .on('question-create', addToDataset)
        .on('question-remove', removeFromDataset);
    }

    Fuse.prototype = {
        list: function () {
            return this.fusejs.list;
        },
        search: function (query) {
            return this.fusejs.search(query);
        }
    };

    function mugToData(mug) {
        if (mug) {
            var defaultLabel = mug.form.vellum.getMugDisplayName(mug);

            return {
                id: mug.ufid,
                name: mug.absolutePath,
                hashtagPath: mug.hashtagPath,
                absolutePath: mug.absolutePath,
                displayPath: mug.form.richText ? mug.hashtagPath : mug.absolutePath,
                icon: mug.options.icon,
                questionId: mug.p.nodeID,
                displayLabel: util.truncate(defaultLabel),
                label: defaultLabel,
                mug: mug,
            };
        }
        return null;
    }

    function generateNewFuseData(form) {
        var caseData = [];
        if (form.richText) {
            caseData = _.chain(form.vellum.datasources.getHashtagMap({}))
             .map(function(absolutePath, hashtag) {
                 return {
                     name: hashtag,
                     hashtagPath: hashtag,
                     absolutePath: absolutePath,
                     icon: 'fcc fcc-fd-case-property',
                     displayLabel: null,
                     displayPath: hashtag,
                 };
             })
             .value();
        }
        return _.chain(form.getMugList())
                .map(mugToData)
                .filter(function(choice) {
                    return choice.name && !_.isUndefined(choice.displayLabel);
                })
                .value().concat(caseData);
    }

    return Fuse;
});


define('tpl/tpl!vellum/templates/undo_alert', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-undo-delete alert alert-'+
((__t=( errors.length ? "danger" : "success" ))==null?'':__t)+
' fade in">\n  <button type="button" class="close">&times;</button>\n  '+
((__t=(gettext("You have deleted a question.")))==null?'':_.escape(__t))+
' <a class="fd-undo">'+
((__t=(gettext("Undo")))==null?'':_.escape(__t))+
'</a>\n  ';
 if (errors.length) { 
__p+='\n    <p>';

      print(format(
        ngettext(
          "Warning: {errs} is still referenced by other questions.",
          "Warning: {errs} are still referenced by other questions.",
          errors.length
        ),
        {errs: errors.join(", ")}
      ))
    
__p+='</p>\n  ';
 } 
__p+='\n</div>\n';
}
return __p;
}; });

define('vellum/undomanager',[
    'jquery',
    'underscore',
    'vellum/util',
    'tpl!vellum/templates/undo_alert',
], function(
    $,
    _,
    util,
    undo_alert
) {
    function alertShown() {
        var alert = $('.fd-undo-delete');
        // creating alert uses classes "fade in", removing alert removes in
        // This sometimes gets triggered after in is removed but before the
        // alert is removed from the page
        if (!alert.hasClass('in')) {
            return false;
        }
        return alert.length;
    }

    function createAlert(mugs) {
        var refs = _.filter(_.map(mugs, function (mug) {
                return mug.isReferencedByOtherMugs(mugs) ? mug.p.nodeID : "";
            }), _.identity);
        $('.fd-undo-container').append(undo_alert({
            errors: refs,
            format: util.format,
        }));
    }

    function toggleAlert(undoStack) {
        if (undoStack.length && !alertShown()) {
            createAlert(_.map(undoStack, function (x) { return x[0]; }));
        } else if (undoStack.length === 0 && alertShown()) {
            $('.fd-undo-delete').remove();
        }
    }

    function UndoManager() {
        var _this = this;
        _this.undoStack = [];

        util.eventuality(this);
    }

    UndoManager.prototype = {
        resetUndo: function (mug, previousMug, position) {
            if (mug) {
                this.undoStack = [[mug, previousMug, position]];
            } else {
                this.undoStack = [];
            }
            toggleAlert(this.undoStack);
            this.fire({
                type: 'reset',
            });
        },
        setUndo: function (stack) {
            this.undoStack = this.undoStack.concat(stack);
            toggleAlert(this.undoStack);
        },
        undo: function () {
            _.each(this.undoStack, function(undo) {
                var mug = undo[0],
                    sibling = undo[1],
                    position = undo[2];
                mug.form.insertQuestion(mug, sibling, position, true);
            });
            this.resetUndo();
        },
    };

    return UndoManager;
});

/**
 * XMLWriter - XML generator for Javascript, based on .NET's XMLTextWriter.
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 *
 * @version 1.1.0
 * @author Ariel Flesler, alexandern, Daniel Miller
 *
 * Original version: http://flesler.blogspot.com/2008/03/xmlwriter-for-javascript.html
 */

function XMLWriter( encoding, version ){
	if( encoding )
		this.encoding = encoding;
	if( version )
		this.version = version;
};
(function(){

XMLWriter.prototype = {
	encoding:'ISO-8859-1',// what is the encoding
	version:'1.0', //what xml version to use
	formatting: 'indented', //how to format the output (indented/none)  ?
	indentChar:'\t', //char to use for indent
	indentation: 1, //how many indentChar to add per level
	newLine: '\n', //character to separate nodes when formatting
	//start a new document, cleanup if we are reusing
	writeStartDocument:function( standalone ){
		this.close();//cleanup
		this.stack = [ ];
		this.standalone = standalone;
	},
	//get back to the root
	writeEndDocument:function(){
		this.active = this.root;
		this.stack = [ ];
	},
	//set the text of the doctype
	writeDocType:function( dt ){
		this.doctype = dt;
	},
	//start a new node with this name, and an optional namespace
	writeStartElement:function( name, ns ){
		if( ns )//namespace
			name = ns + ':' + name;

		var node = { n:name, a:{ }, c: [ ] };//(n)ame, (a)ttributes, (c)hildren

		if( this.active ){
			this.active.c.push(node);
			this.stack.push(this.active);
		}else
			this.root = node;
		this.active = node;
	},
	// Delete last node
	deleteEndElement:function(){
		this.stack.pop();
		this.active.c.pop();
	},
	//go up one node, if we are in the root, ignore it
	writeEndElement:function(){
		this.active = this.stack.pop() || this.root;
	},
	//add an attribute to the active node
	writeAttributeString:function( name, value ){
		if( this.active )
			this.active.a[name] = htmlAttr(value);
	},
	//add a pre-escaped attribute to the active node
	writeRawAttributeString:function( name, value ){
		if( this.active )
			this.active.a[name] = value;
	},
	//add a text node to the active node (XML will be escaped)
	writeString:function( text ){
		if( this.active )
			this.active.c.push(html(text));
	},
	//add XML string to the active node without extra escaping
	writeXML:function( text ){
		if( this.active )
			this.active.c.push(text);
	},
	//shortcut, open an element, write the text and close
	writeElementString:function( name, text, ns ){
		this.writeStartElement( name, ns );
		this.writeString(text);
		this.writeEndElement();
	},
	//add a text node wrapped with CDATA
	writeCDATA:function( text ){
		// keep nested CDATA
		text = text.replace(/>>]/g, "]]><![CDATA[>");
		this.writeString( '<![CDATA[' + text + ']]>' );
	},
	//add a text node wrapped in a comment
	writeComment:function( text ){
		this.writeString('<!-- ' + text + ' -->');
	},
	//generate the xml string, you can skip closing the last nodes
	flush:function(){
		if( this.stack && this.stack[0] )//ensure it's closed
			this.writeEndDocument();

		var
			chr = '', indent = '', num = this.indentation,
			formatting = this.formatting.toLowerCase() == 'indented',
			buffer = '<?xml version="'+this.version+'" encoding="'+this.encoding+'"';

		if( this.standalone !== undefined )
			buffer += ' standalone="' +  (this.standalone ? 'yes' : 'no') + '" ';
		buffer += ' ?>';

		buffer = [buffer];

		if( this.doctype && this.root )
			buffer.push('<!DOCTYPE '+ this.root.n + ' ' + this.doctype+'>');

		if( formatting ){
			while( num-- )
				chr += this.indentChar;
		}

		if( this.root )//skip if no element was added
			format( this.root, indent, chr, buffer );

		return buffer.join( formatting ? this.newLine : '' );
	},
	//cleanup, don't use again without calling startDocument
	close:function(){
		if( this.root )
			clean( this.root );
		this.active = this.root = this.stack = null;
	},
	getDocument: window.ActiveXObject
		? function(){ //MSIE
			var doc = new ActiveXObject('Microsoft.XMLDOM');
			doc.async = false;
			doc.loadXML(this.flush());
			return doc;
		}
		: function(){// Mozilla, Firefox, Opera, etc.
			return (new DOMParser()).parseFromString(this.flush(),'text/xml');
	}
};

var ESCAPES = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	'\t': '&#9;',
	'\n': '&#10;',
	'\r': '&#13;'
};

function html(s) {
	return s.replace(/[&<>"]/g, function (c) { return ESCAPES[c]; });
}

// Escape whitespace in attributes so it is preserved during in-browser
// serialize/parse round-trip.
// See http://www.w3.org/TR/REC-xml/#AVNormalize for browser parsing rules.
function htmlAttr(s) {
	return String(s).replace(/[&<>"\n\r\t]/g, function (c) { return ESCAPES[c]; });
}

//utility, you don't need it
function clean( node ){
	var l = node.c.length;
	while( l-- ){
		if( typeof node.c[l] == 'object' )
			clean( node.c[l] );
	}
	node.n = node.a = node.c = null;
};

//utility, you don't need it
function format( node, indent, chr, buffer ){
	var
		xml = indent + '<' + node.n,
		nc = node.c.length,
		attr, child, i = 0;

	for( attr in node.a )
		xml += ' ' + attr + '="' + node.a[attr] + '"';

	xml += nc ? '>' : ' />';

	buffer.push( xml );

	if( nc ){
		do{
			child = node.c[i++];
			if( typeof child == 'string' ){
				if( nc == 1 )//single text node
					return buffer.push( buffer.pop() + child + '</'+node.n+'>' );
				else //regular text node
					buffer.push( indent+chr+child );
			}else if( typeof child == 'object' ) //element node
				format(child, indent+chr, chr, buffer);
		}while( i < nc );
		buffer.push( indent + '</'+node.n+'>' );
	}
};

})();
define("XMLWriter", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.XMLWriter;
    };
}(this)));

define('vellum/writer',[
    'jquery',
    'underscore',
    'XMLWriter',
    'vellum/util',
], function (
    $,
    _,
    XMLWriter,
    util
) {
    var createXForm = function (form) {
        var xmlWriter = new XMLWriter('UTF-8', '1.0');
        form.vellum.beforeSerialize();

        xmlWriter.writeStartDocument();
        //Generate header boilerplate up to instance level
        xmlWriter.writeStartElement('h:html');
        write_html_tag_boilerplate(xmlWriter, form);
        xmlWriter.writeStartElement('h:head');
        xmlWriter.writeStartElement('h:title');
        xmlWriter.writeString(form.formName);
        xmlWriter.writeEndElement();       //CLOSE TITLE

        xmlWriter.writeStartElement('model');
        xmlWriter.writeStartElement('instance');
        _writeInstanceAttributes(xmlWriter, form.instanceMetadata[0]);

        var dataTree = form.dataTree();
        createDataBlock(form, dataTree, xmlWriter);
        xmlWriter.writeEndElement(); //CLOSE MAIN INSTANCE
        
        // other instances
        for (var i = 1; i < form.instanceMetadata.length; i++) {
            _writeInstance(xmlWriter, form.instanceMetadata[i]);
        }
        
        createBindList(dataTree, xmlWriter);
        
        createSetValues(dataTree, form, xmlWriter);

        form.vellum.contributeToModelXML(xmlWriter, form);
        
        xmlWriter.writeEndElement(); //CLOSE MODEL

        var hashtags = form.knownExternalReferences();
        if (form.richText && !_.isEmpty(hashtags)) {
            xmlWriter.writeStartElement('vellum:hashtags');
            xmlWriter.writeString(JSON.stringify(hashtags));
            xmlWriter.writeEndElement();
        }
        var transforms = form.knownHashtagTransforms();
        if (form.richText && !_.isEmpty(hashtags)) {
            xmlWriter.writeStartElement('vellum:hashtagTransforms');
            xmlWriter.writeString(JSON.stringify(transforms));
            xmlWriter.writeEndElement();
        }

        form.vellum.contributeToHeadXML(xmlWriter, form);

        xmlWriter.writeEndElement(); //CLOSE HEAD

        xmlWriter.writeStartElement('h:body');
        createControlBlock(form, xmlWriter);
        xmlWriter.writeEndElement(); //CLOSE BODY
        xmlWriter.writeEndElement(); //CLOSE HTML
        xmlWriter.writeEndDocument(); //CLOSE DOCUMENT
        form.vellum.afterSerialize();

        return xmlWriter.flush();
    };

    var createModelHeader = function (form, xmlWriter) {
        var uuid, jrm;
        //assume we're currently pointed at the opening date block tag
        //e.g. <model><instance><data> <--- we're at <data> now.

        jrm = form.formJRM;
        if(!jrm) {
            jrm = "http://dev.commcarehq.org/jr/xforms";
        }

        uuid = form.formUuid;
        if(!uuid) {
            uuid = "http://openrosa.org/formdesigner/" + util.generate_xmlns_uuid();
        }

        xmlWriter.writeAttributeString("xmlns:jrm",jrm);
        xmlWriter.writeAttributeString("xmlns", uuid);
        xmlWriter.writeAttributeString("uiVersion", form.formUIVersion || "1");
        xmlWriter.writeAttributeString("version", form.formVersion || "1");
        xmlWriter.writeAttributeString("name", form.formName || gettext("New Form"));
    };

    function write_html_tag_boilerplate (xmlWriter, form) {
        xmlWriter.writeAttributeString( "xmlns:h", "http://www.w3.org/1999/xhtml" );
        xmlWriter.writeAttributeString( "xmlns:orx", "http://openrosa.org/jr/xforms" );
        xmlWriter.writeAttributeString( "xmlns", "http://www.w3.org/2002/xforms" );
        xmlWriter.writeAttributeString( "xmlns:xsd", "http://www.w3.org/2001/XMLSchema" );
        xmlWriter.writeAttributeString( "xmlns:jr", "http://openrosa.org/javarosa" );
        xmlWriter.writeAttributeString( "xmlns:vellum", "http://commcarehq.org/xforms/vellum" );
        var ignore = [];
        if (form.mayDisableRichText && !form.richText) {
            ignore.push('richText');
        }
        if (form.noMarkdown) {
            ignore.push('markdown');
        }
        if (ignore.length) {
            xmlWriter.writeAttributeString("vellum:ignore", ignore.join(" "));
        }
    }

    var _writeInstanceAttributes = function (writer, instanceMetadata) {
        var attrs = instanceMetadata.attributes;
        for (var attrId in attrs) {
            if (attrs.hasOwnProperty(attrId) && attrs[attrId]) {
                writer.writeAttributeString(attrId, attrs[attrId]);
            }
        }
    };

    var _writeInstance = function (writer, instanceMetadata) {
        if (!instanceMetadata.internal) {
            writer.writeStartElement('instance');
            _writeInstanceAttributes(writer, instanceMetadata);
            if (instanceMetadata.children.length) {
                // seriously, this is what you have to do
                // HT: http://stackoverflow.com/questions/652763/jquery-object-to-string
                writer.writeXML($('<div>').append(instanceMetadata.children).clone().html());
            }
            writer.writeEndElement();
        }
    };

    var createDataBlock = function (form, dataTree, xmlWriter) {
        dataTree.walk(function (mug, nodeID, processChildren) {
            if (mug && mug.options.getTagName) {
                nodeID = mug.options.getTagName(mug, nodeID);
                if (nodeID === null) {
                    return;
                }
            }
            xmlWriter.writeStartElement(nodeID);
            if (!mug) {
                // tree root
                createModelHeader(form, xmlWriter);
            } else {
                var rawDataAttributes = mug.p.rawDataAttributes,
                    extra = null;
                if (mug.options.getExtraDataAttributes) {
                    // call this early so it can munge raw attributes
                    extra = mug.options.getExtraDataAttributes(mug);
                }
                // Write any custom attributes first
                for (var k in rawDataAttributes) {
                    if (rawDataAttributes.hasOwnProperty(k)) {
                        xmlWriter.writeAttributeString(k, rawDataAttributes[k]);
                    }
                }

                var dataValue = mug.p.dataValue,
                    xmlnsAttr = mug.p.xmlnsAttr;
                
                if (dataValue){
                    xmlWriter.writeString(dataValue);
                }
                if (mug.options.writeDataNodeXML) {
                    mug.options.writeDataNodeXML(xmlWriter, mug);
                }
                if (mug.p.comment) {
                    xmlWriter.writeAttributeString('vellum:comment', mug.p.comment);
                }
                if (xmlnsAttr){
                    xmlWriter.writeAttributeString("xmlns", xmlnsAttr);
                }
                if (extra) {
                    for (k in extra) {
                        if (extra.hasOwnProperty(k)) {
                            xmlWriter.writeAttributeString(k, extra[k]);
                        }
                    }
                }
            }
            processChildren(mug && mug.options.dataChildFilter);
            xmlWriter.writeEndElement();
        });
    };

    var createBindList = function (dataTree, xmlWriter) {
        dataTree.walk(function (mug, nodeID, processChildren) {
            if(mug && mug.options.getBindList) {
                _.each(mug.options.getBindList(mug), function (attrs) {
                    xmlWriter.writeStartElement('bind');
                    _.each(attrs, function (value, key) {
                        if (value) {
                            util.writeHashtags(xmlWriter, key, value, mug);
                        }
                    });
                    xmlWriter.writeEndElement();
                });
            }
            processChildren();
        });
    };

    var createSetValues = function (dataTree, form, xmlWriter) {
        function writeSetValue(setValue, mug) {
            xmlWriter.writeStartElement('setvalue');
            xmlWriter.writeAttributeString('event', setValue.event);
            util.writeHashtags(xmlWriter, 'ref', setValue.ref, mug);
            util.writeHashtags(xmlWriter, 'value', setValue.value, mug);
            xmlWriter.writeEndElement();
        }

        _.each(form.getSetValues(), function (sv) { writeSetValue(sv, {form: form}); });

        dataTree.walk(function (mug, nodeID, processChildren) {
            if(mug && mug.options.getSetValues) {
                _.each(mug.options.getSetValues(mug), function (setValue) {
                    writeSetValue(setValue, mug);
                });
            }
            processChildren();
        });
    };

    var createControlBlock = function (form, xmlWriter) {
        form.tree.walk(function (mug, nodeID, processChildren) {
            if(!mug) {
                // root node
                processChildren();
                return;
            }

            var opts = mug.options;
            if (opts.isDataOnly) {
                return;
            }
            if (opts.writesOnlyCustomXML) {
                opts.writeCustomXML(xmlWriter, mug);
                return;
            }

            xmlWriter.writeStartElement(mug.options.tagName.toLowerCase());
            if (opts.writeControlLabel) {
                createLabel(xmlWriter, mug);
            }
            if (opts.writeControlHint) {
                createHint(xmlWriter, mug);
            }
            if (opts.writeControlHelp) {
                createHelp(xmlWriter, mug);
            }
            if (opts.writeControlAlert) {
                createAlert(xmlWriter, mug);
            }
            if (opts.writeRepeatItexts) {
                createRepeatButtonItexts(xmlWriter, mug);
            }
            // Write custom attributes first
            var attributes = mug.p.rawControlAttributes;
            for (var k in attributes) {
                if (attributes.hasOwnProperty(k)) {
                    xmlWriter.writeAttributeString(k, attributes[k]);
                }
            }
            if (opts.writeCustomXML) {
                opts.writeCustomXML(xmlWriter, mug);
            }
            if (opts.writeControlRefAttr) {
                var hashtag = mug.hashtagPath;
                util.writeHashtags(xmlWriter, opts.writeControlRefAttr, hashtag, mug);
            }
            var appearanceAttr = mug.getAppearanceAttribute();
            if (appearanceAttr) {
                xmlWriter.writeAttributeString("appearance", appearanceAttr);
            }

            processChildren(opts.controlChildFilter);

            xmlWriter.writeEndElement();
        });
    };

    /**
     * Creates the label tag inside of a control Element in the xform
     */
    function createLabel(xmlWriter, mug) {
        var labelItext = mug.p.labelItext,
            labelRef;
        if (labelItext && labelItext.id) {
            labelRef = "jr:itext('" + labelItext.id + "')";
            // iID is optional so by extension Itext is optional.
            if (labelItext.isEmpty() &&
                    mug.getPresence("labelItext") === 'optional') {
                labelRef = '';
            }
        }
        if (labelRef || mug.p.label) {
            xmlWriter.writeStartElement('label');
            if (labelRef) {
                xmlWriter.writeAttributeString('ref', labelRef);
            }
            if (mug.p.label) {
                xmlWriter.writeString(mug.p.label);
            }
            xmlWriter.writeEndElement(); // close label
        }
    }

    function createHint(xmlWriter, mug) {
        var hintLabel = mug.p.hintLabel,
            hintItext = mug.p.hintItext;
        if (hintLabel || (hintItext && !hintItext.isEmpty())) {
            xmlWriter.writeStartElement('hint');
            if (hintLabel) {
                xmlWriter.writeString(hintLabel);
            }
            if (hintItext && !hintItext.isEmpty()) {
                var ref = "jr:itext('" + hintItext.id + "')";
                xmlWriter.writeAttributeString('ref', ref);
            }
            xmlWriter.writeEndElement();
        }
    }

    function createHelp(xmlWriter, mug) {
        var helpItext = mug.p.helpItext;
        if (helpItext && !helpItext.isEmpty()) {
            xmlWriter.writeStartElement('help');
            var helpRef = "jr:itext('" + helpItext.id + "')";
            xmlWriter.writeAttributeString('ref', helpRef);
            xmlWriter.writeEndElement();
        }
    }

    function createAlert(xmlWriter, mug) {
        var alertItext = mug.p.constraintMsgItext;
        if (alertItext && !alertItext.isEmpty()) {
            xmlWriter.writeStartElement('alert');
            var alertRef = "jr:itext('" + alertItext.id + "')";
            xmlWriter.writeAttributeString('ref', alertRef);
            xmlWriter.writeEndElement();
        }
    }

    function createRepeatButtonItexts(xmlWriter, mug) {
        var addEmptyCaptionItext = mug.p.addEmptyCaptionItext;
        if (addEmptyCaptionItext && !addEmptyCaptionItext.isEmpty()) {
            xmlWriter.writeStartElement('jr:addEmptyCaption');
            var addEmptyCaptionRef = "jr:itext('" + addEmptyCaptionItext.id + "')";
            xmlWriter.writeAttributeString('ref', addEmptyCaptionRef);
            xmlWriter.writeEndElement();
        }
        var addCaptionItext = mug.p.addCaptionItext;
        if (addCaptionItext && !addCaptionItext.isEmpty()) {
            xmlWriter.writeStartElement('jr:addCaption');
            var addCaptionRef = "jr:itext('" + addCaptionItext.id + "')";
            xmlWriter.writeAttributeString('ref', addCaptionRef);
            xmlWriter.writeEndElement();
        }
    }


    return {
        createXForm: createXForm
    };
});

define('vellum/tsv',[
    'underscore'
], function (
    _
) {
    var specialChars = /[\r\n\u2028\u2029"\t]/;

    /**
     * Get a function that returns the next row of tab-separated values
     * each time it is called. Returns null after last row is generated.
     */
    function makeRowParser(value) {
        var simpleLine = /(.*)(?:\n|\r\n|\r|\u2028|\u2029)/mg,
            simpleField = /(.*?)(?:\t|(\n|\r\n|\r|\u2028|\u2029|$))/g,
            quotedField = /^("(?:[^"]|"")*")(?:\t|(\n|\r\n|\r|\u2028|\u2029|$))/,
            escapedQuote = /""/g,
            valueLength = value.length,
            lastIndex = 0;

        function setLastIndex(value) {
            if (value <= lastIndex) {
                // Prevent infinite row generation if somehow the last
                // index does not increase. This should never happen.
                throw new Error("last index " + lastIndex + " -> " + value);
            }
            lastIndex = value;
        }

        function next() {
            if (lastIndex >= valueLength) {
                return null;
            }
            simpleLine.lastIndex = lastIndex;
            var line = simpleLine.exec(value);
            if (line && line[1].indexOf('"') === -1) {
                setLastIndex(simpleLine.lastIndex);
                return line[1].split("\t");
            }
            return parseRow();
        }

        function parseRow() {
            var cell, qcell, row = [];
            simpleField.lastIndex = lastIndex;
            do {
                cell = simpleField.exec(value);
                if (cell[1][0] === '"') {
                    // attempt to parse quoted cell
                    qcell = quotedField.exec(value.slice(lastIndex));
                    if (qcell && qcell[1]) {
                        cell = qcell;
                        cell[1] = cell[1].slice(1, -1).replace(escapedQuote, '"');
                        simpleField.lastIndex = lastIndex + cell[0].length;
                    }
                }
                row.push(cell[1]);
                setLastIndex(simpleField.lastIndex);
            } while (lastIndex < valueLength && _.isUndefined(cell[2]));
            return row;
        }

        return next;
    }

    /**
     * Escape a TSV field value
     *
     * This will convert any object to a string, regardless of whether
     * the object has a nice string representation that would be
     * converted back to the original value by the parser. Null and
     * undefined values are converted to empty string.
     *
     * @param value - a field value.
     * @returns - a string, the escaped field value.
     */
    function escape(value) {
        if (value === null || _.isUndefined(value)) {
            value = "";
        } else {
            value = String(value);
        }
        if (specialChars.test(value)) {
            value = '"' + value.replace(/"/g, '""') + '"';
        }
        return value;
    }

    /**
     * Serialize an array of rows to a tab-delimited string
     *
     * Each row is expected to be an array of field values, which will
     * be converted to strings using the `escape` function.
     *
     * @param rows - an array of row arrays.
     * @returns - a string, the tab-delimited rows. One row per line.
     */
    function tabDelimit(rows) {
        return _.map(rows, function (row) {
            return _.map(row, escape).join("\t");
        }).join("\n");
    }

    return {
        escape: escape,
        makeRowParser: makeRowParser,
        tabDelimit: tabDelimit
    };
});

define('vellum/exporter',[
    'vellum/tsv',
    'vellum/richText'
], function (
    tsv,
    richText
) {
    // todo: abstract out IText stuff into part of the plugin interface
    var generateExportTSV = function (form) {
        var languages = form.vellum.data.javaRosa.Itext.getLanguages();

        var itextColumns = {
            "default": "Text",
            "audio": "Audio",
            "image": "Image",
            "video": "Video",
            "video-inline": "Video Inline",
        };

        var columnOrder = [
            "Question",
            "Type"
        ];

        for (var type in itextColumns) {
            var colName = itextColumns[type];

            for (var i = 0; i < languages.length; i++) {
                columnOrder.push(colName + " (" + languages[i] + ")");
            }
        }

        columnOrder = columnOrder.concat([
            "Display Condition",
            "Validation Condition",
            "Validation Message",
            "Calculate Condition",
            "Required",
            "Hint Text",
            "Help Text",
            "Comment",
        ]);
        const formContainsRepeatGroup = Boolean(form.getMugList().find(mug => mug.options.isRepeat));
        if (formContainsRepeatGroup && form.vellum.opts().features.use_custom_repeat_button_text) {
            columnOrder = columnOrder.concat(["'Add New' Button Text", "'Add Another' Button Text"]);
        }

        var mugToExportRow = function (mug) {
            var row = {},
                itext = mug.p.labelItext,
                defaultLanguage = form.vellum.data.javaRosa.Itext.getDefaultLanguage(),
                i;

            var defaultOrNothing = function (item, language, form) {
                return (item && item.hasForm(form)) ?
                    item.getForm(form).getValueOrDefault(language) : "";
                // TODO see newline treatment in javaRosa.js TSV logic
                //return value.replace(/\r?\n/g, "&#10;");
            };

            // initialize all columns to empty string
            for (i = 0; i < columnOrder.length; i++) {
                row[columnOrder[i]] = "";
            }

            if (mug.options.tagName !== "item") {
                row.Question = mug.absolutePathNoRoot;
            } else {
                row.Question = mug.parentMug.absolutePathNoRoot +
                                "-" + mug.p.nodeID;
            }
            row.Type = mug.options.typeName;

            if (!mug.options.isDataOnly) {
                for (var type in itextColumns) {
                    var colName = itextColumns[type];

                    for (i = 0; i < languages.length; i++) {
                        var key = colName + " (" + languages[i] + ")";
                        row[key] = defaultOrNothing(itext, languages[i], type);
                    }
                }
            }

            if (mug.p.getDefinition('relevantAttr')) {
                row["Display Condition"] = mug.p.relevantAttr;
                row["Calculate Condition"] = mug.p.calculateAttr;
                row.Required = mug.p.requiredAttr ? 'yes' : 'no';
                row["Required Condition"] = mug.p.requiredCondition;

                row["Validation Condition"] = mug.p.constraintAttr;
                row["Validation Message"] = defaultOrNothing(
                    mug.p.constraintMsgItext,
                    defaultLanguage, 'default');
            }

            row["Hint Text"] = defaultOrNothing(mug.p.hintItext, defaultLanguage, 'default');
            row["Help Text"] = defaultOrNothing(mug.p.helpItext, defaultLanguage, 'default');
            if (formContainsRepeatGroup && mug.options.customRepeatButtonText) {
                row["'Add New' Button Text"] = defaultOrNothing(mug.p.addEmptyCaptionItext, defaultLanguage, 'default');
                row["'Add Another' Button Text"] = defaultOrNothing(mug.p.addCaptionItext, defaultLanguage, 'default');
            }
            row.Comment = richText.sanitizeInput(mug.p.comment);

            // make sure there aren't any null values
            for (var prop in row) {
                if (row.hasOwnProperty(prop)) {
                    row[prop] = row[prop] || "";
                }
            }

            return columnOrder.map(function (column) { return row[column]; });
        };

        var rows = [columnOrder].concat(form.getMugList().map(mugToExportRow));
        return tsv.tabDelimit(rows);
    };

    return {
        generateExportTSV: generateExportTSV
    };
});

define('vellum/form',[
    'require',
    'underscore',
    'jquery',
    'vellum/tree',
    'vellum/logic',
    'vellum/richText',
    'vellum/xpath',
    'vellum/escapedHashtags',
    'vellum/fuse',
    'vellum/undomanager',
    'vellum/util',
    'vellum/hqAnalytics',
], function (
    require,
    _,
    $,
    Tree,
    logic,
    richText,
    xpath,
    escapedHashtags,
    Fuse,
    undomanager,
    util,
    analytics
) {
    // Load these dependencies in the background after all other run-time
    // dependencies have been resolved, since they shouldn't be necessary
    // initially.
    var writer,
        exporter;
    require(['vellum/writer', 'vellum/exporter'], function (w, e) {
        writer = w;
        exporter = e;
    });

    var FormError = function (options) {
        var that = {};
        that.message = options.message;
        // the key is how uniqueness is determined
        that.key = options.key; 
        that.level = options.level || "form-warning";
        that.options = options;
        
        that.isMatch = function (other) {
            if (this.key && other.key) {
                return this.key === other.key;
            }
            return false;
        };
        
        return that;
    };

    var InstanceMetadata = function (attributes, children, mug, property) {
        var that = {},
            refs = {};
        that.attributes = attributes;
        that.children = children || [];

        /**
         * Add a reference from mug/property to this instance
         *
         * This does nothing if ref counting is disabled for this instance.
         *
         * @param mug - the referencing mug. Ref counting will be disabled
         *      for this instance if this is evaluates to false.
         * @param property - the property referencing this instance. A generic
         *      reference will be created if this evaluates to false.
         */
        that.addReference = function (mug, property) {
            if (!refs) { return; }
            if (!mug) {
                // disable ref counting for this instance. how unfortunate
                refs = null;
            } else {
                if (!refs[mug.ufid]) {
                    refs[mug.ufid] = {};
                }
                refs[mug.ufid][property || "."] = null;
            }
        };

        /**
         * Drop reference from mug/property to this instance
         *
         * @param mug - the referencing mug. Must be a real mug.
         * @param property - the property referencing this instance. All
         *      references from mug will be removed if this evaluates to false.
         * @returns - true if the last reference to this instance was dropped,
         *      otherwise false. Note: returns false if the given mug did not
         *      reference this instance, even if there are no other references.
         */
        that.dropReference = function (mug, property) {
            if (refs && refs[mug.ufid]) {
                if (property) {
                    delete refs[mug.ufid][property];
                    if (_.isEmpty(refs[mug.ufid])) {
                        delete refs[mug.ufid];
                    }
                } else {
                    delete refs[mug.ufid];
                }
                return _.isEmpty(refs);
            }
            return false;
        };

        if (!_.isUndefined(mug)) {
            that.addReference(mug, property);
        }
        return that;
    };
    var INSTANCE_REGEXP = /(^)instance\((['"])([^'"]+)\2\)/i,
        HASHTAG_NAMESPACE = /^#([^\/]+)/;

    function Form (opts, vellum, mugTypes) {
        var _this = this;

        this.setValues = [];
        this._setValueId = 1;

        this._logicManager = new logic.LogicManager(this, {
                allowedDataNodeReferences: opts.allowedDataNodeReferences
            });

        // Some things in the form and mug methods depend on the UI.  These
        // should eventually be factored out.
        this.vellum = vellum;
        this.mugTypes = mugTypes;

        this.formName = vellum.opts().core.formName || gettext("New Form");
        this.noMarkdown = false;
        this.mugMap = {};
        this.instanceMetadata = [InstanceMetadata({})];
        // {<instance id>: { src or children: <instance src or children>}
        this.knownInstances = {};
        this.richText = !!vellum.opts().features.rich_text;
        // TODO remove mayDisableRichText once the rich_text feature is enabled
        // by default. Otherwise instances of vellum loaded without rich_text
        // specified in features will always write vellum:ignore="richText"
        this.mayDisableRichText = this.richText;

        this._inferHashtags = makeHashtagInferencer(this);
        this.shouldInferHashtags = this.richText;
        vellum.datasources.on("change", this._updateHashtags.bind(this), null, null, this);
        this._updateHashtags();
        this.transformHashtags = escapedHashtags.makeHashtagTransform(this);

        this.tree = new Tree('data', 'control');
        // initalize #form as /data
        // if data is not root node, it will be changed later
        this.addHashtag('#form', '/data');
        this.tree.on('change', function (e) {
            _this.fireChange(e.mug);
        });
        this.enableInstanceRefCounting = opts.enableInstanceRefCounting;
        this.errors = [];
        this.question_counter = 1;
        this.xpath = xpath.parser(this);
        this.undomanager = new undomanager();

        this.undomanager.on('reset', function(e) {
            _this.vellum.adjustToWindow();
        });

        //make the object event aware
        util.eventuality(this);
        this.on('form-load-finished', function() {
            _this.fuse = new Fuse(_this);
        }).on('question-create', function () {
            _this.undomanager.resetUndo();
        });
        this.disconnectDataSources = function () {
            vellum.datasources.unbind(_this, "change");
        };
    }

    Form.prototype = {
        _updateHashtags: function () {
            var form = this,
                vellum = form.vellum,
                oldHashtags = form.hashtagMap;
            form.hashtagNamespaces = {form: true};
            if (form.richText) {
                // TODO always load hashtags, even when rich text is disabled
                form.hashtagMap = _.clone(vellum.datasources.getHashtagMap({}));
                form.invertedHashtagMap = _.invert(form.hashtagMap);
                form.hashtagTransformations = vellum.datasources.getHashtagTransforms({});
                form.hasCaseHashtags = vellum.datasources.isReady();
                form.shouldInferHashtags = !form.hasCaseHashtags;
                _.each(form.hashtagTransformations, function (x, prefix) {
                    form.hashtagNamespaces[HASHTAG_NAMESPACE.exec(prefix)[1]] = true;
                });
            } else {
                form.hashtagMap = {};
                form.invertedHashtagMap = {};
                form.hashtagTransformations = {};
            }
            form.updateKnownInstances(
                _.chain(vellum.datasources.getDataSources([]))
                 .map(function (source) { return [source.id, source.uri]; })
                 .object()
                 .value()
            );
            if (oldHashtags) {
                _.each(oldHashtags, function (xpath, tag) {
                    if (tag.startsWith("#form/")) {
                        form.addHashtag(tag, xpath);
                    }
                });
            }
            // done here for performance reasons. would be nice to be done after
            // every new hashtag, but only for the mugs that reference that hashtag
            form.fixBrokenReferences();
            this._logicManager.validateExternalReferences();
        },
        inferHashtagMeanings: function(hashtag, xpath_) {
            if (hashtag && xpath && this.shouldInferHashtags) {
                this._inferHashtags(hashtag, xpath_);
            }
        },
        isValidHashtag: function(tag) {
            tag = this.normalizeHashtag(tag);
            return this.hashtagMap.hasOwnProperty(tag);
        },
        /**
         * Check if tag has a valid hashtag prefix
         *
         * A valid hashtag prefix ends with a slash, and the given value must
         * contain at least one character after the slash. This does a raw
         * string analysis, it does not convert xpath expressions to hashtags.
         */
        hasValidHashtagPrefix: function(tag) {
            var lastSlashIndex = tag.lastIndexOf("/");
            return lastSlashIndex !== -1 &&
                tag.length > lastSlashIndex + 1 &&
                this.hashtagTransformations.hasOwnProperty(tag.substring(0, lastSlashIndex + 1));
        },
        addHashtag: function(hashtag, xpath) {
            this.hashtagMap[hashtag] = xpath;
            this.invertedHashtagMap[xpath] = hashtag;
        },
        initHashtag: function(hashtag, xpath) {
            if (!this.hashtagMap[hashtag]) {
                this.addHashtag(hashtag, xpath);
                this.hashtagNamespaces[HASHTAG_NAMESPACE.exec(hashtag)[1]] = true;
            }
        },
        removeHashtag: function(hashtag) {
            if (this.hashtagMap.hasOwnProperty(hashtag)) {
                delete this.invertedHashtagMap[this.hashtagMap[hashtag]];
                delete this.hashtagMap[hashtag];
            }
        },
        normalize: function (methodName, xpath, strict) {
            if (!xpath || (this.richText && richText.isInvalid(xpath))) {
                return xpath;
            }
            // try catch is needed as workaround for having an itemset without
            // the itemset plugin enabled
            try {
                return this.xpath.parse(xpath)[methodName]();
            } catch (err) {
                return strict ? null : xpath;
            }
        },
        normalizeHashtag: function (xpath_, strict) {
            return this.normalize('toHashtag', xpath_, strict);
        },
        normalizeXPath: function (xpath_) {
            return this.normalize('toXPath', xpath_);
        },
        getHashtagsInXPath: function (xpath_) {
            try {
                return new logic.LogicExpression(xpath_, this.xpath).getHashtags();
            } catch (err) {
                return [];
            }
        },
        knownExternalReferences: function () {
            return this._logicManager.knownExternalReferences();
        },
        knownHashtagTransforms: function () {
            var data = {},
                prefixes = this.hashtagTransformations;
            if (!_.isEmpty(this.hashtagTransformations)) {
                // Save as "prefixes" leaving room for other types in future
                data.prefixes = _.object(_.map(prefixes, function (func, key) {
                    return [key, func("")];
                }));
            }
            return data;
        },
        referenceHashtag: function(hashtag, mug, property) {
            if (this.hasValidHashtagPrefix(hashtag)) {
                this.referenceInstance('casedb', mug, property);
                this.referenceInstance('commcaresession', mug, property);
            }
        },
        dataTree: function() {
            var rootId = this.getBasePath().slice(1,-1),
                dataTree = new Tree(rootId, 'data'),
                diffDataParents = {},
                _this = this;
            this.tree.walk(function(mug, nodeID, processChildren) {
                if (mug) {
                    if (mug.options.isControlOnly) {
                        return;
                    } else if (mug.p.dataParent) {
                        var dp = mug.p.dataParent;
                        if (diffDataParents[dp]) {
                            diffDataParents[dp].push(mug);
                        } else {
                            diffDataParents[dp] = [mug];
                        }
                    } else {
                        dataTree.insertMug(mug, 'into', mug.parentMug);
                    }
                }
                processChildren();
            });
            _.each(diffDataParents, function (mugs, dataParent) {
                var dataParentMug = _this.mugMap[_this.normalizeHashtag(dataParent)];
                for (var i = 0, len = mugs.length; i < len; i++) {
                    dataTree.insertMug(mugs[i], 'into', dataParentMug);
                }
            });
            return dataTree;
        },
        getBasePath: function (noSep) {
            return "/" + this.tree.getRootNode().getID() + (noSep ? "" : "/");
        },
        fireChange: function (mug) {
            this.fire({
                type: 'change',
                mug: mug
            });
        },
        /**
         * Add an instance if it is not already on the form
         *
         * @param attrs - Instance attributes. The `src` attribute is used to
         *          match other instances on the form. A matching instance will
         *          be found by `id` if the instance has no `src` attribute.
         *          If no matching instance is found, a new instance will be
         *          added with a unique `id`.
         * @param mug - (optional) The mug with which this query is associated.
         *          This and the next parameter are used for instance ref
         *          counting. If omitted, ref counting will be disabled for the
         *          instance.
         * @param property - (optional) The mug property name.
         * @returns - The `id` of the added or already-existing instance.
         */
        addInstanceIfNotExists: function (attrs, mug, property) {
            function getUniqueId(id, ids) {
                var temp = (id || "data") + "-",
                    num = 1;
                while (!id || ids.hasOwnProperty(id)) {
                    id = temp + num;
                    num++;
                }
                return id;
            }
            var meta;
            if (attrs.src) {
                meta = _.find(this.instanceMetadata, function (m) {
                    return m.attributes.src === attrs.src;
                });
                if (!meta) {
                    // attrs.src not found, try to find by id
                    var ids = _.indexBy(this.instanceMetadata, function (m) {
                            return m.attributes.id;
                        });
                    meta = attrs.id && ids.hasOwnProperty(attrs.id) ? ids[attrs.id] : null;
                    if (meta && meta.internal) {
                        // assign new src to internal instance
                        meta.internal = false;
                        meta.attributes.src = attrs.src;
                    } else {
                        // assign unique id to attrs (will create new meta)
                        attrs = _.clone(attrs);
                        attrs.id = getUniqueId(attrs.id, ids);
                        meta = null;
                    }
                    this.knownInstances[attrs.id] = { src: attrs.src };
                }
            } else if (attrs.id) {
                // attrs has no src, find by id
                meta = _.find(this.instanceMetadata, function (m) {
                    return m.attributes.id === attrs.id;
                });
                if (meta) {
                    if (meta.internal && this.knownInstances.hasOwnProperty(attrs.id)) {
                        meta.internal = false;
                        meta.attributes.src = this.knownInstances[attrs.id].src;
                    }
                } else if (this.knownInstances.hasOwnProperty(attrs.id)) {
                    _.defaults(attrs, this.knownInstances[attrs.id]);
                }
            } else {
                throw new Error("unsupported: non-primary instance without id or src");
            }
            if (!meta) {
                meta = InstanceMetadata({
                    src: attrs.src,
                    id: attrs.id
                }, attrs.children, mug || null, property);
                if (!attrs.src && !attrs.children) {
                    meta.internal = true;
                }
                this.instanceMetadata.push(meta);
                return attrs.id;
            } else if (this.enableInstanceRefCounting) {
                meta.addReference(mug, property);
            }
            return meta.attributes.id;
        },
        /**
         * Parse query and get instance metadata
         *
         * This adds a reference to the instance if found.
         *
         * TODO eliminate this method after refactoring callers to not
         * use it (there can be more than one instance reference in an
         * XPath query, so this doesn't make much sense).
         *
         * @param query - A query string, which may start with "instance(...)"
         * @param mug - The mug with which this query is associated.
         * @param property - (optional) The mug property name for the query.
         * @reutrns - an object containing instance attributes or null.
         */
        parseInstance: function (query, mug, property) {
            var match = query.match(INSTANCE_REGEXP),
                instance = null;
            if (match) {
                var instanceId = match[3],
                    meta = this.referenceInstance(instanceId, mug, property);
                if (meta) {
                    instance = _.clone(meta.attributes);
                }
            }
            return instance;
        },
        /**
         * Parse query and get a mapping of instance id: src
         *
         * @param query - A query string, which may contain "instance(...)"
         * @param mug - The mug with which this query is associated.
         * @param property - (optional) The mug property name for the query.
         * @reutrns - {<id>: <src>, ...}
         */
        parseInstanceRefs: function (query, mug, property) {
            var expr = new logic.LogicExpression(query, this.xpath),
                knownInstances = this.knownInstances,
                instances = {};
            expr.analyze();
            _.each(expr.instanceRefs, function (ignore, id) {
                if (knownInstances.hasOwnProperty(id) && knownInstances[id]) {
                    instances[id] = util.extend(knownInstances[id]);
                    if (instances[id].children) {
                        instances[id].children = $('<div>').append(instances[id].children).html();
                    }
                }
            });
            return instances;
        },
        referenceInstance: function (id, mug, property) {
            function idMatch(meta) {
                return meta.attributes.id === id;
            }
            var meta = _.find(this.instanceMetadata, idMatch);
            if (this.enableInstanceRefCounting) {
                if (meta) {
                    meta.addReference(mug, property);
                } else {
                    id = this.addInstanceIfNotExists({id: id}, mug, property);
                    meta = _.find(this.instanceMetadata, idMatch);
                }
            }
            return meta || null;
        },
        /**
         * Replace the instance id in the given query (utility function)
         *
         * Is it too magical to replace the instance id in the query?
         * There might be edge cases where a user is entering a
         * custom instance and query and does not want this.
         */
        updateInstanceQuery: function (query, instanceId, oldId) {
            var regexp = INSTANCE_REGEXP;
            if (oldId) {
                regexp = new RegExp("(^|\W)instance\\((['\"])" +
                                    RegExp.escape(oldId) + "\2\\)", "ig");
            }
            return query.replace(regexp, "$1instance('" + instanceId + "')");
        },
        /**
         * Update internal record of instances known by this form
         *
         * @param map - an object mapping instance IDs to instance sources.
         *      If not given, update the form's internal known instances
         *      using instance metadata in the form.
         */
        updateKnownInstances: function (map) {
            var instances = this.knownInstances;
            if (map) {
                var metas = _.indexBy(this.instanceMetadata, function (m) {
                        return m.attributes.id;
                    });
                _.each(map, function (instance, id) {
                    if (instance && !instances.hasOwnProperty(id)) {
                        if (instance.children) {
                            instances[id] = { children: $(instance.children)};
                        } else if (_.isString(instance)){
                            // assume a string is the src
                            instances[id] = { src: instance };
                        } else {
                            // assume we are fed a correct instance dict
                            instances[id] = instance;
                        }
                        var meta = metas[id];
                        if (meta && meta.internal) {
                            meta.internal = false;
                            meta.attributes.src = instances[id].src;
                        }
                    }
                });
            } else {
                _.each(this.instanceMetadata, function (meta) {
                    if (!meta.attributes.id) {
                        return;
                    }
                    if (meta.attributes.src) {
                        instances[meta.attributes.id] = { src: meta.attributes.src };
                    } else if (meta.children) {
                        instances[meta.attributes.id] = { children: meta.children };
                    }
                });
            }
        },
        /**
         * Drop instance reference, possibly removing the instance
         *
         * @param src - The instance `src` attribute value.
         * @param mug - (optional) A mug that references the query.
         * @param property - (optional) The mug property name for the query.
         * @returns - True if the instance was removed, otherwise false.
         */
        dropInstanceReference: function (src, mug, property) {
            if (!this.enableInstanceRefCounting || !mug) {
                return false;
            }
            var meta = _.find(this.instanceMetadata, function (m) {
                    return m.attributes.src === src;
                });
            if (meta) {
                if (meta.dropReference(mug, property)) {
                    this.instanceMetadata = _.without(this.instanceMetadata, meta);
                    return true;
                }
            }
            return false;
        },
        /**
         * Drop all instance references from the given mug/property
         */
        dropAllInstanceReferences: function (mug, property) {
            this.instanceMetadata = _.filter(this.instanceMetadata, function (meta) {
                return !meta.dropReference(mug, property);
            });
        },
        // todo: update references on rename
        addSetValue: function (event, ref, value) {
            var setValue = _.find(this.setValues, function (setValue) {
                return setValue.event === event && setValue.ref === ref;
            });
            if (setValue) {
                setValue.value = value;
            } else {
                setValue = {
                    _id: this._setValueId++,
                    event: event,
                    ref: ref,
                    value: value
                };
                this.setValues.push(setValue);
            }
            return setValue;
        },
        getSetValues: function () {
            return this.setValues;
        },
        dropSetValues: function (predicate) {
            // Remove all <setvalue> elements matching predicate
            this.setValues = _.reject(this.setValues, predicate);
        },
        setFormID: function (id) {
            this.tree.setRootID(id);
            this.addHashtag('#form', '/' + id);
        },
        setAttr: function (slug, val) {
            this[slug] = val;
            if (slug === "richText" && val && !this.hasCaseHashtags) {
                // TODO remove this if/when hashtags are loaded on form init
                this._updateHashtags();
            }
            this.fire({
                type: 'change'
            });
        },
        createXML: function () {
            return writer.createXForm(this);
        },
        /**
         * Walks through internal tree and grabs
         * all mugs that are not (1)Choices.  Returns
         * a flat list of unique mugs.  This list is primarily for the
         * autocomplete skip logic wizard.
         */
        getMugList: function () {
            return this.tree.treeMap( function (node) {
                if(node.isRootNode) {
                    return;
                }

                return node.getValue();
            });
        },
        /**
         * Add parsing error to the form
         *
         * NOTE these errors are displayed on form load only.
         */
        updateError: function (errObj) {
            errObj = FormError(errObj);
            if (!errObj.key) {
                this.errors.push(errObj);
            }
            else {
                var removed = null;
                for (var i = 0; i < this.errors.length; i++) {
                    if (errObj.isMatch(this.errors[i])) {
                        removed = this.errors.splice(i, 1, errObj);
                    }
                }
                if (!removed) {
                    this.errors.push(errObj);
                }
            }
        },
        /**
         * Get a list of warnings pertaining to form serialization
         *
         * All serialization warnings reported here can be fixed
         * automatically, but the user may prefer to fix them manually.
         *
         * @returns - A list of error objects. See
         * `Mug.getSerializationWarnings` for more details.
         */
        getSerializationWarnings: function () {
            var errors = [];
            this.walkMugs(function (mug) {
                var errs = mug.getSerializationWarnings();
                if (errs.length) {
                    errors.push({mug: mug, errors: errs});
                }
            });
            return errors;
        },
        /**
         * Automatically fix serialization errors
         *
         * After fixing serialization errors, no more errors
         * should be reported by `getSerializationWarnings`.
         *
         * @param errors - The list of error objects returned by
         *                 `getSerializationWarnings`.
         */
        fixSerializationWarnings: function (errors) {
            _.each(errors || [], function (error) {
                error.mug.fixSerializationWarnings(error.errors);
            });
        },
        isFormValid: function (validateMug) {
            return this.tree.isTreeValid(validateMug);
        },
        findFirstMatchingChild: function (parentMug, match) {
            var parent = (parentMug ? this.tree.getNodeFromMug(parentMug)
                                    : this.tree.rootNode);
            return _.find(parent.getChildrenMugs(), match);
        },
        insertMug: function (refMug, newMug, position) {
            this.tree.insertMug(newMug, position, refMug);
        },
        /**
         * Move a mug from its current place to
         * the position specified by the arguments.
         *
         * NOTE the canonical way to rename a mug is to set its
         * `nodeID` property: `mug.p.nodeID = "name"`
         *
         * @param mug - The mug to be moved.
         * @param position - The position relative to `refMug`
         *          ("after", "into", "last", etc.) or "rename", in
         *          which case `refMug` is the new name.
         * @param refMug - The mug relative to which `mug` is moving.
         *          Alternately, the new name if `position` is "rename".
         */
        moveMug: function (mug, position, refMug) {
            function match(sibling) {
                return sibling !== mug && sibling.p.nodeID === newId;
            }
            var newId, oldId, oldPath, oldParent, conflictParent;

            if (position === "rename") {
                newId = refMug;
                if (!this.tree.getNodeFromMug(mug)) {
                    // skip conflict resolution if not in tree
                    mug.p.set("nodeID", newId);
                    return;
                }
                oldId = mug.p.nodeID;
                oldPath = mug.hashtagPath;
                oldParent = conflictParent = mug.parentMug;
            } else {
                oldId = mug.p.nodeID;
                oldPath = mug.hashtagPath;
                oldParent = mug.parentMug;
                this.insertMug(refMug, mug, position);
                var spec = mug.spec.dataParent;
                if (spec && spec.validationFunc(mug) !== 'pass') {
                    mug.p.set("dataParent"); // clear dataParent
                }
                newId = mug.p.conflictedNodeId || oldId;
                conflictParent = mug.parentMug;
            }

            if (!mug.options.isControlOnly) {
                if (this.findFirstMatchingChild(conflictParent, match)) {
                    mug.p.conflictedNodeId = newId;
                    newId = this.generate_question_id(newId, mug);
                } else if (mug.p.has("conflictedNodeId")) {
                    mug.p.conflictedNodeId = null;
                }

                if (mug.p.nodeID !== newId) {
                    // rename without events; nodeID setter calls form.moveMug
                    mug.p.set("nodeID", newId);
                }
            }

            var newPath = mug.hashtagPath;
            this.vellum.handleMugRename(
                this, mug, newId, oldId, newPath, oldPath, oldParent);

            if (position !== "rename") {
                this.fireChange(mug);
            }
        },
        /**
         * Walk through the mugs of the tree and call valueFunc on each mug
         *
         * @param valueFunc - a function called for each mug in the tree. The
         * single argument is the mug.
         */
        walkMugs: function (valueFunc) {
            function callback(mug, nodeID, processChildren) {
                if (mug !== null) {
                    valueFunc(mug);
                }
                processChildren();
            }
            this.tree.walk(callback);
        },
        getDescendants: function (mug) {
            var desc = this.getChildren(mug), i;
            for (i = desc.length - 1; i >= 0; i--) {
                desc = desc.concat(this.getDescendants(desc[i]));
            }
            return desc;
        },
        /**
         * Update references to mug and its children after it is renamed.
         */
        handleMugRename: function (mug, newId, oldId, newPath, oldPath, oldParent) {
            function getPreMovePath(postPath) {
                if (postPath === newPath) {
                    return oldPath;
                }
                return postPath.replace(postRegExp, oldPath + "/");
            }
            this._logicManager.updatePath(mug.ufid, oldPath, newPath);
            if (!newPath) {
                // Items don't have an absolute path. I wonder if it would
                // matter if they had one?
                return;
            }
            var mugs = this.getDescendants(mug).concat([mug]),
                postMovePaths = _(mugs).map(function(mug) { return mug.hashtagPath; }),
                postRegExp = new RegExp("^" + RegExp.escape(newPath) + "/"),
                updates = {},
                preMovePath;
            for (var i = 0; i < mugs.length; i++) {
                if (postMovePaths[i]) {
                    preMovePath = getPreMovePath(postMovePaths[i]);
                    updates[mugs[i].ufid] = [preMovePath, postMovePaths[i]];
                    this._updateMugPath(mugs[i], preMovePath, postMovePaths[i]);
                }
            }
            this._logicManager.updatePaths(updates);
            this.fixBrokenReferences();
            // TODO make Item not a special case
            if (oldId && mug.__className !== "Choice") {
                // update first child of old parent with matching conflicted nodeID
                var conflict = this.findFirstMatchingChild(oldParent, function (mug) {
                        return mug.p.conflictedNodeId === oldId;
                    });
                if (conflict) {
                    this.moveMug(conflict, "rename", oldId);
                }
            }
        },
        changeMugType: function (mug, questionType) {
            var _this = this;
            _this.mugTypes.changeType(mug, questionType);
        },
        getChildren: function (mug) {
            var ctrlNode = this.tree.getNodeFromMug(mug),
                ctrlNodes = ctrlNode ? ctrlNode.getChildren() : [];
            return ctrlNodes.map(function (item) { return item.getValue(); });
        },
        duplicateMug: function (mug) {
            var foo = this._duplicateMug(mug, mug.parentMug),
                duplicate = foo[0],
                pathReplacements = foo[1];

            analytics.workflow('Form Builder', 'Copy', duplicate.options.typeName);

            for (var i = 0; i < pathReplacements.length; i++) {
                var pr = pathReplacements[i];
                this._logicManager.updatePath(pr.mugId, pr.from, pr.to, duplicate.hashtagPath);
            }
            return duplicate;
        },
        /**
         * Copy a Mug and its descendants and insert them after the original
         * Mug. Returns an array with two values:
         *  1. The duplicate Mug.
         *  2. An array of path replacements that should be executed on logic references.
         *
         * @param mug - the mugtype in the original tree to duplicate
         * @param parentMug - the mugtype in the duplicate tree to insert into
         *        
         */
        _duplicateMug: function (mug, parentMug, depth) {
            depth = depth || 0;
            var duplicate = this.mugTypes.make(mug.__className, this, mug);

            if (depth === 0) {
                var nodeID = mug.p.nodeID;
                if (duplicate.p.conflictedNodeId) {
                    duplicate.p.conflictedNodeId = null;
                } else {
                    duplicate.p.nodeID = this.generate_question_id(nodeID, mug);
                }
                
                this.insertQuestion(duplicate, mug, 'after', true);
            } else {
                this.insertQuestion(duplicate, parentMug, 'into', true);
            }

            this.updateLogicReferences(duplicate);
            this.vellum.duplicateMugProperties(duplicate);

            var children = this.getChildren(mug),
                pathReplacements = [];
            for (var i = 0; i < children.length; i++) {
                pathReplacements = pathReplacements.concat(
                    this._duplicateMug(children[i], duplicate, depth + 1)[1]);
            }

            pathReplacements.push({
                mugId: mug.ufid,
                from: mug.hashtagPath,
                to: duplicate.hashtagPath,
            });

            return [duplicate, pathReplacements];
        },
        updateLogicReferences: function (mug, property, value) {
            this._logicManager.updateReferences(mug, property, value);
        },
        /**
         * Determine if a mug property should change
         *
         * This method must be called before the property value has changed.
         *
         * Returns a function that should be called after the property has
         * changed; null if the property should not change.
         */
        shouldMugPropertyChange: function (mug, property, value, previous) {
            if (this.isLoadingXForm) {
                // skip property change handlers during loading phase
                return function () {};
            }

            return function () {
                // legacy, enables auto itext ID behavior, don't add
                // additional dependencies on this code.  Some sort of
                // data binding would be better.
                mug.fire({
                    type: 'property-changed',
                    property: property,
                    val: value,
                    previous: previous
                });

                var event = {
                    type: 'mug-property-change',
                    mug: mug,
                    property: property,
                    val: value,
                    previous: previous
                };
                mug.validate(property);
                this.fire(event);

                this.fireChange(mug);
            }.bind(this);
        },
        createQuestion: function (refMug, position, newMugType, isInternal) {
            var mug = this.mugTypes.make(newMugType, this);
            if (isInternal && !mug.options.isControlOnly) {
                mug.p.nodeID = this.generate_question_id();
            }
            if (mug.__className === "Choice") {
                mug.p.nodeID = "";
            }
            this.insertQuestion(mug, refMug, position, isInternal);

            // Choice require a nodeID and a label, but give user
            // a chance to enter them before displaying an error
            if (mug.__className === "Choice") {
                mug.dropMessage("labelItext", "mug-labelItext-error");
                mug.dropMessage("nodeID", "mug-nodeID-error");
            }

            // should we fix broken references when nodeID is auto-generated?
            //if (!mug.options.isControlOnly && !this.isLoadingXForm) {
            //    this.fixBrokenReferences();
            //}
            return mug;
        },
        insertQuestion: function (mug, refMug, position, isInternal) {
            this.mugMap[mug.ufid] = mug;
            refMug = refMug || this.tree.getRootNode().getValue();
            this.insertMug(refMug, mug, position);
            this._updateMugPath(mug);

            this.fire({
                type: 'question-create',
                mug: mug,
                refMug: refMug,
                position: position,
                isInternal: isInternal
            });
            if (!isInternal) {
                mug.options.afterInsert(this, mug);
            }
        },
        _updateMugPath: function (mug, oldHashtag, newHashtag) {
            var map = this.mugMap, newPath;
            delete map[this.normalizeHashtag(oldHashtag)];
            if (oldHashtag) {
                this.removeHashtag(oldHashtag);
            }
            if (_.isUndefined(newHashtag)) {
                newPath = mug.absolutePath;
                newHashtag = mug.hashtagPath;
            } else {
                newPath = newHashtag.replace(/^#form/, this.getBasePath(true));
                if (newPath === newHashtag) {
                    // this happens if _updateMugPath is commtrack (#supply one day)
                    newPath = null;
                }
            }
            if (newHashtag) {
                if (newPath) {
                    this.addHashtag(newHashtag, newPath);
                }
                map[this.normalizeHashtag(newHashtag)] = mug;
            }
        },
        _fixMugState: function (mug) {
            // parser needs this because it inserts directly into the tree
            this.mugMap[mug.ufid] = mug;
            var path = mug.absolutePath;
            if (path) {
                this.addHashtag(mug.hashtagPath, path);
                this.mugMap[this.normalizeHashtag(mug.hashtagPath)] = mug;
            }
        },
        fixBrokenReferences: function () {
            var updateReferences = this.updateLogicReferences.bind(this);
            this._logicManager.forEachBrokenReference(updateReferences);
        },
        hasBrokenReferences: function () {
            return this._logicManager.hasBrokenReferences();
        },
        isReferencedByOtherMugs: function (mug, except) {
            var exclude = _.object(_.map(except, function (mug) {
                    return [mug.ufid, null];
                }));
            exclude[mug.ufid] = null;
            return this._logicManager.hasReferencingMug(mug, function (mug) {
                return !exclude.hasOwnProperty(mug.ufid);
            });
        },
        /**
         * Get the logical path of the mug's node in the data tree
         *
         * Invariant: absolute paths returned by this function are always
         * data paths, and may not match the control hierarchy.
         *
         * It is not always possible to lookup a mug by traversing the tree
         * using it's absolute path. For example, some mugs encapsulate multiple
         * levels of XML elements. This Form object maintains a hash table to
         * quickly get a mug by its path.
         */
        getAbsolutePath: function (mug, excludeRoot) {
            if (mug && !mug.options.isControlOnly) {
                return this.tree.getAbsolutePath(mug, excludeRoot);
            }
            return null;
        },
        getMugByUFID: function (ufid) {
            return this.mugMap[ufid];
        },
        getMugByPath: function (path) {
            if(!path) { //no path specified
                return null;
            }
            return this.mugMap[this.normalizeHashtag(path)];
        },
        getIconByPath: function (path) {
            var mug = this.getMugByPath(path);
            return mug ? mug.getIcon() : null;
        },
        removeMugsFromForm: function (mugs) {
            function breakReferences(mug, property) {
                if (mug && !seen.hasOwnProperty(mug.ufid + " " + property)) {
                    seen[mug.ufid + " " + property] = null;
                    _this.updateLogicReferences(mug, property);
                }
            }
            var _this = this,
                seen = {},
                ufids = {};
            this.undomanager.resetUndo();
            _this._addToUndoManager(mugs);
            _.each(mugs, function (mug) {
                _this._removeMugFromForm(mug, ufids, false);
            });
            this._logicManager.forEachReferencingProperty(ufids, breakReferences);
        },
        _addToUndoManager: function(mugs) {
            function pushUndoItem(mug) {
                if (ufids.hasOwnProperty(mug.ufid)) {
                    return; // already removed
                }
                ufids[mug.ufid] = null;
                var node = tree.getNodeFromMug(mug),
                    parentMug = mug.parentMug,
                    hasChildren = false,
                    previousSibling = mug.previousSibling,
                    position = previousSibling === parentMug ? 'first' : 'after';
                stack.push([mug, previousSibling, position]);
                if (node) {
                    var children = node.getChildrenMugs();
                    hasChildren = children.length > 0;
                    for (var i = 0; i < children.length; i++) {
                        pushUndoItem(children[i], ufids);
                    }
                }
            }
            var tree = this.tree,
                ufids = {},
                stack = [];
            _.each(mugs, pushUndoItem);
            this.undomanager.setUndo(stack);
        },
        _removeMugFromForm: function(mug, ufids, isInternal) {
            if (ufids.hasOwnProperty(mug.ufid)) {
                return; // already removed
            }
            ufids[mug.ufid] = null;
            var node = this.tree.getNodeFromMug(mug);
            if (node) {
                var children = node.getChildrenMugs();
                for (var i = 0; i < children.length; i++) {
                    this._removeMugFromForm(children[i], ufids, true);
                }
                delete this.mugMap[this.normalizeHashtag(mug.hashtagPath)];
                this.tree.removeMug(mug);
            }
            if (this.enableInstanceRefCounting) {
                this.instanceMetadata = _.filter(this.instanceMetadata, function (meta) {
                    return !meta.dropReference(mug);
                });
            }
            this._logicManager.clearReferences(mug);
            delete this.mugMap[mug.ufid];
            this.fire({
                type: 'question-remove',
                mug: mug,
                isInternal: isInternal,
            });
        },
        isUniqueQuestionId: function (qId, mug) {
            var mugs;
            if (!mug) {
                mugs = this.getMugList(); // check against entire form
            } else {
                var node = this.tree.getNodeFromMug(mug);
                mugs = this.tree.getParentNode(node).getChildrenMugs();
            }
            return !_.any(mugs, function (mug) { return mug.p.nodeID === qId; });
        },

        /**
         * Generates a unique question ID
         *
         * @param question_id - a proposed question ID (may be empty)
         * @param mug
         */
        generate_question_id: function (question_id, mug) {
            if (question_id) {
                var match = /^copy-(\d+)-of-(.+)$/.exec(question_id) ;
                if (match) {
                    question_id = match[2]; 
                }
                var new_id = question_id;
                for (var i = 1;; i++) {
                    if (this.isUniqueQuestionId(new_id, mug)) {
                        return new_id; 
                    }
                    new_id = "copy-" + i + "-of-" + question_id;
                }
            } else {
                return this._make_label(mug && mug.__className === "Choice" ? 'choice' : 'question', mug);
            }
        },
        generate_item_label: function (parentMug, name, i) {
            var node = (parentMug ? this.tree.getNodeFromMug(parentMug)
                                  : this.tree.rootNode),
                items = node.getChildrenMugs(),
                ret;
            if (!name) { name = "choice"; }
            if (arguments.length < 3) {
                i = items.length + 1;
            }
            do {
                ret = name + i++;
            } while (_.any(items, function (item) {
                return item.p.nodeID === ret;
            }));
            return ret;
        },
        /**
         * Private method for constructing unique questionIDs, labels for items, etc
         */
        _make_label: function (prefixStr, mug) {
            var ret;
            do {
                ret = prefixStr + this.question_counter;
                this.question_counter += 1;
            } while (!this.isUniqueQuestionId(ret, mug));
            return ret;
        },
        getExportTSV: function () {
            this.vellum.beforeSerialize();
            var value = exporter.generateExportTSV(this);
            this.vellum.afterSerialize();
            return value;
        },
        undo: function() {
            this.undomanager.undo();
            this.fixBrokenReferences();
            this.vellum.selectSomethingOrHideProperties();
        },
        findUsages: function (path) {
            return this._logicManager.findUsages(path);
        },
    };

    function makeHashtagInferencer(form) {
        function decorator(obj) {
            var realHashtagToXPath = obj.hashtagToXPath;
            obj.hashtagToXPath = function (hashtag) {
                var xpath = realHashtagToXPath(hashtag);
                if (xpath !== info.hashtagMap[hashtag]) {
                    info.hashtagMap[hashtag] = xpath;
                    changes[hashtag] = xpath;
                }
                return xpath;
            };
            return obj;
        }

        function makeTransform(hashtagPrefix, parentPath) {
            function transform(prop) { return parentPath + "/" + prop; }
            return [hashtagPrefix, function (prop) {
                usedTransforms[hashtagPrefix] = transform;
                return transform(prop);
            }];
        }

        // Default case hashtag prefixes used to guess hashtag meanings.
        var session = "instance('commcaresession')/session/data/case_id",
            casepath = "instance('casedb')/cases/case[@case_id = " + session + "]",
            parent = "instance('casedb')/cases/case[@case_id = " + casepath + "/index/parent]",
            grandma = "instance('casedb')/cases/case[@case_id = " + parent + "/index/parent]",
            user = "instance('casedb')/cases/case[@case_type = 'commcare-user']" +
                   "[hq_user_id = instance('commcaresession')/session/context/userid]",
            info = {
                hashtagTransformations: _.object([
                    makeTransform("#case/", casepath),
                    makeTransform("#case/parent/", parent),
                    makeTransform("#case/grandparent/", grandma),
                    makeTransform("#user/", user),
                ]),
            },
            changes = null, // reset on inferHashtags
            usedTransforms = null, // reset on inferHashtags
            parser = xpath.parser(info, decorator);

        /**
         * Infer hashtags using default hashtag transformations
         *
         * This function tries to make up for the fact that there was a
         * time when xpath transform details were not written in the
         * <vellum:hashtags> element of form XML, and therefore it is
         * necessary to guess hashtag meansings using default transformations.
         */
        return function inferHashtags(hashtag, xpath_) {
            var newpath;
            changes = {};
            usedTransforms = {};
            info.hashtagMap = _.clone(form.hashtagMap);
            info.hashtagNamespaces = form.hashtagNamespaces;
            try {
                newpath = parser.parse(hashtag).toXPath();
            } catch (err) {
                window.console.log(util.formatExc(err));
            }
            // Update form when the guess matches the real xpath expression
            if (newpath === xpath_ && _.some(changes)) {
                _.each(changes, function (xpath, hashtag) {
                    form.initHashtag(hashtag, xpath);
                });
                _.each(usedTransforms, function (transform, key) {
                    if (!form.hashtagTransformations.hasOwnProperty(key)) {
                        form.hashtagTransformations[key] = transform;
                    }
                });
            }
        };
    }

    return {
        Form: Form,
        InstanceMetadata: InstanceMetadata
    };
});

define('vellum/parser',[
    'vellum/form',
    'vellum/util',
    'vellum/xml',
    'jquery',
    'underscore',
], function (
    form_,
    util,
    xml,
    $,
    _
) {
    var DEFAULT_FORM_ID = 'data';

    function init (instance) {
        var data = instance.data.core;
        data.controlNodeAdaptorMap = buildControlNodeAdaptorMap();
        instance.updateControlNodeAdaptorMap(data.controlNodeAdaptorMap);
    }

    function getAttributes (element) {
        var attributes = _.chain($(element)[0].attributes)
                .map(function (value) {
                    return [value.nodeName, value.nodeValue];
                }) .object().value();

        return attributes;
    }

    function parseXForm(xmlString, formOpts, vellum, warnings) {
        var Form = form_.Form,
            InstanceMetadata = form_.InstanceMetadata,
            form = new Form(formOpts, vellum, formOpts.mugTypes);
        form.parseErrors = [];
        form.parseWarnings = warnings;
        form.isLoadingXForm = true; // disable mug nodeId change logic

        if (!xmlString) {
            form.isLoadingXForm = false;
            return form;
        }

        var xml = util.parseXML(xmlString),
            docNode = xml.find('h\\:xdoc'),
            head = xml.find(':root > h\\:head, :root > head'),
            title = head.children('h\\:title, title'),
            binds = head.find('bind'),
            instances = _getInstances(xml),
            data = $(instances[0]).children(),
            setValues = head.find('> model > setvalue');

        if(xml.find('parsererror').length > 0) {
            throw gettext('PARSE ERROR!:') + xml.find('parsererror').find('div').html();
        }

        if (!docNode.length) {
            docNode = head.parent();
        }
        var ignore = docNode.xmlAttr('vellum:ignore');
        ignore = ignore ? ignore.split(" ") : [];
        if (_.contains(ignore, 'richText')) {
            form.richText = false;
        }
        if (_.contains(ignore, 'markdown')) {
            form.noMarkdown = true;
        }

        // set all instance metadatas
        form.instanceMetadata = instances.map(function (instance) {
            return InstanceMetadata(
                getAttributes(instance),
                $(instance).children()
            );
        });
        form.updateKnownInstances();

        if (form.richText && !form.vellum.datasources.isReady()) {
            // load hashtags from form to prevent unknown hashtag warnings
            initHashtags(
                form,
                head.children('vellum\\:hashtags, hashtags'),
                head.children('vellum\\:hashtagTransforms, hashtagTransforms')
            );
        }

        // TODO! adapt
        if(data.length === 0) {
            form.parseErrors.push(
                gettext('No Data block was found in the form. Please check that your form is valid!'));
        }

        parseDataTree(form, data[0], title.length ? title.text() : "");
        parseBindList(form, binds);

        parseSetValues(form, setValues);

        var controls = xml.find(':root > h\\:body, :root > body').children();
        parseControlTree(form, controls);

        var i;
        // update parse error and warn information in the model/UI
        if (form.parseErrors) {
            for (i = 0; i < form.parseErrors.length; i++) {
                form.updateError({
                    level: "error",
                    message: form.parseErrors[i]
                });
            }
        }

        if (form.parseWarnings) {
            for (i = 0; i < form.parseWarnings.length; i++) {
                form.updateError({
                    level: "parse-warning",
                    message: form.parseWarnings[i]
                });
            }
        }

        form.isLoadingXForm = false;
        return form;
    }

    function initHashtags(form, hashtags, transforms) {
        function transformHashtag(hashtag, xpath) {
            if (!xpath) {
                var match = /(#.+\/)([^\/]+)/.exec(hashtag);
                if (match && transforms.hasOwnProperty(match[1])) {
                    return transforms[match[1]] + match[2];
                }
            }
            return xpath;
        }

        try {
            hashtags = JSON.parse($.trim(hashtags.text()));
        } catch (err) {
            hashtags = {};
        }
        try {
            transforms = JSON.parse($.trim(transforms.text())).prefixes || {};
        } catch (err) {
            transforms = {};
        }
        if (!_.isEmpty(transforms)) {
            form.hashtagTransformations = _.object(_.map(transforms, function (val, key) {
                return [key, function (prop) { return val + prop; }];
            }));
        }
        _.each(hashtags, function (xpath, hash) {
            form.initHashtag(hash, transformHashtag(hash, xpath, transforms));
        });
        form.shouldInferHashtags = _.some(form.hashtagMap, function (value) {
            return value === null;
        });
    }

    // DATA PARSING FUNCTIONS
    function parseDataTree (form, dataEl, titleText) {
        var root = $(dataEl),
            tree = form.tree,
            recFunc;

        recFunc = function (parentMug) {
            var mug = form.vellum.parseDataElement(form, this, parentMug),
                children = mug.options.parseDataNode(mug, $(this), parentMug);
            tree.insertMug(mug, 'into', parentMug);
            // HACK fix abstraction broken by direct tree insert
            form._fixMugState(mug);
            children.each(function () {
                recFunc.call(this, mug);
            });
        };

        if (root[0]) {
            form.setFormID(root[0].tagName);
        } else {
            form.setFormID(DEFAULT_FORM_ID);
        }
        root.children().each(function () {
            recFunc.call(this, null);
        });
        //try to grab the JavaRosa XForm Attributes in the root data element...
        form.formUuid = root.xmlAttr("xmlns");
        form.formJRM = root.xmlAttr("xmlns:jrm");
        form.formUIVersion = root.xmlAttr("uiVersion");
        form.formVersion = root.xmlAttr("version");

        var optionsName = form.vellum.opts().core.formName,
            formName = optionsName || root.xmlAttr("name") || titleText;
        if (formName) {
            form.formName = formName;
        } else {
            form.parseWarnings.push(
                gettext('Form does not have a Name! The default form name will be used'));
        }

        if (!form.formUuid || form.formUuid === "undefined") {
            form.formUuid = "http://openrosa.org/formdesigner/" + util.generate_xmlns_uuid();
        }
        if (!form.formJRM) {
            form.parseWarnings.push(gettext('Form JRM namespace attribute was not found in data block. One will be added automatically'));
        }
        if (!form.formUIVersion) {
            form.parseWarnings.push(gettext('Form does not have a UIVersion attribute, one will be generated automatically'));
        }
        if (!form.formVersion) {
            form.parseWarnings.push(gettext('Form does not have a Version attribute (in the data block), one will be added automatically'));
        }
    }

    function parseDataElement(form, el, parentMug, role) {
        var $el = $(el),
            nodeID = el.nodeName,
            nodeVal = $el.children().length ? null : $el.text(),
            extraXMLNS = $el.popAttr('xmlns') || null,
            comment = $el.popAttr('vellum:comment') || null;
        role = role || $el.xmlAttr('vellum:role');

        if (role && form.mugTypes.allTypes.hasOwnProperty(role) &&
            form.mugTypes.allTypes[role].supportsDataNodeRole) {
            $el.popAttr('vellum:role');
        } else {
            role = 'DataBindOnly';
        }

        var mug = form.mugTypes.make(role, form);
        mug.p.nodeID = nodeID;
        mug.__originalNodeID = nodeID;

        mug.p.dataValue = nodeVal || undefined;

        if (extraXMLNS && (extraXMLNS !== form.formUuid)) {
            mug.p.xmlnsAttr = extraXMLNS;
        }
        if (comment) {
            mug.p.comment = comment;
        }
        // add arbitrary attributes
        mug.p.rawDataAttributes = getAttributes(el);
        return mug;
    }

    function parseSetValues(form, setValues) {
        var rootNodeName = form.tree.getRootNode().getID();

        setValues.each(function () {
            var $el = $(this);
            form.vellum.parseSetValue(
                form, $el, processPath(parseVellumAttrs(form, $el, 'ref', true), rootNodeName, form));
        });
    }

    function parseSetValue(form, el, path) {
        var mug = form.getMugByPath(path),
            event = el.xmlAttr('event'),
            ref = parseVellumAttrs(form, el, 'ref', true),
            value = parseVellumAttrs(form, el, 'value', true);

        // HACK: hardcoding these as that's what setValue will support for now
        if (!mug || (event !== 'xforms-ready' && event !== 'jr-insert')) {
            form.addSetValue(event, ref, value);
        } else {
            mug.p.defaultValue = value;
        }
    }

    var lookForNamespaced = function (element, reference) {
        // due to the fact that FF and Webkit store namespaced
        // values slightly differently, we have to look in
        // a couple different places.
        return element.popAttr("jr:" + reference) ||
               element.popAttr("jr\\:" + reference) || null;
    };

    function parseControlElement(form, $cEl, parentMug) {
        var tagName = $cEl[0].nodeName.toLowerCase(),
            appearance = $cEl.popAttr('appearance'),
            adapt, mug = null;

        var getAdaptor = form.vellum.getControlNodeAdaptorFactory(tagName);
        if (getAdaptor) {
            adapt = getAdaptor($cEl, appearance, form, parentMug);
        }
        if (!adapt) {
            // unknown question type
            adapt = makeReadOnlyAdaptor($cEl, appearance, form, parentMug);
        }

        if (!adapt.ignoreDataNode) {
            var path = adapt.path;
            if (!path) {
                path = getPathFromControlElement($cEl, form, parentMug);
            }
            mug = form.getMugByPath(path);
        }
        mug = adapt(mug, form);
        var node = form.tree.getNodeFromMug(mug);
        if (!node) {
            // insert control-only mug into the tree
            mug.options.isControlOnly = true; // TODO should not be mutating mug.options, check if this is necessary
            node = form.tree.insertMug(mug, 'into', parentMug);
            // HACK fix abstraction broken by direct tree insert
            form.mugMap[mug.ufid] = mug;
        } else if (node.parent.value !== parentMug) {
            var dataParentNode = node.parent,
                dataParentMug = node.parent.value;
            mug.p.dataParent = dataParentNode.isRootNode ? '#form' : dataParentMug.hashtagPath;
            node = form.tree.insertMug(mug, 'into', parentMug);
        }
        if (appearance) {
            mug.p.appearance = appearance;
        }

        if (!adapt.skipPopulate) {
            form.vellum.populateControlMug(mug, $cEl);

            // add any arbitrary attributes that were directly on the control
            mug.p.rawControlAttributes = getAttributes($cEl);
        }
        return node;
    }

    function populateControlMug(mug, $cEl) {
        var labelEl = $cEl.children('label'),
            hintEl = $cEl.children('hint'),
            imageSize = $cEl.popAttr('jr:imageDimensionScaledMax');
        if (labelEl.length && mug.getPresence("label") !== 'notallowed') {
            var labelVal = xml.humanize(labelEl);
            if (labelVal) {
                mug.p.label = labelVal;
            }
        }
        if (hintEl.length && mug.getPresence("hintLabel") !== 'notallowed') {
            mug.p.hintLabel = xml.humanize(hintEl);
        }
        if (mug.__className === "Image") {
            mug.p.imageSize = imageSize ? parseInt(imageSize) : "";
        }
    }

    /**
     * Make mug adaptor to convert from data-bind-only mug to control mug
     *
     * @param type - The final (adapted) mug type.
     * @returns - An adaptor function that returns the adapted mug. The adaptor
     *  function accepts two arguments `(mug, form)`: `mug` is a data-bind-only
     *  mug or null, and `form` is the form object. Additionally, the adaptor
     *  function has the following attributes:
     *
     *      - type : the `type` parameter passed to `makeMugAdaptor`.
     */
    function makeMugAdaptor(type) {
        var adapt = function (mug, form) {
            if (mug) {
                form.changeMugType(mug, type);
            } else {
                // unexpected; can happen with bad XForm (missing data node)
                // TODO parse warning
                mug = form.mugTypes.make(type, form);
            }
            return mug;
        };
        adapt.type = type;
        return adapt;
    }

    /**
     * A mug adaptor factory for mugs with no corresponding data node (Item)
     *
     * The mug passed to `adapt` is ignored (assumed to be undefined). An
     * attribute is set on the returned adaptor (`ignoreDataNode = true`)
     * to make the parser skip the data node lookup.
     */
    function makeControlOnlyMugAdaptor(type) {
        var adapt = function (mug, form) {
            return form.mugTypes.make(type, form);
        };
        adapt.type = type;
        adapt.ignoreDataNode = true;
        return adapt;
    }

    function makeReadOnlyAdaptor($cEl, appearance, form, parentMug) {
        var adapt = function (mug, form) {
            mug = makeMugAdaptor('ReadOnly')(mug, form);
            if ($cEl.length === 1 && $cEl[0].poppedAttributes) {
                // restore attributes removed during parsing
                _.each($cEl[0].poppedAttributes, function (val, key) {
                    $cEl.xmlAttr(key, val);
                });
            }
            mug.p.rawControlXML = $cEl;
            return mug;
        };
        adapt.skipPopulate = true;
        return adapt;
    }

    function buildControlNodeAdaptorMap() {
        var inputAdaptors = {
                'string': makeMugAdaptor('Text'),
                'long': makeMugAdaptor('Long'),
                'int': makeMugAdaptor('Int'),
                'double': makeMugAdaptor('Double'),
                'date': makeMugAdaptor('Date'),
                'datetime': makeMugAdaptor('DateTime'),
                'time': makeMugAdaptor('Time'),
                'geopoint': makeMugAdaptor('Geopoint'),
                'barcode': makeMugAdaptor('Barcode'),
                'intent': makeMugAdaptor('AndroidIntent')
            },
            // pre-make adaptors for these because they are used frequently
            adaptSelect = makeMugAdaptor('Select'),
            adaptItem = makeControlOnlyMugAdaptor('Choice'),
            _adaptTrigger = makeMugAdaptor('Trigger'),
            triggerAdaptor = function (appearance) {
                return function (mug, form) {
                    mug = _adaptTrigger(mug, form);
                    mug.p.appearance = appearance;
                    return mug;
                };
            };
        return {
            secret: function () { return makeMugAdaptor('Secret'); },
            select: function () { return makeMugAdaptor('MSelect'); },
            select1: function () { return adaptSelect; },
            trigger: function ($cEl, appearance) { return triggerAdaptor(appearance); },
            input: function ($cEl, appearance) {
                if ($cEl.popAttr('readonly') === 'true()') {
                    // WARNING produces different XML than consumed (input -> trigger)
                    return triggerAdaptor(appearance);
                }
                return function(mug, form) {
                    var dataType = mug && mug.p.rawBindAttributes && mug.p.rawBindAttributes.type;
                    if (dataType) {
                        dataType = dataType.replace('xsd:',''); //strip out extraneous namespace
                        dataType = dataType.toLowerCase();
                        if (inputAdaptors.hasOwnProperty(dataType)) {
                            delete mug.p.rawBindAttributes.type;
                            if (dataType === 'string' && appearance === 'numeric') {
                                return makeMugAdaptor('PhoneNumber')(mug, form);
                            }
                            return inputAdaptors[dataType](mug, form);
                        } else if (appearance === 'micro-image' && form.vellum.opts().features.case_micro_image) {
                            return makeMugAdaptor('MicroImage')(mug, form);
                        }
                    }
                    return inputAdaptors.string(mug, form);
                };
            },
            item: function ($cEl) {
                var adapt = function (mug, form) {
                    mug = adaptItem(mug, form);
                    mug.p.nodeID = $cEl.children('value').text();
                    return mug;
                };
                adapt.type = adaptItem.type;
                adapt.ignoreDataNode = true;
                return adapt;
            },
            group: function ($cEl, appearance, form, parentMug) {
                var type;
                if (appearance === 'field-list') {
                    type = 'FieldList';
                } else {
                    var repeat = $cEl.children('repeat');
                    if (repeat.length === 1) {
                        var adapt = function (mug, form) {
                            mug = makeMugAdaptor('Repeat')(mug, form);
                            mug.p.repeat_count = parseVellumAttrs(form, repeat, 'jr:count') || null;
                            mug.p.rawRepeatAttributes = getAttributes(repeat);
                            return mug;
                        };
                        adapt.repeat = repeat;
                        adapt.path = getPathFromControlElement(repeat, form, parentMug);
                        adapt.type = 'Repeat';
                        return adapt;
                    } else {
                        type = 'Group';
                    }
                }
                return makeMugAdaptor(type);
            },
            upload: function ($cEl, appearance, form, parentMug) {
                var mediaType = $cEl.popAttr('mediatype');
                if(!mediaType) {
                    // Why throw?! This will kill form parsing.
                    // TODO create a parser warning instead?
                    throw 'Unable to parse binary question type. ' +
                        'The question has no MediaType attribute assigned to it!';
                }
                var type;
                mediaType = mediaType.toLowerCase();
                if (mediaType === 'video/*') { /* fix eclipse syntax highlighter */
                    type = 'Video';
                } else if (mediaType === 'image/*') { /* fix eclipse syntax highlighter */
                    if (appearance === 'signature') {
                        type = 'Signature';
                    } else {
                        type = 'Image';
                    }
                } else if (mediaType === 'audio/*') { /* fix eclipse syntax highlighter */
                    type = 'Audio';
                } else {
                    // Why throw?! This will kill form parsing.
                    // TODO create a parser warning instead?
                    throw 'Unrecognized upload question type for Element: ' +
                          getPathFromControlElement($cEl, form, parentMug);
                }
                return makeMugAdaptor(type);
            }
        };
    }

    function parseBoolAttributeValue (attrString, undefined) {
        if (!attrString) {
            return undefined;
        }
        var str = attrString.toLowerCase().replace(/\s/g, '');
        if (str === 'false()') {
            return false;
        } else if (str) {
            return true;
        } else {
            return undefined;
        }
    }

    /**
     * Figures out what the xpath is of a control element
     * by looking at the ref or nodeset attributes.
     * @param el - a jquery-wrapped xforms control element.
     * @return - a string of the ref/nodeset value
     */
    function getPathFromControlElement(el, form, parentMug, noPop) {
        if(!el){
            return null;
        }
        var path = parseVellumAttrs(form, el, 'ref', noPop),
            rootNodeName = form.tree.getRootNode().getID(),
            nodeId, pathToTry;
        if(!path){
            path = parseVellumAttrs(form, el, 'nodeset', noPop);
        }
        if (!path) {
            // attempt to support sloppy hand-written forms
            nodeId = parseVellumAttrs(form, el, 'bind', noPop);
            if (nodeId) {
                pathToTry = processPath(nodeId, rootNodeName, form);
                if (!form.getMugByPath(pathToTry)) {
                    form.parseWarnings.push(gettext("Ambiguous bind:") + " " + nodeId);
                } else {
                    path = pathToTry;
                }
            }
        }
        path = path || nodeId || null;
        if (path && path[0] !== "/" && path[0] !== "#" && path[0] !== "`") {
            // make path absolute
            if (parentMug) {
                var parentPath = parentMug.hashtagPath;
                if (parentPath) {
                    path = parentPath + "/" + path;
                }
            } else {
                path = form.getBasePath() + path;
            }
        }
        return path;
    }

    function parseControlTree(form, controlsTree) {
        function controlGenerator(controlNodes, parentMug) {
            var i = 0, count = controlNodes.length;
            return function () {
                if (i >= count) {
                    return null;
                }
                var $cEl = $(controlNodes[i++]),
                    node = parseControlElement(form, $cEl, parentMug),
                    mug = node.value;
                if (mug.options.controlNodeChildren) {
                    merge(node, mug.options.controlNodeChildren($cEl));
                }
                return node;
            };
        }
        function makeGenerator(items) {
            var i = 0, count = items.length;
            return function () {
                return i < count ? items[i++] : null;
            };
        }
        function getID(node) {
            return node.value.ufid;
        }
        function merge(node, controlsTree) {
            // getID(child) must have a unique and stable return value
            // for each child for the duration of this function call
            var nextChild0 = makeGenerator(node.children),
                nextChild1 = controlGenerator(controlsTree, node.value),
                child0 = nextChild0(),
                child1 = nextChild1(),
                controls = [],
                seen = {},
                fixOrder = false;

            while (child1) {
                if (child0) {
                    if (child0 === child1) {
                        controls.push(child1);
                        child1 = nextChild1();
                    }
                    seen[getID(child0)] = null;
                    child0 = nextChild0();
                } else {
                    fixOrder = fixOrder || seen.hasOwnProperty(getID(child1));
                    controls.push(child1);
                    child1 = nextChild1();
                }
            }
            if (fixOrder) {
                node.children = _.union(controls, node.children);
            }
        }
        merge(form.tree.getRootNode(), controlsTree);
    }

    // BIND PARSING FUNCTIONS

    /**
     * Takes in a path and converts it to an absolute path (if it isn't one already)
     * @param path - a relative or absolute nodeset path
     * @param rootNodeName - the name of the model root (used to create the absolute path)
     * @return absolute nodeset path.
     */
    function processPath (path, rootNodeName, form) {
        var newPath, parsed;
        try {
            parsed = form.xpath.parse(path);
        } catch (ex) {
            return path;
        }
        if (!(parsed instanceof form.xpath.models.XPathPathExpr ||
              parsed instanceof form.xpath.models.HashtagExpr)) {
            return path;
        }

        if (parsed.initial_context === form.xpath.models.XPathInitialContextEnum.RELATIVE) {
            parsed.steps.splice(0, 0, form.xpath.models.XPathStep({axis: "child", test: rootNodeName}));
            parsed.initial_context = form.xpath.models.XPathInitialContextEnum.ROOT;
        }
        newPath = parsed.toHashtag();
        return newPath;
    }

    function parseBindList (form, bindList) {
        var rootNodeName = form.tree.getRootNode().getID();

        bindList.each(function () {
            var el = $(this),
                path = parseVellumAttrs(form, el, 'nodeset') || parseVellumAttrs(form, el, 'ref');

            form.vellum.parseBindElement(
                form, el, processPath(path, rootNodeName, form));
        });
    }

    function parseBindElement (form, el, path) {
        var mug = form.getMugByPath(path);

        if(!mug){
            form.parseWarnings.push(util.format(
                gettext("Bind Node [{path}] found but has no associated " +
                        "Data node. This bind node will be discarded!"),
                {path: path}
            ));
            return;
        }

        var required = el.popAttr('required');

        var attrs = {
            relevantAttr: parseVellumAttrs(form, el, 'relevant'),
            calculateAttr: parseVellumAttrs(form, el, 'calculate'),
            constraintAttr: parseVellumAttrs(form, el, 'constraint'),
            constraintMsgAttr: lookForNamespaced(el, "constraintMsg"),
            requiredAttr: parseBoolAttributeValue(required),
            requiredCondition: (parseVellumAttrs(form, el, 'requiredCondition') ||
                                ((required !== 'true()' && required !== 'false()') ? required : undefined)),
        };

        var raw = attrs.rawBindAttributes = getAttributes(el);

        // normalize type ('int' and 'integer' are both valid).
        if(raw.type && raw.type.toLowerCase() === 'xsd:integer') {
            raw.type = 'xsd:int';
        }

        mug.p.setAttrs(attrs);
    }

    function parseVellumAttrs(form, el, key, noPop) {
        var method = (noPop ? el.xmlAttr : el.popAttr).bind(el),
            vellumAttr = method('vellum:' + key.replace(/:/g, "__")),
            xmlAttr = method(key);
        form.inferHashtagMeanings(vellumAttr, xmlAttr);
        return form.normalizeHashtag(form.richText && vellumAttr ? vellumAttr : xmlAttr);
    }

    var _getInstances = function (xml) {
        // return all the instances in the form.
        // if there's more than one, guarantee that the first item returned
        // is the main instance.
        var instances = xml.find("instance");
        var foundMain = false;
        var ret = [];
        for (var i = 0; i < instances.length; i++) {
            // the main should be the one without an ID
            if (!$(instances[i]).xmlAttr("id")) {
                if (foundMain) {
                    throw "multiple unnamed instance elements found in the form! this is not allowed. please add id's to all but 1 instance.";
                }
                ret.splice(0, 0, instances[i]);
                foundMain = true;
            } else {
                ret.push(instances[i]);
            }
        }
        return ret;
    };

    return {
        init: init,
        parseXForm: parseXForm,
        parseDataElement: parseDataElement,
        parseBindElement: parseBindElement,
        parseSetValue: parseSetValue,
        populateControlMug: populateControlMug,
        getAttributes: getAttributes,
        getPathFromControlElement: getPathFromControlElement,
        makeControlOnlyMugAdaptor: makeControlOnlyMugAdaptor,
        makeMugAdaptor: makeMugAdaptor
    };
});

/**
 * Data sources describe hashtag and XPath expressions that can be used
 * to reference external data like cases and fixtures from within a form.
 *
 * Format in opts:
 * dataSourcesEndpoint: function(callback) or string (URL)
 *
 * The endpoint function receives a callback argument. It should call the
 * `callback` with a list of objects (for a URL, the response should be JSON
 * in this format):
 * [
 *      {
 *          id: string (data source and instance id, must be unique for
 *              each data source),
 *          uri: string (instance src),
 *          path: string (path to root node),
 *          name: string (optional human readable name, defaults to id),
 *          structure: {
 *              // Elements and attributes in this data source. The keys
 *              // in this object are XML element or attribute names.
 *              // Attribute names start with @.
 *              element: {
 *                  name: string (optional human readable name),
 *                  description: string (optional description of the element),
 *                  merge: true (optional flag. When set, the element key
 *                         will be appended to the path used to construct
 *                         children and its children will be merged with
 *                         this elements siblings. "name" is ignored if
 *                         this flag is set.),
 *                  structure: {
 *                      // Optional, nested elements and attributes.
 *                  },
 *              },
 *              ref-element: {
 *                  // Element reference, similar to a foreign key. A filter
 *                  // will be constructed on the referenced element equating
 *                  // the value of this element to the reference `key`.
 *                  reference: {
 *                      hashtag: string (optional hashtag prefix for referenced
 *                               elements and attributes),
 *                      source: string (optional data source id, use
 *                              this data source if not specified),
 *                      subset: string (optional subset id),
 *                      subset_key: string (optional subset key, if omitted then
 *                                  the first subset with an `id` matching
 *                                  this reference's `subset` will be used),
 *                      subset_filter: true (optional, When set, add
 *                                     `subset_key` predicate to the reference
 *                                     expression),
 *                      key: string (referenced element or attribute),
 *                  }
 *              },
 *              @attribute: {
 *                  name: string (optional human readable name),
 *                  description: string (optional description of the element),
 *              }
 *          },
 *          subsets: [
 *              {
 *                  // Descriptor for a reference-able subset of elements
 *                  // in this source.
 *                  id: string (required identifier for this subset),
 *                  key: string (optional id element or attribute name),
 *                  name: string (optional human readable name),
 *                  structure: { ... }, // see structure above
 *                  related: {
 *                      string (index name): {
 *                          // same keys as structure.ref-element.reference
 *                          // plus one more:
 *                          index: string (optional index path, default: '/index'),
 *                      },
 *                      ...
 *                  },
 *              },
 *              ...
 *          ],
 *      },
 *      ...
 * ]
 *
 * Elements can be nested indefinitely with structure keys describing inner
 * elements and attributes. The structure of a subset is merged with the
 * unfiltered element structure, which means that all elements and attributes
 * available in the unfiltered element are also avaliable in the filtered
 * subset.
 *
 * See ../tests/options.js:dataSources for an example schema.
 *
 * Example instance element using data source id and uri:
 *
 *  <instance id="commcaresession" src="jr://instance/session">
 *
 * Example hashtags with corresponding XPath expressions constructed using
 * the schema in tests/options.js:
 *
 *  #case/dob
 *  instance('casedb')/cases/case[
 *      @case_id = instance('commcaresession')/session/data/case_id
 *  ]/dob
 *
 *  #case/parent/edd
 *  instance('casedb')/cases/case[
 *      @case_id = instance('casedb')/cases/case[
 *          @case_id = instance('commcaresession')/session/data/case_id
 *      ]/index/parent
 *  ]/edd
 *
 *  #case/grandparent/address
 *  instance('casedb')/cases/case[
 *      @case_id = instance('casedb')/cases/case[
 *          @case_id = instance('casedb')/cases/case[
 *              @case_id = instance('commcaresession')/session/data/case_id
 *          ]/index/parent
 *      ]/index/parent
 *  ]/address
 *
 *  #user/role
 *  instance('casedb')/cases/case[@case_type = 'commcare-user'][
 *      hq_user_id = instance('commcaresession')/session/context/userid
 *  ]/role
 *
 */
define('vellum/datasources',[
    'jquery',
    'underscore',
    'vellum/util',
], function (
    $,
    _,
    util
) {
    var builders = {};

    /**
     * Initialize and return a datasources loader
     *
     * This function is called during core init.
     *
     * The returned "eventuality" object fires one of two events:
     *
     *  - change - fired when data sources changed. Currently this only
     *      happens once when data sources are first loaded.
     *  - error - fired when data sources could not be loaded.
     */
    function init(endpoint, invalidCaseProperties) {
        var that = util.eventuality({
            endpoint: endpoint,
            invalidCaseProperties: invalidCaseProperties,
        });

        that.reset = function () {
            that.retryTimeout = 1000;
            that.cache = {};
        };

        that.isReady = function () {
            return getValue(that, "sources") !== undefined;
        };

        that.getDataSources = function (defaultValue) {
            return getValue(that, "sources", defaultValue);
        };

        that.getDataNodes = function (defaultValue) {
            return getValue(that, "dataNodes", defaultValue);
        };

        that.getHashtagMap = function (defaultValue) {
            return getValue(that, "hashtagMap", defaultValue);
        };

        that.getHashtagTransforms = function (defaultValue) {
            return getValue(that, "hashtagTransforms", defaultValue);
        };

        that.getNode = function (hashtag, defaultValue) {
            var nodeMap = getValue(that, "nodeMap", {});
            return nodeMap.hasOwnProperty(hashtag) ? nodeMap[hashtag] : defaultValue;
        };

        /**
         * Add callback to be called immediately if ready and also on change.
         *
         * @return a function that unbinds the callback.
         */
        that.onChangeReady = function (callback) {
            var context = {};
            if (that.isReady()) {
                callback();
            }
            that.on("change", callback, null, null, context);
            return function () { that.unbind(context, "change"); };
        };

        that.reset();
        if (endpoint && _.isString(endpoint)) {
            loadDataSources(that);
        }

        return that;
    }

    /**
     * Asynchronously load data sources
     */
    function loadDataSources(that) {
        function finish(data) {
            that.cache = {sources: data.length ? data : [{
                id: "",
                uri: "",
                path: "",
                name: gettext("Not Found"),
                structure: {}
            }]};
            that.loading = false;
            that.fire("change");
        }

        function onError(jqXHR, errorType, error) {
            that.fire({
                type: "error",
                xhr: jqXHR,
                errorType: errorType,
                error: error,
            });
            window.console.log(util.formatExc(error || errorType));
            if (that.retryTimeout < 8001) {  // 8000 = 4 retries
                // exponential backoff retry
                setTimeout(function () {
                    loadDataSources(that);
                }, that.retryTimeout);
                that.retryTimeout = that.retryTimeout * 2;
            }
        }

        if (that.endpoint) {
            if (_.isString(that.endpoint)) {
                that.loading = true;
                $.ajax({
                    type: 'GET',
                    url: that.endpoint,
                    dataType: 'json',
                    success: finish,
                    error: onError,
                    data: {}
                });
            } else {
                that.endpoint(finish);
            }
        } else {
            finish([]);
        }
    }

    /**
     * Get value derived from loaded data sources
     *
     * This function delegates to a "builder" function. Each "builder"
     * function must return either the built object (not `undefined`)
     * or `undefined` to indicate that the value is not available yet.
     *
     * @param that - datasources instance.
     * @param name - the name of the value to get.
     * @param defaultValue - the value to return if the requested value
     *      cannot be built (because data sources are not yet loaded).
     * @returns the requested value
     */
    function getValue(that, name, defaultValue) {
        var cache = that.cache;
        if (cache.hasOwnProperty(name)) {
            return cache[name];
        }
        var value = builders[name](that);
        if (value !== undefined) {
            cache[name] = value;
            return value;
        }
        return defaultValue;
    }

    builders.sources = function (that) {
        if (!that.loading) {
            loadDataSources(that);
        }
        return that.cache.sources;
    };

    /**
     * Build a list of data nodes
     *
     * Each node represents a known entity that can be referenced by
     * hashtag and/or xpath expression.
     */
    builders.dataNodes = function (that) {
        function wordWrap(inStr, maxLength) {
            if (inStr.length <= maxLength) {
                return inStr;
            }
            let outStr = "",
                bufferStr = inStr;
            while (bufferStr.length > maxLength) {
                outStr += bufferStr.slice(0, maxLength) + "\n";
                bufferStr = bufferStr.slice(maxLength, bufferStr.length);
            }
            outStr += "\n" + bufferStr;
            return outStr;
        }

        function insertWordBreaks(inStr, maxLength) {
            let words = inStr.split(" "),
                outStr = "";
            for (let word of words) {
                outStr += wordWrap(word, maxLength);
                outStr += " ";
            }
            return outStr.trim();
        }

        function node(source, parentPath, info, index) {
            return function (item, id) {
                if (_.contains(that.invalidCaseProperties, id)) {
                    return null;
                }

                var path = parentPath ? parentPath + "/" + id : id,
                    tree = getTree(item, id, path, info),
                    name = tree.name;

                return {
                    name: name,
                    description: insertWordBreaks(tree.description, 43),
                    hashtag: info.hashtag && !index ? info.hashtag + '/' + name : null,
                    parentPath: parentPath,
                    xpath: path,
                    index: index || false,
                    sourceInfo: info,
                    getNodes: tree.getNodes,
                    recursive: tree.recursive,
                };
            };
        }
        function getTree(item, id, path, info) {
            var tree = {
                    name: item.name || id,
                    description: item.description || '',
                    recursive: false
            },
                source = item,
                children = null;
            if (!item.structure && item.reference) {
                var ref = item.reference;
                source = sources[ref.source || info.id];
                if (source) {
                    info = _.extend(_.omit(source, "structure"), {
                        _parent: info,
                        hashtag: ref.hashtag,
                    });
                    var keyPath = path;
                    path = "instance('" + source.id + "')" + source.path;
                    if (ref.subset_filter && ref.subset_key && ref.subset) {
                        path += "[" + ref.subset_key + " = '" + ref.subset + "']";
                    }
                    path += "[" + ref.key + " = " + keyPath + "]";
                    if (source.subsets && ref.subset) {
                        var where = {id: ref.subset};
                        if (ref.subset_key) {
                            where.key = ref.subset_key;
                        }
                        source = _.findWhere(source.subsets, where) || source;
                    }
                    var name = source.name || source.id;
                    if (name) {
                        tree.name = name;
                    }
                    if (seen.hasOwnProperty(source.id)) {
                        // defer to prevent infinite loop
                        tree.recursive = true;
                    } else {
                        seen[source.id] = true;
                    }
                }
            }
            tree.getNodes = function () {
                if (children === null) {
                    children = getNodes(source, path, info);
                }
                return children;
            };
            return tree;
        }
        function getNodes(source, path, info) {
            var nodes = _.chain(source && source.structure)
                .map(function (item, id) {
                    if (item.merge) {
                        return getNodes(item, path + "/" + id, {_parent: info});
                    } else {
                        return node(source, path, info)(item, id);
                    }
                })
                .flatten()
                .compact() // TODO remove with invalidCaseProperties
                .sortBy("text")
                .value();
            if (source && source.related) {
                nodes = _.chain(source.related)
                    .map(function (ref, relation) {
                        var item, index;
                        item = {reference: ref};
                        index = ref.index || "/index";
                        return node(source, path + index, info, true)(item, relation);
                    })
                    .sortBy("text")
                    .value()
                    .concat(nodes);
            }
            return nodes;
        }

        var sources = getValue(that, "sources"),
            seen = {},
            nodes;
        if (sources) {
            sources = sources = _.indexBy(sources, "id");
            if (sources.commcaresession) {
                var source = sources.commcaresession,
                    info = _.omit(source, "structure"),
                    path = "instance('" + source.id + "')" + source.path;
                // do not show Session node for now
                nodes = node(source, null, info)(source, path).getNodes();
            }
        }
        return nodes;
    };

    /**
     * Intermediate builder; extracts hashtags and transforms from data nodes.
     */
    builders.hashtags = function (that) {
        function walk(nodes, hashtags) {
            _.each(nodes, function (node) {
                if (!node.index) {
                    hashtags.nodeMap[node.hashtag || node.xpath] = node;
                }
                if (node.hashtag && !node.index) {
                    hashtags.map[node.hashtag] = node.xpath;
                    hashtags.transforms[node.sourceInfo.hashtag + '/'] = function (prop) {
                        return node.parentPath + "/" + prop;
                    };
                }
                if (!node.recursive) {
                    walk(node.getNodes(), hashtags);
                }
            });
            return hashtags;
        }
        var nodes = getValue(that, "dataNodes");
        return nodes ? walk(nodes, {
            map: {},
            nodeMap: {},
            transforms: {},
        }) : undefined;
    };

    /**
     * Build an object containing hashtags mapped to data nodes.
     */
    builders.nodeMap = function (that) {
        var hashtags = getValue(that, "hashtags");
        return hashtags && hashtags.nodeMap;
    };

    /**
     * Build an object containing hashtags mapped to XPath expressions.
     */
    builders.hashtagMap = function (that) {
        var hashtags = getValue(that, "hashtags");
        return hashtags && hashtags.map;
    };

    /**
     * Build an object containing hashtag transformations.
     *
     * {"#case/": function (prop) { return "#case/" + prop; }}
     */
    builders.hashtagTransforms = function (that) {
        var hashtags = getValue(that, "hashtags");
        return hashtags && hashtags.transforms;
    };

    return {init: init};
});

define('vellum/javaRosa/util',[
    'underscore',
    'jquery',
    'vellum/tsv',
    'vellum/richText',
    'vellum/xml',
    'vellum/util'
], function (
    _,
    $,
    tsv,
    richText,
    xml,
    util
) {
    var SUPPORTED_MEDIA_TYPES = ['image', 'audio', 'video', 'video-inline'],
        ITEXT_TYPES = ['default', 'audio', 'image', 'video', 'video-inline'],
        ITEXT_PROPERTIES = [
            'labelItext',
            'hintItext',
            'helpItext',
            'constraintMsgItext',
            'addEmptyCaptionItext',
            'addCaptionItext',
        ];

    var getDefaultItextRoot = function(mug) {
        if (mug.__className === "Choice") {
            var regex = new RegExp(util.invalidAttributeRegex.source, 'g');
            return getDefaultItextRoot(mug.parentMug) + "-" +
                mug.getNodeID().replace(regex, '_');
        } else {
            var path = mug.absolutePathNoRoot;
            if (!path) {
                if (mug.parentMug) {
                    path = mug.parentMug.absolutePathNoRoot +
                            "/" + mug.getNodeID();
                } else {
                    // fall back to nodeID if mug path still not found
                    // this can happen with malformed XForms
                    path = "/" + mug.getNodeID();
                }
            }
            return path.slice(1);
        }
    };

    var getDefaultItextId = function(mug, property) {
        return getDefaultItextRoot(mug) + "-" + property;
    };

    var looksLikeMarkdown = function(val, supportTables) {
        /* Regex checks (in order):
         * ordered lists
         * unordered lists
         * strikethrough
         * headings
         * italics/bold/bold italics
         * links
         * tables (hasTable regex) 
         */
        var hasMarkdown = /^\d+[\.\)] |^\* |~~.+~~|# |\*{1,3}\S.*\*{1,3}|\[.+\]\(\S+\)/m.test(val),
            hasTable = false;
        if (supportTables) {
            hasTable = /^(\|[^\n]+\|\r?\n)((?:\|\s*:?[-]+:?\s*)+\|)(\n(?:\|[^\n]+\|\r?\n?)*)?$/m.test(val);
        }
        return hasMarkdown || hasTable;
    };

    /**
     * Call visitor function for each Itext item in the form
     */
    var forEachItextItem = function(form, visit) {
        var seen = {};

        form.tree.walk(function (mug, nodeID, processChildren) {
            if(mug) { // skip root node
                _.each(ITEXT_PROPERTIES, function (property) {
                    var item = mug.p[property];
                    if (item && !item.key) {
                        // this should never happen
                        window.console.log(
                            "ignoring ItextItem without a key: " + item.id);
                        return;
                    } else if (item && !seen.hasOwnProperty(item.key)) {
                        seen[item.key] = true;
                        visit(item, mug, property);
                    }
                });
            }
            processChildren();
        });
    };

    /**
     * Walks the tree and grabs Itext items from mugs
     *
     * This updates the ID of each returned Itext item according to it's
     * autoId property. IDs of items with autoId turned off will not be
     * modified unless the ID is blank or it conflicts with another item.
     * NOTE because this mutates itext IDs it could cause subtle side
     * effects if anything depends on Itext IDs not changing at random
     * times such as save, copy, paste, export translations, etc.
     *
     * @param form - the vellum instance's Form object.
     * @param asObject - if true, return all items in an object keyed by id;
     *                   otherwise return a list of non-empty Itext items.
     * @returns - a list or object containing Itext items (see `asObject`).
     */
    var getItextItemsFromMugs = function(form, asObject) {
        var empty = asObject,
            items = [],
            byId = {},
            props = _.object(_.map(ITEXT_PROPERTIES, function (thing) {
                return [thing, thing.replace("Itext", "")];
            }));

        forEachItextItem(form, function (item, mug, property) {
            var itemIsEmpty = item.isEmpty();
            if (!itemIsEmpty || empty) {
                var id = item.autoId || !item.id ?
                         getDefaultItextId(mug, props[property]) : item.id,
                    origId = id,
                    count = 2;
                if (byId.hasOwnProperty(id) && (itemIsEmpty || item === byId[id])) {
                    // ignore same or empty item with duplicate ID
                    return;
                }
                while (byId.hasOwnProperty(id)) {
                    id = origId + count;
                    count++;
                }
                item.id = id;
                byId[id] = item;
                if (!asObject) {
                    items.push(item);
                }
            }
        });
        return asObject ? byId : items;
    };

    var parseXLSItext = function (form, str, Itext) {
        var forms = ITEXT_TYPES,
            languages = Itext.getLanguages(),
            nextRow = tsv.makeRowParser(str),
            header = nextRow(),
            i, cells, head, item;

        if (header) {
            header = _.map(header, function (val) {
                var formlang = val.split(/[-_]/);
                if (forms.indexOf(formlang[0]) === -1 ||
                        languages.indexOf(formlang[1]) === -1) {
                    return null;
                }
                return {form: formlang[0], lang: formlang[1]};
            });
        }

        var items = getItextItemsFromMugs(form, true);
        for (cells = nextRow(); cells; cells = nextRow()) {
            item = items[cells[0]];
            if (!item) {
                // TODO alert user that row was skipped
                continue;
            }
            for (i = 1; i < cells.length; i++) {
                head = header[i];
                if (head) {
                    if (item.hasForm(head.form)) {
                        item.getForm(head.form).setValue(head.lang, cells[i]);
                    } else if ($.trim(cells[i])) {
                        item.getOrCreateForm(head.form).setValue(head.lang, cells[i]);
                    }
                }
            }
        }
        Itext.fire("change");
    };

    var generateItextXLS = function (form, Itext) {
        function rowify(firstVal, languages, forms, func) {
            var row = [firstVal];
            _.each(forms, function (form) {
                _.each(languages, function (language) {
                    row.push(func(language, form));
                });
            });
            return row;
        }

        function makeRow(item, languages, forms) {
            return rowify(item.id, languages, forms, function (language, form) {
                return item.hasForm(form) ? item.get(form, language) : "";
            });
        }

        function makeHeadings(languages, forms) {
            return rowify("label", languages, forms, function (language, form) {
                return form + '_' + language;
            });
        }

        // TODO: should this be configurable?
        var forms = ITEXT_TYPES,
            languages = Itext.getLanguages(),
            rows = [];

        if (languages.length > 0) {
            var items = getItextItemsFromMugs(form);
            rows.push(makeHeadings(languages, forms));
            _.each(items, function (item) {
                rows.push(makeRow(item, languages, forms));
            });
        }
        return tsv.tabDelimit(rows);
    };

    var warnOnNonOutputableValue = function(form, mug, path) {
        if (!mug.options.canOutputValue) {
            // TODO display message near where it was dropped
            // HACK should be in the itext widget, which has the mug and path
            var current = form.vellum.getCurrentlySelectedMug(),
                typeName = mug.options.typeName;
            if (current) {
                current.addMessage(null, {
                    key: "javaRosa-output-value-type-error",
                    level: mug.WARNING,
                    message: util.format(gettext(
                        "{type} nodes cannot be used in an output value. " +
                        "Please remove the output value for '{path}' or " +
                        "your form will have errors."
                    ), {type: typeName, path: path}),
                });
            }
        }
    };

    var getOutputRef = function(path, dateFormat) {
        if (dateFormat) {
            return '<output value="format-date(date(' + path + '), \'' + dateFormat + '\')"/>';
        } else {
            return '<output value="' + path + '" />';
        }
    };

    var warnOnCircularReference = function(property, mug, path, refName, propName) {
        // TODO track output refs in logic manager
        if (path === "." && property === 'label') {
            var fieldName = mug.p.getDefinition(property).lstring;
            mug.addMessage(propName, {
                key: "core-circular-reference-warning",
                level: mug.WARNING,
                message: util.format(gettext(
                    "The {field} for a question is not allowed to reference " +
                    "the question itself. Please remove the {ref} from the " +
                    "{field} or your form will have errors."
                ), {field: fieldName, ref: refName}),
            });
        }
    };

    var insertOutputRef = function(vellum, target, path, mug, dateFormat) {
        var output = getOutputRef(path, dateFormat),
            form = vellum.data.core.form;
        if (form.richText) {
            richText.editor(target).insertOutput(output);
        } else {
            util.insertTextAtCursor(target, output, true);
        }
        if (mug) {
            warnOnCircularReference(
                'label', mug, path, gettext('output value'), target.attr('name'));
            warnOnNonOutputableValue(form, mug, path);
        }
    };

    function _outputToXPathOrHashtag (functionName) {
        return function (text, xpathParser, escape) {
            if (text) {
                var xquery = xml.query(text);
                xquery.find('output').each(function() {
                    var $this = $(this),
                        value = $this.xmlAttr('value') || $this.xmlAttr('ref');
                    try {
                        var parsedValue = xpathParser.parse(value);
                        $this.xmlAttr('value', parsedValue[functionName]());
                    } catch (e) {
                        $this.xmlAttr('value', value);
                    }
                });
                text = xquery.toString();
                if (escape) {
                    text = text.replace(/(<)|>/g, function (match, lt) {
                        return lt ? "&lt;" : "&gt;";
                    });
                }
            }
            return text;
        };
    }


    return {
        ITEXT_PROPERTIES: ITEXT_PROPERTIES,
        SUPPORTED_MEDIA_TYPES: SUPPORTED_MEDIA_TYPES,
        forEachItextItem: forEachItextItem,
        generateItextXLS: generateItextXLS,
        getDefaultItextRoot: getDefaultItextRoot,
        getDefaultItextId: getDefaultItextId,
        getItextItemsFromMugs: getItextItemsFromMugs,
        getOutputRef: getOutputRef,
        insertOutputRef: insertOutputRef,
        looksLikeMarkdown: looksLikeMarkdown,
        parseXLSItext: parseXLSItext,
        outputToXPath: _outputToXPathOrHashtag('toXPath'),
        outputToHashtag: _outputToXPathOrHashtag('toHashtag'),
    };
});

/* global console */
define('vellum/debugutil',["underscore"], function (_) {
    if (_.isUndefined(console)) {
        return {
            log: function () {},
            error: function () {}
        };
    } else {
        return {
            log: function () { console.log.apply(console, arguments); },
            error: function () { console.error.apply(console, arguments); }
        };
    }
});

// plugin pattern adapted from JSTree, minus plugin events

define('vellum/base',[
    'jquery',
    'underscore'
], function (
    $,
    _,
    undefined
) {
    // The order of plugins in this list is important: it controls the order in
    // which plugin methods are called. Core is at the center, each plugin is a
    // layer on top of the next. A method call starts at the last plugin in the
    // list that defines the method and continues toward the core (assuming each
    // plugin method calls `this.__callOld()`)
    var corePlugins = [
            'core',
            'intents',
            'javaRosa',
            'lock',
            'ignore',
            'uploader',
            'windowManager',
            'copyPaste',
            'commander',
        ];

    function bindPluginMethod(pluginName, fn, fnName) {
        // this is not how jstree does it, and a bit hacky, but it makes
        // defining plugins simpler
        if (fnName === 'init' && pluginName !== 'core') {
            return;
        }

        // call private methods normally
        if (fnName.indexOf('_') === 0) {
            if (this[fnName] !== undefined) {
                throw ("private plugin method " + pluginName + "." + fnName +
                       " would overwrite existing: " + this[fnName]);
            }
            // this could be a problem if two plugins have a private
            // method with the same name, easily fixed
            this[fnName] = fn;
            return;
        }

        fn.plugin = pluginName;
        fn.old = this[fnName];
        this[fnName] = function () {
            var func = fn,
                args = Array.prototype.slice.call(arguments),
                old = this.__callOld;

            this.__callOld = function () {
                return func.old.apply(this, (arguments.length ?
                    Array.prototype.slice.call(arguments) : args));
            };
            try {
                return func.apply(this, args);
            } finally {
                this.__callOld = old;
            }
        };
        this[fnName].old = fn.old;
        this[fnName].plugin = pluginName;
    }

    $.fn.vellum = function (options) {
        var isMethodCall = typeof options === 'string',
            args = Array.prototype.slice.call(arguments, 1),
            instance;

        if (isMethodCall) {
            if (options === "get") {
                // get the vellum instance on the selected element or one of its parents
                var obj = this;
                while (obj && obj.length) {
                    instance = obj.data("vellum_instance");
                    if (instance instanceof $.vellum._instance) {
                        return instance;
                    }
                    obj = obj.parent();
                }
                return null; // vellum instance not found
            }
            // call method
            instance = this.data("vellum_instance");
            return instance[options].apply(instance, args);
        } else {
            // Instantiate an instance for each element in the jquery object set
            // passed.  In practice, it's unlikely that you'd ever want to
            // instantiate multiple instances at once.
            this.each(function () {
                var instance = new $.vellum._instance($(this), options);
                $.data(this, "vellum_instance", instance);
            });
            return this;
        }
    };

    $.vellum = {
        defaults: {},
        _plugins: {},
        _fn: {},
        _instance: function ($f, options) {
            options.plugins = _.filter(
                _.union(corePlugins, options.plugins || []),
                function (name) {
                    return !_.isUndefined($.vellum._plugins[name]);
                }
            );
            options = $.extend(true, {}, $.vellum.defaults, options);

            var instance = this;
            this.$f = $f;
            this.data = {};
            this.opts = function () { 
                return $.extend(true, {}, options);
            };

            this.getData = function () {
                return this.data;
            }.bind(this);

            this.isPluginEnabled = function (name) {
                return options.plugins.indexOf(name) !== -1;
            };

            _.each(options.plugins, function (pluginName, i) {
                instance.data[pluginName] = {};
                var fns = $.vellum._plugins[pluginName];
                if (fns) {
                    _.each(fns, function (fn, fnName) {
                        if (i === 0) {
                            // bind root plugin (usually "core") methods
                            // directly to instance to make debugging easier
                            // and method calls have less overhead.
                            instance[fnName] = fn;
                        } else {
                            bindPluginMethod.call(instance, pluginName, fn, fnName);
                        }
                    });
                }
            });

            _.each(options.plugins, function (p) {
                var initFn = $.vellum._plugins[p].init;
                if (initFn) {
                    initFn.apply(instance);
                }
            });

            // do final initialization that requires all plugins to be loaded
            instance.postInit();
        },
        plugin: function (pluginName, defaults, fns) {
            $.vellum.defaults[pluginName] = defaults;
            $.vellum._plugins[pluginName] = fns;
            return $;
        }
    };

    return;
});

define('vellum/jstree-plugins',[
    'jquery',
    'jquery.jstree'
], function (
    $
) {
    /**
     * Conditional events plugin
     *
     * Conditional handlers are bound to the JSTree instance and are
     * called with the same arguments as the JSTree function that they
     * are gating. The boolean result of the handler will be used to
     * determine if the gated method should be called (true -> call).
     *
     * `redraw_node` is a special case: it overrides the super method,
     * and therefore is responsible for calling the super method.
     *
     * Based on https://github.com/vakata/jstree/blob/master/src/misc.js
     * See also http://stackoverflow.com/a/24499593/10840
     */
    "use strict";
    $.jstree.defaults.conditionalevents = {
        should_activate: function () { return true; },
        //should_move: function () { return true; },
        redraw_node: function () {
            var args = Array.prototype.slice.call(arguments);
            return this.parent.redraw_node.apply(this.inst, args);
        }
    };
    $.jstree.plugins.conditionalevents = function (options, parent) {
        this.activate_node = function () {
            var args = Array.prototype.slice.call(arguments);
            if(this.settings.conditionalevents.should_activate.apply(this, args)) {
                parent.activate_node.apply(this, args);
            }
        };
        //this.move_node = function () {
        //    var args = Array.prototype.slice.call(arguments);
        //    if(this.settings.conditionalevents.should_move.apply(this, args)) {
        //        parent.move_node.apply(this, args);
        //    }
        //};
        this.redraw_node = function () {
            var args = Array.prototype.slice.call(arguments),
                base = {inst: this, parent: parent};
            return this.settings.conditionalevents.redraw_node.apply(base, args);
        };
        this.edit = function () {
            // do nothing: disable F2 -> rename node
        };
    };
});


define('less/less!vellum/less-style/main',[],function(){});
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('caretjs',["jquery"], function ($) {
      return (root.returnExportsGlobal = factory($));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like enviroments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    factory(jQuery);
  }
}(this, function ($) {

/*
  Implement Github like autocomplete mentions
  http://ichord.github.com/At.js

  Copyright (c) 2013 chord.luo@gmail.com
  Licensed under the MIT license.
*/

/*
 textarea  input 

.
*/


var EditableCaret, InputCaret, Mirror, Utils, discoveryIframeOf, methods, oDocument, oFrame, oWindow, pluginName, setContextBy;

pluginName = 'caret';

EditableCaret = (function() {
  function EditableCaret($inputor) {
    this.$inputor = $inputor;
    this.domInputor = this.$inputor[0];
  }

  EditableCaret.prototype.setPos = function(pos) {
    var fn, found, offset, sel;
    if (sel = oWindow.getSelection()) {
      offset = 0;
      found = false;
      (fn = function(pos, parent) {
        var node, range, _i, _len, _ref, _results;
        _ref = parent.childNodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (found) {
            break;
          }
          if (node.nodeType === 3) {
            if (offset + node.length >= pos) {
              found = true;
              range = oDocument.createRange();
              range.setStart(node, pos - offset);
              sel.removeAllRanges();
              sel.addRange(range);
              break;
            } else {
              _results.push(offset += node.length);
            }
          } else {
            _results.push(fn(pos, node));
          }
        }
        return _results;
      })(pos, this.domInputor);
    }
    return this.domInputor;
  };

  EditableCaret.prototype.getIEPosition = function() {
    return this.getPosition();
  };

  EditableCaret.prototype.getPosition = function() {
    var inputor_offset, offset;
    offset = this.getOffset();
    inputor_offset = this.$inputor.offset();
    offset.left -= inputor_offset.left;
    offset.top -= inputor_offset.top;
    return offset;
  };

  EditableCaret.prototype.getOldIEPos = function() {
    var preCaretTextRange, textRange;
    textRange = oDocument.selection.createRange();
    preCaretTextRange = oDocument.body.createTextRange();
    preCaretTextRange.moveToElementText(this.domInputor);
    preCaretTextRange.setEndPoint("EndToEnd", textRange);
    return preCaretTextRange.text.length;
  };

  EditableCaret.prototype.getPos = function() {
    var clonedRange, pos, range;
    if (range = this.range()) {
      clonedRange = range.cloneRange();
      clonedRange.selectNodeContents(this.domInputor);
      clonedRange.setEnd(range.endContainer, range.endOffset);
      pos = clonedRange.toString().length;
      clonedRange.detach();
      return pos;
    } else if (oDocument.selection) {
      return this.getOldIEPos();
    }
  };

  EditableCaret.prototype.getOldIEOffset = function() {
    var range, rect;
    range = oDocument.selection.createRange().duplicate();
    range.moveStart("character", -1);
    rect = range.getBoundingClientRect();
    return {
      height: rect.bottom - rect.top,
      left: rect.left,
      top: rect.top
    };
  };

  EditableCaret.prototype.getOffset = function(pos) {
    var clonedRange, offset, range, rect, shadowCaret;
    if (oWindow.getSelection && (range = this.range())) {
      if (range.endOffset - 1 > 0 && range.endContainer !== this.domInputor) {
        clonedRange = range.cloneRange();
        clonedRange.setStart(range.endContainer, range.endOffset - 1);
        clonedRange.setEnd(range.endContainer, range.endOffset);
        rect = clonedRange.getBoundingClientRect();
        offset = {
          height: rect.height,
          left: rect.left + rect.width,
          top: rect.top
        };
        clonedRange.detach();
      }
      if (!offset || (offset != null ? offset.height : void 0) === 0) {
        clonedRange = range.cloneRange();
        shadowCaret = $(oDocument.createTextNode("|"));
        clonedRange.insertNode(shadowCaret[0]);
        clonedRange.selectNode(shadowCaret[0]);
        rect = clonedRange.getBoundingClientRect();
        offset = {
          height: rect.height,
          left: rect.left,
          top: rect.top
        };
        shadowCaret.remove();
        clonedRange.detach();
      }
    } else if (oDocument.selection) {
      offset = this.getOldIEOffset();
    }
    if (offset) {
      offset.top += $(oWindow).scrollTop();
      offset.left += $(oWindow).scrollLeft();
    }
    return offset;
  };

  EditableCaret.prototype.range = function() {
    var sel;
    if (!oWindow.getSelection) {
      return;
    }
    sel = oWindow.getSelection();
    if (sel.rangeCount > 0) {
      return sel.getRangeAt(0);
    } else {
      return null;
    }
  };

  return EditableCaret;

})();

InputCaret = (function() {
  function InputCaret($inputor) {
    this.$inputor = $inputor;
    this.domInputor = this.$inputor[0];
  }

  InputCaret.prototype.getIEPos = function() {
    var endRange, inputor, len, normalizedValue, pos, range, textInputRange;
    inputor = this.domInputor;
    range = oDocument.selection.createRange();
    pos = 0;
    if (range && range.parentElement() === inputor) {
      normalizedValue = inputor.value.replace(/\r\n/g, "\n");
      len = normalizedValue.length;
      textInputRange = inputor.createTextRange();
      textInputRange.moveToBookmark(range.getBookmark());
      endRange = inputor.createTextRange();
      endRange.collapse(false);
      if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
        pos = len;
      } else {
        pos = -textInputRange.moveStart("character", -len);
      }
    }
    return pos;
  };

  InputCaret.prototype.getPos = function() {
    if (oDocument.selection) {
      return this.getIEPos();
    } else {
      return this.domInputor.selectionStart;
    }
  };

  InputCaret.prototype.setPos = function(pos) {
    var inputor, range;
    inputor = this.domInputor;
    if (oDocument.selection) {
      range = inputor.createTextRange();
      range.move("character", pos);
      range.select();
    } else if (inputor.setSelectionRange) {
      inputor.setSelectionRange(pos, pos);
    }
    return inputor;
  };

  InputCaret.prototype.getIEOffset = function(pos) {
    var h, textRange, x, y;
    textRange = this.domInputor.createTextRange();
    pos || (pos = this.getPos());
    textRange.move('character', pos);
    x = textRange.boundingLeft;
    y = textRange.boundingTop;
    h = textRange.boundingHeight;
    return {
      left: x,
      top: y,
      height: h
    };
  };

  InputCaret.prototype.getOffset = function(pos) {
    var $inputor, offset, position;
    $inputor = this.$inputor;
    if (oDocument.selection) {
      offset = this.getIEOffset(pos);
      offset.top += $(oWindow).scrollTop() + $inputor.scrollTop();
      offset.left += $(oWindow).scrollLeft() + $inputor.scrollLeft();
      return offset;
    } else {
      offset = $inputor.offset();
      position = this.getPosition(pos);
      return offset = {
        left: offset.left + position.left - $inputor.scrollLeft(),
        top: offset.top + position.top - $inputor.scrollTop(),
        height: position.height
      };
    }
  };

  InputCaret.prototype.getPosition = function(pos) {
    var $inputor, at_rect, end_range, format, html, mirror, start_range;
    $inputor = this.$inputor;
    format = function(value) {
      value = value.replace(/<|>|`|"|&/g, '?').replace(/\r\n|\r|\n/g, "<br/>");
      if (/firefox/i.test(navigator.userAgent)) {
        value = value.replace(/\s/g, '&nbsp;');
      }
      return value;
    };
    if (pos === void 0) {
      pos = this.getPos();
    }
    start_range = $inputor.val().slice(0, pos);
    end_range = $inputor.val().slice(pos);
    html = "<span style='position: relative; display: inline;'>" + format(start_range) + "</span>";
    html += "<span id='caret' style='position: relative; display: inline;'>|</span>";
    html += "<span style='position: relative; display: inline;'>" + format(end_range) + "</span>";
    mirror = new Mirror($inputor);
    return at_rect = mirror.create(html).rect();
  };

  InputCaret.prototype.getIEPosition = function(pos) {
    var h, inputorOffset, offset, x, y;
    offset = this.getIEOffset(pos);
    inputorOffset = this.$inputor.offset();
    x = offset.left - inputorOffset.left;
    y = offset.top - inputorOffset.top;
    h = offset.height;
    return {
      left: x,
      top: y,
      height: h
    };
  };

  return InputCaret;

})();

Mirror = (function() {
  Mirror.prototype.css_attr = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopStyle", "borderRightStyle", "borderBottomStyle", "borderLeftStyle", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontWeight", "height", "letterSpacing", "lineHeight", "marginBottom", "marginLeft", "marginRight", "marginTop", "outlineWidth", "overflow", "overflowX", "overflowY", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "textAlign", "textOverflow", "textTransform", "whiteSpace", "wordBreak", "wordWrap"];

  function Mirror($inputor) {
    this.$inputor = $inputor;
  }

  Mirror.prototype.mirrorCss = function() {
    var css,
      _this = this;
    css = {
      position: 'absolute',
      left: -9999,
      top: 0,
      zIndex: -20000
    };
    if (this.$inputor.prop('tagName') === 'TEXTAREA') {
      this.css_attr.push('width');
    }
    $.each(this.css_attr, function(i, p) {
      return css[p] = _this.$inputor.css(p);
    });
    return css;
  };

  Mirror.prototype.create = function(html) {
    this.$mirror = $('<div></div>');
    this.$mirror.css(this.mirrorCss());
    this.$mirror.html(html);
    this.$inputor.after(this.$mirror);
    return this;
  };

  Mirror.prototype.rect = function() {
    var $flag, pos, rect;
    $flag = this.$mirror.find("#caret");
    pos = $flag.position();
    rect = {
      left: pos.left,
      top: pos.top,
      height: $flag.height()
    };
    this.$mirror.remove();
    return rect;
  };

  return Mirror;

})();

Utils = {
  contentEditable: function($inputor) {
    return !!($inputor[0].contentEditable && $inputor[0].contentEditable === 'true');
  }
};

methods = {
  pos: function(pos) {
    if (pos || pos === 0) {
      return this.setPos(pos);
    } else {
      return this.getPos();
    }
  },
  position: function(pos) {
    if (oDocument.selection) {
      return this.getIEPosition(pos);
    } else {
      return this.getPosition(pos);
    }
  },
  offset: function(pos) {
    var offset;
    offset = this.getOffset(pos);
    return offset;
  }
};

oDocument = null;

oWindow = null;

oFrame = null;

setContextBy = function(settings) {
  var iframe;
  if (iframe = settings != null ? settings.iframe : void 0) {
    oFrame = iframe;
    oWindow = iframe.contentWindow;
    return oDocument = iframe.contentDocument || oWindow.document;
  } else {
    oFrame = void 0;
    oWindow = window;
    return oDocument = document;
  }
};

discoveryIframeOf = function($dom) {
  var error;
  oDocument = $dom[0].ownerDocument;
  oWindow = oDocument.defaultView || oDocument.parentWindow;
  try {
    return oFrame = oWindow.frameElement;
  } catch (_error) {
    error = _error;
  }
};

$.fn.caret = function(method, value, settings) {
  var caret;
  if (methods[method]) {
    if ($.isPlainObject(value)) {
      setContextBy(value);
      value = void 0;
    } else {
      setContextBy(settings);
    }
    caret = Utils.contentEditable(this) ? new EditableCaret(this) : new InputCaret(this);
    return methods[method].apply(caret, [value]);
  } else {
    return $.error("Method " + method + " does not exist on jQuery.caret");
  }
};

$.fn.caret.EditableCaret = EditableCaret;

$.fn.caret.InputCaret = InputCaret;

$.fn.caret.Utils = Utils;

$.fn.caret.apis = methods;


}));

/**
 * at.js - 1.5.4
 * Copyright (c) 2018 chord.luo <chord.luo@gmail.com>;
 * Homepage: http://ichord.github.com/At.js
 * License: MIT
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define('atjs',["jquery"], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    factory(jQuery);
  }
}(this, function ($) {
var DEFAULT_CALLBACKS, KEY_CODE;

KEY_CODE = {
  ESC: 27,
  TAB: 9,
  ENTER: 13,
  CTRL: 17,
  A: 65,
  P: 80,
  N: 78,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  BACKSPACE: 8,
  SPACE: 32
};

DEFAULT_CALLBACKS = {
  beforeSave: function(data) {
    return Controller.arrayToDefaultHash(data);
  },
  matcher: function(flag, subtext, should_startWithSpace, acceptSpaceBar) {
    var _a, _y, match, regexp, space;
    flag = flag.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    if (should_startWithSpace) {
      flag = '(?:^|\\s)' + flag;
    }
    _a = decodeURI("%C3%80");
    _y = decodeURI("%C3%BF");
    space = acceptSpaceBar ? "\ " : "";
    regexp = new RegExp(flag + "([A-Za-z" + _a + "-" + _y + "0-9_" + space + "\'\.\+\-]*)$|" + flag + "([^\\x00-\\xff]*)$", 'gi');
    match = regexp.exec(subtext);
    if (match) {
      return match[2] || match[1];
    } else {
      return null;
    }
  },
  filter: function(query, data, searchKey) {
    var _results, i, item, len;
    _results = [];
    for (i = 0, len = data.length; i < len; i++) {
      item = data[i];
      if (~new String(item[searchKey]).toLowerCase().indexOf(query.toLowerCase())) {
        _results.push(item);
      }
    }
    return _results;
  },
  remoteFilter: null,
  sorter: function(query, items, searchKey) {
    var _results, i, item, len;
    if (!query) {
      return items;
    }
    _results = [];
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      item.atwho_order = new String(item[searchKey]).toLowerCase().indexOf(query.toLowerCase());
      if (item.atwho_order > -1) {
        _results.push(item);
      }
    }
    return _results.sort(function(a, b) {
      return a.atwho_order - b.atwho_order;
    });
  },
  tplEval: function(tpl, map) {
    var error, error1, template;
    template = tpl;
    try {
      if (typeof tpl !== 'string') {
        template = tpl(map);
      }
      return template.replace(/\$\{([^\}]*)\}/g, function(tag, key, pos) {
        return map[key];
      });
    } catch (error1) {
      error = error1;
      return "";
    }
  },
  highlighter: function(li, query) {
    var regexp;
    if (!query) {
      return li;
    }
    regexp = new RegExp(">\\s*([^\<]*?)(" + query.replace("+", "\\+") + ")([^\<]*)\\s*<", 'ig');
    return li.replace(regexp, function(str, $1, $2, $3) {
      return '> ' + $1 + '<strong>' + $2 + '</strong>' + $3 + ' <';
    });
  },
  beforeInsert: function(value, $li, e) {
    return value;
  },
  beforeReposition: function(offset) {
    return offset;
  },
  afterMatchFailed: function(at, el) {}
};

var App;

App = (function() {
  function App(inputor) {
    this.currentFlag = null;
    this.controllers = {};
    this.aliasMaps = {};
    this.$inputor = $(inputor);
    this.setupRootElement();
    this.listen();
  }

  App.prototype.createContainer = function(doc) {
    var ref;
    if ((ref = this.$el) != null) {
      ref.remove();
    }
    return $(doc.body).append(this.$el = $("<div class='atwho-container'></div>"));
  };

  App.prototype.setupRootElement = function(iframe, asRoot) {
    var error, error1;
    if (asRoot == null) {
      asRoot = false;
    }
    if (iframe) {
      this.window = iframe.contentWindow;
      this.document = iframe.contentDocument || this.window.document;
      this.iframe = iframe;
    } else {
      this.document = this.$inputor[0].ownerDocument;
      this.window = this.document.defaultView || this.document.parentWindow;
      try {
        this.iframe = this.window.frameElement;
      } catch (error1) {
        error = error1;
        this.iframe = null;
        if ($.fn.atwho.debug) {
          throw new Error("iframe auto-discovery is failed.\nPlease use `setIframe` to set the target iframe manually.\n" + error);
        }
      }
    }
    return this.createContainer((this.iframeAsRoot = asRoot) ? this.document : document);
  };

  App.prototype.controller = function(at) {
    var c, current, currentFlag, ref;
    if (this.aliasMaps[at]) {
      current = this.controllers[this.aliasMaps[at]];
    } else {
      ref = this.controllers;
      for (currentFlag in ref) {
        c = ref[currentFlag];
        if (currentFlag === at) {
          current = c;
          break;
        }
      }
    }
    if (current) {
      return current;
    } else {
      return this.controllers[this.currentFlag];
    }
  };

  App.prototype.setContextFor = function(at) {
    this.currentFlag = at;
    return this;
  };

  App.prototype.reg = function(flag, setting) {
    var base, controller;
    controller = (base = this.controllers)[flag] || (base[flag] = this.$inputor.is('[contentEditable]') ? new EditableController(this, flag) : new TextareaController(this, flag));
    if (setting.alias) {
      this.aliasMaps[setting.alias] = flag;
    }
    controller.init(setting);
    return this;
  };

  App.prototype.listen = function() {
    return this.$inputor.on('compositionstart', (function(_this) {
      return function(e) {
        var ref;
        if ((ref = _this.controller()) != null) {
          ref.view.hide();
        }
        _this.isComposing = true;
        return null;
      };
    })(this)).on('compositionend', (function(_this) {
      return function(e) {
        _this.isComposing = false;
        setTimeout(function(e) {
          return _this.dispatch(e);
        });
        return null;
      };
    })(this)).on('keyup.atwhoInner', (function(_this) {
      return function(e) {
        return _this.onKeyup(e);
      };
    })(this)).on('keydown.atwhoInner', (function(_this) {
      return function(e) {
        return _this.onKeydown(e);
      };
    })(this)).on('blur.atwhoInner', (function(_this) {
      return function(e) {
        var c;
        if (c = _this.controller()) {
          c.expectedQueryCBId = null;
          return c.view.hide(e, c.getOpt("displayTimeout"));
        }
      };
    })(this)).on('click.atwhoInner', (function(_this) {
      return function(e) {
        return _this.dispatch(e);
      };
    })(this)).on('scroll.atwhoInner', (function(_this) {
      return function() {
        var lastScrollTop;
        lastScrollTop = _this.$inputor.scrollTop();
        return function(e) {
          var currentScrollTop, ref;
          currentScrollTop = e.target.scrollTop;
          if (lastScrollTop !== currentScrollTop) {
            if ((ref = _this.controller()) != null) {
              ref.view.hide(e);
            }
          }
          lastScrollTop = currentScrollTop;
          return true;
        };
      };
    })(this)());
  };

  App.prototype.shutdown = function() {
    var _, c, ref;
    ref = this.controllers;
    for (_ in ref) {
      c = ref[_];
      c.destroy();
      delete this.controllers[_];
    }
    this.$inputor.off('.atwhoInner');
    return this.$el.remove();
  };

  App.prototype.dispatch = function(e) {
    var _, c, ref, results;
    if (void 0 === e) {
      return;
    }
    ref = this.controllers;
    results = [];
    for (_ in ref) {
      c = ref[_];
      results.push(c.lookUp(e));
    }
    return results;
  };

  App.prototype.onKeyup = function(e) {
    var ref;
    switch (e.keyCode) {
      case KEY_CODE.ESC:
        e.preventDefault();
        if ((ref = this.controller()) != null) {
          ref.view.hide();
        }
        break;
      case KEY_CODE.DOWN:
      case KEY_CODE.UP:
      case KEY_CODE.CTRL:
      case KEY_CODE.ENTER:
        $.noop();
        break;
      case KEY_CODE.P:
      case KEY_CODE.N:
        if (!e.ctrlKey) {
          this.dispatch(e);
        }
        break;
      default:
        this.dispatch(e);
    }
  };

  App.prototype.onKeydown = function(e) {
    var ref, view;
    view = (ref = this.controller()) != null ? ref.view : void 0;
    if (!(view && view.visible())) {
      return;
    }
    switch (e.keyCode) {
      case KEY_CODE.ESC:
        e.preventDefault();
        view.hide(e);
        break;
      case KEY_CODE.UP:
        e.preventDefault();
        view.prev();
        break;
      case KEY_CODE.DOWN:
        e.preventDefault();
        view.next();
        break;
      case KEY_CODE.P:
        if (!e.ctrlKey) {
          return;
        }
        e.preventDefault();
        view.prev();
        break;
      case KEY_CODE.N:
        if (!e.ctrlKey) {
          return;
        }
        e.preventDefault();
        view.next();
        break;
      case KEY_CODE.TAB:
      case KEY_CODE.ENTER:
      case KEY_CODE.SPACE:
        if (!view.visible()) {
          return;
        }
        if (!this.controller().getOpt('spaceSelectsMatch') && e.keyCode === KEY_CODE.SPACE) {
          return;
        }
        if (!this.controller().getOpt('tabSelectsMatch') && e.keyCode === KEY_CODE.TAB) {
          return;
        }
        if (view.highlighted()) {
          e.preventDefault();
          view.choose(e);
        } else {
          view.hide(e);
        }
        break;
      default:
        $.noop();
    }
  };

  return App;

})();

var Controller,
  slice = [].slice;

Controller = (function() {
  Controller.prototype.uid = function() {
    return (Math.random().toString(16) + "000000000").substr(2, 8) + (new Date().getTime());
  };

  function Controller(app, at1) {
    this.app = app;
    this.at = at1;
    this.$inputor = this.app.$inputor;
    this.id = this.$inputor[0].id || this.uid();
    this.expectedQueryCBId = null;
    this.setting = null;
    this.query = null;
    this.pos = 0;
    this.range = null;
    if ((this.$el = $("#atwho-ground-" + this.id, this.app.$el)).length === 0) {
      this.app.$el.append(this.$el = $("<div id='atwho-ground-" + this.id + "'></div>"));
    }
    this.model = new Model(this);
    this.view = new View(this);
  }

  Controller.prototype.init = function(setting) {
    this.setting = $.extend({}, this.setting || $.fn.atwho["default"], setting);
    this.view.init();
    return this.model.reload(this.setting.data);
  };

  Controller.prototype.destroy = function() {
    this.trigger('beforeDestroy');
    this.model.destroy();
    this.view.destroy();
    return this.$el.remove();
  };

  Controller.prototype.callDefault = function() {
    var args, error, error1, funcName;
    funcName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    try {
      return DEFAULT_CALLBACKS[funcName].apply(this, args);
    } catch (error1) {
      error = error1;
      return $.error(error + " Or maybe At.js doesn't have function " + funcName);
    }
  };

  Controller.prototype.trigger = function(name, data) {
    var alias, eventName;
    if (data == null) {
      data = [];
    }
    data.push(this);
    alias = this.getOpt('alias');
    eventName = alias ? name + "-" + alias + ".atwho" : name + ".atwho";
    return this.$inputor.trigger(eventName, data);
  };

  Controller.prototype.callbacks = function(funcName) {
    return this.getOpt("callbacks")[funcName] || DEFAULT_CALLBACKS[funcName];
  };

  Controller.prototype.getOpt = function(at, default_value) {
    var e, error1;
    try {
      return this.setting[at];
    } catch (error1) {
      e = error1;
      return null;
    }
  };

  Controller.prototype.insertContentFor = function($li) {
    var data, tpl;
    tpl = this.getOpt('insertTpl');
    data = $.extend({}, $li.data('item-data'), {
      'atwho-at': this.at
    });
    return this.callbacks("tplEval").call(this, tpl, data, "onInsert");
  };

  Controller.prototype.renderView = function(data) {
    var searchKey;
    searchKey = this.getOpt("searchKey");
    data = this.callbacks("sorter").call(this, this.query.text, data.slice(0, 1001), searchKey);
    return this.view.render(data.slice(0, this.getOpt('limit')));
  };

  Controller.arrayToDefaultHash = function(data) {
    var i, item, len, results;
    if (!$.isArray(data)) {
      return data;
    }
    results = [];
    for (i = 0, len = data.length; i < len; i++) {
      item = data[i];
      if ($.isPlainObject(item)) {
        results.push(item);
      } else {
        results.push({
          name: item
        });
      }
    }
    return results;
  };

  Controller.prototype.lookUp = function(e) {
    var query, wait;
    if (e && e.type === 'click' && !this.getOpt('lookUpOnClick')) {
      return;
    }
    if (this.getOpt('suspendOnComposing') && this.app.isComposing) {
      return;
    }
    query = this.catchQuery(e);
    if (!query) {
      this.expectedQueryCBId = null;
      return query;
    }
    this.app.setContextFor(this.at);
    if (wait = this.getOpt('delay')) {
      this._delayLookUp(query, wait);
    } else {
      this._lookUp(query);
    }
    return query;
  };

  Controller.prototype._delayLookUp = function(query, wait) {
    var now, remaining;
    now = Date.now ? Date.now() : new Date().getTime();
    this.previousCallTime || (this.previousCallTime = now);
    remaining = wait - (now - this.previousCallTime);
    if ((0 < remaining && remaining < wait)) {
      this.previousCallTime = now;
      this._stopDelayedCall();
      return this.delayedCallTimeout = setTimeout((function(_this) {
        return function() {
          _this.previousCallTime = 0;
          _this.delayedCallTimeout = null;
          return _this._lookUp(query);
        };
      })(this), wait);
    } else {
      this._stopDelayedCall();
      if (this.previousCallTime !== now) {
        this.previousCallTime = 0;
      }
      return this._lookUp(query);
    }
  };

  Controller.prototype._stopDelayedCall = function() {
    if (this.delayedCallTimeout) {
      clearTimeout(this.delayedCallTimeout);
      return this.delayedCallTimeout = null;
    }
  };

  Controller.prototype._generateQueryCBId = function() {
    return {};
  };

  Controller.prototype._lookUp = function(query) {
    var _callback;
    _callback = function(queryCBId, data) {
      if (queryCBId !== this.expectedQueryCBId) {
        return;
      }
      if (data && data.length > 0) {
        return this.renderView(this.constructor.arrayToDefaultHash(data));
      } else {
        return this.view.hide();
      }
    };
    this.expectedQueryCBId = this._generateQueryCBId();
    return this.model.query(query.text, $.proxy(_callback, this, this.expectedQueryCBId));
  };

  return Controller;

})();

var TextareaController,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

TextareaController = (function(superClass) {
  extend(TextareaController, superClass);

  function TextareaController() {
    return TextareaController.__super__.constructor.apply(this, arguments);
  }

  TextareaController.prototype.catchQuery = function() {
    var caretPos, content, end, isString, query, start, subtext;
    content = this.$inputor.val();
    caretPos = this.$inputor.caret('pos', {
      iframe: this.app.iframe
    });
    subtext = content.slice(0, caretPos);
    query = this.callbacks("matcher").call(this, this.at, subtext, this.getOpt('startWithSpace'), this.getOpt("acceptSpaceBar"));
    isString = typeof query === 'string';
    if (isString && query.length < this.getOpt('minLen', 0)) {
      return;
    }
    if (isString && query.length <= this.getOpt('maxLen', 20)) {
      start = caretPos - query.length;
      end = start + query.length;
      this.pos = start;
      query = {
        'text': query,
        'headPos': start,
        'endPos': end
      };
      this.trigger("matched", [this.at, query.text]);
    } else {
      query = null;
      this.view.hide();
    }
    return this.query = query;
  };

  TextareaController.prototype.rect = function() {
    var c, iframeOffset, scaleBottom;
    if (!(c = this.$inputor.caret('offset', this.pos - 1, {
      iframe: this.app.iframe
    }))) {
      return;
    }
    if (this.app.iframe && !this.app.iframeAsRoot) {
      iframeOffset = $(this.app.iframe).offset();
      c.left += iframeOffset.left;
      c.top += iframeOffset.top;
    }
    scaleBottom = this.app.document.selection ? 0 : 2;
    return {
      left: c.left,
      top: c.top,
      bottom: c.top + c.height + scaleBottom
    };
  };

  TextareaController.prototype.insert = function(content, $li) {
    var $inputor, source, startStr, suffix, text;
    $inputor = this.$inputor;
    source = $inputor.val();
    startStr = source.slice(0, Math.max(this.query.headPos - this.at.length, 0));
    suffix = (suffix = this.getOpt('suffix')) === "" ? suffix : suffix || " ";
    content += suffix;
    text = "" + startStr + content + (source.slice(this.query['endPos'] || 0));
    $inputor.val(text);
    $inputor.caret('pos', startStr.length + content.length, {
      iframe: this.app.iframe
    });
    if (!$inputor.is(':focus')) {
      $inputor.focus();
    }
    return $inputor.change();
  };

  return TextareaController;

})(Controller);

var EditableController,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EditableController = (function(superClass) {
  extend(EditableController, superClass);

  function EditableController() {
    return EditableController.__super__.constructor.apply(this, arguments);
  }

  EditableController.prototype._getRange = function() {
    var sel;
    sel = this.app.window.getSelection();
    if (sel.rangeCount > 0) {
      return sel.getRangeAt(0);
    }
  };

  EditableController.prototype._setRange = function(position, node, range) {
    if (range == null) {
      range = this._getRange();
    }
    if (!(range && node)) {
      return;
    }
    node = $(node)[0];
    if (position === 'after') {
      range.setEndAfter(node);
      range.setStartAfter(node);
    } else {
      range.setEndBefore(node);
      range.setStartBefore(node);
    }
    range.collapse(false);
    return this._clearRange(range);
  };

  EditableController.prototype._clearRange = function(range) {
    var sel;
    if (range == null) {
      range = this._getRange();
    }
    sel = this.app.window.getSelection();
    if (this.ctrl_a_pressed == null) {
      sel.removeAllRanges();
      return sel.addRange(range);
    }
  };

  EditableController.prototype._movingEvent = function(e) {
    var ref;
    return e.type === 'click' || ((ref = e.which) === KEY_CODE.RIGHT || ref === KEY_CODE.LEFT || ref === KEY_CODE.UP || ref === KEY_CODE.DOWN);
  };

  EditableController.prototype._unwrap = function(node) {
    var next;
    node = $(node).unwrap().get(0);
    if ((next = node.nextSibling) && next.nodeValue) {
      node.nodeValue += next.nodeValue;
      $(next).remove();
    }
    return node;
  };

  EditableController.prototype.catchQuery = function(e) {
    var $inserted, $query, _range, index, inserted, isString, lastNode, matched, offset, query, query_content, range;
    if (!(range = this._getRange())) {
      return;
    }
    if (!range.collapsed) {
      return;
    }
    if (e.which === KEY_CODE.ENTER) {
      ($query = $(range.startContainer).closest('.atwho-query')).contents().unwrap();
      if ($query.is(':empty')) {
        $query.remove();
      }
      ($query = $(".atwho-query", this.app.document)).text($query.text()).contents().last().unwrap();
      this._clearRange();
      return;
    }
    if (/firefox/i.test(navigator.userAgent)) {
      if ($(range.startContainer).is(this.$inputor)) {
        this._clearRange();
        return;
      }
      if (e.which === KEY_CODE.BACKSPACE && range.startContainer.nodeType === document.ELEMENT_NODE && (offset = range.startOffset - 1) >= 0) {
        _range = range.cloneRange();
        _range.setStart(range.startContainer, offset);
        if ($(_range.cloneContents()).contents().last().is('.atwho-inserted')) {
          inserted = $(range.startContainer).contents().get(offset);
          this._setRange('after', $(inserted).contents().last());
        }
      } else if (e.which === KEY_CODE.LEFT && range.startContainer.nodeType === document.TEXT_NODE) {
        $inserted = $(range.startContainer.previousSibling);
        if ($inserted.is('.atwho-inserted') && range.startOffset === 0) {
          this._setRange('after', $inserted.contents().last());
        }
      }
    }
    $(range.startContainer).closest('.atwho-inserted').addClass('atwho-query').siblings().removeClass('atwho-query');
    if (($query = $(".atwho-query", this.app.document)).length > 0 && $query.is(':empty') && $query.text().length === 0) {
      $query.remove();
    }
    if (!this._movingEvent(e)) {
      $query.removeClass('atwho-inserted');
    }
    if ($query.length > 0) {
      switch (e.which) {
        case KEY_CODE.LEFT:
          this._setRange('before', $query.get(0), range);
          $query.removeClass('atwho-query');
          return;
        case KEY_CODE.RIGHT:
          this._setRange('after', $query.get(0).nextSibling, range);
          $query.removeClass('atwho-query');
          return;
      }
    }
    if ($query.length > 0 && (query_content = $query.attr('data-atwho-at-query'))) {
      $query.empty().html(query_content).attr('data-atwho-at-query', null);
      this._setRange('after', $query.get(0), range);
    }
    _range = range.cloneRange();
    _range.setStart(range.startContainer, 0);
    matched = this.callbacks("matcher").call(this, this.at, _range.toString(), this.getOpt('startWithSpace'), this.getOpt("acceptSpaceBar"));
    isString = typeof matched === 'string';
    if ($query.length === 0 && isString && (index = range.startOffset - this.at.length - matched.length) >= 0) {
      range.setStart(range.startContainer, index);
      $query = $('<span/>', this.app.document).attr(this.getOpt("editableAtwhoQueryAttrs")).addClass('atwho-query');
      range.surroundContents($query.get(0));
      lastNode = $query.contents().last().get(0);
      if (lastNode) {
        if (/firefox/i.test(navigator.userAgent)) {
          range.setStart(lastNode, lastNode.length);
          range.setEnd(lastNode, lastNode.length);
          this._clearRange(range);
        } else {
          this._setRange('after', lastNode, range);
        }
      }
    }
    if (isString && matched.length < this.getOpt('minLen', 0)) {
      return;
    }
    if (isString && matched.length <= this.getOpt('maxLen', 20)) {
      query = {
        text: matched,
        el: $query
      };
      this.trigger("matched", [this.at, query.text]);
      return this.query = query;
    } else {
      this.view.hide();
      this.query = {
        el: $query
      };
      if ($query.text().indexOf(this.at) >= 0) {
        if (this._movingEvent(e) && $query.hasClass('atwho-inserted')) {
          $query.removeClass('atwho-query');
        } else if (false !== this.callbacks('afterMatchFailed').call(this, this.at, $query)) {
          this._setRange("after", this._unwrap($query.text($query.text()).contents().first()));
        }
      }
      return null;
    }
  };

  EditableController.prototype.rect = function() {
    var $iframe, iframeOffset, rect;
    rect = this.query.el.offset();
    if (!(rect && this.query.el[0].getClientRects().length)) {
      return;
    }
    if (this.app.iframe && !this.app.iframeAsRoot) {
      iframeOffset = ($iframe = $(this.app.iframe)).offset();
      rect.left += iframeOffset.left - this.$inputor.scrollLeft();
      rect.top += iframeOffset.top - this.$inputor.scrollTop();
    }
    rect.bottom = rect.top + this.query.el.height();
    return rect;
  };

  EditableController.prototype.insert = function(content, $li) {
    var data, overrides, range, suffix, suffixNode;
    if (!this.$inputor.is(':focus')) {
      this.$inputor.focus();
    }
    overrides = this.getOpt('functionOverrides');
    if (overrides.insert) {
      return overrides.insert.call(this, content, $li);
    }
    suffix = (suffix = this.getOpt('suffix')) === "" ? suffix : suffix || "\u00A0";
    data = $li.data('item-data');
    this.query.el.removeClass('atwho-query').addClass('atwho-inserted').html(content).attr('data-atwho-at-query', "" + data['atwho-at'] + this.query.text).attr('contenteditable', "false");
    if (range = this._getRange()) {
      if (this.query.el.length) {
        range.setEndAfter(this.query.el[0]);
      }
      range.collapse(false);
      range.insertNode(suffixNode = this.app.document.createTextNode("" + suffix));
      this._setRange('after', suffixNode, range);
    }
    if (!this.$inputor.is(':focus')) {
      this.$inputor.focus();
    }
    return this.$inputor.change();
  };

  return EditableController;

})(Controller);

var Model;

Model = (function() {
  function Model(context) {
    this.context = context;
    this.at = this.context.at;
    this.storage = this.context.$inputor;
  }

  Model.prototype.destroy = function() {
    return this.storage.data(this.at, null);
  };

  Model.prototype.saved = function() {
    return this.fetch() > 0;
  };

  Model.prototype.query = function(query, callback) {
    var _remoteFilter, data, searchKey;
    data = this.fetch();
    searchKey = this.context.getOpt("searchKey");
    data = this.context.callbacks('filter').call(this.context, query, data, searchKey) || [];
    _remoteFilter = this.context.callbacks('remoteFilter');
    if (data.length > 0 || (!_remoteFilter && data.length === 0)) {
      return callback(data);
    } else {
      return _remoteFilter.call(this.context, query, callback);
    }
  };

  Model.prototype.fetch = function() {
    return this.storage.data(this.at) || [];
  };

  Model.prototype.save = function(data) {
    return this.storage.data(this.at, this.context.callbacks("beforeSave").call(this.context, data || []));
  };

  Model.prototype.load = function(data) {
    if (!(this.saved() || !data)) {
      return this._load(data);
    }
  };

  Model.prototype.reload = function(data) {
    return this._load(data);
  };

  Model.prototype._load = function(data) {
    if (typeof data === "string") {
      return $.ajax(data, {
        dataType: "json"
      }).done((function(_this) {
        return function(data) {
          return _this.save(data);
        };
      })(this));
    } else {
      return this.save(data);
    }
  };

  return Model;

})();

var View;

View = (function() {
  function View(context) {
    this.context = context;
    this.$el = $("<div class='atwho-view'><ul class='atwho-view-ul'></ul></div>");
    this.$elUl = this.$el.children();
    this.timeoutID = null;
    this.context.$el.append(this.$el);
    this.bindEvent();
  }

  View.prototype.init = function() {
    var header_tpl, id;
    id = this.context.getOpt("alias") || this.context.at.charCodeAt(0);
    header_tpl = this.context.getOpt("headerTpl");
    if (header_tpl && this.$el.children().length === 1) {
      this.$el.prepend(header_tpl);
    }
    return this.$el.attr({
      'id': "at-view-" + id
    });
  };

  View.prototype.destroy = function() {
    return this.$el.remove();
  };

  View.prototype.bindEvent = function() {
    var $menu, lastCoordX, lastCoordY;
    $menu = this.$el.find('ul');
    lastCoordX = 0;
    lastCoordY = 0;
    return $menu.on('mousemove.atwho-view', 'li', (function(_this) {
      return function(e) {
        var $cur;
        if (lastCoordX === e.clientX && lastCoordY === e.clientY) {
          return;
        }
        lastCoordX = e.clientX;
        lastCoordY = e.clientY;
        $cur = $(e.currentTarget);
        if ($cur.hasClass('cur')) {
          return;
        }
        $menu.find('.cur').removeClass('cur');
        return $cur.addClass('cur');
      };
    })(this)).on('click.atwho-view', 'li', (function(_this) {
      return function(e) {
        $menu.find('.cur').removeClass('cur');
        $(e.currentTarget).addClass('cur');
        _this.choose(e);
        return e.preventDefault();
      };
    })(this));
  };

  View.prototype.visible = function() {
    return $.expr.filters.visible(this.$el[0]);
  };

  View.prototype.highlighted = function() {
    return this.$el.find(".cur").length > 0;
  };

  View.prototype.choose = function(e) {
    var $li, content;
    if (($li = this.$el.find(".cur")).length) {
      content = this.context.insertContentFor($li);
      this.context._stopDelayedCall();
      this.context.insert(this.context.callbacks("beforeInsert").call(this.context, content, $li, e), $li);
      this.context.trigger("inserted", [$li, e]);
      this.hide(e);
    }
    if (this.context.getOpt("hideWithoutSuffix")) {
      return this.stopShowing = true;
    }
  };

  View.prototype.reposition = function(rect) {
    var _window, offset, overflowOffset, ref;
    _window = this.context.app.iframeAsRoot ? this.context.app.window : window;
    if (rect.bottom + this.$el.height() - $(_window).scrollTop() > $(_window).height()) {
      rect.bottom = rect.top - this.$el.height();
    }
    if (rect.left > (overflowOffset = $(_window).width() - this.$el.width() - 5)) {
      rect.left = overflowOffset;
    }
    offset = {
      left: rect.left,
      top: rect.bottom
    };
    if ((ref = this.context.callbacks("beforeReposition")) != null) {
      ref.call(this.context, offset);
    }
    this.$el.offset(offset);
    return this.context.trigger("reposition", [offset]);
  };

  View.prototype.next = function() {
    var cur, next, nextEl, offset;
    cur = this.$el.find('.cur').removeClass('cur');
    next = cur.next();
    if (!next.length) {
      next = this.$el.find('li:first');
    }
    next.addClass('cur');
    nextEl = next[0];
    offset = nextEl.offsetTop + nextEl.offsetHeight + (nextEl.nextSibling ? nextEl.nextSibling.offsetHeight : 0);
    return this.scrollTop(Math.max(0, offset - this.$el.height()));
  };

  View.prototype.prev = function() {
    var cur, offset, prev, prevEl;
    cur = this.$el.find('.cur').removeClass('cur');
    prev = cur.prev();
    if (!prev.length) {
      prev = this.$el.find('li:last');
    }
    prev.addClass('cur');
    prevEl = prev[0];
    offset = prevEl.offsetTop + prevEl.offsetHeight + (prevEl.nextSibling ? prevEl.nextSibling.offsetHeight : 0);
    return this.scrollTop(Math.max(0, offset - this.$el.height()));
  };

  View.prototype.scrollTop = function(scrollTop) {
    var scrollDuration;
    scrollDuration = this.context.getOpt('scrollDuration');
    if (scrollDuration) {
      return this.$elUl.animate({
        scrollTop: scrollTop
      }, scrollDuration);
    } else {
      return this.$elUl.scrollTop(scrollTop);
    }
  };

  View.prototype.show = function() {
    var rect;
    if (this.stopShowing) {
      this.stopShowing = false;
      return;
    }
    if (!this.visible()) {
      this.$el.show();
      this.$el.scrollTop(0);
      this.context.trigger('shown');
    }
    if (rect = this.context.rect()) {
      return this.reposition(rect);
    }
  };

  View.prototype.hide = function(e, time) {
    var callback;
    if (!this.visible()) {
      return;
    }
    if (isNaN(time)) {
      this.$el.hide();
      return this.context.trigger('hidden', [e]);
    } else {
      callback = (function(_this) {
        return function() {
          return _this.hide();
        };
      })(this);
      clearTimeout(this.timeoutID);
      return this.timeoutID = setTimeout(callback, time);
    }
  };

  View.prototype.render = function(list) {
    var $li, $ul, i, item, len, li, tpl;
    if (!($.isArray(list) && list.length > 0)) {
      this.hide();
      return;
    }
    this.$el.find('ul').empty();
    $ul = this.$el.find('ul');
    tpl = this.context.getOpt('displayTpl');
    for (i = 0, len = list.length; i < len; i++) {
      item = list[i];
      item = $.extend({}, item, {
        'atwho-at': this.context.at
      });
      li = this.context.callbacks("tplEval").call(this.context, tpl, item, "onDisplay");
      $li = $(this.context.callbacks("highlighter").call(this.context, li, this.context.query.text));
      $li.data("item-data", item);
      $ul.append($li);
    }
    this.show();
    if (this.context.getOpt('highlightFirst')) {
      return $ul.find("li:first").addClass("cur");
    }
  };

  return View;

})();

var Api;

Api = {
  load: function(at, data) {
    var c;
    if (c = this.controller(at)) {
      return c.model.load(data);
    }
  },
  isSelecting: function() {
    var ref;
    return !!((ref = this.controller()) != null ? ref.view.visible() : void 0);
  },
  hide: function() {
    var ref;
    return (ref = this.controller()) != null ? ref.view.hide() : void 0;
  },
  reposition: function() {
    var c;
    if (c = this.controller()) {
      return c.view.reposition(c.rect());
    }
  },
  setIframe: function(iframe, asRoot) {
    this.setupRootElement(iframe, asRoot);
    return null;
  },
  run: function() {
    return this.dispatch();
  },
  destroy: function() {
    this.shutdown();
    return this.$inputor.data('atwho', null);
  }
};

$.fn.atwho = function(method) {
  var _args, result;
  _args = arguments;
  result = null;
  this.filter('textarea, input, [contenteditable=""], [contenteditable=true]').each(function() {
    var $this, app;
    if (!(app = ($this = $(this)).data("atwho"))) {
      $this.data('atwho', (app = new App(this)));
    }
    if (typeof method === 'object' || !method) {
      return app.reg(method.at, method);
    } else if (Api[method] && app) {
      return result = Api[method].apply(app, Array.prototype.slice.call(_args, 1));
    } else {
      return $.error("Method " + method + " does not exist on jQuery.atwho");
    }
  });
  if (result != null) {
    return result;
  } else {
    return this;
  }
};

$.fn.atwho["default"] = {
  at: void 0,
  alias: void 0,
  data: null,
  displayTpl: "<li>${name}</li>",
  insertTpl: "${atwho-at}${name}",
  headerTpl: null,
  callbacks: DEFAULT_CALLBACKS,
  functionOverrides: {},
  searchKey: "name",
  suffix: void 0,
  hideWithoutSuffix: false,
  startWithSpace: true,
  acceptSpaceBar: false,
  highlightFirst: true,
  limit: 5,
  maxLen: 20,
  minLen: 0,
  displayTimeout: 300,
  delay: null,
  spaceSelectsMatch: false,
  tabSelectsMatch: true,
  editableAtwhoQueryAttrs: {},
  scrollDuration: 150,
  suspendOnComposing: true,
  lookUpOnClick: true
};

$.fn.atwho.debug = false;

}));

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define('codemirror/lib/codemirror',factory) :
  (global = global || self, global.CodeMirror = factory());
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;
    if (self.time <= +new Date) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date);
    }
  };
  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 50;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers, arr = map && map[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range;
    try {range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) { return false }
    return range.compareEndPoints("StartToEnd", range) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }

  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }

  // Add a span to a line.
  function addMarkedSpan(line, span, op) {
    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));
    if (inThisOp && inThisOp.has(line.markedSpans)) {
      line.markedSpans.push(span);
    } else {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      if (inThisOp) { inThisOp.add(line.markedSpans); }
    }
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      gutterWrap.setAttribute("aria-hidden", "true");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight; box.bottom += widgetHeight;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e$1) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () {
        if (!cm.hasFocus()) { onBlur(cm); }
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) { onFocus(cm); }
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      if (cm.state.focused) { onBlur(cm); }
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId,          // Unique ID
      markArrays: null         // Used by addMarkedSpan
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range = document.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
    // Send an event to consumers responding to changes in gutter width.
    signalLater(display, "gutterChanged", display);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++)
      { if (!this.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    cm.options.direction = doc.direction;
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(prev) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = prev ? prev.undoDepth : Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        { if (op(this.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this; }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range.head; }
      else if (start == "anchor") { pos = range.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
      else { pos = range.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head || ranges[i].anchor)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {
      var this$1 = this;

      this.history = new History(this.history);
      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
    },

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) { continue }
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function () {
        if (++read == n) {
          operation(cm, function () {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(
                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return
        }
        var reader = new FileReader;
        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
        reader.onload = function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return
          }
          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e$1){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars", "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        { return lookupKey(key, map.fallthrough, handle, context) }
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") { dir = -dir; }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
      { document.execCommand("cut"); }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }
        else { delayBlurEvent(cm); }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if ((webkit && !safari) || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    cm.state.delayingBlurEvent = true;
    setTimeout(function () { return display.input.focus(); }, 20);
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) { delayBlurEvent(cm); }
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
      else
        { ourRange = range; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
    var order = getOrder(anchorLine);
    if (!order) { return range }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e$1) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });

    option("screenReaderLabel", null, function (cm, val) {
      val = (val === '') ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });

    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(function () {
        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }
      }, 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          { indented = indentLine(cm, range.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function(map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this, j, how); }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) { pos = range.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range.from() : range.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty())
            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range.from() : range.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse)
            { return dir < 0 ? range.from() : range.to() }
          var headPos = cursorCoords(this$1, range.head, "div");
          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range, margin) {
        if (range == null) {
          range = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range == "number") {
          range = {from: Pos(range, 0), to: null};
        } else if (range.from == null) {
          range = {from: range, to: null};
        }
        if (!range.to) { range.to = range.from; }
        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "codepoint", "char", "column" (like char, but
  // doesn't cross line boundaries), "word" (across next word), or
  // "group" (to the start of next group of word or
  // non-word-non-whitespace chars). The visually param controls
  // whether, in right-to-left text, direction 1 means to move towards
  // the next index in the string, or towards the character to the right
  // of the current position. The resulting position will have a
  // hitSide=true property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) { return true }
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
      }
      return false
    }

    on(div, "paste", function (e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = activeElt();
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.div.setAttribute('aria-label', label);
    } else {
      this.div.removeAttribute('aria-label');
    }
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = activeElt() == this.div;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt() != this.div)
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find(0)))
            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.textarea.setAttribute('aria-label', label);
    } else {
      this.textarea.removeAttribute('aria-label');
    }
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, */) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.61.1";

  return CodeMirror;

})));

define('codemirror', ['codemirror/lib/codemirror'], function (main) { return main; });

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define('codemirror/mode/xml/xml',["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
}

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  allowMissingTagName: false,
  caseFold: false
}

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    }
  }

  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName || "";
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return attrState(type, stream, state);
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return closeState(type, stream, state);
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null}
      if (baseIndent != null) state.baseIndent = baseIndent
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState
    },

    xmlCurrentTag: function(state) {
      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
    },

    xmlCurrentContext: function(state) {
      var context = []
      for (var cx = state.context; cx; cx = cx.prev)
        context.push(cx.tagName)
      return context.reverse()
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
// In a browser, 'this' will be 'window'.
// Users of node.js should 'require' the uncompressed version since Google's
// JS compiler may break the following exports for non-browser environments.
this['diff_match_patch'] = diff_match_patch;
this['DIFF_DELETE'] = DIFF_DELETE;
this['DIFF_INSERT'] = DIFF_INSERT;
this['DIFF_EQUAL'] = DIFF_EQUAL;

define("diff-match-patch", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.diff_match_patch;
    };
}(this)));

/*
CryptoJS v3.0.2
code.google.com/p/crypto-js
(c) 2009-2012 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(i,m){var p={},h=p.lib={},n=h.Base=function(){function a(){}return{extend:function(b){a.prototype=this;var c=new a;b&&c.mixIn(b);c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.$super.extend(this)}}}(),o=h.WordArray=n.extend({init:function(a,b){a=
this.words=a||[];this.sigBytes=b!=m?b:4*a.length},toString:function(a){return(a||e).stringify(this)},concat:function(a){var b=this.words,c=a.words,d=this.sigBytes,a=a.sigBytes;this.clamp();if(d%4)for(var f=0;f<a;f++)b[d+f>>>2]|=(c[f>>>2]>>>24-8*(f%4)&255)<<24-8*((d+f)%4);else if(65535<c.length)for(f=0;f<a;f+=4)b[d+f>>>2]=c[f>>>2];else b.push.apply(b,c);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<32-8*(b%4);a.length=i.ceil(b/4)},clone:function(){var a=
n.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],c=0;c<a;c+=4)b.push(4294967296*i.random()|0);return o.create(b,a)}}),q=p.enc={},e=q.Hex={stringify:function(a){for(var b=a.words,a=a.sigBytes,c=[],d=0;d<a;d++){var f=b[d>>>2]>>>24-8*(d%4)&255;c.push((f>>>4).toString(16));c.push((f&15).toString(16))}return c.join("")},parse:function(a){for(var b=a.length,c=[],d=0;d<b;d+=2)c[d>>>3]|=parseInt(a.substr(d,2),16)<<24-4*(d%8);return o.create(c,b/2)}},g=q.Latin1={stringify:function(a){for(var b=
a.words,a=a.sigBytes,c=[],d=0;d<a;d++)c.push(String.fromCharCode(b[d>>>2]>>>24-8*(d%4)&255));return c.join("")},parse:function(a){for(var b=a.length,c=[],d=0;d<b;d++)c[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return o.create(c,b)}},j=q.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},k=h.BufferedBlockAlgorithm=n.extend({reset:function(){this._data=o.create();
this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,c=b.words,d=b.sigBytes,f=this.blockSize,e=d/(4*f),e=a?i.ceil(e):i.max((e|0)-this._minBufferSize,0),a=e*f,d=i.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(c,g);g=c.splice(0,a);b.sigBytes-=d}return o.create(g,d)},clone:function(){var a=n.clone.call(this);a._data=this._data.clone();return a},_minBufferSize:0});h.Hasher=k.extend({init:function(){this.reset()},
reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);this._doFinalize();return this._hash},clone:function(){var a=k.clone.call(this);a._hash=this._hash.clone();return a},blockSize:16,_createHelper:function(a){return function(b,c){return a.create(c).finalize(b)}},_createHmacHelper:function(a){return function(b,c){return l.HMAC.create(a,c).finalize(b)}}});var l=p.algo={};return p}(Math);
(function(){var i=CryptoJS,m=i.lib,p=m.WordArray,m=m.Hasher,h=[],n=i.algo.SHA1=m.extend({_doReset:function(){this._hash=p.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(o,i){for(var e=this._hash.words,g=e[0],j=e[1],k=e[2],l=e[3],a=e[4],b=0;80>b;b++){if(16>b)h[b]=o[i+b]|0;else{var c=h[b-3]^h[b-8]^h[b-14]^h[b-16];h[b]=c<<1|c>>>31}c=(g<<5|g>>>27)+a+h[b];c=20>b?c+((j&k|~j&l)+1518500249):40>b?c+((j^k^l)+1859775393):60>b?c+((j&k|j&l|k&l)-1894007588):c+((j^k^l)-
899497514);a=l;l=k;k=j<<30|j>>>2;j=g;g=c}e[0]=e[0]+g|0;e[1]=e[1]+j|0;e[2]=e[2]+k|0;e[3]=e[3]+l|0;e[4]=e[4]+a|0},_doFinalize:function(){var i=this._data,h=i.words,e=8*this._nDataBytes,g=8*i.sigBytes;h[g>>>5]|=128<<24-g%32;h[(g+64>>>9<<4)+15]=e;i.sigBytes=4*h.length;this._process()}});i.SHA1=m._createHelper(n);i.HmacSHA1=m._createHmacHelper(n)})();

define("CryptoJS", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.CryptoJS;
    };
}(this)));


define('tpl/tpl!vellum/templates/xpath_validation_errors', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="alert alert-danger">\n    <h4><i class="fa fa-warning"></i> '+
((__t=(gettext("Validation Failed")))==null?'':_.escape(__t))+
'</h4>\n    <p>'+
((__t=(gettext("Please fix the error before leaving this page:")))==null?'':_.escape(__t))+
'</p>\n    <pre>\n      '+
((__t=(errors))==null?'':__t)+
'\n    </pre>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/xpath_expression', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="form-group xpath-expression-group">\n    <div class="xpath-expression-row">\n        <div class="col-sm-3">\n            <'+
((__t=(tag))==null?'':__t)+
' '+
((__t=(tagArgs))==null?'':__t)+
' class="fd-input form-control left-question xpath-edit-node jstree-drop"\n                   type="text" placeholder="'+
((__t=( leftPlaceholder ))==null?'':__t)+
'" ></'+
((__t=(tag))==null?'':__t)+
'>\n        </div>\n        <div class="col-sm-3">\n            <select class="form-control op-select">\n                ';
 _.each(operationOpts, function (opt) { 
__p+='\n                <option value="'+
((__t=(opt[1]))==null?'':__t)+
'">'+
((__t=(opt[0]))==null?'':__t)+
'</option>\n                ';
 }); 
__p+='\n            </select>\n        </div>\n        <div class="col-sm-3">\n            <'+
((__t=(tag))==null?'':__t)+
' '+
((__t=(tagArgs))==null?'':__t)+
' class="fd-input form-control right-question xpath-edit-node jstree-drop"\n                   type="text" placeholder="'+
((__t=( rightPlaceholder ))==null?'':__t)+
'" ></'+
((__t=(tag))==null?'':__t)+
'>\n        </div>\n        <div class="col-sm-3">\n            <button type="button" class="btn btn-danger xpath-delete-expression pull-right">\n                <i class="fa fa-remove"></i>\n            </button>\n            <div class="validation-result-container">\n                <p class="validation-results alert alert-success hide">\n                    <i class="fa fa-check"></i>\n                </p>\n                <p class="validation-results alert alert-danger hide">\n                    <i class="fa fa-warning"></i>\n                </p>\n            </div>\n        </div>\n    </div>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/xpath', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-xpath-editor-container form form-horizontal">\n\n    <fieldset class="xpath-advanced hide">\n        <legend> \n            <i class="fa fa-cog"></i> '+
((__t=(gettext("Edit <span class='property-name'>Expression</span> (Advanced)")))==null?'':__t)+
'\n            <button type="button" class="btn btn-default fd-xpath-show-simple-button pull-right xpath-mode-toggle">\n                '+
((__t=(gettext("Show Simple Mode")))==null?'':_.escape(__t))+
'\n            </button>\n        </legend>\n        <div class="alert alert-info xpath-advanced-notice hide">\n            <i class="fa fa-info-circle"></i>\n            '+
((__t=(gettext("You are currently in Advanced Mode because your logic is too complicated for Simple Mode.")))==null?'':_.escape(__t))+
'\n        </div>\n        <div class="form-group">\n            <label class="control-label col-sm-2">\n                '+
((__t=(gettext("XPath Expression")))==null?'':_.escape(__t))+
'\n            </label>\n            <div class="col-sm-10">\n                <'+
((__t=( tag ))==null?'':__t)+
' '+
((__t=( tagArgs ))==null?'':__t)+
'\n                          class="fd-textarea form-control fd-xpath-editor-text jstree-drop"></'+
((__t=( tag ))==null?'':__t)+
'>\n                <p class="help-block">'+
((__t=(gettext("You can drag a question into the box.")))==null?'':_.escape(__t))+
'</p>\n                <p class="help-block">\n                    <a target="_blank"\n                       href="https://help.commcarehq.org/display/commcarepublic/Common+Logic+and+Calculations">\n                        <i class="fa fa-info-circle"></i> '+
((__t=(gettext("Guide to Common Logic and Calculations")))==null?'':_.escape(__t))+
'\n                    </a>\n                </p>\n            </div>\n        </div>\n    </fieldset>\n\n    <fieldset class="xpath-simple hide fieldset-condensed">\n        <legend>\n            '+
((__t=(gettext("Edit <span class='property-name'>Expression</span>")))==null?'':__t)+
'\n            <button type="button" class="btn btn-default pull-right xpath-mode-toggle fd-xpath-show-advanced-button">\n                <i class="fa fa-cog"></i> '+
((__t=(gettext("Show Advanced Mode")))==null?'':_.escape(__t))+
'\n            </button>\n        </legend>\n        <div class="form-group">\n            <label class="control-label col-sm-2">'+
((__t=(gettext("Result is")))==null?'':_.escape(__t))+
'</label>\n            <div class="col-sm-10">\n                <select class="form-control top-level-join-select">\n                    ';
 _.each(topLevelJoinOpts, function (opt) { 
__p+='\n                    <option value="'+
((__t=(opt[1]))==null?'':__t)+
'">'+
((__t=(opt[0]))==null?'':__t)+
'</option>\n                    ';
 }); 
__p+='\n                </select>\n            </div>\n        </div>\n        <div class="form-group">\n            <label class="control-label col-sm-2">'+
((__t=(gettext("Expression")))==null?'':_.escape(__t))+
'</label>\n            <div class="col-sm-10">\n                <div class="fd-xpath-editor-expressions well"></div>\n                <p class="help-block pull-right">\n                    <a target="_blank"\n                       href="https://help.commcarehq.org/display/commcarepublic/Common+Logic+and+Calculations">\n                        <i class="fa fa-info-circle"></i> '+
((__t=(gettext("Guide to Common Logic and Calculations")))==null?'':_.escape(__t))+
'\n                    </a>\n                </p>\n                <p>\n                    <button type="button" class="btn btn-default fd-add-exp">\n                        <i class="fa fa-plus"></i> '+
((__t=(gettext("Add Expression")))==null?'':_.escape(__t))+
'\n                    </button>\n                </p>\n            </div>\n        </div>\n    </fieldset>\n\n    <div class="fd-xpath-validation-summary hide"></div>\n\n    <div class="form-actions form-actions-condensed fd-xpath-actions">\n        <div class="col-sm-2"></div>\n        <div class="col-sm-10">\n            <button type="button" class="btn btn-default fd-xpath-save-button">'+
((__t=(gettext("Save")))==null?'':_.escape(__t))+
'</button>\n            <button type="button" class="btn btn-default fd-xpath-cancel-button">'+
((__t=(gettext("Cancel")))==null?'':_.escape(__t))+
'</button>\n        </div>\n    </div>\n</div>\n';
}
return __p;
}; });


define('less/less!vellum/less-style/xpath-editor',[],function(){});
define('vellum/expressionEditor',[
    'jquery',
    'underscore',
    'vellum/debugutil',
    'vellum/atwho',
    'vellum/richText',
    'vellum/hqAnalytics',
    'tpl!vellum/templates/xpath_validation_errors',
    'tpl!vellum/templates/xpath_expression',
    'tpl!vellum/templates/xpath',
    'less!vellum/less-style/xpath-editor'
], function (
    $,
    _,
    debug,
    atwho,
    richText,
    analytics,
    xpath_validation_errors,
    xpath_expression,
    xpath_tpl
) {
    function validateXPath(form, expr) {
        if (expr) {
            if (richText.isInvalid(expr)) {
                expr = richText.unescapeXPath(expr, form);
            }
            try {
                var parsed = form.xpath.parse(expr);
                return [true, parsed];
            } catch (err) {
                return [false, err];
            }
        }
        return [true, null];
    }

    function showXPathEditor($div, options) {
        var editorContent = $div,
            richTextOptions = {isExpression: true},
            form = options.mug.form,
            validate = _.partial(validateXPath, form),
            saveButton;
        options = _.defaults(options, {
            leftPlaceholder: gettext("Drag question here"),
            rightPlaceholder: gettext("Drag question here"),
        });

        var handleChange = function () {
            saveButton.removeClass("btn-default disabled").addClass("btn-success");
            options.change();
        };

        // Handlers for the simple expression editor
        var simpleExpressions = {};
        var operationOpts = [];
        var expTypes = form.xpath.models.XPathExpressionTypeEnum;
        var BinOpHandler = {
            toString: function(op, left, right) {
                // make sure we wrap the vals in parens in case they were necessary
                // todo, construct manually, and validate individual parts.
                return "(" + left + ") " + 
                    form.xpath.models.expressionTypeEnumToXPathLiteral(op) + 
                    " (" + right + ")";
            },
            typeLeftRight: function(expOp) {
                return expOp;
            }
        };
        var FunctionHandler = {
            toString: function(op, left, right) {
                return op + "(" + left + ", " + right + ")";
            },
            typeLeftRight: function(expOp) {
                if (expOp.args.length !== 2) return false;
                return {
                    type: expOp.id,
                    left: expOp.args[0],
                    right: expOp.args[1]
                };
            }
        };
        function addOp(expr, value, label) {
            value = form.xpath.models.expressionTypeEnumToXPathLiteral(value);
            simpleExpressions[value] = expr;
            operationOpts.push([label, value]);
        }

        addOp(BinOpHandler, expTypes.EQ, gettext("is equal to"));
        addOp(BinOpHandler, expTypes.NEQ, gettext("is not equal to"));
        addOp(BinOpHandler, expTypes.LT, gettext("is less than"));
        addOp(BinOpHandler, expTypes.LTE, gettext("is less than or equal to"));
        addOp(BinOpHandler, expTypes.GT, gettext("is greater than"));
        addOp(BinOpHandler, expTypes.GTE, gettext("is greater than or equal to"));
        addOp(FunctionHandler, "selected", gettext("has selected value"));

        var getExpressionInput = function () {
            return $div.find(".fd-xpath-editor-text");
        };

        var setExpression = function(input, val) {
            if (options.mug.form.richText) {
                richText.editor(input, form, richTextOptions).setValue(val);
            } else {
                input.val(val);
            }
        };

        var getExpression = function(input) {
            if (options.mug.form.richText) {
                return richText.editor(input, form, richTextOptions).getValue();
            } else {
                return input.val();
            }
        };

        var getValidationSummary = function () {
            return $div.find(".fd-xpath-validation-summary");
        };
        var getExpressionPane = function () {
            return $div.find(".fd-xpath-editor-expressions");
        };
        var getTopLevelJoinSelect = function () {
            return $(editorContent.find(".top-level-join-select")[0]);
        };
        var addAutocomplete = function (input, choices) {
            if (choices) {
                if (_.isFunction(choices)) {
                    choices = choices();
                }
                atwho.autocomplete(input, options.mug, {choices: choices});
            } else {
                atwho.autocomplete(input, options.mug, {
                    property: options.path,
                    useRichText: options.mug.form.richText,
                });
            }
        };

        var getExpressionFromSimpleMode = function () {
            // basic
            var pane = getExpressionPane();
            var expressionParts = [];
            var joinType = getTopLevelJoinSelect().val();
            pane.children().each(function() {
                var left = getExpression($(this).find(".left-question")),
                    right = getExpression($(this).find(".right-question"));

                // ignore empty expressions
                if (left === "" && right === "") {
                    return;
                }
                var op = $($(this).find(".op-select")[0]).val();
                var exprPath = simpleExpressions[op].toString(op, left, right);
                expressionParts.push(exprPath);
            });
            var preparsed = expressionParts.join(" " + joinType + " ");
            // try to parse and unparse to clean up the formatting
            var results = validate(preparsed);
            if (results[0] && results[1]) {
                return results[1].toXPath();
            }
            return preparsed;
        };

        var getExpressionFromUI = function () {
            if ($div.find(".xpath-simple").hasClass('hide')) {
                // advanced
                return getExpression(getExpressionInput());
            } else {
                return getExpressionFromSimpleMode();
            }
        };

        var tryAddExpression = function(parsedExpression, joiningOp) {
            // trys to add an expression to the UI.
            // if the expression is empty just appends a new div for the expression.
            // if the expression exists, it will try to parse it into sub
            // expressions.
            // returns the expression if it succeeds, otherwise false.
            if (parsedExpression && options.DEBUG_MODE) {
                debug.log("trying to add", parsedExpression.toString());
            }

            var isJoiningOp = function (subElement) {
                // something that joins expressions
                return (subElement instanceof form.xpath.models.XPathBoolExpr);
            };

            var isExpressionOp = function (subElement) {
                // something that can be put into an expression
                return (subElement instanceof form.xpath.models.XPathCmpExpr ||
                        subElement instanceof form.xpath.models.XPathEqExpr ||
                        simpleExpressions.hasOwnProperty(subElement.id));
            };

            var newExpressionUIElement = function (expOp) {
                var tag = 'input', tagArgs = '';
                if (options.mug.form.richText) {
                    tag = 'div';
                    tagArgs = 'contenteditable="true"';
                }

                var $expUI = $(xpath_expression({
                    operationOpts: operationOpts,
                    leftPlaceholder: options.leftPlaceholder,
                    rightPlaceholder: options.rightPlaceholder,
                    tag: tag,
                    tagArgs: tagArgs,
                }));

                if (options.mug.form.richText) {
                    $expUI.find('.fd-input').each(function () {
                        richText.editor($(this), form, richTextOptions);
                    });
                }

                var getLeftQuestionInput = function () {
                    return $($expUI.find(".left-question")[0]);
                };

                var getRightQuestionInput = function () {
                    return $($expUI.find(".right-question")[0]);
                };

                var validateExpression = function(item) {
                    handleChange();
                    var le = getExpression(getLeftQuestionInput()),
                        re = getExpression(getRightQuestionInput());


                    $expUI.find('.validation-results').addClass('hide');

                    if (le && validate(le)[0] && re && validate(re)[0]) {
                        $expUI.find('.validation-results.alert-success').removeClass('hide');
                    } else {
                        $expUI.find('.validation-results.alert-danger').removeClass('hide');
                    }
                };

                var populateQuestionInputBox = function (input, expr, pairedExpr) {
                    setExpression(input, expr.toXPath());
                };

                // add event handlers to validate the inputs
                if (options.mug.form.richText) {
                    $expUI.find('.xpath-edit-node').each(function () {
                        richText.editor($(this), form, richTextOptions).on('change', validateExpression);
                    });
                } else {
                    $expUI.find('.xpath-edit-node').on('keyup change', validateExpression);
                }
                $expUI.find('.op-select').on('change', validateExpression);

                $expUI.find('.xpath-delete-expression').click(function() {
                    $expUI.remove();
                    handleChange();
                });

                if (expOp) {
                    // populate
                    if (options.DEBUG_MODE) {
                        debug.log("populating", expOp.toString());
                    }
                    if (simpleExpressions.hasOwnProperty(expOp.id)) {
                        // comparison and equality operators DO NOT have an "id"
                        // property, so they will not get here. It doesn't
                        // matter though since already fulfill the necessary
                        // "type/left/right" interface.
                        expOp = simpleExpressions[expOp.id].typeLeftRight(expOp);
                        if (!expOp) return false;
                    }
                    populateQuestionInputBox(getLeftQuestionInput(), expOp.left);
                    $expUI.find('.op-select').val(form.xpath.models.expressionTypeEnumToXPathLiteral(expOp.type));
                    // the population of the left can affect the right,
                    // so we need to update the reference
                    populateQuestionInputBox(getRightQuestionInput(), expOp.right, expOp.left);
                }

                addAutocomplete(getLeftQuestionInput(), options.leftAutocompleteChoices);
                addAutocomplete(getRightQuestionInput(), options.rightAutocompleteChoices);

                return $expUI;
            };

            var failAndClear = function () {
                getExpressionPane().empty();
                if (options.DEBUG_MODE) {
                    debug.log("fail", parsedExpression);
                }
                return false;
            };

            var expressionPane = getExpressionPane();
            var expressionUIElem, leftUIElem, rightUIElem;
            if (!parsedExpression) {
                // just create a new expression
                expressionUIElem = newExpressionUIElement();
                return expressionUIElem.appendTo(expressionPane);
            } else {
                // we're creating for an existing expression, this is more complicated

                if (isExpressionOp(parsedExpression)) {
                    // if it's an expression op stick it in.
                    // no need to join, so this is good.
                    expressionUIElem = newExpressionUIElement(parsedExpression);
                    if (!expressionUIElem) {
                        return failAndClear();
                    }
                    return expressionUIElem.appendTo(expressionPane);
                } else if (isJoiningOp(parsedExpression)) {
                    // if it's a joining op the first element has to be
                    // an expression and the second must be a valid op
                    // isExpressionOp(parsedExpression.right))
                    if (joiningOp && parsedExpression.type !== joiningOp) {
                        // we tried to add a joining op that was different from
                        // what we were already working on. Fail.
                        return failAndClear();
                    }
                    leftUIElem = tryAddExpression(parsedExpression.left, parsedExpression.type);
                    rightUIElem = tryAddExpression(parsedExpression.right, parsedExpression.type);
                    if (leftUIElem && rightUIElem) {
                        leftUIElem.appendTo(expressionPane);
                        rightUIElem.appendTo(expressionPane);
                        getTopLevelJoinSelect().val(parsedExpression.type);
                    } else {
                        // something recursively failed. Raise failure up.
                        return failAndClear();
                    }
                    return rightUIElem; // this is arbitrary / maybe wrong
                } else {
                    // fail and return nothing.
                    return failAndClear();
                }
            }
        };

        var setUIForExpression = function (xpathstring) {
            if (options.DEBUG_MODE) {
                debug.log("setting ui for", xpathstring);
            }
            var results = validate(xpathstring);
            if (results[0]) {
                // it parsed correctly, try to load it.
                var parsed = results[1];
                // try to load the operation into the UI.
                if (tryAddExpression(parsed)) {
                    // it succeeded. nothing more to do
                } else {
                    // show advanced mode.
                    showAdvancedMode(parsed.toXPath(), true);
                }
            } else {
                showAdvancedMode(xpathstring, true);
            }
        };

        var updateXPathEditor = function(options) {
            // clear validation text
            getValidationSummary()
                .text("")
                .addClass("hide");

            // clear expression builder
            var expressionPane = getExpressionPane();
            expressionPane.empty();

            // update expression builder
            if (options.xpathType === "bool") {
                showSimpleMode(options.value);
                if (!options.value) {
                    tryAddExpression();
                }
            } else {
                if (options.mug.form.richText) {
                    showAdvancedMode(options.value);
                } else {
                    showAdvancedMode(form.normalizeXPath(options.value));
                }
            }
        };

        // toggle simple/advanced mode
        var showAdvancedMode = function (text, showNotice) {
            setExpression(getExpressionInput(), text);
            addAutocomplete(getExpressionInput());
            getExpressionPane().empty();

            $div.find(".xpath-advanced").removeClass('hide');
            $div.find(".xpath-simple").addClass('hide');
            $div.find('.fd-xpath-actions').removeClass('form-actions-condensed');
            if (showNotice) {
                $div.find(".xpath-advanced-notice").removeClass('hide');
                $div.find(".fd-xpath-show-simple-button").addClass('hide');
            } else {
                $div.find(".xpath-advanced-notice").addClass('hide');
                $div.find(".fd-xpath-show-simple-button").removeClass('hide');
            }
        };
        var showSimpleMode = function (text) {
            $div.find(".xpath-simple").removeClass('hide');
            $div.find('.fd-xpath-actions').addClass('form-actions-condensed');
            $div.find(".xpath-advanced").addClass('hide');

            getExpressionPane().empty();
            // this sometimes sends us back to advanced mode (if we couldn't parse)
            // for now consider that fine.
            if (text) {
                setUIForExpression(text);
            }
        };

        var initXPathEditor = function() {
            var tag = 'textarea', tagArgs = 'rows="5"';
            if (options.mug.form.richText) {
                tag = 'div';
                tagArgs = 'contenteditable="true"';
            }

            var $xpathUI = $(xpath_tpl({
                topLevelJoinOpts: [
                    [gettext("True when ALL of the expressions are true."), expTypes.AND],
                    [gettext("True when ANY of the expressions are true."), expTypes.OR]
                ],
                tag: tag,
                tagArgs: tagArgs,
            }));
            editorContent.html($xpathUI);
            saveButton = $xpathUI.find('.fd-xpath-save-button');

            $xpathUI.find('.fd-xpath-show-advanced-button').click(function () {
                analytics.fbUsage('Edit Expression', 'Show Advanced Mode');
                showAdvancedMode(getExpressionFromSimpleMode());

            });

            $xpathUI.find('.fd-xpath-show-simple-button').click(function () {
                showSimpleMode(getExpression(getExpressionInput()));
            });

            $xpathUI.find('.fd-add-exp').click(function () {
                tryAddExpression();
            });

            var advancedInput = $xpathUI.find('.fd-xpath-editor-text');
            if (options.mug.form.richText) {
                richText.editor(advancedInput, form, richTextOptions)
                        .on('change', handleChange);
            } else {
                advancedInput.on('change keyup', handleChange);
            }

            getTopLevelJoinSelect().change(handleChange);

            var done = function (val) {
                options.done(val);
                editorContent.empty();
            };

            saveButton.addClass("disabled").click(function() {
                var uiExpression  = getExpressionFromUI();
                setExpression(getExpressionInput(), uiExpression);
                var results = validate(uiExpression);
                if (results[0]) {
                    done(uiExpression);
                } else {
                    getValidationSummary()
                        .html($(xpath_validation_errors({
                            errors: results[1].message
                        })))
                        .removeClass("hide");
                }
            });

            $xpathUI.find('.fd-xpath-cancel-button').click(function () {
                done(false);
            });
            return $xpathUI;
        };

        var $xpathUI = initXPathEditor();
        updateXPathEditor(options);
        if (options.onLoad) {
            options.onLoad($xpathUI);
        }
    }

    return {
        showXPathEditor: showXPathEditor,
        validateXPath: validateXPath,
    };
});

// the UI/ViewModel

define('vellum/core',[
    'require',
    'save-button',
    'underscore',
    'jquery',
    'tpl!vellum/templates/main',
    'tpl!vellum/templates/add_question',
    'tpl!vellum/templates/edit_source',
    'tpl!vellum/templates/confirm_overwrite',
    'tpl!vellum/templates/control_group_stdInput',
    'tpl!vellum/templates/form_errors_template',
    'tpl!vellum/templates/question_fieldset',
    'tpl!vellum/templates/question_type_changer',
    'tpl!vellum/templates/question_toolbar',
    'tpl!vellum/templates/alert_global',
    'tpl!vellum/templates/modal_content',
    'tpl!vellum/templates/modal_button',
    'tpl!vellum/templates/find_usages',
    'tpl!vellum/templates/find_usages_search',
    'vellum/mugs',
    'vellum/widgets',
    'vellum/richText',
    'vellum/parser',
    'vellum/xml',
    'vellum/datasources',
    'vellum/util',
    'vellum/javaRosa/util',
    'vellum/hqAnalytics',
    'vellum/atwho',
    'vellum/debugutil',
    'vellum/base',
    'vellum/jstree-plugins',
    'less!vellum/less-style/main',
    'jquery.jstree',
    'jstree-actions',
    'jquery.bootstrap',
    'caretjs',
    'atjs'
], function (
    require,
    SaveButton,
    _,
    $,
    main_template,
    add_question,
    edit_source,
    confirm_overwrite,
    control_group_stdInput,
    form_errors_template,
    question_fieldset,
    question_type_changer,
    question_toolbar,
    alert_global,
    modal_content,
    modal_button,
    find_usages,
    find_usages_search,
    mugs,
    widgets,
    richText,
    parser,
    xml,
    datasources,
    util,
    jrUtil,
    analytics,
    atwho,
    debug
) {
    // Load these modules in the background after all runtime dependencies have
    // been resolved, since they're not needed initially.
    setTimeout(function () {
        require([
            'codemirror',
            'codemirror/mode/xml/xml',
            'diff-match-patch',
            'CryptoJS',
            'vellum/expressionEditor',
        ], function () {});
    }, 0);

    var isMac = util.isMac,
        HOTKEY_UNICODE = {
            Ctrl: "Ctrl+",
            Alt: "Alt+",
            Shift: "Shift+",
        };
    if (isMac) {
        HOTKEY_UNICODE = {
            Ctrl: "\u2318",
            Alt: "\u2325",
            Shift: "\u21E7",
        };
    }

    var DEBUG_MODE = false;

    var MESSAGE_TYPES = {
        "error": {
            cssClass: "alert-danger",
            title: gettext("Error"),
            icon: "fa fa-exclamation-circle",
        },
        "parse-warning": {
            cssClass: "alert-warning",
            title: gettext("Warning"),
            icon: "fa fa-warning",
        },
        "form-warning": {
            cssClass: "alert-warning",
            title: gettext("Form Warning"),
            icon: "fa fa-info-circle",
        },
        "info": {
            cssClass: "alert-info",
            title: gettext("Notification"),
            icon: "fa fa-info-circle",
        },
    };

    var fn = {};

    fn.isCurrentlySelectedMugValid = function () {
        var mug = this.getCurrentlySelectedMug();
        if (mug) {
            mug.validate();
            return !mug.hasErrors();
        }
        return true;
    };

    fn.init = function () {
        this.data.core.mugTypes = new mugs.MugTypesManager(
            this.getMugSpec(), this.getMugTypes(), this.opts());

        var _this = this,
            bindBeforeUnload = this.opts().core.bindBeforeUnload;
        this.data.core.saveButton = SaveButton.init({
            save: function(event) {
                var forceFullSave = event && event.altKey;
                if (forceFullSave &&
                    !window.confirm(gettext("Holding the ALT key while clicking save " +
                            "invokes an inefficient save procedure. Do " +
                            "this only if a normal save fails."))) {
                    return; // abort
                }
                _this.ensureCurrentMugIsSaved(function () {
                    analytics.workflow("Clicked Save in the form builder");
                    _this.validateAndSaveXForm(forceFullSave);
                });
                _this.data.core.form.walkMugs(function (mug) {
                    mug.__originalNodeID = mug.p.nodeID;
                    mug.dropMessage("nodeID", "mug-nodeID-changed-warning");
                });
            },
            unsavedMessage: gettext('Are you sure you want to exit? All unsaved changes will be lost!'),
            csrftoken: _this.opts().csrftoken
        });

        var validateForSave = _.debounce(function () {
            var form = _this.data.core.form,
                template = "<div class='alert alert-danger'>{error}<br/>{action}</div>",
                icon = "<i class='fd-valid-alert-icon fa fa-warning'></i>",
                action;
            if (form.hasBrokenReferences()) {
                action = gettext("Look for questions marked with $1 and " +
                    "check they don't reference deleted questions.");
                return {
                    title: gettext("Errors in Form"),
                    content: util.format(template, {
                        error: gettext("Form has reference errors."),
                        action: action.replace('$1', icon),
                    }),
                };
            } else if (!_this.isCurrentlySelectedMugValid()) {
                action = gettext("Look for questions marked with $1 and fix the errors.");
                // TODO make a more efficient way to check if any mug in the
                // form is not valid and use that instead of only current mug.
                return {
                    title: "Validation Failed",
                    content: util.format(template, {
                        error: gettext("Form has validation errors."),
                        action: action.replace('$1', icon),
                    }),
                };
            } else {
                return {title: "", content: ""};
            }
        }, 500, true);
        _this.data.core.saveButton.ui.popover({
            title: function () {
                return validateForSave().title;
            },
            content: function() {
                return validateForSave().content;
            },
            html: true,
            placement: 'bottom',
            container: 'body',
            trigger: 'hover',
            sanitize: false,
        });
        // Saving, and the associated modal, can interfere with the popover,
        // so make absolutely sure that the popover is removed on save.
        _this.data.core.saveButton.ui.on('click', function() {
            $(this).popover('hide');
        });

        bindBeforeUnload(this.data.core.saveButton.beforeunload);

        this.data.core.lastSavedXForm = this.opts().core.form;

        this.$f.addClass('formdesigner');
        var mainVars = _.extend({format: util.format}, HOTKEY_UNICODE);
        this.$f.empty().append(main_template(mainVars));
        $(document).on("keydown", function (e) {
            var key = util.getKeyChord(e);
            (fn.hotkeys[key] || _.identity).call(_this, e);
        });

        $(document).on('click', '.jstree-hover', function(e) {
            e.preventDefault();
            var ufid = $(this).data("ufid");
            _this.scrollTreeTo(ufid);
            analytics.fbUsage("Clicked link to show in tree");
            analytics.workflow("Clicked on easy reference popover's link to show in tree");
        });

        $(window).on('hashchange', function () {
            _this.selectSomethingOrHideProperties(true, window.location.hash);
        });

        this._init_toolbar();
        this._init_add_question();
        this._createJSTree();
        this.datasources = datasources.init(
            this.opts().core.dataSourcesEndpoint,
            this.opts().core.invalidCaseProperties
        );
    };

    fn.postInit = function () {
        var _this = this;
        function onReady () {
            // Allow onReady to access vellum instance (mostly for tests)
            _this.opts().core.onReady.apply(_this);
        }
        if (_this.opts().features.allow_bulk_form_actions) {
            this._init_bulk_update_questions();
        }
        this._init_extra_tools();
        parser.init(this);
        this.loadXFormOrError(this.opts().core.form, function () {
            setTimeout(onReady, 0);
        });
    };

    fn.hotkeys = {
        "Ctrl+Alt+=": function () {
            this.data.core.$tree.jstree("open_all");
        },
        "Ctrl+Alt+-": function () {
            this.data.core.$tree.jstree("close_all");
        },
    };

    /**
     * Get all Mug types.
     *
     * @returns {Object} - Object with `normal` and `auxiliary` properties containing mug definitions.
     */
    fn.getMugTypes = function () {
        return mugs.baseMugTypes;
    };

    fn._init_add_question = function () {
        var _this = this,
            $dropdown = _this.$f.find(".fd-add-question-dropdown");
        this.data.core.QUESTIONS_IN_TOOLBAR = [];

        _.each(_this.getQuestionGroups(), function (groupData) {
            var getQuestionData = function (questionType) {
                var mugType = _this.data.core.mugTypes[questionType],
                    questionData = [
                        questionType,
                        mugType.typeName,
                        mugType.icon
                    ];

                _this.data.core.QUESTIONS_IN_TOOLBAR.push(questionType);
                return questionData;
            };

            groupData.questions = _.map(groupData.questions, getQuestionData);
        });

        $dropdown.find(".fd-add-question").after($(add_question({
            groups: _.map(_this.getQuestionGroups(), function(groupData) {
                var defaultMug = _this.data.core.mugTypes[groupData.group[0]];
                return {
                    name: groupData.group[1] || defaultMug.typeName,
                    defaultQuestion: {
                        slug: groupData.group[0],
                        name: groupData.group[1] || defaultMug.typeName,
                        icon: groupData.group[2] || defaultMug.icon,
                    },
                    questions: _.map(groupData.questions, function(questionType) {
                        var mugType = _this.data.core.mugTypes[questionType];
                        return {
                            slug: questionType,
                            name: mugType.typeName,
                            icon: mugType.icon,
                        };
                    }),
                };
            }),
        })));

        $dropdown.find(".fd-question-type").click(function (e) {
            if (!$(this).hasClass('disabled')) {
                _this.addQuestion($(this).data('qtype'));
            }
            e.preventDefault();
        });
    };

    fn._init_toolbar = function () {
        var $saveButtonContainer = this.$f.find('.fd-save-button');
        this.data.core.saveButton.ui.appendTo($saveButtonContainer);
    };

    /**
     * Get question groups to display.
     *
     * @returns {Object} - List of group configurations. Each group configuration is an object with the
     *              following properties:
     *              - group: [groupName, groupDisplayName]
     *              - questions: [mugType, ...]
     */
    fn.getQuestionGroups = function () {
        let mediaGroup = {
            group: ["Image", gettext('Multimedia Capture')],
            questions: [
                "Image",
                "Audio",
                "Video",
                "Signature"
            ]
        };
        if (this.opts().features.case_micro_image) {
            mediaGroup.questions.push("MicroImage");
        }

        return [
            {
                group: ["Text"],
                questions: ["Text"],
            },
            {
                group: ["Select", gettext('Multiple Choice')],
                questions: ["Select", "MSelect"],
            },
            {
                group: ["Int", gettext('Number')],
                questions: [
                    "Int",
                    "PhoneNumber",
                    "Double",
                ]
            },
            {
                group: ["Date", gettext('Date')],
                questions: [
                    "Date",
                    "Time",
                    "DateTime"
                ]
            },
            {
                group: ["Group", gettext('Groups')],
                questions: [
                    "Group",
                    "Repeat",
                    "FieldList"
                ]
            },
            mediaGroup,
            {
                group: ["Trigger"],
                questions: ["Trigger"],
            },
            {
                group: ["DataBindOnly", gettext('Hidden Value')],
                questions: [
                    "DataBindOnly"
                ]
            },
            {
                group: ["Geopoint", gettext('Advanced'), ''],
                textOnly: true,
                questions: this.getAdvancedQuestions()
            }
        ];
    };

    fn.getAdvancedQuestions = function () {
        return [
            "Geopoint",
            "Barcode",
            "Secret",
        ];
    };

    fn._init_bulk_update_questions = function () {
        var _this = this,
            menuItems = this.getBulkUpdateMenuItems();

        var $lastItem = this.$f.find('.fd-bulk-update-header');
        $lastItem.nextUntil(".divider").remove();
        _(menuItems).each(function (menuItem) {
            var $menuLink = $(util.format(
                    "<a tabindex='-1' href='#'>{name}</a>",
                    _.extend(menuItem)
                )).click(function (e) {
                    e.preventDefault();
                    _this.showConfirmBulkActionModal(menuItem.confirmMessage, menuItem.confirmAction);
                }),
                $newItem = $("<li></li>").append($menuLink);
            $lastItem.after($newItem);
            $lastItem = $newItem;
        });

    };

    fn.getBulkUpdateMenuItems = function () {
        var _this = this,
            menuItems =  [
                {
                    name: gettext('Make Required'),
                    confirmMessage: gettext("You are about to make all existing " +
                        "questions on this form required. This action will overwrite " +
                        "the current configuration of this form and can only be " +
                        "undone by editing individual questions."),
                    confirmAction: function () {
                        _this.makeAllQuestionsRequired();
                    },
                },
            ];

        if (_this.data.core.databrowser) {
            menuItems.push({
                name: gettext('Load Default Values'),
                confirmMessage: gettext("You are about to set matching case " +
                    "properties as Default Values for all existing questions. " +
                    "This action will overwrite existing Default Values for " +
                    "all questions with matching case properties and can only " +
                    "be undone by editing individual questions."),
                confirmAction: function () {
                    _this.defaultMatchingQuestionsToCaseProperties();
                },
            });
        }
        return menuItems;
    };

    fn.makeAllQuestionsRequired = function () {
        var _this = this;
        _this.data.core.form.walkMugs(function (mug) {
            if (mug.spec.requiredAttr && mug.isVisible('requiredAttr')) {
                mug.p.requiredAttr = true;
            }
        });
        _this.refreshCurrentMug();
    };

    fn.defaultMatchingQuestionsToCaseProperties = function () {
        var _this = this,
            caseProperties = _this.datasources.getHashtagMap({});
        _this.data.core.form.walkMugs(function (mug) {
            if (mug.isVisible('defaultValue')) {
                var caseProp = '#case/' + mug.p.nodeID,
                    userCaseProp = '#user/' + mug.p.nodeID;
                if (caseProperties.hasOwnProperty(caseProp)) {
                    mug.p.defaultValue = caseProp;
                } else if (caseProperties.hasOwnProperty(userCaseProp)) {
                    mug.p.defaultValue = userCaseProp;
                }
            }
        });
        _this.refreshCurrentMug();
    };

    fn.showConfirmBulkActionModal = function (confirmMessage, confirmActionFn) {
        var _this = this,
            $modal;
        $modal = this.generateNewModal(gettext("Are you sure you want to perform this action?"), [
            {
                title: gettext('Continue'),
                cssClasses: "btn-primary",
                action: function () {
                    _this.closeModal();
                    confirmActionFn();
                }
            }
        ], gettext("Cancel"));
        $modal.find('.modal-body').html($('<p></p>').text(confirmMessage));
        $modal.modal('show');
    };

    fn._init_extra_tools = function () {
        var _this = this,
            menuItems = this.getToolsMenuItems();

        var $lastItem = this.$f.find('.fd-tools-menu');
        $lastItem.nextUntil(".divider").remove();
        _(menuItems).each(function (menuItem) {
            var hotkey = menuItem.hotkey || "",
                key = "";
            if (hotkey) {
                fn.hotkeys[hotkey] = function () {
                    menuItem.action.apply(_this, function () {});
                };
                key = hotkey.replace(/(Ctrl|Alt|Shift)\+/g, function (match, mod) {
                    return HOTKEY_UNICODE[mod] || mod;
                });
                key = "<span class='hotkey'>" + key + "</span>";
            }
            var $a = $(util.format(
                    "<a tabindex='-1' href='#'><i class='{icon}'></i> {name}{key}</a>",
                    _.extend({key: key}, menuItem)
                )).click(function (e) {
                    e.preventDefault();
                    _this.ensureCurrentMugIsSaved(function () {
                        analytics.fbUsage("Tools", menuItem.name);
                        menuItem.action.call(_this, function () {
                            _this.refreshVisibleData();
                        });
                    });
                }),
                $newItem = $("<li></li>").append($a);
            $lastItem.after($newItem);
            $lastItem = $newItem;
        });

        this.$f.find('.fd-expand-all').click(function() {
            _this.data.core.$tree.jstree("open_all");
        });

        this.$f.find('.fd-collapse-all').click(function() {
            _this.data.core.$tree.jstree("close_all");
        });

        this.$f.find('.fd-button-copy').click(function () {
            analytics.usage("Copy Paste", "Copy Button");
            analytics.workflow("Clicked Copy Button in form builder");
            _this.ensureCurrentMugIsSaved(function () {
                _this.displayMultipleSelectionView();
                var selected = _this.jstree("get_selected");
                if (selected.length) {
                    $("#" + selected[0] + " a").focus();
                }
            });
        });

        // Section toggling menu
        this.$f.find(".fd-content-right").on('click', '.fd-section-changer .dropdown-menu a', function(e) {
            var $link = $(e.target);
            _this.collapseSection($link.data("slug"), $link.hasClass("selected"));
        });
    };

    fn.toggleFullScreen = function () {
        var _this = this,
            expand = gettext("Expand Editor"),
            shrink = gettext("Shrink Editor"),
            expandOrShrink = new RegExp(RegExp.escape(expand) + "|" + RegExp.escape(shrink)),
            $fullScreenMenuItem = $(_.find(_this.$f.find('.fd-tools-menu').nextAll(), function(li) {
                return $(li).find("a").text().match(expandOrShrink);
            })).find("a"),
            html = $fullScreenMenuItem.html();
        analytics.fbUsage("Full Screen Mode", _this.opts().core.formid);
        if (_this.data.windowManager.fullscreen) {
            _this.data.windowManager.fullscreen = false;
            $fullScreenMenuItem.html(html.replace(new RegExp(RegExp.escape(shrink)), expand));
        } else {
            _this.data.windowManager.fullscreen = true;
            $fullScreenMenuItem.html(html.replace(new RegExp(RegExp.escape(expand)), shrink));
        }
        $fullScreenMenuItem.find("i").toggleClass("fa-down-left-and-up-right-to-center").toggleClass("fa-up-right-and-down-left-from-center");
        _this.adjustToWindow();
        if (_this.opts().windowManager.toggleFullScreenCallback) {
            _this.opts().windowManager.toggleFullScreenCallback(_this.data.windowManager.fullscreen);
        }
    };

    fn.getToolsMenuItems = function () {
        var _this = this;
        return [
            {
                name: gettext('Expand Editor'),
                icon: "fa-solid fa-up-right-and-down-left-from-center",
                hotkey: "Ctrl+Alt+F",
                action: function (done) {
                    _this.toggleFullScreen();
                }
            },
            {
                name: gettext("Export Form Contents"),
                icon: "fa-regular fa-file-excel",
                action: function (done) {
                    _this.showExportModal(done);
                }
            },
            {
                name: gettext("Edit Source XML"),
                icon: "fa fa-edit",
                action: function (done) {
                    _this.showSourceXMLModal(done);
                }
            },
            {
                name: gettext("Form Properties"),
                icon: "fa-regular fa-rectangle-list",
                action: function (done) {
                    _this.showFormPropertiesModal(done);
                }
            },
            {
                name: gettext("Find Usages"),
                icon: "fa fa-search",
                action: function (done) {
                    _this.findUsages(done);
                }
            },
        ];
    };

    // should switch to use jstree languages plugin
    fn.refreshVisibleData = function () {
        // update any display values that are affected
        var _this = this;
        this.data.core.form.getMugList().map(function (mug) {
            _this.refreshMugName(mug);
        });

        this.refreshCurrentMug();
    };

    fn.refreshCurrentMug = function () {
        var curMug = this.getCurrentlySelectedMug();
        if (curMug) {
            this.displayMugProperties(curMug);
        }
    };

    fn.getMugDisplayName = function (mug) {
        var lang = this.data.core.currentItextDisplayLanguage ||
                   this.data.javaRosa.Itext.getDefaultLanguage(),
            val = mug.getDisplayName(lang, false);
        if (val && mug._core_cachedDisplayNameKey === val) {
            // avoid calling richText.bubbleOutputs ~5 times per display mug.
            // bubbleOutputs with many bubbles is slow
            return mug._core_cachedDisplayNameValue;
        }
        mug._core_cachedDisplayNameKey = val;
        if (mug.form.richText) {
            val = richText.bubbleOutputs(val, this.data.core.form, false);
        } else {
            val = jrUtil.outputToXPath(val, mug.form.xpath, true);
        }
        mug._core_cachedDisplayNameValue = val;
        return val;
    };

    fn._resizeFullScreenModal = function($modal) {
        var modalHeaderHeight, modalFooterHeight, modalHeight, modalBodyHeight;
        modalHeaderHeight = $modal.find('.modal-header').outerHeight(false);
        modalFooterHeight = $modal.find('.modal-footer').outerHeight(false);
        modalHeight = $(window).height() - 40;
        modalBodyHeight = modalHeight - (modalFooterHeight - modalHeaderHeight) - 126;
        $modal.find(".modal-body").css('height', modalBodyHeight + 'px');
    };

    fn.showSourceXMLModal = function (done) {
        function validateMug(mug) {
            mug.validate();
            return !mug.hasErrors();
        }
        var _this = this,
            $modal, $updateForm, $textarea, codeMirror,
            warn = !this.data.core.form.isFormValid(validateMug) ?
                " <i class='fd-valid-alert-icon fa fa-warning' /> " +
                gettext("Validation failed. Form may not perform correctly on your device!") :
                "";

        $modal = this.generateNewModal(gettext("Edit Form's Source XML") + warn, [
            {
                title: gettext("Update Source"),
                cssClasses: "btn-primary",
                action: function () {
                    codeMirror.save();
                    _this.loadXFormOrError($textarea.val(), function () {
                        $modal.modal('hide');
                        done();
                    }, true);
                }
            }
        ]);
        $updateForm = $(edit_source({
            description: gettext("This is the raw XML. You can edit or paste " +
                "into this box to make changes to your form. Press 'Update " +
                "Source' to save changes, or 'Close' to cancel.")
        }));

        $modal.addClass('fd-full-screen-modal')
            .find('.modal-body')
            .removeClass('form-horizontal').removeClass('form')
            .html($updateForm);
        this._resizeFullScreenModal($modal);

        $textarea = $updateForm.find('textarea');

        // populate text
        if(!this.data.core.formLoadingFailed){
            $textarea.val(this.createXML());
        } else {
            $textarea.val(this.data.core.failedLoadXML);
        }

        codeMirror = require('codemirror').fromTextArea($textarea.get(0), {
            mode: 'xml',
            lineNumbers: true,
            viewportMargin: Infinity,
        });

        $modal.modal('show');
        $modal.one('shown.bs.modal', function () {
            var $body = $modal.find(".modal-body"),
                bodyHeight = $body.height(),
                pHeight = $body.find("p").outerHeight(true);
            codeMirror.setSize('100%', bodyHeight - pHeight);
            codeMirror.refresh();
            codeMirror.focus();
        });
    };

    fn.showExportModal = function(done) {
        var $modal,
            $exportForm;

        $modal = this.generateNewModal(gettext("Export Form Contents"), []);
        $exportForm = $(edit_source({
            description: gettext("Copy and paste this content into a " +
                "spreadsheet program like Excel to easily share your " +
                "form with others.")
        }));
        $modal.find('.modal-body').html($exportForm);

        // display current values
        var $text = $exportForm.find('textarea');
        $text.val(this.data.core.form.getExportTSV());
        $modal.modal('show');
        $modal.one('shown.bs.modal', function () { $text.focus(); });
    };

    fn.showOverwriteWarning = function(send, formText, serverForm) {
        var $modal, $overwriteForm, _this = this;

        $modal = _this.generateNewModal(gettext("Lost Work Warning"), [
            {
                title: gettext("Overwrite their work"),
                cssClasses: "btn-primary",
                defaultButton: true,
                action: function () {
                    $('#form-differences').hide();
                    send(formText, 'full');
                    _this.closeModal();
                }
            },
            {
                title: gettext("Show XML Differences"),
                cssClasses: "btn-info",
                action: function () {
                    $('#form-differences').show();

                    $modal.addClass('fd-full-screen-modal')
                        .removeClass('form-horizontal')
                        .find('.modal-body')
                        .html($overwriteForm);
                    _this._resizeFullScreenModal($modal);

                    $modal.find('.btn-info').prop('disabled', true);
                }
            }
        ], gettext("Cancel"), "fa fa-warning");

        var diff = util.xmlDiff(formText, serverForm || "");

        $overwriteForm = $(confirm_overwrite({
            description: gettext("Looks like someone else has edited this form " +
                         "since you loaded the page. Are you sure you want " +
                         "to overwrite their work?"),
            xmldiff: util.escape(diff),
        }));
        $modal.find('.modal-body').html($overwriteForm);

        $('#form-differences').hide();
        $modal.modal('show');
    };

    fn.showFormPropertiesModal = function () {
        var _this = this,
            $modal = this.generateNewModal(gettext("Edit Form Properties"), []),
            $modalBody = $modal.find('.modal-body'),
            formProperties = [
                {
                    label: gettext("Disable Text Formatting"),
                    slug: "noMarkdown",
                    type: "checkbox",
                    value: function(jq, val) {
                        return val ? jq.prop('checked', val) : jq.prop('checked');
                    }
                }
            ];

        if (this.opts().features.rich_text) {
            formProperties.push({
                label: gettext("Use Easy References"),
                slug: "richText",
                type: "checkbox",
                value: function(jq, val) {
                    return val ? jq.prop('checked', val) : jq.prop('checked');
                }
            });
        }

        _.each(formProperties, function (prop) {
            var $propertyInput = $(control_group_stdInput({
                label: prop.label,
                type: prop.type || 'text',
            }));
            $modalBody.append($propertyInput);
            $propertyInput.find('input')
                .val(_this.data.core.form[prop.slug])
                .on('change', function () {
                    var $this = $(this),
                        currentVal = $this.val();
                    if (prop.value) {
                        currentVal = prop.value($this);
                    }
                    _this.data.core.form.setAttr(prop.slug, currentVal);
                    _this.refreshVisibleData();
                });
            if (prop.value) {
                prop.value($propertyInput.find('input'), _this.data.core.form[prop.slug]);
            }
        });

        $modal.modal('show');
        $modal.one('shown.bs.modal', function () {
            $modalBody.find("input:first").focus().select();
        });
    };

    fn.findUsages = function () {
        var _this = this,
            $modal = this.generateNewModal(gettext("Use of each question"), []),
            $modalBody = $modal.find('.modal-body'),
            form = _this.data.core.form,
            tableData = form.findUsages();

        $modal.addClass('fd-full-screen-modal');
        $modalBody.append($(find_usages_search()));
        $modalBody.append($(find_usages({tableData: tableData})));

        this._resizeFullScreenModal($modal);
        $modal.modal('show');

        $modalBody.find('.link-to-question').click(function() {
            var goToMug = $(this).text();
            $modal.modal('hide');
            _this.setCurrentMug(form.getMugByPath(goToMug));
            return false;
        });

        $modalBody.find('#findUsagesSearch').on('keypress inserted.atwho', _.debounce(function () {
            var searchKey = $.trim(this.value),
                filteredData = {};
            if (!searchKey) {
                filteredData = tableData;
            } else {
                _.each(tableData, function (refsToUsedMug, usedMugPath) {
                    if (usedMugPath.includes(searchKey)) {
                        filteredData[usedMugPath] = refsToUsedMug;
                        return;
                    }
                    _.each(refsToUsedMug, function (propName, usedInMugPath) {
                        if (usedInMugPath.includes(searchKey)) {
                            if (!filteredData[usedMugPath]) {
                                filteredData[usedMugPath] = {};
                            }
                            filteredData[usedMugPath][usedInMugPath] = propName;
                        }
                    });
                });
            }
            $modalBody.find('table').remove();
            $modalBody.append($(find_usages({tableData: filteredData})));
        }, 250));

        atwho.autocomplete($('#findUsagesSearch'), _this.getCurrentlySelectedMug(),{
            useRichText: true,
        });
    };

    fn.closeModal = function (done, immediate) {
        var _this = this,
            $modal = _this.$f.find('.fd-modal-generic-container .modal');
        if (done) {
            $modal.one('hidden.bs.modal', function() {
                done.apply(_this);
            });
        }
        if (immediate) {
            // skip animation
            $modal.removeClass('fade');
        }
        $modal.modal('hide');
    };

    fn.generateNewModal = function (title, buttons, closeButtonTitle, headerIcon) {
        if (typeof closeButtonTitle === "undefined") {
            closeButtonTitle = gettext("Close");
        }
        buttons.reverse();
        buttons = _.map(buttons, function (button) {
            button.cssClasses = button.cssClasses || "";
            return button;
        });

        var _this = this,
            $modalContainer = _this.$f.find('.fd-modal-generic-container');

        // Close any existing modal - multiple modals is a bad state
        _this.closeModal(undefined, true);

        var $modal = $(modal_content({
                title: title,
                closeButtonTitle: closeButtonTitle,
                headerIcon: headerIcon,
            }));
        $modal.one("shown.bs.modal", function () {
            $modal.find(".btn-default:last").focus();
        });

        _.each(buttons, function (button) {
            button.defaultButton = button.defaultButton || false;
            button.action = button.action || function () {
                _this.closeModal();
            };
            $modal.find('.modal-footer').prepend(
                $(modal_button(button)).click(button.action));
        });
        $modalContainer.html($modal);
        return $modal;
    };

    var showPageSpinner = function() {
        var spinner = $("<div><div><div></div></div></div>");
        spinner.addClass("fd-form-saving");
        $('body').append(spinner);
    };

    var hidePageSpinner = function() {
        $(".fd-form-saving").remove();
    };

    fn.handleDropFinish = function(target, path, mug, event) {
        var _this = this,
            ops = target.closest(".xpath-expression-row").find(".op-select");

        if (target) {
            // the .change fires the validation controls
            if (widgets.util.getWidget(target, this).options.richText && _this.data.core.form.richText) {
                richText.editor(target).insertExpression(path);
            } else {
                target.val(target.val() + path).change();
            }

            var targetType,
                category = util.getReferenceName(path);
            switch (target[0].id) {
                case 'property-relevantAttr':
                    targetType = "Display";
                    break;
                case 'property-constraintAttr':
                    targetType = "Validation";
                    break;
                case 'property-calculateAttr':
                    targetType = "Calculation";
                    break;
                default:
                    targetType = "Expression Editor";
                    break;
            }
            analytics.usage(category, "Drag and Drop", targetType);
        }

        if (mug && ops && mug.options.defaultOperator) {
            ops.val(mug.options.defaultOperator);
        }
    };

    var typeData;
    // todo: jstree-related methods could be extracted out as a jstree wrapper
    // separate from the rest of the UI code.
    fn._createJSTree = function () {
        typeData = {
            "#": {
                valid_children: this.data.core.mugTypes.Group.validChildTypes
            },
            "default": {
                icon: 'fa fa-question-circle',
                max_children: 0,
                valid_children: []
            }
        };
        _(this.data.core.mugTypes.allTypes).each(function (type, typeName) {
            typeData[typeName] = {
                icon: type.icon,
                max_children: type.maxChildren,
                valid_children: type.validChildTypes
            };
        });

        var $tree, _this = this;
        this.data.core.$tree = $tree = this.$f.find('.fd-question-tree');
        $tree.jstree({
            "core": {
                data: [],
                worker: false,
                multiple: true,
                strings: {
                    'New node': this.opts().core.noTextString
                },
                check_callback: function(operation, node, parent, position, more) {
                    // operation can be 'create_node', 'rename_node', 'delete_node',
                    // 'move_node' or 'copy_node'. In case of 'rename_node'
                    // position is filled with the new node name
                    if (operation === "move_node") {
                        return _this.checkMove(node.id, node.type,
                                               parent.id, parent.type, position);
                    }
                    return true;  //allow all other operations
                }
            },
            "dnd" : {
                copy: false,
                inside_pos: "last"
            },
            "types": typeData,
            conditionalevents: {
                should_activate: function () {
                    return _this.ensureCurrentMugIsSaved();
                },
                redraw_node: function (obj) {
                    var args = Array.prototype.slice.call(arguments),
                        node = this.parent.redraw_node.apply(this.inst, args);
                    obj = this.inst.get_node(obj);
                    // decorate node with error indicator if present
                    if (node && obj.data && obj.data.errors) {
                        $(node).find('a > i').first().after(obj.data.errors);
                    }
                    return node;
                }
            },
            "plugins" : [ "themes", "types", "dnd", "conditionalevents", "actions" ]
            // We enable the "themes" plugin, but bundle the default theme CSS
            // (with base64-embedded images) in our CSS build.  The themes
            // plugin needs to stay enabled because it adds CSS selectors to
            // themeable items, which it would be hard to adapt the existing
            // selectors to if they didn't exist.
        }).on("select_node.jstree deselect_node.jstree", function (e, data) {
            var selected = _this.jstree('get_selected');
            if (!selected.length) {
                _this.hideQuestionProperties();
            } else if (selected.length < 2) {
                var mug = _this.data.core.form.getMugByUFID(selected[0]);
                _this.displayMugProperties(mug);
                _this._setURLHash(mug);
            } else {
                _this.displayMultipleSelectionView();
            }
        }).on("open_node.jstree", function (e, data) {
            if (window.event && window.event.altKey) {
                _this.jstree("open_all", data.node);
            }
            var mug = _this.data.core.form.getMugByUFID(data.node.id);
            _this.data.core.form.getDescendants(mug).map(function(descendant) {
                _this.refreshMugName(descendant);
            });
        }).on("close_node.jstree", function (e, data) {
            if (window.event && window.event.altKey) {
                _this.jstree("close_all", data.node);
            }
        }).on("move_node.jstree", function (e, data) {
            var form = _this.data.core.form,
                mug = form.getMugByUFID(data.node.id),
                refMug = data.parent !== "#" ? form.getMugByUFID(data.parent) : null,
                rel = _this.getRelativePosition(refMug, data.position);
            form.moveMug(mug, rel.position, rel.mug);
            data.node.icon = mug.getIcon();
            _this.refreshCurrentMug();
        }).on('model.jstree', function (e, data) {
            // Dynamically update node icons. This is unnecessary for
            // most nodes, but some (items in select questions) have a
            // different icon depending on their parent type.
            _(data.nodes).each(function (id) {
                var node = _this.jstree("get_node", id);
                if (node.data.mug) {
                    node.icon = node.data.mug.getIcon();
                }
            });
        });
    };

    /**
     * Setup handlers for drag/drop outside of tree
     *
     * NOTE this is done once when Vellum is loaded. These handlers must work
     * for multiple Vellum instances on the same page.
     *
     * These handlers need to be executed AFTER jstree's own dnd_move and
     * dnd_stop handlers, so wait to attach them until the first time a
     * drag begins.
     */
    $(document).one("dnd_move.vakata.jstree", function (e, data) {
        $(document).on("dnd_move.vakata.jstree", function (e, data) {
            var source = $(data.data.obj),
                target = $(data.event.target),
                inst = $.jstree.reference(target);
            if (!inst && target.vellum("get") === source.vellum("get")) {
                // only when not dragging inside the tree
                if (target.closest('.jstree-drop').length) {
                    data.helper.find('.jstree-icon').removeClass('jstree-er').addClass('jstree-ok');
                } else {
                    data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
                }
            }
        }).on("dnd_stop.vakata.jstree", function (e, data) {
            var vellum = $(data.data.obj).vellum("get"),
                target = $(data.event.target),
                inst = $.jstree.reference(target);

            if (!inst && (target.closest('.jstree-drop').length) && vellum === target.vellum("get")) {
                if (data.data.origin) {
                    var node = data.data.origin.get_node(data.data.nodes[0]);
                    if (node.data && node.data.handleDrop) {
                        node.data.handleDrop(target.closest('.jstree-drop'), data.event);
                    }
                }
            }
        });
    });

    fn.scrollTreeTo = function (ufid) {
        // http://stackoverflow.com/a/30538877/10840
        this.jstree("_open_to", ufid);
        this.jstree("hover_node", ufid);
        var $node = $(".jstree-hovered");
        if ($node.length) {
            var $scrollable = $node.closest(".fd-scrollable"),
                treeTop = $scrollable.offset().top,
                treeHeight = $scrollable.height(),
                nodeTop = $node.offset().top,
                nodeHeight = $node.height(),
                nodesOffset = nodeTop - $node.closest(".fd-question-tree").offset().top;
            if (nodeTop < treeTop || nodeTop + nodeHeight > treeTop + treeHeight) {
                // scroll node to middle of tree viewport
                $scrollable.scrollTop(nodesOffset - (treeHeight - nodeHeight) / 2);
            }
        }
    };

    /**
     * Get relative position like "before", "after", "first", or "last"
     *
     * @param mug - The parent mug among whose children to position; null for
     *              root.
     * @param position - An integer or string position. If this is not a number
     *                   then the given mug and position are returned.
     * @returns An object `{mug: mug, position: string}`. The returned mug may
     *          differ from the original "parent" mug.
     */
    fn.getRelativePosition = function (mug, position) {
        if (!_.isNumber(position)) {
            return {mug: mug, position: position};
        }
        if (position === 0) {
            return {mug: mug, position: "first"};
        }
        var node = this.jstree("get_node", mug ? mug.ufid : "#");
        if (position > node.children.length) {
            return {mug: mug, position: "last"};
        }
        var child = this.jstree("get_node", node.children[position - 1]);
        return {mug: child.data.mug, position: "after"};
    };

    fn.checkMove = function (srcId, srcType, dstId, dstType, position) {
        var form = this.data.core.form,
            targetMug = form.getMugByUFID(dstId),
            sourceMug = form.getMugByUFID(srcId);
        if (!sourceMug) {
            return false;
        }
        if (position === 'inside') { position = 'into'; } // normalize for Vellum

        var locked = !this.isMugPathMoveable(sourceMug.hashtagPath);
        if (locked) {
            if (position === 'into' || position === 'last' || position === 'first') {
                return sourceMug.parentMug === targetMug;
            } else {
                return sourceMug.parentMug === targetMug.parentMug;
            }
        }

        return true;
    };

    fn.onFormChange = function (mug) {
        this.data.core.saveButton.fire("change");
        this.notifyUserActivity();
    };

    fn.notifyUserActivity = function() {
        var now = Date.now(),
            // default timeout: 5 minutes in ms
            activityTimeout = this.opts().core.activityTimeout || 5 * 60 * 1000,
            activityUrl = this.opts().core.activityUrl;
        if (activityUrl) {
            if (!this.data.core.activityTimestamp) {
                this.data.core.activityTimestamp = now;
            } else if (now - this.data.core.activityTimestamp >= activityTimeout) {
                this.data.core.activityTimestamp = now;
                if (_.isFunction(activityUrl)) {
                    activityUrl();
                } else {
                    $.get(activityUrl);
                }
            }
        }
    };

    fn.jstree = function () {
        var tree = this.data.core.$tree;
        return tree.jstree.apply(tree, arguments);
    };

    /**
     * Get currently selected mug or mugs
     *
     * This depends on the UI. Avoid using it unless there is no way to
     * get the mug from other context.
     *
     * @param multiple - If false (default) get the first selected mug;
     *      null if there is no selection. Otherwise get a (possibly
     *      empty) list of selected mugs.
     * @param treeOrder - If false (default) return mugs in the order they
     *      were selected. Otherwise return them in the order they appear
     *      in the tree. Ignored if `multiple` is false.
     * @returns - A list of mugs, single mug, or null, depending on
     *      parameters and the UI state.
     */
    fn.getCurrentlySelectedMug = function (multiple, treeOrder) {
        var selected = this.jstree('get_selected'),
            form = this.data.core.form;
        if (multiple) {
            if (treeOrder && selected.length > 1) {
                var ids = _.object(_.map(selected, function (id) {
                        return [id, true];
                    })),
                    count = selected.length,
                    mugs = [];
                form.tree.walk(function (mug, nodeID, processChildren) {
                    if (mug && ids.hasOwnProperty(mug.ufid)) {
                        mugs.push(mug);
                    }
                    if (mugs.length !== count) {
                        processChildren();
                    }
                });
                return mugs;
            }
            return _.map(selected, form.getMugByUFID.bind(form));
        }
        return selected.length ? form.getMugByUFID(selected[0]) : null;
    };

    fn.getCurrentMugInput = function (propPath) {
        // HACK tightly coupled to widgets
        // unfortunately the widget id is not easily accessible from here
        return this.$f.find("[name=property-" + propPath + "]");
    };

    fn.mugToXPathReference = function (mug) {
        // for choices, return the quoted value.
        // for everything else return the path
        if (mug.__className === "Choice") {
            return "'" + mug.p.nodeID + "'";
        } else {
            // for the currently selected mug, return a "."
            return (mug.ufid === this.getCurrentlySelectedMug().ufid) ?
                "." : (mug.form.richText ? mug.hashtagPath : mug.absolutePath);
        }
        // Instead of depending on the UI state (currently selected mug), it
        // would probably be better to have this be handled by the widget using
        // its bound mug.
    };

    // Suggest a node ID, based on the mug's label
    fn.nodeIDFromLabel = function(mug) {
        var suggestedID = this.getMugDisplayName(mug) || "";
        suggestedID = $("<div/>").html(suggestedID).text();     // strip any HTML (i.e., bubbles)
        suggestedID = suggestedID.toLowerCase();
        suggestedID = suggestedID.trim();
        suggestedID = suggestedID.replace(/\s+/g, '_');         // collapse whitespace & replace with underscores
        suggestedID = suggestedID.replace(/[^\w\-]/g, '');      // strip illegal characters
        suggestedID = suggestedID.replace(/^[^a-z]*/i, '');     // must start with a letter
        suggestedID = suggestedID.replace(/_*$/g, '');          // drop trailing underscores
        suggestedID = suggestedID.substring(0, 75);             // no exceedingly long IDs
        return mug.form.generate_question_id(suggestedID, mug);
    };

    // Attempt to guard against doing actions when there are unsaved or invalid
    // pending changes.
    fn.ensureCurrentMugIsSaved = function (callback) {
        var currentMug = this.getCurrentlySelectedMug();

        if (this.data.core.hasXPathEditorChanged) {
            this.alert(
                gettext("Unsaved Changes in Editor"),
                gettext("You have UNSAVED changes in the Expression Editor. " +
                        "Please save changes before continuing."));
            return false;
        } else {
            if (currentMug && !currentMug.p.nodeID) {
                currentMug.p.nodeID = this.nodeIDFromLabel(currentMug);
            }
            (callback || function () {})();
            return true;
        }
    };

    fn.loadXFormOrError = function (formString, done, updateSaveButton) {
        done = done || function () {};
        var _this = this;

        if (_this.opts().core.formLoadingCallback) {
            _this.opts().core.formLoadingCallback();
        } else {
            showPageSpinner();
        }
        //wait for the spinner to come up.
        window.setTimeout(function () {
            //universal flag for indicating that there's something wrong enough
            //with the form that vellum can't deal.
            _this.data.core.formLoadingFailed = false;
            try {
                // a place for plugins to put parse warnings
                _this.data.core.parseWarnings = [];
                _this.loadXML(formString, {});
                delete _this.data.core.parseWarnings;
                _this.data.core.form.fire('form-load-finished');

                if (formString) {
                    if (updateSaveButton) {
                        _this.data.core.saveButton.fire('change');
                    }
                } else {
                    _this.$f.find('.fd-content-right .fd-column').addClass('hide');
                    _this.$f.find('.fd-default-panel').removeClass('hide');
                }
                if (_this.opts().core.formIconClass) {
                    _this.$f.find('.fd-form-icon').addClass(_this.opts().core.formIconClass);
                } else {
                    _this.$f.find('.fd-form-icon').addClass('fa fa-edit');
                }
                if (_this.opts().core.defaultHelpTextTemplateId) {
                    _this.$f.find('.fd-default-helptext')
                        .html($(_this.opts().core.defaultHelpTextTemplateId).html())
                        .addClass('alert alert-info');
                }
                $(".fd-tree .fd-head-text").text(_this.data.core.form.formName);
                if (_this.opts().core.formLoadedCallback) {
                    _this.opts().core.formLoadedCallback();
                } else {
                    hidePageSpinner();
                }
            } catch (e) {
                window.console.log(util.formatExc(e));
                // hack: don't display the whole invalid XML block if it
                // was a parse error
                var msg = e.toString();
                if (msg.indexOf("Invalid XML") !== -1) {
                    msg = gettext("Parsing Error. Please check that your form is valid XML.");
                }

                _this.hideQuestionProperties();

                var $modal = _this.generateNewModal(
                        gettext("Error"), [], gettext("OK"), "fa fa-warning");
                $modal.find(".modal-body").text(msg);
                $modal.modal('show');

                _this.data.core.formLoadingFailed = true;
                _this.data.core.failedLoadXML = formString;

                if (_this.opts().core.formLoadedCallback) {
                    _this.opts().core.formLoadedCallback();
                } else {
                    hidePageSpinner();
                }
                throw e;
            }
            done();
        }, this.opts().core.loadDelay);
    };

    fn.loadXML = function (formXML, options) {
        var form, _this = this, selectedHashtag = window.location.hash;
        _this.data.core.$tree.children().children().each(function (i, el) {
            _this.jstree("delete_node", el);
        });
        options = _.extend({
            mugTypes: this.data.core.mugTypes,
            allowedDataNodeReferences: this.opts().core.allowedDataNodeReferences,
            enableInstanceRefCounting: true
        }, options);
        if (this.data.core.form) {
            this.data.core.form.disconnectDataSources();
        }
        this.data.core.form = form = parser.parseXForm(
            formXML, options, this, _this.data.core.parseWarnings);
        this.onXFormLoaded(form);
        if (formXML) {
            _this._resetMessages(_this.data.core.form.errors);
            _this._populateTree(selectedHashtag);
        }

        form.on('question-type-change', function (e) {
            _this.jstree("set_type", e.mug.ufid, e.qType);

            if (e.mug === _this.getCurrentlySelectedMug()) {
                _this.refreshCurrentMug();
            }
        }).on('parent-question-type-change', function (e) {
            _this.jstree("set_icon", e.childMug.ufid, e.childMug.getIcon());
        }).on('question-remove', function (e) {
            if (e.mug) {
                e.mug.unbind(_this.data.core);
                if (e.mug === _this._propertiesMug) {
                    // prevent e.mug.validate() on deleted mug
                    _this._propertiesMug.teardownProperties();
                    _this._propertiesMug = null;
                }
            }
            var currentMug = _this.getCurrentlySelectedMug();
            if (e.mug && e.mug.parentMug && e.mug.parentMug === currentMug) {
                _this.displayMugProperties(currentMug);
            }
            if (!e.isInternal) {
                var prev = _this.jstree("get_prev_dom", e.mug.ufid);
                _this.jstree("delete_node", e.mug.ufid);
                if (prev) {
                    _this.jstree("select_node", prev);
                } else {
                    _this.selectSomethingOrHideProperties();
                }
            }
            // HACK: need to explicitly remove the control node so that
            // getNodeFromMug doesn't return a node that no longer exists
            e.mug._node_control = undefined;

            $('.fd-undo').click(function () {
                _this.ensureCurrentMugIsSaved(form.undo.bind(form));
                return false;
            });
            $('.fd-undo-container').on('click', '.close', function() {
                form.undomanager.resetUndo();
            });
        }).on('question-create', function (e) {
            _this.handleNewMug(e.mug, e.refMug, e.position);
            _this.setTreeActions(e.mug);
            var currentMug = _this.getCurrentlySelectedMug();
            if (e.mug && e.mug.parentMug && e.mug.parentMug === currentMug) {
                _this.displayMugProperties(currentMug);
            }
            if (!e.isInternal) {
                _this.setCurrentMug(e.mug);
            }
        }).on('change', function (e) {
            _this.onFormChange(e.mug);
        }).on('question-label-text-change', function (e) {
            _this.refreshMugName(e.mug);
            _this.toggleConstraintItext(e.mug);
        }).on('change-display-language', function (e) {
            var mug = _this.getCurrentlySelectedMug();
            if (mug) {
                _this.refreshMugName(mug);
            }
        }).on('mug-property-change', function (e) {
            _this.refreshMugName(e.mug);
            _this.toggleConstraintItext(e.mug);
            if (e.property === 'comment' && e.val) {
                _this.$f.find('.fd-question-comment').show();
                _this.$f.find('.fd-question-comment').text(e.val);
            }
        });
    };

    /**
     * Setup form after parsing XML
     *
     * This method is provided for plugins to perform setup related
     * tasks that need access to the form object. It is called just
     * after parsing XML before tree population.
     */
    fn.onXFormLoaded = function (form) {
        form.warnWhenChanged = this.opts().core.hasSubmissions;
        form.submissionUrl = this.opts().core.hasSubmissionsUrl;
    };

    fn.refreshMugName = function (mug) {
        var name = this.getMugDisplayName(mug);
        if (name !== this.jstree("get_text", mug.ufid)) {
            this.jstree('rename_node', mug.ufid, name);
        }
        var currentMug = this.getCurrentlySelectedMug();
        if (currentMug && mug.ufid === currentMug.ufid) {
            this.$f.find(".fd-question-properties .fd-head h2").html(name);
        }
    };

    fn.toggleConstraintItext = function (mug) {
        // todo: don't handle this one-off in the UI layer
        var current = this.getCurrentlySelectedMug();
        if (current && current.ufid !== mug.ufid) {
	         return;
        }
        var state = (mug.p.constraintMsgItext &&
                     (!mug.p.constraintMsgItext.isEmpty() ||
                      mug.p.constraintAttr)),
            $constraintItext = $('.itext-block-constraintMsg');

        if (state) {
            $constraintItext.removeClass('hide');
        } else {
            $constraintItext.addClass('hide');
        }
    };

    fn._populateTree = function (selectedHashtag) {
        // NOTE: this performs the final step in the mug parsing process.
        // It should only be called once after a new XForm is loaded.
        var _this = this,
            form = this.data.core.form;

        form.walkMugs(function (mug) {
            _this.handleMugParseFinish(mug);
            var inTree = _this.createQuestion(mug, mug.parentMug, 'into');
            if (inTree) {
                var changed = mug.validate();
                if (!changed && mug.hasErrors()) {
                    _this.setTreeValidationIcon(mug);
                }
                _this.setTreeActions(mug);
            }
        });

        _this.selectSomethingOrHideProperties(true, selectedHashtag);
    };

    fn.selectSomethingOrHideProperties = function (forceDeselect, questionPath) {
        if (forceDeselect) {
            this.jstree('deselect_all');
        }
        // ensure something is selected if possible
        if (!this.jstree('get_selected').length) {
            // if there's any nodes in the tree, just select the first
            var all_nodes = this.data.core.$tree.find("li"),
                selected;
            if (questionPath) {
                var mug = this.getMugByPath(questionPath) || undefined,
                    ufid = mug && mug.ufid;
                if (ufid) {
                    selected = all_nodes.filter('[id= ' + ufid + ']');
                }
            }
            if (selected && selected.length > 0) {
                this.jstree('select_node', selected[0]);
                this.scrollTreeTo(selected[0].id);
                return true;
            } else if (all_nodes.length > 0) {
                this.jstree('select_node', all_nodes[0]);
                this.scrollTreeTo(all_nodes[0].id);
                return true;
            } else {
                // otherwise clear the Question Edit UI pane
                this.jstree('deselect_all');
                this.hideQuestionProperties();
                this.$f.find('.fd-content-right .fd-column').addClass('hide');
                this.$f.find('.fd-default-panel').removeClass('hide');
                return false;
            }
        }

        return true;
    };

    fn.addQuestion = function (qType, position, refMug) {
        var _this = this,
            mug;
        this.ensureCurrentMugIsSaved(function () {
            if (position) {
                if (!/^(before|after|into|first|last)$/.test(position)) {
                    throw new Error("bad position: " + position);
                }
                if (!_this.isInsertAllowed(qType, position, refMug)) {
                    throw new Error("cannot insert " + qType + " " + position +
                        " " + (refMug ? refMug.hashtagPath : "root node"));
                }
            } else {
                var foo = _this.getInsertTargetAndPosition(
                    _this.getCurrentlySelectedMug(), qType);
                if (!foo) {
                    throw new Error("cannot add " + qType + " at the current position");
                }
                position = foo.position;
                refMug = foo.mug;
            }
            analytics.workflow("Added question in form builder");
            mug = _this.data.core.form.createQuestion(refMug, position, qType);

            _this.scrollTreeTo(mug.ufid);
            _this.focusFirstInput();
        });
        // the returned value will be `undefined` if ensureCurrentMugIsSaved
        // had to defer for user feedback
        return mug;
    };

    fn.focusFirstInput = function () {
        // Focus on first input, which might be a normal input or a rich text input
        var $firstGroup = this.$f.find(".fd-question-properties .form-group:first");
        if ($firstGroup.length) {
            var $input = $firstGroup.find("input, textarea");
            if ($input.length) {
                // Rich text is off
                $input.focus();
            } else {
                // Rich text is on
                $input = $firstGroup.find(".fd-textarea, .fd-input");
                richText.editor($input).focus();
            }
        }
    };

    fn.adjustToWindow = function() {
        this.data.windowManager.adjustToWindow();
    };

    /**
     * Find insertion position for new mug of type `qType`.
     *
     * Try insert into `refMug`, then after `refMug`, then after each of
     * `refMug`'s ancestors.
     *
     * @param refMug - Mug relative to which to insert.
     * @param qType - Type of question being inserted.
     * @param after - (optional) Try insert after instead of into `refMug`.
     * @returns - `{mug: <refMug>, position: <position>}` or, if there is
     *      no valid insert position for the given question type, `null`.
     *      Valid positions: before, after, first, last, into (same as last).
     *      In practice position will be one of `"last"` or `"after"`.
     */
    fn.getInsertTargetAndPosition = function (refMug, qType, after) {
        var parent, childTypes, position = after ? 'after' : 'last';
        while (refMug) {
            if (position === 'after') {
                parent = refMug.parentMug;
                if (!parent) {
                    if (!this.isInsertAllowed(qType, position, refMug)) {
                        return null;
                    }
                    break;
                }
            } else {
                parent = refMug;
            }
            if (this.jstree("is_closed", parent.ufid)) {
                refMug = parent;
                position = 'after';
                continue;
            }
            childTypes = typeData[parent.__className].valid_children;
            if (childTypes.indexOf(qType) !== -1) {
                break;
            } else if (position !== 'after') {
                position = 'after';
            } else {
                refMug = refMug.parentMug;
            }
        }
        if (!refMug && !this.isInsertAllowed(qType, position, refMug)) {
            return null;
        }
        return {mug: refMug, position: position};
    };

    /**
     * Check if a question of the given `type` can be inserted at `position`
     * relative to `refMug`
     *
     * WARNING the bare minimum has been implemented to support
     * getInsertTargetAndPosition(). Needs to be fleshed out for other uses.
     *
     * Valid positions: before, after, first, last, into (same as last)
     */
    fn.isInsertAllowed = function (type, position, refMug) {
        var parentType = "#"; // root type
        if (refMug) {
            if (position === "after" || position === "before") {
                if (refMug.parentMug) {
                    parentType = refMug.parentMug.__className;
                }
            } else if (position === "into" || position === "first" || position === "last") {
                parentType = refMug.__className;
            } else {
                throw new Error("validation of insert " + position + " " +
                                refMug.__className + " not implemented");
            }
        } else if (position !== "into" && position !== "first" && position !== "last") {
            throw new Error("validation of insert " + position +
                            " root node not implemented");
        }
        return typeData[parentType].valid_children.indexOf(type) !== -1;
    };

    fn.handleNewMug = function (mug, refMug, position) {
        this.createQuestion(mug, refMug, position);
    };

    /**
     * Create a question in the tree GUI
     *
     * @returns The tree node that was created or `false` if it was not created.
     */
    fn.createQuestion = function (mug, refMug, position) {
        var node, _this = this;
        mug.on("messages-changed", function (event) {
            _this.setTreeValidationIcon(event.mug);
        }, null, null, this.data.core);
        node = _this.jstree("create_node",
            refMug ? "#" + refMug.ufid : "#",
            {
                text: this.getMugDisplayName(mug),
                type: mug.__className,
                data: {
                    mug: mug,
                    handleDrop: function (target, event) {
                        var path = _this.mugToXPathReference(mug);
                        _this.handleDropFinish(target, path, mug, event);
                    }
                },
                li_attr: {
                    id: mug.ufid,
                    rel: mug.__className
                },
                state: { opened: true }
            },
            // NOTE 'into' is not a supported position in JSTree
            (position === 'into' ? 'last' : position)
        );

        return node;
    };

    fn.handleMugParseFinish = function (mug) {
    };

    fn.getMugByPath = function (path) {
        return this.data.core.form.getMugByPath(path);
    };

    fn.setCurrentMug = function (mug) {
        this.jstree("deselect_all", true).jstree('select_node', mug.ufid);
    };

    fn.displayMugProperties = function (mug) {
        var $props = this.$f.find('.fd-question-properties');
        this.$f.find('.fd-default-panel').addClass('hide');

        this.showContentRight();
        $props.addClass("hide");

        this._setPropertiesMug(mug);
        var $content = this.$f.find(".fd-props-content").empty(),
            sections = this.getSections(mug),
            $messages = $("<div class='messages' />");

        this.$f.find('.fd-props-toolbar').html(this.getMugToolbar(mug));
        for (var i = 0; i < sections.length; i++) {
            var section = _.clone(sections[i]);

            section.mug = mug;
            section.properties = _(section.properties)
                .map(function(property) {
                    return getWidgetClassAndOptions(property, mug);
                })
                .filter(_.identity);

            if (section.properties.length) {
                this.getSectionDisplay(mug, section).appendTo($content);
            }
        }

        // Setup area for messages not associated with a property/widget.
        if ($content.children().length) {
            $messages.insertAfter($content.children().first());
        } else {
            $messages.appendTo($content);
        }
        function refreshMessages() {
            $messages.empty().append(widgets.util.getMessages(mug, null));
        }
        mug.on("messages-changed", refreshMessages, null, "teardown-mug-properties");
        refreshMessages();

        this.$f.find('.fd-content-right .fd-column').addClass("hide");
        $props.removeClass("hide");
        this.adjustToWindow();
        this.$f.find('.fd-help a').fdHelp();

        this.refreshMugName(mug);
        this.toggleConstraintItext(mug);
    };

    fn._setURLHash = function (mug) {
        if (mug && mug.getNodeID() !== undefined &&
            mug.hashtagPath && mug.hashtagPath.startsWith("#") && !mug.hashtagPath.endsWith('/')) {
            window.history.replaceState(null, null, mug.hashtagPath);
        }
        else {
            // If the mug doesn't have a question id yet, remove the hash from the url
            window.history.replaceState(null, null, ' ');
        }
    };

    fn._setPropertiesMug = function (mug) {
        if (this._propertiesMug) {
            this._propertiesMug.teardownProperties();
            try {
                this._propertiesMug.validate();
            } catch (err) {
                // ignore error
            }
        }
        this._propertiesMug = mug;
    };

    fn.displayMultipleSelectionView = function () {
        var mugs = this.getCurrentlySelectedMug(true);
        this.showContentRight();
        this.hideQuestionProperties();
        this._setPropertiesMug(null);
        this.$f.find('.fd-props-toolbar').html(this.getMugToolbar(mugs, true));
        this.$f.find(".fd-props-content").empty();
        this.showQuestionProperties();
    };

    fn.showContentRight = function () {
        this.$f.find('.fd-content-right').show();
    };

    fn.hideContentRight = function () {
        this.$f.find('.fd-content-right').hide();
    };

    fn.showQuestionProperties = function () {
        this.$f.find('.fd-content-right .fd-column').addClass("hide");
        this.$f.find('.fd-question-properties').removeClass("hide");
    };

    fn.hideQuestionProperties = function () {
        this.$f.find('.fd-question-properties').addClass("hide");
    };

    /**
     * Display an editor in the question properties area
     *
     * @param options - Object with editor options:
     *  {
     *      headerText: "text to display in header",
     *      loadEditor: function($div, options),    // load editor into $div
     *      change: function(value),                // editor changed callback
     *      done: function(value)                   // editor done callback
     *  }
     */
    fn.displaySecondaryEditor = function(options) {
        // All mention of "xpath" in this function is from when this function
        // displayed the xpath editor. It has been adapted to show any editor.
        var _this = this,
            $editor = this.$f.find('.fd-xpath-editor');

        $editor.find('.fd-head h2').text(options.headerText);
        options.DEBUG_MODE = DEBUG_MODE;
        this.hideQuestionProperties();

        var done = options.done;
        options.done = function (val) {
            done(val);
            if (_this.data.core.hasXPathEditorChanged) {
                _this.data.core.hasXPathEditorChanged = false;
                $editor.addClass("hide");
                _this.refreshCurrentMug();
            } else {
                $editor.addClass("hide");
                _this.showQuestionProperties();
            }
        };
        var change = options.change;
        options.change = function (val) {
            _this.data.core.hasXPathEditorChanged = true;
            if (change) {
                change(val);
            }
        };
        _this.$f.find('.fd-content-right .fd-column').addClass('hide');
        $editor.removeClass("hide");
        options.loadEditor(_this.$f.find('.fd-xpath-editor-content'), options);
    };

    fn.displayXPathEditor = function(options) {
        options.headerText = gettext("Expression Editor");
        options.loadEditor = function($div, options) {
            require(['vellum/expressionEditor'], function (expressionEditor) {
                expressionEditor.showXPathEditor($div, options);
            });
        };
        this.displaySecondaryEditor(options);
    };

    fn.alert = function (title, message, buttons) {
        buttons = buttons || [];
        if (this.data.core.isAlertVisible) {
            return;
        }

        var _this = this;
        this.data.core.isAlertVisible = true;
        if (!buttons.length) {
            buttons.push({title: gettext("OK"), defaultButton: true});
        }

        var $modal = this.generateNewModal(title, buttons, false, "fa fa-warning");

        // store a reference to $modal on this so modal button actions can
        // reference it in order to hide it at the right point in time.  This is
        // a bit of a hack but any alternative is probably a lot more
        // complicated.
        this.data.core.$modal = $modal;

        $modal.removeClass('fade');
        if (message instanceof $) {
            $modal.find('.modal-body').append(message);
        } else {
            $modal.find('.modal-body').append($('<p />').text(message));
        }
        $modal
            .modal('show')
            .on('hide.bs.modal', function () {
                _this.data.core.isAlertVisible = false;
            });
    };

    fn.alertUser = function(message) {
        this._resetMessages([{
            level: 'info',
            message: message,
        }]);
    };

    fn.setTreeValidationIcon = function (mug) {
        var node = mug.ufid && this.jstree("get_node", mug.ufid);
        if (node) {
            var errors = mug.getErrors();
            if (errors.length) {
                var msg = errors.join("\n").replace(/"/g, "'");
                node.data.errors = '<i class="fd-valid-alert-icon ' +
                    'fa fa-warning" title="' + msg + '"></i>';
            } else {
                node.data.errors = null;
            }
            this.jstree("redraw_node", node);
        }
    };

    fn._resetMessages = function (errors) {
        var error, messages_div = this.$f.find('.fd-messages');

        function asArray(value) {
            // TODO: I don't like this array business, should be refactored away
            // to the callers.
            if (typeof value === "string" || !(value instanceof Array)) {
                // value is a string or not-an-array (so try turn it into a string)
                value = ['' + value];
            }
            return value;
        }

        if (errors.length > 0) {
            // Show message(s) from the last error only because multiple errors
            // fill up the screen and thus impede usability.  TODO ideally the
            // other errors would be accessible in some way.  Maybe hidden by
            // default with a clickable indicator to show them?

            error = errors[errors.length - 1];
            var showMessage = function() {
                messages_div.html(alert_global({
                    messageType: MESSAGE_TYPES[error.level],
                    messages: asArray(error.message)
                }))
                .fadeIn(500);
            };
            if (messages_div.is(":visible")) {
                messages_div.fadeOut(500, showMessage);
            } else {
                showMessage();
            }
        }
    };

    fn.sectionIsCollapsed = function(section) {
        var collapseKey = "collapse-" + section.slug;
        if (section.slug === "main") {
            // Always show basic section
            return false;
        }
        return localStorage.hasOwnProperty(collapseKey) ?
            localStorage.getItem(collapseKey) :
            section.isCollapsed;
    };

    fn.collapseSection = function(slug, shouldCollapse) {
        var $fieldset = $(".fd-question-fieldset[data-slug='" + slug + "']"),
            $command = $(".fd-section-changer [data-slug='" + slug + "']");
        if (shouldCollapse) {
            $fieldset.addClass("hide");
            $command.removeClass("selected");
        } else {
            $fieldset.removeClass("hide");
            $command.addClass("selected");
        }
        localStorage.setItem('collapse-' + slug, shouldCollapse ? "1" : "");
    };

    fn.getSectionDisplay = function (mug, options) {
        var _this = this,
            isCollapsed = _this.sectionIsCollapsed(options),
            $sec = $(question_fieldset({
                fieldsetClass: "fd-question-edit-" + options.slug || "anon",
                fieldsetTitle: options.displayName,
                fieldsetSlug: options.slug,
                isCollapsed: !!isCollapsed,
                help: options.help
            })),
            $fieldsetContent = $sec.find('.fd-fieldset-content');
        options.properties.map(function (prop) {
            var elemWidget = prop.widget(mug, $.extend(prop.options, {
                vellum: _this,
                displayXPathEditor: function (options) {
                    _this.data.core.currentlyEditedProperty = prop.options.path;
                    _this.displayXPathEditor(options);
                }
            }));
            elemWidget.setValue(elemWidget.currentValue);
            elemWidget.on("change", function () {
                _this.onFormChange(mug);
            });
            var $ui = elemWidget.getUIElement();
            widgets.util.setWidget($ui, elemWidget);
            $fieldsetContent.append($ui);
            elemWidget.refreshMessages();
        });
        return $sec;
    };

    fn.getMugToolbar = function (mug, multiselect) {
        var _this = this,
            form = this.data.core.form,
            mugs = multiselect ? mug : [mug],
            $baseToolbar = $(question_toolbar({
                comment: multiselect ? '' : richText.sanitizeInput(mug.p.comment),
                isDeleteable: mugs && mugs.length && _.every(mugs, function (mug) {
                    return _this.isMugRemoveable(mug, mug.hashtagPath);
                }),
                isCopyable: !multiselect && mug.options.isCopyable,
                sections: multiselect ? [] : _.chain(_this.getSections(mug))
                    .rest()
                    .filter(function(s) {
                        // Limit to sections relevant to this mug
                        return _.some(_.map(s.properties, function(property) {
                            return getWidgetClassAndOptions(property, mug);
                        }));
                    })
                    .map(function(s) {
                        // Just pass the template a show/hide flag
                        return _.extend({
                            show: !_this.sectionIsCollapsed(s),
                        }, s);
                    })
                    .value(),
            }));
        $baseToolbar.find('.fd-button-remove').click(function () {
            var mugs = _this.getCurrentlySelectedMug(true, true);
            form.removeMugsFromForm(mugs);
            _this.refreshCurrentMug();
        });
        if (!multiselect) {
            $baseToolbar.find('.btn-toolbar.pull-left')
                .prepend(this.getQuestionTypeChanger(mug));
            if (mug.p.comment) {
                $baseToolbar.find('.fd-question-comment').show();
            }
        }
        return $baseToolbar;
    };

    fn.getQuestionTypeChanger = function (mug) {
        var _this = this;
        var getQuestionList = function (mug) {
            var currentTypeName = mug.__className,
                currentType = _this.data.core.mugTypes[currentTypeName],
                questions = _this.data.core.QUESTIONS_IN_TOOLBAR,
                ret = [];

            for (var i = 0; i < questions.length; i++) {
                var typeName = questions[i],
                    q = _this.data.core.mugTypes[typeName];
                if (currentTypeName !== typeName &&
                        !currentType.typeChangeError(mug, typeName) &&
                        // Check the reverse change as well.
                        q.isTypeChangeable &&
                        !q.typeChangeError(mug, currentTypeName)) {
                    ret.push({
                        slug: questions[i],
                        name: q.typeName,
                        icon: q.icon
                    });
                }
            }
            return ret;
        };
        var changeable = this.isMugTypeChangeable(mug, mug.hashtagPath);

        var $questionTypeChanger = $(question_type_changer({
            currentQuestionIcon: mug.getIcon(),
            currentTypeName: mug.options.typeName,
            questions: changeable ? getQuestionList(mug) : []
        }));
        $questionTypeChanger.find('.change-question').click(function (e) {
            try {
                _this.changeMugType(mug, $(this).data('qtype'));
            } catch (err) {
                window.alert(util.format(gettext("Sorry, {err}"), {err: err}));
            }
            e.preventDefault();
        });
        $questionTypeChanger.addClass('fd-question-changer');
        return $questionTypeChanger;
    };

    fn.changeMugType = function (mug, type) {
        this.data.core.form.changeMugType(mug, type);
        this.setTreeActions(mug);
    };

    fn.setTreeActions = function(mug) {
        var _this = this,
            tree = _this.data.core.$tree,
            action_id = "add_choice";
        if (mug.options.canAddChoices) {
            tree.jstree(true).add_action(mug.ufid, {
                "id": action_id,
                "class": "fa fa-plus add_choice",
                "text": " " + gettext("Add Choice"),
                "after": true,
                "selector": "a",
                "event": "click",
                "callback": function (node_id, node, action_id, action_el) {
                    _this.ensureCurrentMugIsSaved(function () {
                        _this.setCurrentMug(mug);
                        _this.addQuestion("Choice");
                    });
                }
            });
        } else {
            tree.jstree(true).remove_action(mug.ufid, action_id);
        }
    };

    fn.createXML = function () {
        return this.data.core.form.createXML();
    };

    fn.canSerializeXForm = function (forAction, retry) {
        var _this = this,
            form = this.data.core.form,
            displayLanguage = this.data.core.currentItextDisplayLanguage,
            warnings = form.getSerializationWarnings();
        if (warnings.length) {
            var message = $(form_errors_template({
                    errors: warnings,
                    displayLanguage: displayLanguage
                }));
            forAction = forAction ? " " + gettext("and") + " " + forAction : "";
            this.alert(gettext("There are errors in the form"), message, [
                {
                    title: gettext("Fix Manually"),
                    action: function () {
                        _this.data.core.$modal.modal('hide');
                    }
                }, {
                    title: gettext("Fix Automatically") + forAction,
                    cssClasses: 'btn-primary',
                    defaultButton: true,
                    action: function () {
                        form.fixSerializationWarnings(warnings);
                        _this.data.core.$modal.modal('hide');
                        retry();
                        _this.refreshVisibleData();
                    }
                }
            ]);
            return false;
        }
        return true;
    };

    fn.validateAndSaveXForm = function (forceFullSave) {
        function retry() {
            _this.validateAndSaveXForm(forceFullSave);
        }
        var _this = this;
        if (!this.canSerializeXForm(gettext("Save"), retry)) {
            return; // validate/create XML failed
        }
        var formText = this.createXML();
        try {
            // ensure that form is valid XML; throws an error if not
            xml.parseXML(formText);
        } catch (err) {
            // something went wrong parsing, but maybe the user wants to save anyway
            // let's ask them with a scary message encouraging them not to.
            var theScaryWarning = gettext(
                "It looks like your form is not valid XML. This can " +
                "often happen if you use a reserved character in one of your questions. " +
                "Characters to look out for are <, >, and &. You can still save, but " +
                "you CANNOT LOAD THIS FORM again until you fix the XML by hand. " +
                "What would you like to do?");
            var $modal = _this.generateNewModal(gettext("Form Validation Error"), [
                {
                    title: gettext('Fix the problem (recommended)'),
                    cssClasses: "btn-primary",
                    action: function() {
                        _this.closeModal();
                    },
                },
                {
                    title: gettext('Save anyway'),
                    cssClasses: "btn-default",
                    action: function() {
                        _this.closeModal();
                        _this.send(formText, forceFullSave ? 'full' : null);
                    },
                },
            ], false, "fa fa-warning");
            $modal.find(".modal-body").html(theScaryWarning);
            $modal.modal('show');
            return;
        }

        this.send(formText, forceFullSave ? 'full' : null);
    };

    fn.send = function (formText, saveType) {
        var CryptoJS = require('CryptoJS'),
            _this = this,
            opts = this.opts().core,
            checkForConflict = false,
            patch, data;
        saveType = saveType || opts.saveType;

        var url = saveType === 'patch' ?  opts.patchUrl : opts.saveUrl;

        showPageSpinner();

        if (saveType === 'patch') {
            checkForConflict = true;
            var diff_match_patch = require('diff-match-patch'),
                dmp = new diff_match_patch();
            patch = dmp.patch_toText(
                dmp.patch_make(this.data.core.lastSavedXForm, formText)
            );
            // abort if diff too long and send full instead
            if (patch.length > formText.length && opts.saveUrl) {
                saveType = 'full';
                url = opts.saveUrl;
            }
        }

        data = saveType === 'patch' ? {patch: patch} : {xform: formText};
        data.case_references = JSON.stringify(this.data.core.form._logicManager.caseReferences());
        if (checkForConflict) {
            data.sha1 = CryptoJS.SHA1(this.data.core.lastSavedXForm).toString();
        }

        this.data.core.saveButton.ajax({
            type: "POST",
            url: url,
            data: data,
            dataType: 'json',
            error: function() {
                hidePageSpinner();
            },
            success: function (data) {
                if (checkForConflict) {
                    if (data.status === 'conflict') {
                        // reset save button to unsaved state
                        _this.data.core.saveButton.fire("change");
                        var force_full = _this.opts()
                            .features.full_save_on_missing_conflict_xform;
                        if (_.isUndefined(data.xform) && force_full) {
                            // unconditionally overwrite if no xform to compare
                            // this codepath is for standalone/test mode only
                            _this.send(formText, 'full');
                        } else {
                            hidePageSpinner();
                            _this.showOverwriteWarning(_this.send.bind(_this),
                                                       formText, data.xform);
                        }
                        return;
                    } else if (CryptoJS.SHA1(formText).toString() !== data.sha1) {
                        debug.error("sha1's didn't match");
                        _this.send(formText, 'full');
                    }
                }
                hidePageSpinner();
                _this.opts().core.onFormSave(data);
                _this.data.core.lastSavedXForm = formText;
                _this._setURLHash(_this._propertiesMug);
            }
        });
    };

    /**
     * Get UI sections for the mug. This controls the UI for the mug.
     *
     * @param {Mug} mug - The mug to get sections for.
     * @return {Array<Object>} List of sections to display for the given mug.
     *      Each section is an object with the following properties:
     *      - slug: The slug of the section.
     *      - displayName: The display name of the section. Should be tagged for translation with `gettext`.
     *      - properties: List of mug properties to display.
     *      - help: Help configuration with `title`, `text` and `link` properties.
     *      - isCollapsed: Boolean indicating whether the section should be collapsed by default.
     */
    fn.getSections = function (mug) {
        return [
            {
                slug: "main",
                displayName: gettext("Basic"),
                properties: this.getMainProperties(),
                help: {
                    title: gettext("Basic"),
                    text: "<p>" + util.format(
                        gettext("The {displaytext} " +
                            "appears in the application. This text will not " +
                            "appear in data exports."),
                        {displaytext: "<strong>" + gettext("Display Text") + "</strong>"}
                    ) + "</p> ",
                    link: "https://confluence.dimagi.com/display/commcarepublic/Form+Builder"
                }
            },
            {
                slug: "data_source",
                displayName: gettext("Data Source"),
                properties: this.getDataSourceProperties(),
                isCollapsed: true,
                help: {
                    title: gettext("Data Source"),
                    text: gettext("You can configure an external data source like a " +
                        "case list or lookup table to use as the choices for " +
                        "a multiple choice question.")
                }
            },
            {
                slug: "logic",
                displayName: gettext("Logic"),
                properties: this.getLogicProperties(),
                isCollapsed: true,
                help: {
                    title: gettext("Logic"),
                    text: gettext("Use logic to control when questions are asked and what answers are valid. " +
                        "You can add logic to display a question based on a previous answer, to make " +
                        "the question required or ensure the answer is in a valid range."),
                    link: "https://confluence.dimagi.com/display/commcarepublic/Common+Logic+and+Calculations"
                }
            },
            {
                displayName: gettext("Media"),
                slug: "content",
                properties: this.getMediaProperties(),
                isCollapsed: true,
                help: {
                    title: gettext("Media"),
                    text: gettext("This will allow you to add images, audio or video media to a question, or other custom content."),
                    link: "https://confluence.dimagi.com/display/commcarepublic/Multimedia+in+CommCare"
                }
            },
            {
                slug: "advanced",
                type: "accordion",
                displayName: gettext("Advanced"),
                properties: this.getAdvancedProperties(),
                isCollapsed: true,
                help: {
                    title: gettext("Advanced"),
                    text: gettext("These are advanced settings and are not needed for most applications.  " +
                        "Please only change these if you have a specific need!"),
                    link: "https://confluence.dimagi.com/display/commcarepublic/Application+Building"
                }
            }
        ];
    };

    fn.getMainProperties = function () {
        return [
            "label",
            "calculateAttr",
            "nodeID",
            "requiredAttr",
            "readOnlyControl",
            "itemsetData",
            "imageSize",
        ];
    };

    fn.getDataSourceProperties = function () {
        return [ ];
    };

    fn.getMediaProperties = function () {
        return [
            "mediaItext"
        ];
    };

    fn.getLogicProperties = function () {
        return [
            "relevantAttr",
            "constraintAttr",
            "repeat_count",
            "defaultValue",
            "requiredCondition",
        ];
    };

    fn.getAdvancedProperties = function () {
        return [
            "dataSource",
            "dataValue",
            "xmlnsAttr",
            "label",
            "hintLabel",
            "constraintMsgAttr",
            "dataParent",
            'appearance',
            'comment',
        ];
    };

    function getWidgetClassAndOptions(propPath, mug) {
        var propDef = mug.p.getDefinition(propPath);
        if (!propDef || !mug.isVisible(propPath)) {
            return null;
        }
        return {
            widget: propDef.widget || widgets.text,
            options: $.extend(true, {path: propPath}, propDef)
        };
    }

    fn.getMugSpec = function () {
        return mugs.baseSpecs;
    };

    fn.isMugRemoveable = function (mug, path) {
        return mug.options.isRemoveable;
    };

    fn.isPropertyLocked = function (mugPath, propertyPath) {
        return false;
    };

    fn.isMugPathMoveable = function (mugPath) {
        return true;
    };

    fn.isMugTypeChangeable = function (mug, mugPath) {
        return mug.options.isTypeChangeable;
    };

    fn.handleMugRename = function (form, mug, newId, oldId, newPath, oldPath, oldParent) {
        form.handleMugRename(mug, newId, oldId, newPath, oldPath, oldParent);
    };

    fn.duplicateMugProperties = function(mug) {};

    fn.beforeSerialize = function () {};
    fn.afterSerialize = function () {};

    fn.beforeBulkInsert = function (form) {};
    fn.afterBulkInsert = function (form) {
        this.refreshVisibleData();
    };

    fn.parseDataElement = function (form, el, parentMug, role) {
        return parser.parseDataElement(form, el, parentMug, role);
    };

    /**
     * Parse data from a `bind` element during form loading.
     *
     * @param {Form} form - The form instance being loaded.
     * @param {jQuery} el - JQuery object representing the bind element being processed.
     * @param {String} path - The path of the element within the form.
     */
    fn.parseBindElement = function (form, el, path) {
        parser.parseBindElement(form, el, path);
    };

    /**
     * Parse data from a `setvalue` element during form loading.
     *
     * @param {Form} form - The form instance being loaded.
     * @param {jQuery} el - JQuery object representing the bind element being processed.
     * @param {String} path - The path of the element within the form.
     */
    fn.parseSetValue = function (form, el, path) {
        parser.parseSetValue(form, el, path);
    };

    fn.getControlNodeAdaptorFactory = function (tagName) {
        return this.data.core.controlNodeAdaptorMap[tagName];
    };

    /**
     * Extension point for mug setup during control node parsing
     *
     * The mug has been inserted into the tree by the time this method
     * is called.
     *
     * @param mug - for which the control element is being parsed.
     * @param controlElement - jQuery-wrapped control element.
     */
    fn.populateControlMug = function (mug, controlElement) {
        return parser.populateControlMug(mug, controlElement);
    };

    /**
     * Extension point for plugins to hook into the mapping of control nodes
     * to control mugs.
     *
     * @param map - An object mapping control node tag names to functions.
     *  The keys to this map are lowercase control node tag names.
     *  The values are functions that support the following call signature:
     *
     *      `adapt = makeMugAdaptor($controlElement, appearance, form, parentMug)`
     *
     *  `makeMugAdaptor` must return a function that converts a data-bind-only
     *  mug or null to a control mug. This function must support the following
     *  call signature:
     *
     *      `mug = adapt(mug, form)`
     *
     *  Most adaptor factories will use `parser.js:makeMugAdaptor` to create an
     *  `adapt` function that does a typical mug conversion. See also
     *  `parser.js:makeControlOnlyMugAdaptor` for control-only mugs.
     */
    fn.updateControlNodeAdaptorMap = function (map) {};

    fn.contributeToModelXML = function (xmlWriter, form) {};

    fn.contributeToHeadXML = function (xmlWriter, form) {};

    fn.initMediaUploaderWidget = function (widget) {};

    fn.destroy = function () {};

    $.vellum.plugin("core", {
        form: null,
        loadDelay: 500,
        patchUrl: false,
        hasSubmissions: false,
        hasSubmissionsUrl: false,
        saveUrl: false,
        saveType: 'full',
        staticPrefix: "",
        allowedDataNodeReferences: [],
        noTextString: '[no text]',
        onReady: function () {},
        onFormSave: function (data) {},
        bindBeforeUnload: function (handler) {
            $(window).on('beforeunload', handler);
        }
    }, fn);
});

/*
 * "Ignore but Retain" plugin.
 *
 * This plugin allows you to mark any node in an XForm's XML with
 * 'vellum:ignore="retain"'.
 *
 * Marked nodes (with the exception of data, bind, and control nodes) will be
 * removed from the XML before it's processed by Vellum, and reinserted when
 * Vellum writes out XML. Data, bind, and control nodes are consumed by a
 * special `Ignored` mug type and inserted into the question tree like other
 * mugs. Ignored nodes are reinserted as close as possible to their original
 * position relative to the nodes that were around them when the form was
 * originally parsed.
 *
 * Most question ID and path changes are handled.
 *
 * Spec:
 * https://docs.google.com/document/d/12see6m3Lr6nVVgjfstS3oS6Vc1UT7l4bqYNRtDB-GXQ/
 */
define('vellum/ignoreButRetain',[
    'underscore',
    'jquery',
    'vellum/xml',
    'vellum/parser',
    'vellum/core'
], function (
    _,
    $,
    xml,
    parser
) {
    var xmls = new XMLSerializer(),
        parseXML = xml.parseXML,
        MUG = "mug",
        PARENT = "parent";

    $.vellum.plugin("ignore", {}, {
        loadXML: function (xmlStr, options) {
            this.data.ignore.ignoredNodes = [];
            if (!xmlStr) {
                this.__callOld();
                return;
            }
            var _this = this,
                ignoredEls = [],
                xml = parseXML(xmlStr),
                ignores = xml.find('[vellum\\:ignore="retain"]');

            this.data.ignore.active = ignores.length;
            if (!this.data.ignore.active) {
                // skip serialize
                this.__callOld();
                return;
            }

            options.enableInstanceRefCounting = false;
            this.data.ignore.ignoredMugs = [];

            var model = xml.find('h\\:xdoc > h\\:head > model').first(),
                instance = model.find('instance').first(),
                body = xml.find('h\\:xdoc > h\\:body, h\\:xdoc > body').first();
            _.each([model, instance, body], function (el) {
                if (!el.length) {
                    window.console.log("WARNING", el.tagName, "not found");
                }
            });
            ignores = ignores.not(function (i, el) {
                var isDataOrControl = _.any($(el).parents(), function (parent) {
                        return instance.is(parent) || body.is(parent) ||
                            _.any(ignores, function (ignored) {
                                // exclude nested nodes ... O(n^2)
                                return $(ignored).is(parent);
                            });
                    });
                if (!isDataOrControl && el.nodeName === "bind") {
                    return $(el).parent().is(model);
                }
                return isDataOrControl;
            });
            ignores.each(function (i, el) {
                _this.data.ignore.ignoredNodes.push(getPathAndPosition(el));
                ignoredEls.push(el);
            });

            // do this last in case one ignore node follows another; it can still
            // use the first one as its reference
            _.each(ignoredEls, function (el) {
                el.parentElement.removeChild(el);
            });
           
            this.__callOld(xmls.serializeToString(xml[0]), options);
        },
        createXML: function () {
            var xmlStr = this.__callOld(),
                ignoredNodes = this.data.ignore.ignoredNodes;
            if (!this.data.ignore.active) {
                return xmlStr;
            }

            var xml = $(parseXML(xmlStr));

            _.each(ignoredNodes, function (node) {
                if (node.path === "h\\:xdoc > h\\:body") {
                    // Something weird happens involving body since it's an HTML
                    // tag, apparently.  But only when it's the terminal node in a
                    // selector. Also behaves differently in FF and Chrome.
                    node.path = "h\\:xdoc > body, h\\:xdoc > h\\:body";
                } else if (node.path === "h\\:xdoc > h\\:head") {
                    // same as above?
                    node.path = "h\\:xdoc > head, h\\:xdoc > h\\:head";
                }

                var parentNode = xml.find(node.path),
                    ignored = parseXML(node.nodeXML)[0].childNodes[0],
                    prev = node.prev && parentNode.find(node.prev),
                    next = node.next && parentNode.find(node.next);

                if (prev && prev.length) {
                    prev.first().after(ignored);
                } else if (next && next.length) {
                    next.first().before(ignored);
                } else {
                    // sibling was deleted, insert at end
                    parentNode.append(ignored);
                }
            });

            var count = 0;
            return xmls.serializeToString(xml[0])
                // firefox adds xmlns="" to fragments when adding them to the
                // document
                .replace(/ xmlns=""/g, '')
                .replace(/ xmlns:vellum="(.+?)"/g, function (match) {
                    return count++ ? '' : match;
                });
        },
        getMugTypes: function () {
            var types = this.__callOld();
            types.normal.Ignored = IgnoredQuestion;
            return types;
        },
        parseDataElement: function (form, el, parentMug) {
            if (this.data.ignore.active) {
                var $el = $(el);
                if ($el.xmlAttr("vellum:ignore") === "retain") {
                    var mug = form.mugTypes.make("Ignored", form);
                    mug.p.nodeID = el.nodeName;
                    mug.p.rawDataAttributes = parser.getAttributes(el);
                    if ($el.children().length) {
                        mug.p.dataNodeXML = serializeXML($el)
                            // strip wrapper element
                            .replace(/^<[^>]+>([^]*)<\/[^>]+>$/, "$1");
                    } else {
                        mug.p.dataNodeXML = "";
                    }
                    this.data.ignore.ignoredMugs.push(mug);
                    return mug;
                }
            }
            return this.__callOld();
        },
        parseBindElement: function (form, el, path) {
            if (this.data.ignore.active) {
                path = form.normalizeXPath(path);
                var mug = form.getMugByPath(path);
                if (!mug) {
                    mug = findParent(path, form);
                }
                if ((mug && mug.__className === "Ignored") ||
                    el.xmlAttr("vellum:ignore") === "retain")
                {
                    var basePath, relativeTo;
                    if (mug && mug.__className === "Ignored") {
                        basePath = mug.absolutePath;
                        relativeTo = MUG;
                    } else {
                        var parent = null;
                        if (mug) {
                            parent = mug.options.isSpecialGroup ? mug : mug.parentMug;
                        }
                        mug = makeIgnoredMug(form, parent);
                        form.tree.insertMug(mug, 'into', parent);
                        // HACK fix abstraction broken by direct tree insert
                        form._fixMugState(mug);
                        basePath = parent ? parent.absolutePath : form.getBasePath(true);
                        relativeTo = PARENT;
                        this.data.ignore.ignoredMugs.push(mug);
                    }
                    mug.p.binds.push({
                        path: path.startsWith(basePath) ?
                                    path.slice(basePath.length) : path,
                        relativeTo: path.startsWith(basePath) ? relativeTo : null,
                        attrs: parser.getAttributes(el)
                    });
                    return;
                }
            }
            this.__callOld();
        },
        parseSetValue: function (form, el, path) {
            if (this.data.ignore.active) {
                path = form.normalizeXPath(path);
                var mug = form.getMugByPath(path);
                if (!mug) {
                    mug = findParent(path, form);
                }
                if ((mug && mug.__className === "Ignored") ||
                    el.xmlAttr("vellum:ignore") === "retain")
                {
                    var basePath, relativeTo;
                    if (mug && mug.__className === "Ignored") {
                        basePath = mug.absolutePath;
                        relativeTo = MUG;
                    } else {
                        var parent = null;
                        if (mug) {
                            parent = mug.options.isSpecialGroup ? mug : mug.parentMug;
                        }
                        mug = makeIgnoredMug(form, parent);
                        form.tree.insertMug(mug, 'into', parent);
                        // HACK fix abstraction broken by direct tree insert
                        form._fixMugState(mug);
                        basePath = parent ? parent.absolutePath : form.getBasePath(true);
                        relativeTo = PARENT;
                        this.data.ignore.ignoredMugs.push(mug);
                    }
                    mug.p.setValues.push({
                        ref: el.xmlAttr('ref'),
                        event: el.xmlAttr('event'),
                        value: el.xmlAttr('value')
                    });
                    return;
                }
            }
            this.__callOld();
        },
        getControlNodeAdaptorFactory: function (tagName) {
            var getAdaptor = this.__callOld();
            if (this.data.ignore.active) {
                var ignoredMugs = this.data.ignore.ignoredMugs;
                return function ($cEl, appearance, form, parentMug) {
                    function adapt() {
                        if (!mug || mug.__className !== "Ignored") {
                            mug = makeIgnoredMug(form, parentMug);
                            ignoredMugs.push(mug);
                        }
                        restoreAttributes($cEl);
                        mug.p.controlNode = serializeXML($cEl);
                        return mug;
                    }
                    adapt.skipPopulate = true;
                    var path = parser.getPathFromControlElement(
                                        $cEl, form, parentMug, true),
                        mug = form.getMugByPath(path);
                    if ($cEl.xmlAttr("vellum:ignore") === "retain") {
                        adapt.ignoreDataNode = mug && mug.__className !== "Ignored";
                        return adapt;
                    }
                    if (mug && mug.__className === "Ignored") {
                        return adapt;
                    }
                    var args = Array.prototype.slice.call(arguments);
                    return getAdaptor && getAdaptor.apply(null, args);
                };
            }
            return getAdaptor;
        },
        getSections: function (mug) {
            if (this.data.ignore.active && mug.__className === "Ignored") {
                return [{
                    slug: "advanced",
                    type: "accordion",
                    displayName: "Advanced",
                    properties: [
                        "nodeID",
                    ],
                    isCollapsed: true,
                    help: {
                        title: gettext("Advanced"),
                        text: gettext("This question represents advanced content " +
                          "that is not supported by the form builder. Please " +
                          "only change it if you have a specific need!")
                    }
                }];
            }
            return this.__callOld();
        },
        handleMugRename: function (form, mug, newID, oldID, newPath, oldPath) {
            this.__callOld();
            var _this = this;
            if (this.data.ignore.active && oldPath) {
                // does not use normalizeXPath for oldPath as old XPath is invalid
                oldPath = oldPath.replace(/^#form\//, form.getBasePath(true) + "/");
                newPath = form.normalizeXPath(newPath);
                var oldEscaped = RegExp.escape(oldPath),
                    pathRegex = new RegExp(oldEscaped + '(\\W|$)', 'g'),
                    newPattern = newPath + "$1";
                _.each(_this.data.ignore.ignoredNodes, function (node) {
                    node.nodeXML = node.nodeXML.replace(pathRegex, newPattern);
                });
                _.each(_this.data.ignore.ignoredMugs, function (mug) {
                    if (mug.p.controlNode) {
                        mug.p.controlNode =
                            mug.p.controlNode.replace(pathRegex, newPattern);
                    }
                    _.each(mug.p.binds, function (bind) {
                        bind.attrs = _.object(_.map(bind.attrs, function (value, key) {
                            return [key, value.replace(pathRegex, newPattern)];
                        }));
                    });
                });
            }
        }
    });

    var IgnoredQuestion = {
            typeName: gettext("Ignored XML"),
            icon: 'fa fa-question-circle',
            isTypeChangeable: false,
            isRemoveable: false,
            isCopyable: false,
            ignoreHashtags: true,
            isHashtaggable: false,
            init: function (mug) {
                mug.p.binds = [];
                mug.p.setValues = [];
            },
            parseDataNode: function (mug, node) {
                return $([]);
            },
            getTagName: function (mug, nodeID) {
                return mug.p.rawDataAttributes ? nodeID : null;
            },
            writeDataNodeXML: function (writer, mug) {
                if (mug.p.dataNodeXML) {
                    writer.writeXML(mug.p.dataNodeXML);
                }
            },
            getBindList: function (mug) {
                return _.map(mug.p.binds, function (bind) {
                    var attrs = _.clone(bind.attrs),
                        basePath = "";
                    if (bind.relativeTo === MUG) {
                        basePath = mug.absolutePath;
                    } else if (bind.relativeTo === PARENT) {
                        var parent = mug.parentMug;
                        basePath = parent ? parent.absolutePath :
                                            mug.form.getBasePath(true);
                    }
                    attrs.nodeset = basePath + bind.path;
                    return attrs;
                });
            },
            getSetValues: function(mug) {
                return mug.p.setValues;
            },
            writesOnlyCustomXML: true,
            writeCustomXML: function (writer, mug) {
                if (mug.p.controlNode) {
                    writer.writeXML(mug.p.controlNode);
                }
            },
            spec: {
                label: { presence: 'notallowed' },
                labelItext: { presence: 'notallowed' },
                labelItextID: { presence: 'notallowed' },
                hintLabel: { presence: 'notallowed' },
                hintItext: { presence: 'notallowed' },
                hintItextID: { presence: 'notallowed' },
                helpItext: { presence: 'notallowed' },
                helpItextID: { presence: 'notallowed' },
                mediaItext: { presence: 'notallowed' },
                otherItext: { presence: 'notallowed' },
                appearance: { presence: 'notallowed' },
            }
        };

    function findParent(path, form) {
        var parent = null,
            regex = /[\/[][^\/[]+$/;
        while (!parent && path && regex.test(path)) {
            path = path.replace(regex, "");
            if (path) {
                parent = form.getMugByPath(path);
            }
        }
        return parent;
    }

    function makeIgnoredMug(form, parent) {
        var mug = form.mugTypes.make("Ignored", form);
        mug.p.nodeID = form.generate_item_label(parent, "ignored--", 1);
        return mug;
    }

    function restoreAttributes(el) {
        if (el.length && el[0].poppedAttributes) {
            el.xmlAttr(el[0].poppedAttributes);
        }
    }

    function serializeXML(xml) {
        var string = xmls.serializeToString(xml[0]),
            i = string.indexOf(">");
        if (i === -1) {
            return string;
        }
        // remove xmlns attributes from the root node
        return string.slice(0, i)
                     .replace(/ xmlns(:.*?)?="(.*?)"/g, "") + string.slice(i);
    }

    function getPathAndPosition(node) {
        var origNode = node,
            path = [],
            prev, next;

        prev = getSiblingSelector(node, "previous");
        next = getSiblingSelector(node, "next");
        node = node.parentElement;

        while (node) {
            path.unshift(getNodeIdentifierSelector(node));
            node = node.parentElement;
        }

        var nodeXML = xmls.serializeToString(origNode)
            // XMLSerializer adds xmlns to fragments, which we don't want.  This
            // should only remove the xmlns from the root node, so if inner elements
            // have an XMLNS, it will be preserved.
                .replace(/xmlns="(.*?)"/, "");

        return {
            prev: prev,
            next: next,
            path: path.join(" > "),
            nodeXML: "\n" + nodeXML
        };
    }

    function getSiblingSelector(node, position) {
        var sel = getNodeIdentifierSelector(node[position + "ElementSibling"]);
        return sel && sel + ", " + sel.replace(/\w+:([^:]*)$/, "$1");
    }

    function getNodeIdentifierSelector(node) {
        if (!node) {
            return null;
        }
        var $node = $(node),
            nodeset = $node.xmlAttr('nodeset'),
            ref = $node.xmlAttr('ref'),
            id = $node.xmlAttr('id'),
            tagName = ($node.prop('tagName') || '').toLowerCase();

        if (tagName === 'setvalue') {
            return '[event="' + $node.xmlAttr('event') + '"]' +
                   '[ref="' + ref + '"]';
        } else if (nodeset) {
            return '[nodeset="' + nodeset + '"]';
        } else if (ref) {
            return '[ref="' + ref + '"]';
        } else if (id) {
            return '[id="' + id + '"]';
        } else {
            // escape ':' in namespaced selector for jQuery selector usage
            return node.nodeName.replace(":", "\\:");

            // to have this be fully generic for a node with any path,
            // we would have to add an :nth-child or even better :nth-of-type
            // selector for intermediate nodes without a question ID but which
            // could be at a level with multiple nodes with the same tag name.
            // But this would have complex edge cases for when nodes at inner
            // levels were added or deleted -- being able to recognize that a
            // find failed and then retry with a different selector expression.
            //
            // For XForms and the ignored nodes that we expect to see, the
            // current implementation is sufficient.
        }
    }
});

/*
 * Android app callout module
 *
 * Can be either templated or custom.
 *
 * Templated means that there is only a dropdown, options are defined by
 * the options passed in to the vellum instance
 *
 * Custom intents has the same dropdown, but also has an input used to define
 * an app id
 */
define('vellum/intentManager',[
    'vellum/mugs',
    'vellum/widgets',
    'vellum/util',
    'vellum/xml',
    'underscore',
    'jquery',
    'vellum/core'
], function (
    mugs,
    widgets,
    util,
    xml,
    _,
    $
) {
    "use strict";
    var DEFAULT_XMLNS = "http://opendatakit.org/xforms",
        INTENT_SPECIFIC_SPECS = [
            "androidIntentAppId",
            "docTemplate",
            "androidIntentExtra",
            "androidIntentResponse",
            "unknownAttributes",
            "intentXmlns",
        ],
        intentTemplates;

    function makeODKXIntentTag (nodeID, appID) {
        return {
            androidIntentAppId: appID || "",
            intentXmlns: DEFAULT_XMLNS,
            androidIntentExtra: {},
            androidIntentResponse: {},
            unknownAttributes: {},
            nodeID: nodeID
        };
    }

    function intentAppIdWidget(mug, options) {
        options.defaultOptions = intentTemplates;

        var features = options.vellum.opts().features,
            widget;

        if (noIntents(features) || onlyTemplatedIntents(features)) {
            widget = widgets.dropdown(mug, options);
        } else {
            widget = widgets.dropdownWithInput(mug, options);
        }

        return widget;
    }

    function printTemplateWidget(mug, options) {
        var widget = widgets.abstractMediaWidget(mug, options);
        widget.getBaseMediaPath = function () {
            return "jr://file/commcare/text/" + mug.p.nodeID;
        };
        return widget;
    }

    var parseInnerTags = function (tagObj, innerTag) {
        var store = {};
        _.each(tagObj.find(innerTag), function (inner) {
            var $innerTag = $(inner),
                key = $innerTag.xmlAttr('key'),
                value;
            value = $innerTag.xmlAttr('ref');
            if (store.hasOwnProperty(key)) {
                if (_.isArray(store[key])) {
                    store[key].push(value);
                } else {
                    store[key] = [store[key], value];
                }
            } else {
                store[key] = value;
            }
        });
        return store;
    };

    var writeInnerTagXML = function(xmlWriter, innerTag, store, mug) {
        if (store) {
            _.each(store, function (ref, key) {
                if (key) {
                    _.each(_.isArray(ref) ? ref : [ref], function (ref) {
                        xmlWriter.writeStartElement(innerTag);
                        xmlWriter.writeAttributeString("key", key);
                        if (mug) {
                            util.writeHashtags(xmlWriter, "ref", ref, mug);
                        } else {
                            xmlWriter.writeAttributeString("ref", ref);
                        }
                        xmlWriter.writeEndElement();
                    });
                }
            });
        }
    };

    function writeXML(xmlWriter, properties, mug) {
        var intentTemplate = findIntentTemplate(properties.androidIntentAppId);
        xmlWriter.writeStartElement('odkx:intent');
        xmlWriter.writeAttributeString("xmlns:odkx", properties.intentXmlns);
        xmlWriter.writeAttributeString("id", properties.nodeID);
        xmlWriter.writeAttributeString("class", properties.androidIntentAppId);
        if (intentTemplate && intentTemplate.type) {
            xmlWriter.writeAttributeString("type", intentTemplate.type);
        }
        _.each(properties.unknownAttributes, function (value, name) {
            xmlWriter.writeAttributeString(name, value);
        });
        writeInnerTagXML(xmlWriter, 'extra', properties.androidIntentExtra, mug);
        if (properties.docTemplate) {
            writeInnerTagXML(xmlWriter, 'extra', {
                'cc:print_template_reference': "'" + properties.docTemplate + "'"
            });
        }
        writeInnerTagXML(xmlWriter, 'response', properties.androidIntentResponse, mug);
        xmlWriter.writeEndElement('odkx:intent');
    }

    function parseIntentTags(tags) {
        var intentTags = {};

        _.each(tags, function (tagXML) {
            var $tag, tagId, newTag;
            $tag = $(tagXML);

            tagId = $tag.xmlAttr('id');
            newTag = makeODKXIntentTag(tagId, $tag.xmlAttr('class'));

            newTag.xmlns = $tag.xmlAttr('xmlns:odkx') || newTag.intentXmlns;
            newTag.androidIntentExtra = parseInnerTags($tag, 'extra');
            newTag.androidIntentResponse = parseInnerTags($tag, 'response');

            _.chain(tagXML.attributes)
             .filter(function(attr) {
                 return !_.contains(['id', 'class', 'xmlns:odk'], attr.nodeName);
             })
             .each(function(attr) {
                 newTag.unknownAttributes[attr.nodeName] = attr.nodeValue;
             });

            intentTags[tagId] = newTag;
        });

        return intentTags;
    }

    function syncMugWithIntent (tags, mug) {
        // called when initializing a new mug or when parsing a form
        if (mug.__className === "AndroidIntent" ||
            mug.__className === "PrintIntent") {
            var nodeID = mug.p.nodeID,
                tag = tags.hasOwnProperty(nodeID) ? tags[nodeID] : makeODKXIntentTag(nodeID);

            _.each(INTENT_SPECIFIC_SPECS, function (key) {
                if (!mug.p[key]) {
                    mug.p[key] = tag[key];
                }
            });

            delete tags[tag.nodeID];
        }

        if (mug.p.androidIntentAppId === "org.commcare.dalvik.action.PRINT") {
            mug.form.changeMugType(mug, 'PrintIntent');
        } else if (!mug.p.androidIntentAppId) {
            mug.p.androidIntentAppId = intentTemplates[0].value;
        }

        if (mug.__className === "PrintIntent") {
            if (mug.p.androidIntentExtra['cc:print_template_reference']) {
                mug.p.docTemplate = mug.p.androidIntentExtra['cc:print_template_reference'].replace(/^'|'$/g, '');
                delete mug.p.androidIntentExtra['cc:print_template_reference'];
            }
        }
    }

    function writeIntentXML (unmappedIntentTags, xmlWriter, tree) {
        // make sure any leftover intent tags are still kept
        _.each(unmappedIntentTags, function (tag) {
            writeXML(xmlWriter, tag);
        });

        tree.treeMap(function(node) {
            var mug = node.getValue();
            if (mug && mug.options.dataType === 'intent') {
                writeXML(xmlWriter, mug.p, mug);
            }
        });
    }

    function serializeAttrs(value, key, mug, data) {
        data[key] = _.clone(mug.p[key]);
        if (data[key][""] === "") {
            delete data[key][""];
        }
    }

    var AndroidIntent = util.extend(mugs.defaultOptions, {
        typeName: gettext('Android App Callout'),
        dataType: 'intent',
        tagName: 'input',
        icon: 'fcc fcc-fd-android-intent',
        isTypeChangeable: false,
        init: function (mug, form) {
            mug.p.intentXmlns = mug.p.intentXmlns || DEFAULT_XMLNS;
        },
        spec: {
            androidIntentAppId: {
                lstring: gettext('External App'),
                visibility: 'visible',
                widget: intentAppIdWidget,
                noCustom: true,
                placeholder: gettext('Insert Android Application ID'),
                deserialize: function (data, key, mug) {
                    if (data.intent) {
                        // support old format for now
                        mug.p.androidIntentAppId = data.intent.path || "";
                        _.each([
                            ["intentXmlns", "xmlns"],
                            ["androidIntentExtra", "extra"],
                            ["androidIntentResponse", "response"],
                            ["unknownAttributes", "unknownAttributes"],
                        ], function (keys) {
                            var attr = keys[0], key = keys[1];
                            if (!_.isEmpty(data.intent[key])) {
                                mug.p[attr] = data.intent[key];
                            }
                        });
                    } else {
                        mug.p[key] = data[key];
                    }
                },
                validationFunc: function (mug) {
                    function valueNotInIntentTemplates (val) {
                        return _.chain(intentTemplates)
                                .map(function(template) { return template.value; })
                                .find(function(appId) { return appId === val; })
                                .isUndefined()
                                .value();
                    }
                    var opts = mug.form.vellum.opts(),
                        features = opts.features,
                        link = opts.core.externalLinks.changeSubscription,
                        changesub = gettext("change your subscription");
                    link = link ? "[" + changesub + "](" + link + ")" : changesub;
                    if (noIntents(features)) {
                        return util.format(gettext(
                            "You no longer have access to built in or external integration in your application.\n\n" +
                            "Built in integrations are available on the Pro plan and higher. " +
                            "External integrations are available on the Advanced plan and higher. " +
                            "Before you can make a new version of your application, " +
                            "you must {link} or delete this question."), {link: link});
                    } else if (onlyTemplatedIntents(features) &&
                               valueNotInIntentTemplates(mug.p.androidIntentAppId)) {
                        return util.format(gettext(
                            "Your subscription only has access to built-in integration.\n\n" +
                            "External integrations are available on the Advanced plan and higher. " +
                            "Before you can make a new version of your application, " +
                            "you must {link} or delete this question."), {link: link});
                    }

                    // Validate that IDs are unique across app callouts
                    var intents = _.filter(mug.form.getMugList(), function(m) {
                        return m.p.androidIntentAppId;
                    });
                    if (intents.length > 1) {
                        var idCounts = _.countBy(intents, function(i) {
                            return i.p.nodeID;
                        });
                        _.each(intents, function(i) {
                            var changed = false;
                            if (idCounts[i.p.nodeID] > 1) {
                                changed = i.messages.update("nodeID", {
                                    key: "intent-nodeID-duplicate",
                                    level: i.ERROR,
                                    message: gettext("Android app callouts of the same type must have different question ids."),
                                });
                            } else {
                                changed = i.dropMessage("nodeID", "intent-nodeID-duplicate");
                            }
                            if (changed) {
                                i.fire({type: "messages-changed", mug: i});
                            }
                        });
                    }

                    return 'pass';
                },
            },
            androidIntentExtra: {
                lstring: gettext('Extra'),
                visibility: 'visible',
                widget: widgets.baseKeyValue,
                serialize: serializeAttrs,
            },
            androidIntentResponse: {
                lstring: gettext('Response'),
                visibility: 'visible',
                widget: widgets.baseKeyValue,
                serialize: serializeAttrs,
            },
            unknownAttributes: {
                visibility: 'hidden',
                presence: 'optional',
                serialize: serializeAttrs,
            },
            intentXmlns: {
                visibility: 'hidden',
                presence: 'optional',
                lstring: gettext("Special Intent XMLNS attribute"),
            }
        },
        getAppearanceAttribute: function (mug) {
            return 'intent:' + mug.p.nodeID;
        }
    });

    var PrintIntent = util.extend(AndroidIntent, {
        typeName: gettext('Print'),
        icon: 'fa fa-print',
        init: function (mug, form) {
            AndroidIntent.init(mug, form);
            mug.p.androidIntentAppId = "org.commcare.dalvik.action.PRINT";
        },
        spec: {
            docTemplate: {
                lstring: gettext('Document Template'),
                visibility: 'visible',
                widget: printTemplateWidget,
            },
            androidIntentAppId: { visibility: 'hidden' },
        }
    });

    function noIntents(features) {
        return !features.custom_intents && !features.templated_intents;
    }

    function onlyTemplatedIntents(features) {
        return features.templated_intents && !features.custom_intents;
    }

    function intents(features) {
        return !noIntents(features);
    }

    function findIntentTemplate(intentId) {
        return _.find(intentTemplates, function (intent) {
            return intent.value === intentId;
        });
    }

    $.vellum.plugin("intents", {}, {
        init: function() {
            var opts = this.opts().intents;
            intentTemplates = _.map(opts && opts.templates, function (temp) {
                return {value: temp.id, text: temp.name, type: temp.mime};
            });
        },
        loadXML: function (xmlString) {
            this.data.intents.unmappedIntentTags = parseIntentTags(
                xml.parseXML(xmlString)
                    .find('h\\:head, head')
                    .children("odkx\\:intent, intent")
            );
            this.__callOld();
        },
        contributeToHeadXML: function (xmlWriter, form) {
            this.__callOld();
            writeIntentXML(this.data.intents.unmappedIntentTags, xmlWriter, form.tree);
        },
        handleNewMug: function (mug) {
            var ret = this.__callOld();
            syncMugWithIntent(this.data.intents.unmappedIntentTags, mug);
            return ret;
        },
        handleMugParseFinish: function (mug) {
            this.__callOld();
            syncMugWithIntent(this.data.intents.unmappedIntentTags, mug);
        },
        getMugTypes: function () {
            var types = this.__callOld();
            types.normal.AndroidIntent = AndroidIntent;
            types.normal.PrintIntent = PrintIntent;
            return types;
        },
        getAdvancedQuestions: function () {
            var ret = this.__callOld();
            if (intents(this.opts().features)) {
                ret.push("AndroidIntent");
                if (this.opts().features.printing) {
                    ret.push("PrintIntent");
                }
            }
            return ret;
        },
        getMainProperties: function () {
            var ret = this.__callOld().concat(INTENT_SPECIFIC_SPECS);
            if (onlyTemplatedIntents(this.opts().features)) {
                ret = _.without(ret, "androidIntentExtra", "androidIntentResponse");
            }
            return ret;
        },
    });
});


define('tpl/tpl!vellum/templates/data_source_editor', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-data-source-editor-container form form-horizontal">\n\n    <fieldset class="data-source-advanced">\n        <legend>\n            <i class="fa fa-cog"></i> '+
((__t=(gettext("Edit Data Source")))==null?'':_.escape(__t))+
'\n        </legend>\n        <div class="form-group">\n            <label class="control-label col-sm-2">\n                '+
((__t=(gettext("Query Expression")))==null?'':_.escape(__t))+
'\n            </label>\n            <div class="col-sm-10">\n                <textarea rows="5"\n                          name="query"\n                          class="form-control fd-data-source-query jstree-drop"></textarea>\n                <p class="help-block">\n                    <a target="_blank"\n                       href="https://help.commcarehq.org/display/commcarepublic/Common+Logic+and+Calculations">\n                        <i class="fa fa-info-circle"></i> '+
((__t=(gettext("Guide to Common Logic and Calculations")))==null?'':_.escape(__t))+
'\n                    </a>\n                </p>\n            </div>\n        </div>\n        <legend>'+
((__t=(gettext("Optional Instance Properties")))==null?'':_.escape(__t))+
'</legend>\n        <div class="form-group">\n            <label class="control-label col-sm-2">\n                '+
((__t=(gettext("Instance ID")))==null?'':_.escape(__t))+
'\n            </label>\n            <div class="col-sm-10">\n                <input name="instance-id" type="text" class="form-control jstree-drop" />\n            </div>\n        </div>\n        <div class="form-group">\n            <label class="control-label col-sm-2">\n                '+
((__t=(gettext("Instance URI")))==null?'':_.escape(__t))+
'\n            </label>\n            <div class="col-sm-10">\n                <input name="instance-src" type="text" class="form-control jstree-drop" />\n            </div>\n        </div>\n    </fieldset>\n\n    <div class="form-actions form-actions-condensed fd-data-source-actions">\n        <div class="col-sm-2"></div>\n        <div class="col-sm-10">\n            <button type="button" class="btn btn-primary fd-data-source-save-button">'+
((__t=(gettext("Save")))==null?'':_.escape(__t))+
'</button>\n            <button type="button" class="btn btn-default fd-data-source-cancel-button">'+
((__t=(gettext("Cancel")))==null?'':_.escape(__t))+
'</button>\n        </div>\n    </div>\n    </div>\n</div>\n';
}
return __p;
}; });

define('vellum/dataSourceWidgets',[
    'jquery',
    'underscore',
    'vellum/widgets',
    'tpl!vellum/templates/data_source_editor'
], function (
    $,
    _,
    widgets,
    edit_source
) {
    /**
     * Load data source editor
     *
     * @param $div - jQuery object in which editor will be created.
     * @param options - Object containing editor options:
     *      {
     *          source: {
     *              id: "<instance id>",
     *              src: "<instance src>",
     *              query: "<query expression>"
     *          },
     *          change: callback,   // called when the editor content changes
     *          done: callback      // called with no arguments on cancel
     *      }
     */
    function loadDataSourceEditor($div, options) {
        var $ui = $(edit_source()),
            $instanceId = $ui.find("[name=instance-id]"),
            $instanceSrc = $ui.find("[name=instance-src]"),
            $query = $ui.find("[name=query]");
        $div.empty().append($ui);

        if (options.source) {
            $instanceId.val(options.source.id || "");
            $instanceSrc.val(options.source.src || "");
            $query.val(options.source.query || "");
        }

        function getDataSource() {
            return {
                id: $instanceId.val(),
                src: $instanceSrc.val(),
                query: $query.val()
            };
        }

        if (options.change) {
            $instanceId.on('change keyup', function () {
                options.change(getDataSource());
            });

            $instanceSrc.on('change keyup', function () {
                options.change(getDataSource());
            });

            $query.on('change keyup', function () {
                options.change(getDataSource());
            });
        }

        var done = function (val) {
            $div.find('.fd-data-source-editor').hide();
            options.done(val);
        };

        $ui.find('.fd-data-source-save-button').click(function () {
            done(getDataSource());
        });

        $ui.find('.fd-data-source-cancel-button').click(function () {
            done();
        });

        if (options.onLoad) {
            options.onLoad($ui);
        }
    }

    function advancedDataSourceWidget(mug, options, labelText) {
        var widget = widgets.text(mug, options),
            getUIElement = widgets.util.getUIElement,
            getUIElementWithEditButton = widgets.util.getUIElementWithEditButton,
            super_getValue = widget.getValue,
            super_setValue = widget.setValue,
            currentValue = null;

        widget.options.richText = false;
        widget.getUIElement = function () {
            var query = getUIElementWithEditButton(
                    getUIElement(widget.input, labelText),
                    function () {
                        mug.form.vellum.displaySecondaryEditor({
                            source: local_getValue(),
                            headerText: labelText,
                            loadEditor: loadDataSourceEditor,
                            onLoad: function ($ui) {
                                widgets.util.setWidget($ui, widget);
                            },
                            done: function (source) {
                                if (!_.isUndefined(source)) {
                                    local_setValue(source);
                                    widget.handleChange();
                                }
                            }
                        });
                    }
                );
            return $("<div></div>").append(query);
        };

        function local_getValue() {
            currentValue.query = super_getValue();
            return currentValue;
        }

        function local_setValue(val) {
            currentValue = val;
            super_setValue(val.query || "");
        }

        widget.getValue = local_getValue;
        widget.setValue = local_setValue;

        return widget;
    }

    // -------------------------------------------------------------------------
    // The following are functions related to "fixture" type data sources only

    /**
     * @param options - Optionally pass in:
     *      onOptionsLoaded - callback called when options are loaded
     *      hasAdvancedEditor - enable advanced editor if true
     *      getSource(mug) - Initializes the source for the advanced editor
     *      setSource(source, mug) - Saves the source from the advanced editor
     */
    function fixtureWidget(mug, options, labelText) {
        var CUSTOM_XML = gettext("Lookup table was not found in the project"),
            EMPTY_VALUE = JSON.stringify({src: "", id: "", query: ""});

        function isEmptyValue(val) {
            return !val || _.all(_.map(val, _.isEmpty));
        }

        function local_getValue() {
            var value = super_getValue();
            return value ? JSON.parse(value) : EMPTY_VALUE;
        }

        function local_setValue(val) {
            var jsonVal = EMPTY_VALUE;
            if (!isEmptyValue(val)) {
                jsonVal = JSON.stringify(val);
                if (!widget.equivalentOption(jsonVal)) {
                    widget.addOption(jsonVal, CUSTOM_XML);
                }
            }
            super_setValue(jsonVal);
            hasValue = true;
        }

        var widget = widgets.dropdown(mug, options),
            super_getValue = widget.getValue,
            super_setValue = widget.setValue,
            getSource = options.getSource ? options.getSource : local_getValue,
            setSource = options.setSource ? options.setSource : local_setValue,
            hasValue = false;

        widget.options.richText = false;
        widget.addOption(EMPTY_VALUE, gettext("Loading..."));
        var disconnect = mug.form.vellum.datasources.onChangeReady(function () {
            var data = mug.form.vellum.datasources.getDataSources(),
                value;
            if (options.dataSourcesFilter) {
                data = options.dataSourcesFilter(data);
            }
            if (hasValue) {
                value = local_getValue();
            }
            widget.clearOptions();
            var fixtures = getPossibleFixtures(data);
            widget.addOptions(generateFixtureOptions(fixtures));
            if (hasValue && !isEmptyValue(value)) {
                local_setValue(value);
            } else if (fixtures && fixtures.length) {
                // default to first option
                local_setValue(_.omit(fixtures[0], 'name'));
            }
            if (options.onOptionsLoaded) {
                options.onOptionsLoaded(data);
            }
        });
        mug.on('teardown-mug-properties', disconnect, null, "teardown-mug-properties");

        if (options.hasAdvancedEditor) {
            widget.getUIElement = function () {
                var query = widgets.util.getUIElementWithEditButton(
                        widgets.util.getUIElement(widget.input, labelText),
                        function () {
                            mug.form.vellum.displaySecondaryEditor({
                                source: getSource(mug),
                                headerText: labelText,
                                loadEditor: loadDataSourceEditor,
                                onLoad: function ($ui) {
                                    widgets.util.setWidget($ui, widget);
                                },
                                done: function (source) {
                                    if (!_.isUndefined(source)) {
                                        setSource(source, mug);
                                        widget.handleChange();
                                    }
                                }
                            });
                        }
                    );
                query.find(".fd-edit-button").text("...");
                return $("<div></div>").append(query);
            };
        }

        widget.getValue = local_getValue;
        widget.setValue = local_setValue;

        return widget;
    }

    function getPossibleFixtures(data) {
        function generateFixtureDefinitions(structure, baseFixture) {
            return _.map(structure, function(value, key) {
                var ret = [],
                    newBaseFixture = {
                        id: baseFixture.id,
                        src: baseFixture.src,
                        query: baseFixture.query + "/" + key,
                        name: baseFixture.name + " - " + (value.name || key),
                    };

                if (!(_.isEmpty(value.structure) || value.no_option)) {
                    ret = [newBaseFixture];
                }
                return ret.concat(generateFixtureDefinitions(value.structure, newBaseFixture));
            });
        }

        return _.flatten(_.map(data, function(fixture) {
            var baseFixture = {
                id: fixture.id,
                src: fixture.uri,
                query: "instance('" + fixture.id + "')" + fixture.path,
                name: fixture.name || fixture.id
            };

            return [baseFixture].concat(generateFixtureDefinitions(fixture.structure, baseFixture));
        }));
    }

    function generateFixtureOptions(fixtures) {
        return _.map(fixtures, function(fixture) {
            return {
                value: JSON.stringify(_.omit(fixture, 'name')),
                text: fixture.name
            };
        });
    }

    function generateFixtureColumns(fixture) {
        function generateColumns(structure) {
            return _.map(structure, function(value, key) {
                return [key].concat(_.map(generateColumns(value.structure), function(value) {
                    return key + '/' + value;
                }));
            });
        }

        if (fixture) {
            return _.flatten(generateColumns(fixture.structure));
        }
        return [];
    }

    function autocompleteChoices(data, fixtureUri) {
        // This seems wrong: fixture_uri references the root of the
        // fixture structure, and options are generated from the root.
        // However, the itemset may be referencing a non-root element
        // and therefore the choices returned here will be incorrectly qualified.
        var fixture = _.find(data, function (source) {
            return source.uri === fixtureUri;
        });
        return fixture ? generateFixtureColumns(fixture) : [];
    }

    // -------------------------------------------------------------------------
    
    return {
        advancedDataSourceWidget: advancedDataSourceWidget,
        fixtureWidget: fixtureWidget,
        autocompleteChoices: autocompleteChoices,
        getPossibleFixtures: getPossibleFixtures,
    };
});

/**
 *  The itemset plugin enables questions to interact with sets of data.
 *  Its primary use is to populate data-driven select questions.
 *
 *  Itemsets contain
 *      instance: which top-level data source contains the items
 *      nodeset: path to apply to the instance to get at the desired items
 *      valueRef: reference to apply to each node to get the item's value
 *      labelRef: reference to apply to each node to get the item's display name
 *
 *  Dynamic select mugs have a child itemset mug. A dynamic select mug's
 *  p.itemsetData, an array with at most one item, stores the itemset's
 *  persistent state.
 */
define('vellum/itemset',[
    'underscore',
    'jquery',
    'vellum/widgets',
    'vellum/dataSourceWidgets',
    'vellum/mugs',
    'vellum/parser',
    'vellum/util',
    'vellum/atwho',
    'vellum/debugutil'
], function (
    _,
    $,
    widgets,
    datasourceWidgets,
    mugs,
    parser,
    util,
    atwho,
    debug
) {
    var mugTypes = mugs.baseMugTypes.normal,
        Itemset, isAdvancedItemsetEnabled, opts,
        changeSubscriptionLink,
        END_FILTER = /\[[^\[\]]*\]$/;

    Itemset = util.extend(mugs.defaultOptions, {
        isControlOnly: true,
        typeName: gettext('Lookup Table Data'),
        tagName: 'itemset',
        icon: 'fa fa-th',
        isTypeChangeable: false,
        // have to delete the parent select
        isRemoveable: false,
        isCopyable: false,
        getIcon: function (mug) {
            return 'fa fa-th';
        },
        init: function (mug, form, baseSpec) {
            mug.p.itemsetData = {};
        },
        writeControlLabel: false,
        writeControlRefAttr: null,
        writeCustomXML: function (xmlWriter, mug) {
            var data = mug.p.itemsetData,
                nodeset = data.nodeset,
                filter = mug.p.filter,
                valueRef = mug.p.valueRef,
                labelRef = mug.p.labelRef,
                sortRef = mug.p.sortRef;
            if (filter) {
                nodeset += '[' + filter + ']';
            }
            util.writeHashtags(xmlWriter, 'nodeset', nodeset || '', mug);
            xmlWriter.writeStartElement('label');
            xmlWriter.writeAttributeString('ref', labelRef || '');
            xmlWriter.writeEndElement();
            xmlWriter.writeStartElement('value');
            xmlWriter.writeAttributeString('ref', valueRef || '');
            xmlWriter.writeEndElement();
            var features = mug.form.vellum.opts().features;
            if (sortRef && sortRef.trim() && features.sorted_itemsets) {
                xmlWriter.writeStartElement('sort');
                xmlWriter.writeAttributeString('ref', sortRef);
                xmlWriter.writeEndElement();
            }
        },
        spec: {
            label: { presence: 'notallowed' },
            labelItext: { presence: 'notallowed' },
            labelItextID: { presence: 'notallowed' },
            hintLabel: { presence: 'notallowed' },
            hintItext: { presence: 'notallowed' },
            hintItextID: { presence: 'notallowed' },
            helpItext: { presence: 'notallowed' },
            helpItextID: { presence: 'notallowed' },
            mediaItext: { presence: 'notallowed' },
            otherItext: { presence: 'notallowed' },
            appearance: { presence: 'notallowed' },
            itemsetData: {
                lstring: gettext('Lookup Table'),
                visibility: 'visible_if_present',
                presence: 'optional',
                widget: itemsetWidget,
                serialize: function (value, key, mug, data) {
                    value.nodeset = mugs.serializeXPath(value.nodeset, key, mug, data);
                    return value;
                },
                deserialize: function (data, key, mug, context) {
                    var value = data[key];
                    if (value) {
                        mugs.updateInstances(data, mug);
                        if (value.instance && value.instance.id && value.instance.src) {
                            var instances = {};
                            instances[value.instance.id] = value.instance.src;
                            mug.form.updateKnownInstances(instances);
                        }
                        var fakeMug = {form: mug.form, p: value};
                        value.nodeset = mugs.deserializeXPath(value, "nodeset", fakeMug, context);
                        //support old copy/paste
                        if (value.valueRef) {
                            mug.p.valueRef = value.valueRef;
                        }
                        if (value.labelRef) {
                            mug.p.labelRef = value.labelRef;
                        }
                        if (value.sortRef) {
                            mug.p.sortRef = value.sortRef;
                        }
                    }
                    return value;
                },
                validationFunc: function (mug) {
                    if (!mug.options.lookupTablesEnabled) {
                        return util.format(gettext(
                            "You no longer have access to Lookup Tables in your application. " +
                            "Lookup Tables are available on the Standard plan and higher.\n" +
                            "Before you can make a new version of your application, " +
                            "you must {link} or delete this question"
                        ), {
                            link: changeSubscriptionLink ?
                                "[" + gettext("change your subscription") +
                                "](" + changeSubscriptionLink + ")" :
                                gettext("change your subscription")
                        });
                    }
                    var itemsetData = mug.p.itemsetData;
                    if (!itemsetData.nodeset) {
                        return gettext("A data source must be selected.");
                    } else {
                        mug.form.updateLogicReferences(
                            mug, "itemsetData", itemsetData.nodeset);
                    }

                    return 'pass';
                }
            },
            valueRef: {
                lstring: 'Value Field',
                widget: refWidget,
                visibility: 'visible',
                presence: 'required',
                validationFunc: validateRefWidget('valueRef'),
                serialize: function (value, key, mug, data) {
                    if (mug.p.valueRef) {
                        data.itemsetData[0].valueRef = mug.p.valueRef;
                    }
                },
            },
            labelRef: {
                lstring: gettext('Display Text Field'),
                widget: refWidget,
                visibility: 'visible',
                presence: 'required',
                validationFunc: validateRefWidget('labelRef'),
                serialize: function (value, key, mug, data) {
                    if (mug.p.labelRef) {
                        data.itemsetData[0].labelRef = mug.p.labelRef;
                    }
                },
            },
            sortRef: {
                lstring: gettext('Sort Field'),
                widget: refWidget,
                visibility: function (mug) {
                    return mug.form.vellum.opts().features.sorted_itemsets;
                },
                presence: 'optional',
                validationFunc: validateRefWidget('sortRef'),
                serialize: function (value, key, mug, data) {
                    if (mug.p.sortRef) {
                        data.itemsetData[0].sortRef = mug.p.sortRef;
                    }
                },
            },
            filter: {
                lstring: gettext('Filter'),
                presence: 'optional',
                widget: widgets.xPath,
                xpathType: 'bool',
                serialize: mugs.serializeXPath,
                deserialize: mugs.deserializeXPath,
                visibility: 'visible',
                leftPlaceholder: '',
                autocompleteChoices: function(mug) {
                    var sources = getDataSources(mug),
                        src = mug.p.itemsetData.instance.src;
                    return datasourceWidgets.autocompleteChoices(sources, src);
                },
                help: gettext("This is an XPath expression that will filter the set " +
                      "of choices from the lookup table"),
            }
        }
    });

    function afterDynamicSelectInsert(form, mug) {
        var children = mug.form.getChildren(mug);
        if (children.length) {
            return children[0];
        }
        var sources = getDataSources(mug),
            newMug = form.createQuestion(mug, 'into', "Itemset", true);
        if (sources.length) {
            var src = sources[0].uri,
                nodeset = "instance('" + sources[0].id + "')" + sources[0].path,
                choices = datasourceWidgets.autocompleteChoices(sources, src);
            newMug = populateNodesetAttributes(newMug, choices);
            newMug.p.filter = '';
            newMug.p.itemsetData = {
                instance: form.parseInstance(
                    nodeset, newMug, "itemsetData"),
                nodeset: nodeset,
            };
        }
        return newMug;
    }

    var itemsetDataSpec = {
            presence: 'optional',
            visibility: 'hidden',
            serialize: function (value, key, mug, data) {
                value = _.chain(mug.form.getChildren(mug))
                    .map(function (child) {
                        return child.spec[key].serialize(child.p[key], key, child, data);
                    })
                    .filter(_.identity)
                    .value();
                return !_.isEmpty(value) ? value : undefined;
            },
            deserialize: function (data, key, mug, context) {
                _.each(data[key], function (value, i) {
                    var children = mug.form.getChildren(mug),
                        itemset = children[i] || afterDynamicSelectInsert(mug.form, mug),
                        dat = _.clone(data);
                    dat[key] = value;
                    itemset.p[key] = itemset.spec[key].deserialize(dat, key, itemset, context);
                });
            }
        };

    $.vellum.plugin("itemset", {}, {
        init: function () {
            opts = this.opts().itemset;
            isAdvancedItemsetEnabled = this.opts().features.advanced_itemsets;
            Itemset.lookupTablesEnabled = this.opts().features.lookup_tables;
            changeSubscriptionLink = this.opts().core.externalLinks.changeSubscription;
        },
        getQuestionGroups: function () {
            var groups = this.__callOld();
            if (this.opts().features.lookup_tables) {
               groups.splice(groups.length - 1, 0, {
                    group: ["SelectDynamic", gettext('Lookup Tables')],
                    questions: ["SelectDynamic", "MSelectDynamic"],
                });
            }
            return groups;
        },
        getMugTypes: function () {
            var types = this.__callOld();
            types.auxiliary.Itemset = Itemset;
            types.normal = $.extend(types.normal, {
                "MSelectDynamic": util.extend(mugTypes.MSelect, {
                    typeName: gettext('Checkbox Lookup Table'),
                    typeChangeError: function (mug, typeName) {
                        if (typeName.match(/^M?Select$/)) {
                            if (mug.form.getChildren(mug).length > 0) {
                                return gettext("Cannot change to Multiple/Single Choice " +
                                      "question if it has Choices. " +
                                      "Please remove all Choices and try again.");
                            }
                            return '';
                        }
                        return typeName === "SelectDynamic" ? "" :
                            gettext("Can only change to a Multiple Choice Lookup Table");
                    },
                    validChildTypes: ["Itemset"],
                    maxChildren: 1,
                    afterInsert: afterDynamicSelectInsert,
                    canAddChoices: false,
                    spec: {
                        itemsetData: itemsetDataSpec,
                        valueRef: itemsetDataSpec,
                        labelRef: itemsetDataSpec,
                        sortRef: itemsetDataSpec,
                        filter: itemsetDataSpec,
                    }
                }),
                "SelectDynamic": util.extend(mugTypes.Select, {
                    typeName: gettext('Multiple Choice Lookup Table'),
                    typeChangeError: function (mug, typeName) {
                        if (typeName.match(/^M?Select$/)) {
                            if (mug.form.getChildren(mug).length > 0) {
                                return gettext("Cannot change to Multiple/Single Choice " +
                                      "question if it has Choices. " +
                                      "Please remove all Choices and try again.");
                            }
                            return '';
                        }
                        return typeName === "MSelectDynamic" ? "" :
                            gettext("Can only change to a Checkbox Lookup Table");
                    },
                    validChildTypes: ["Itemset"],
                    maxChildren: 1,
                    afterInsert: afterDynamicSelectInsert,
                    canAddChoices: false,
                    spec: {
                        itemsetData: itemsetDataSpec,
                        valueRef: itemsetDataSpec,
                        labelRef: itemsetDataSpec,
                        sortRef: itemsetDataSpec,
                        filter: itemsetDataSpec,
                    }
                })
            });
            return types;
        },
        updateControlNodeAdaptorMap: function (map) {
            this.__callOld();
            var adaptItemset = parser.makeControlOnlyMugAdaptor('Itemset');
            map.itemset = function ($element, appearance, form, parentMug) {
                var adapt = function (mug, form) {
                    if (parentMug.__className === 'Select') {
                        form.changeMugType(parentMug, 'SelectDynamic');
                    } else if (parentMug.__className === 'MSelect') {
                        form.changeMugType(parentMug, 'MSelectDynamic');
                    } else {
                        debug.log("Unknown parent type: " + parentMug.__className);
                    }
                    mug = adaptItemset(mug, form);
                    var nodeset = parseNodeset(
                            $element.popAttr('vellum:nodeset') ||
                            $element.popAttr('nodeset'));
                    mug.p.filter = nodeset.filter;
                    mug.p.itemsetData = {
                        instance: form.parseInstance(
                                    nodeset.value, mug, "itemsetData"),
                        nodeset: nodeset.value,
                    };
                    mug.p.labelRef = $element.children('label').xmlAttr('ref');
                    mug.p.valueRef = $element.children('value').xmlAttr('ref');
                    var sortEl = $element.children('sort');
                    if (sortEl.length) {
                        mug.p.sortRef = sortEl.xmlAttr('ref');
                    }
                    return mug;
                };
                adapt.ignoreDataNode = true;
                return adapt;
            };
        },
        loadXML: function () {
            this.__callOld();
            this.data.core.form.on("mug-property-change", function (event) {
                var mug = event.mug;
                if (mug.__className === "Itemset" && event.property === "itemsetData") {
                    updateDataSource(mug, event.val, event.previous);
                }
            });
        },
        getMainProperties: function() {
            return this.__callOld().concat([
                'valueRef',
                'labelRef',
                'sortRef',
            ]);
        },
        getLogicProperties: function () {
            var ret = this.__callOld();
            ret.push('filter');
            return ret;
        },
        changeMugType: function (mug, type) {
            var changeToItemset = mug.__className.match(/^M?Select/) && type.match(/^M?SelectDynamic$/);
            this.__callOld();
            if (changeToItemset) {
                afterDynamicSelectInsert(mug.form, mug);
            }
        },
    });

    function updateDataSource(mug, value, previous) {
        if (previous && previous.instance && previous.instance.src) {
            mug.form.dropInstanceReference(
                        previous.instance.src, mug, "itemsetData.instance");
        }
        if (value && value.instance && value.instance.src) {
            var instanceId = mug.form.addInstanceIfNotExists(
                    value.instance, mug, "itemsetData.instance");
            if (instanceId !== value.instance.id) {
                value.instance.id = instanceId;
                value.nodeset = mug.form.updateInstanceQuery(value.nodeset, instanceId);
            }
        }
    }

    function parseNodeset(nodeset) {
        var i = nodeset.search(END_FILTER);
        if (i !== -1) {
            return {
                value: nodeset.slice(0, i),
                filter: nodeset.slice(i + 1, -1)
            };
        }
        return {value: nodeset, filter: ''};
    }

    function getDataSources(mug) {
        // get asynchronously loaded data if available
        var sources = mug.form.vellum.datasources.getDataSources([]);
        if (opts.dataSourcesFilter) {
            sources = opts.dataSourcesFilter(sources);
        }
        return sources;
    }

    function populateNodesetAttributes(mug, choices) {
        if (!mug.p.labelRef) {
            if (_.contains(choices, "name")) {
                mug.p.labelRef = "name";
            } else {
                mug.p.labelRef = choices[0];
            }
        }
        if (!mug.p.valueRef) {
            if (_.contains(choices, "@id")) {
                mug.p.valueRef = "@id";
            } else {
                mug.p.valueRef = choices.length > 1 ? choices[1] : choices[0];
            }
        }
        return mug;
    }

    function itemsetWidget(mug, options) {
        function isEmptyValue(value) {
            return !value || _.all(_.map(value, _.isEmpty));
        }

        function updateAutocomplete(data) {
            var value = super_getValue(),
                choices = datasourceWidgets.autocompleteChoices(data, value ? value.src : "");
            atwho.autocomplete(valueRef(), mug, {choices: choices});
            atwho.autocomplete(labelRef(), mug, {choices: choices});
            atwho.autocomplete(sortRef(), mug, {choices: choices});
            return choices;
        }

        function onOptionsLoaded(data) {
            dataSources = data;
            optionsLoaded = true;
            if (canUpdateAutocomplete) {
                // cannot do this until widget is fully initialized
                // because updateAutocomplete() calls super_getValue()
                var choices = updateAutocomplete(data);
                if (choices && choices.length && isEmptyValue(current.value)) {
                    mug = populateNodesetAttributes(mug, choices);
                    if (current.hasOwnProperty("value")) {
                        // HACK push async-loaded default value to the mug.
                        // This should not be done in UI (widget) code.
                        // TODO kick off async load options in SelectDynamic mug
                        // init and clean up related hacks.
                        super_handleChange();
                    }
                }
            }
        }

        function labelRef() { return $('#property-labelRef'); }
        function valueRef() { return $('#property-valueRef'); }
        function sortRef() { return $('#property-sortRef'); }

        options = _.extend({}, options, {
            onOptionsLoaded: onOptionsLoaded,
            dataSourcesFilter: opts.dataSourcesFilter,
        });
        if (isAdvancedItemsetEnabled) {
            options.hasAdvancedEditor = true;
            options.getSource = function (mug) {
                var val = super_getValue();
                if (mug.p.filter) {
                    val.query += "[" + mug.p.filter + "]";
                }
                return val;
            };
            options.setSource = function (source, mug) {
                var val = source,
                    nodeset = parseNodeset(source.query);
                val.query = nodeset.value;
                mug.p.filter = nodeset.filter;
                super_setValue(val);
            };
        }

        var current = {},
            dataSources = [],
            optionsLoaded = false,
            canUpdateAutocomplete = false,
            widget = datasourceWidgets.fixtureWidget(mug, options, gettext("Lookup Table")),
            super_getValue = widget.getValue,
            super_setValue = widget.setValue,
            super_handleChange = widget.handleChange;

        widget.handleChange = function() {
            updateAutocomplete(dataSources);
            super_handleChange();
        };

        widget.getValue = function () {
            var val = super_getValue();
            return {
                instance: ($.trim(val.src) ? {id: val.id, src: val.src} : {id: null, src: null}),
                nodeset: val.query,
            };
        };

        widget.setValue = function (val) {
            var hasValue = current.hasOwnProperty("value");
            current.value = val;
            if (optionsLoaded && !hasValue && isEmptyValue(val)) {
                // ignore first call (during core widget init) to retain the
                // default value that was set when options were loaded
                super_handleChange();
                return;
            }
            val = _.isEmpty(val) ? {instance: {}} : val;
            super_setValue({
                id: (val.instance ? val.instance.id : ""),
                src: (val.instance ? val.instance.src : ""),
                query: val.nodeset || ""
            });
        };

        canUpdateAutocomplete = true;
        if (optionsLoaded) {
            // call again to update auto-complete and set defaults
            onOptionsLoaded(dataSources);
        }

        return widget;
    }

    function refWidget(mug, options) {
        var widget = widgets.text(mug, options);

        var value = mug.p.itemsetData,
            instance = value ? value.instance : null,
            src = instance ? instance.src : "",
            choices = datasourceWidgets.autocompleteChoices(getDataSources(mug), src);

        atwho.autocomplete(widget.input, mug, {choices: choices});

        return widget;
    }

    function validateRefWidget(attr) {
        return function(mug) {
            var itemsetData = mug.p.itemsetData,
                mugAttr = mug.p[attr],
                instance = itemsetData.instance,
                instanceSrc = instance ? instance.src : '',
                sources = getDataSources(mug),
                fixtures = datasourceWidgets.getPossibleFixtures(sources),
                notCustom = _.some(fixtures, function (fixture) {
                    return fixture.src === instanceSrc;
                }),
                choices = datasourceWidgets.autocompleteChoices(sources, instanceSrc),
                filterRegex = /\[[^\[]+]/g,
                strippedMugAttr = mugAttr.replace(filterRegex, "");

            if (notCustom && !_.contains(choices, strippedMugAttr)) {
                return util.format(
                    gettext("{attr} was not found in the lookup table"),
                    {attr: mugAttr}
                );
            }

            return 'pass';
        };
    }
});


define('tpl/tpl!vellum/templates/language_selector', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li class="divider language-selector"></li>\n<li class="dropdown-header language-selector">'+
((__t=(gettext("Display")))==null?'':_.escape(__t))+
'</li>\n';
 _.each(languages, function(language) { 
__p+='\n<li><a tabindex="-1" class="fd-display-item language-selector" data-code="'+
((__t=(language.code))==null?'':_.escape(__t))+
'"><i class="fa fa-check"></i>'+
((__t=(language.name))==null?'':_.escape(__t))+
'';

    if (language.name !== language.code && language.code !== '_ids') {
        
__p+=' ('+
((__t=(language.code))==null?'':_.escape(__t))+
')';

    }
    
__p+='</a></li>';

}); 
__p+='\n';
}
return __p;
}; });

define('vellum/javaRosa/itext',[
    'underscore',
    'jquery',
    'vellum/javaRosa/util',
    'vellum/util',
    'vellum/xml',
    'vellum/core'
], function (
    _,
    $,
    jrUtil,
    util,
    xml
) {
    var _nextItextItemKey = 1;
    var ItextItem = function(options) {
        this.forms = options.forms || [];
        this.id = options.id || "";
        this.autoId = _.isUndefined(options.autoId) ? true : options.autoId;
        this.hasMarkdown = _.isUndefined(options.hasMarkdown) ? false : options.hasMarkdown;
        this.itextModel = options.itextModel;
        this.key = String(_nextItextItemKey++);
        this.refCount = 1;
    };
    ItextItem.prototype = {
        clone: function () {
            var item = new ItextItem({
                forms: _.map(this.forms, function (f) { return f.clone(); }),
                id: this.id,
                autoId: this.autoId,
                itextModel: this.itextModel,
                hasMarkdown: this.hasMarkdown
            });
            return item;
        },
        getForms: function () {
            return this.forms;
        },
        getFormNames: function () {
            return this.forms.map(function (form) {
                return form.name;
            });
        },
        hasForm: function (name) {
            return this.getFormNames().indexOf(name) !== -1;
        },
        getForm: function (name) {
            return util.reduceToOne(this.forms, function (form) {
                return form.name === name;
            }, "form name = " + name);
        },
        getOrCreateForm: function (name) {
            try {
                return this.getForm(name);
            } catch (err) {
                return this.addForm(name);
            }
        },
        addForm: function (name) {
            if (!this.hasForm(name)) {
                var newForm = new ItextForm({
                    name: name,
                    itextModel: this.itextModel
                });
                this.forms.push(newForm);
                return newForm;
            }
        },
        removeForm: function (name) {
            var names = this.getFormNames();
            var index = names.indexOf(name);
            if (index !== -1) {
                this.forms.splice(index, 1);
            }
        },
        cloneForm: function (cloneFrom, cloneTo) {
            var newForm = this.getOrCreateForm(cloneFrom).clone();
            newForm.name = cloneTo;
            this.forms.push(newForm);
        },
        get: function(form, language) {
            if (_.isUndefined(form) || form === null) {
                form = "default";
            }
            if (_.isUndefined(language) || language === null) {
                language = this.itextModel.getDefaultLanguage();
            }
            if (this.hasForm(form)) {
                return this.getForm(form).getValue(language);
            }
        },
        /**
         * Set the value of this item
         *
         * @param value - The value to set.
         * @param form - The form for which a value should be set.
         *        Defaults to `"default"` if not specified.
         * @param language - The language to set. If not specified, the
         *        default language will be unconditionally set to the
         *        given value. Additionally, any other language whose
         *        value is empty or matches the previous value of the
         *        default language will be set to the new value.
         */
        set: function(value, form, language) {
            if (_.isUndefined(form) || form === null) {
                form = "default";
            }
            var itextForm = this.getOrCreateForm(form);
            if (_.isUndefined(language) || language === null) {
                language = this.itextModel.getDefaultLanguage();
                var oldDefault = itextForm.getValue(language);
                itextForm.setValue(language, value);
                // also set each language that does not have a value
                // or whose value matches the old default value
                _.each(this.itextModel.languages, function (lang) {
                    var old = itextForm.getValue(lang);
                    if (!old || old === oldDefault) {
                        itextForm.setValue(lang, value);
                    }
                });
            } else {
                itextForm.setValue(language, value);
            }
        },
        defaultValue: function() {
            return this.get();
        },
        isEmpty: function () {
            if (this.forms) {
                return _.every(this.forms, function (form) {
                    return form.isEmpty();
                });
            }
            return true;
        },
        hasHumanReadableItext: function() {
            var self = this;
            return _.some(['default', 'long', 'short'].concat(jrUtil.SUPPORTED_MEDIA_TYPES), function(form) {
                return self.hasForm(form) && _.every(self.itextModel.languages, function(lang) {
                    return self.get(form, lang);
                });
            });
        },
        mapLogicExpressions: function (fn) {
            var forms = this.getForms(),
                ret = _.map(forms, function(form) {
                    return _.map(form.getOutputRefExpressions(), fn);
                });
            return _.flatten(ret);
        },
        /**
         * Call the given function for each output value
         *
         * Each expression will be replaced with the value returned by
         * the function unless undefined.
         */
        updateLogicExpressions: function (fn, mug) {
            var changed = _.some(_.map(this.getForms(), function (iform) {
                return iform.forEachExpression(fn);
            }));
            if (changed) {
                // HACK strange place to fire form event
                mug.form.fire({type: 'question-label-text-change', mug: mug});
            }
        },
    };

    var ItextForm  = function (options) {
        this.itextModel = options.itextModel;
        this.data = options.data || {};
        this.name = options.name || "default";
        this.outputExpressions = null;
    };
    ItextForm.prototype = {
        clone: function () {
            return new ItextForm({
                itextModel: this.itextModel,
                data: _.clone(this.data),
                name: this.name
            });
        },
        getValue: function (lang) {
            return this.data[lang];
        },
        setValue: function (lang, value) {
            this.data[lang] = xml.humanize(value);
            this.outputExpressions = null;
        },
        getValueOrDefault: function (lang) {
            // check the actual language first
            if (this.data[lang]) {
                return this.data[lang];
            }
            var defLang = this.itextModel.getDefaultLanguage();
            // check the default, if necesssary
            if (lang !== defLang && this.data[defLang]) {
                return this.data[defLang];
            }
            // check arbitrarily for something
            for (var i in this.data) {
                if (this.data.hasOwnProperty(i) && this.data[i]) {
                    return this.data[i];
                }
            }
            // there wasn't anything
            return "";
        },
        isEmpty: function () {
            for (var lang in this.data) {
                if (this.data.hasOwnProperty(lang) && this.data[lang]) {
                    return false;
                }
            }
            return true;
        },
        /**
         * Initialize undefined languages in this form
         *
         * This will use the value returned by `getValueOrDefault()`
         * unless the form is empty, in which case it will use the
         * provided `defaultValue`, which defaults to an empty string.
         *
         * @param defaultValue - value to use if the form is empty.
         */
        initUndefined: function (defaultValue) {
            var defLang = this.itextModel.getDefaultLanguage(),
                data = this.data;
            defaultValue = this.getValueOrDefault(defLang) || defaultValue || "";
            _.each(this.itextModel.languages, function (lang) {
                if (!data.hasOwnProperty(lang)) {
                    data[lang] = defaultValue;
                }
            });
        },
        getOutputRefExpressions: function () {
            if (this.outputExpressions === null) {
                this.outputExpressions = this._getOutputRefExpressions();
            }
            return this.outputExpressions;
        },
        _getOutputRefExpressions: function () {
            var refs = [];
            this.forEachExpression(function (expr) {
                if (expr) {
                    refs.push(expr);
                }
            });
            return refs;
        },
        /**
         * Call a function for each output in this form's values
         *
         * The function will be passed two arguments:
         *
         * - expression: the output value expression.
         * - lang: the language of the form containing the expression.
         * 
         * The return value of the function will be assigned to the
         * output value if it is truthy and different from the
         * expression that was passed to the function.
         *
         * @returns true if any expression was changed else false.
         */
        forEachExpression: function (fn) {
            var change = false,
                shouldReset, xquery;
            for (var lang in this.data) {
                if (this.data.hasOwnProperty(lang) && this.data[lang]) {
                    shouldReset = false;
                    xquery = xml.query(this.data[lang]);
                    _.each(xquery.find('output'), function (output) {
                        output = $(output);
                        var key = !output.is("[ref]") ? "value" : "ref",
                            vkey = "vellum:" + key,
                            value = output.xmlAttr(vkey) || output.xmlAttr(key),
                            result = fn(value);
                        if (result !== undefined && result !== value) {
                            output.xmlAttr(key, result).removeAttr(vkey);
                            shouldReset = true;
                        }
                    });
                    if (shouldReset) {
                        this.setValue(lang, xquery.toString());
                        change = true;
                    }
                }
            }
            return change;
        },
    };

    /**
     * The itext holder object. Access all Itext through this gate.
     *
     * Expected forms of itext:
     * - default (i.e. no special form)
     * - long
     * - short
     * - image
     * - audio
     * - hint
     *
     */
    var ItextModel = function () {
        util.eventuality(this);
        
        this.languages = [];
    };
    ItextModel.prototype = {
        getLanguages: function () {
            return this.languages;
        },
        hasLanguage: function (lang) {
            return this.languages.indexOf(lang) !== -1;
        },
        addLanguage: function (lang) {
            if (!this.hasLanguage(lang)) {
                this.languages.push(lang);
            } 
        },
        removeLanguage: function (lang) {
            if(this.hasLanguage(lang)) {
                this.languages.splice(this.languages.indexOf(lang), 1);
            }
            // if we removed the default, reset it
            if (this.getDefaultLanguage() === lang) {
                this.setDefaultLanguage(this.languages.length > 0 ? this.languages[0] : "");
            }
        },
        setDefaultLanguage: function (lang) {
            this.defaultLanguage = lang;
        },
        getDefaultLanguage: function () {
            if (this.defaultLanguage) {
                return this.defaultLanguage;
            } else {
                return this.languages.length > 0 ? this.languages[0] : "";
            }
        },
        /*
         * Create a new blank item
         */
        createItem: function (id, autoId, hasMarkdown) {
            return new ItextItem({
                id: id,
                autoId: autoId,
                itextModel: this,
                forms: [new ItextForm({
                    name: "default",
                    itextModel: this
                })],
                hasMarkdown: hasMarkdown
            });
        },
        updateForMug: function (mug) {
            // set default itext id/values
            if (!mug.options.isDataOnly) {
                if (!mug.p.labelItext && mug.getPresence("labelItext") !== "notallowed") {
                    var item = mug.p.labelItext = this.createItem();
                    item.set(mug.getLabelValue());
                    mug.validate();
                }
                if (!mug.p.hintItext && mug.getPresence("hintItext") !== "notallowed") {
                    mug.p.hintItext = this.createItem();
                }
                if (!mug.p.helpItext && mug.getPresence("helpItext") !== "notallowed") {
                    mug.p.helpItext = this.createItem();
                }
                if (mug.options.isRepeat && mug.options.customRepeatButtonText) {
                    if (!mug.p.addEmptyCaptionItext) {
                        mug.p.addEmptyCaptionItext = this.createItem();
                    }
                    if (!mug.p.addCaptionItext) {
                        mug.p.addCaptionItext = this.createItem();
                    }
                }
            }
            if (!mug.options.isControlOnly) {
                // set constraint msg if legal and not there
                if (mug.getPresence("constraintMsgItext") !== "notallowed" &&
                    !mug.p.constraintMsgItext) {
                    mug.p.constraintMsgItext = this.createItem();
                }
            }
        }
    };

    return {
        form: ItextForm,
        item: ItextItem,
        model: ItextModel,
    };
});


define('text/text!vellum/templates/button_remove.html',[],function () { return '<button type="button" class="btn btn-danger"><i class="fa fa-remove"></i></button>\n';});


define('tpl/tpl!vellum/templates/control_group', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="form-group">\n    <label class="control-label col-sm-3"><div>'+
((__t=(label))==null?'':__t)+
'</div></label>\n    <div class="controls col-sm-9"></div>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/auto_box', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-itextID-checkbox-container col-sm-1">\n    <label class="checkbox">\n        <!-- checkbox goes here -->\n        '+
((__t=(gettext("auto?")))==null?'':_.escape(__t))+
'\n    </label>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/markdown_help', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div>\n    <div class="fd-help pull-right">\n      <a tabindex="-1"\n        data-title="'+
((__t=(title))==null?'':_.escape(__t))+
'"\n        data-placement="right"\n        data-content="'+
((__t=(gettext("Use text formatting to <strong>bold</strong> and <em>italicize</em> words, use bulleted lists, and <a target='_blank' href='https://help.commcarehq.org/display/commcarepublic/Text+Formatting'>more</a>")))==null?'':__t)+
'"\n      ></a>\n    </div>\n    <a class="turn-markdown-off markdown-trigger clearfix">'+
((__t=(gettext("Turn Off Text Formatting")))==null?'':_.escape(__t))+
'</a>\n    <a class="turn-markdown-on markdown-trigger clearfix">'+
((__t=(gettext("Turn On Text Formatting")))==null?'':_.escape(__t))+
'</a>\n</div>\n';
}
return __p;
}; });

define('vellum/javaRosa/itextWidget',[
    'underscore',
    'jquery',
    'tpl!vellum/templates/auto_box',
    'tpl!vellum/templates/markdown_help',
    'vellum/javaRosa/util',
    'vellum/widgets',
    'vellum/richText',
    'vellum/util',
    'vellum/atwho',
    'vellum/core'
], function (
    _,
    $,
    auto_box,
    markdown_help,
    jrUtil,
    widgets,
    richText,
    util,
    atwho
) {
    var DEFAULT_EXTENSIONS = {
            image: 'png',
            audio: 'mp3',
            video: '3gp',
            'video-inline': '3gp',
        };

    var iTextIDWidget = function (mug, options) {
        var widget = widgets.text(mug, options),
            $input = widget.input,
            currentValue = null;

        function autoGenerateId() {
            return jrUtil.getDefaultItextId(mug, widget.path.replace(/Itext$/, ""));
        }

        function updateAutoId() {
            _setValue(autoGenerateId());
            setAutoMode(true);
        }

        function unlinkSharedItext() {
            if (currentValue.refCount > 1) {
                currentValue.refCount--;
                currentValue = currentValue.clone();
            }
        }

        var _setValue = widget.setValue;

        widget.setValue = function (value) {
            currentValue = value;
            if (value.autoId) {
                updateAutoId();
            } else {
                _setValue(value.id);
                setAutoMode(false);
            }
        };

        widget.getValue = function() {
            currentValue.id = $input.val();
            currentValue.autoId = getAutoMode();
            return currentValue;
        };

        // auto checkbox
        var $autoBox = $("<input />").attr("type", "checkbox");

        $autoBox.change(function () {
            if ($(this).prop('checked')) {
                unlinkSharedItext();
                updateAutoId();
                widget.handleChange();
            }
        });

        function setAutoMode(autoMode) {
            $autoBox.prop("checked", autoMode);
        }

        function getAutoMode() {
            return $autoBox.prop('checked');
        }

        var _getUIElement = widget.getUIElement;
        widget.getUIElement = function () {
            var $uiElem = _getUIElement().css('position', 'relative'),
                $autoBoxContainer = $(auto_box());

            $autoBoxContainer.find("label").prepend($autoBox);
            $uiElem.find('.controls')
                .removeClass("col-sm-9")
                .addClass("col-sm-8")
                .after($autoBoxContainer);

            return $uiElem;
        };

        widget.input.keyup(function () {
            // turn off auto-mode if the id is ever manually overridden
            var newVal = $(this).val();
            if (newVal !== autoGenerateId()) {
                setAutoMode(false);
            }
        });

        mug.on("property-changed", function (e) {
            if (getAutoMode() && e.property === "nodeID") {
                $input.val(autoGenerateId());
            }
        }, null, "teardown-mug-properties");

        return widget;
    };

    var baseItextLabelWidget = function (mug, language, form, options) {
        var vellum = mug.form.vellum,
            Itext = vellum.data.javaRosa.Itext,
            // todo: id->class
            id = "itext-" + language + "-" + options.itextType,
            widgetClass = options.baseWidgetClass || widgets.richTextarea,
            widget, $input;

        options.language = language;

        if (options.idSuffix) {
            id = id + options.idSuffix;
        }
        options.id = id;
        widget = widgetClass(mug, options);

        $input = widget.input;
        $input.addClass('jstree-drop');

        if (options.path === 'labelItext') {
            if (!mug.form.richText) {
                $input.keydown(function (e) {
                    // deletion of entire output ref in one go
                    if (e && e.which === 8 || e.which === 46) {
                        var control = widget.getControl()[0],
                            pos = util.getCaretPosition(control),
                            val = widget.getValue(),
                            outputBegin = '<output',
                            outputEnd = '/>',
                            start,
                            end,
                            match;
                        if (e.which === 8) { // backspace
                            if (pos > 1) {
                                match = val.substr(pos - 2, 2);
                                if (match === outputEnd) {
                                    start = val.lastIndexOf(outputBegin, pos);
                                    end = pos;
                                }
                            }
                        } else if (e.which === 46) { // delete
                            match = val.substr(pos, outputBegin.length);
                            if (match === outputBegin) {
                                end = val.indexOf(outputEnd, pos);
                                end = end === -1 ? end : end + 2;
                                start = pos;
                            }
                        }
                        if (start || end && start !== -1 && end !== -1) {
                            var noRef = val.slice(0, start) + val.slice(end, val.length);
                            widget.setValue(noRef);
                            util.setCaretPosition(control, start);
                            e.preventDefault();
                        }
                    }
                });
            }
        }

        if (_.contains(jrUtil.ITEXT_PROPERTIES, options.path)) {
            atwho.autocomplete($input, mug, {
                category: "Output Value",
                insertTpl: '<output value="${name}" />',
                property: "labelItext",
                outputValue: true,
                useRichText: mug.form.richText,
            });
        }

        widget.displayName = options.displayName;
        widget.itextType = options.itextType;
        widget.form = form || "default";

        widget.language = language;
        widget.languageName = util.langCodeToName[widget.language] || widget.language;
        widget.showOneLanguage = Itext.getLanguages().length < 2;
        widget.defaultLang = Itext.getDefaultLanguage();
        widget.isDefaultLang = widget.language === widget.defaultLang;
        widget.isSyncedWithDefaultLang = false;

        widget.getItextItem = function () {
            // Make sure the real itextItem is being updated at all times, not a stale one.
            return options.getItextByMug(widget.mug);
        };

        widget.getItextValue = function (lang) {
            var itextItem = widget.getItextItem(), value;
            if (!lang) {
                lang = widget.language;
            }
            value = itextItem && itextItem.get(widget.form, lang);
            if (mug.form.richText) {
                return jrUtil.outputToHashtag(value, widget.mug.form.xpath);
            } else {
                return jrUtil.outputToXPath(value, widget.mug.form.xpath);
            }
        };

        widget.setItextValue = function (value) {
            value = richText.sanitizeInput(value);
            var itextItem = widget.getItextItem();
            // TODO should not be using hashtags when rich text is off
            //if (mug.form.richText) {
            value = jrUtil.outputToHashtag(value, widget.mug.form.xpath);
            //}
            if (itextItem) {
                if (widget.isDefaultLang) {
                    widget.mug.fire({
                        type: 'defaultLanguage-itext-changed',
                        form: widget.form,
                        prevValue: itextItem.get(widget.form, widget.language),
                        value: value,
                        itextType: widget.itextType
                    });
                }
                itextItem.getForm(widget.form).setValue(widget.language, value);
            }
        };

        widget.getLangDesc = function () {
            if (widget.showOneLanguage) {
                return "";
            }
            return " (" + widget.languageName + ")";
        };

        widget.getDisplayName = function () {
            return widget.displayName + widget.getLangDesc();
        };

        widget.init = function (loadDefaults) {
            // Note, there are TWO defaults here.
            // There is the default value when this widget is initialized.
            // There is the value of the default language.
            if (loadDefaults) {
                var defaultValue = widget.getDefaultValue();
                widget.getItextItem().getOrCreateForm(widget.form);
                widget.setValue(defaultValue);
                widget.handleChange();
            } else {
                var value = widget.getItextValue();

                if (!_.isString(value)) {
                    if (!widget.isDefaultLang) {
                        value = widget.getItextValue(widget.defaultLang) || "";
                    } else {
                        value = "";
                    }
                }

                widget.setItextValue(value);
                widget.setValue(value);
            }
        };

        var _updateValue = widget.updateValue;
        widget.updateValue = function () {
            _updateValue();
            if (!widget.getValue() && !widget.isDefaultLang) {
                widget.setItextValue(widget.getItextValue(widget.defaultLang));
            }
        };

        widget.toggleDefaultLangSync = function (val) {
            widget.isSyncedWithDefaultLang = !val && !widget.isDefaultLang;
        };

        widget.getDefaultValue = function () {
            return null;
        };

        if (!widget.isDefaultLang) {
            widget.mug.on('defaultLanguage-itext-changed', function (e) {
                if (e.form === widget.form && e.itextType === widget.itextType) {
                    if (widget.getItextValue() === e.prevValue) {
                        // Make sure all the defaults keep in sync.
                        // why doesn't setValue set the itext value?
                        widget.setItextValue(e.value);
                        widget.setValue(e.value);
                    }
                }
            }, null, "teardown-mug-properties");
        }

        widget.refreshMessages = function () {
            widget.getMessagesContainer()
                .empty()
                .append(widget.getMessages(mug, widget.id));
        };

        widget.save = function () {
            widget.setItextValue(widget.getValue());
        };

        return widget;
    };

    var itextLabelWidget = function (mug, language, form, options) {
        var widget = baseItextLabelWidget(mug, language, form, options),
            super_handleChange = widget.handleChange;

        widget.handleChange = function () {
            var item = widget.getItextItem(),
                before = item && item.get(widget.form, widget.language);
            super_handleChange();
            var after = item && item.get(widget.form, widget.language);
            if (before !== after) {
                // TODO fire event for every mug that has an itext item
                // with the same ID as this itext item
                mug.form.fire({
                    type: 'question-label-text-change',
                    mug: mug,
                    text: after
                });
            }
        };

        return widget;
    };

    var itextMarkdownWidget = function (mug, language, form, options) {
        options = options || {};
        var parent = options.parent;
        var widget = itextLabelWidget(mug, language, form, options),
            super_setValue = widget.setValue,
            super_getUIElement = widget.getUIElement,
            super_handleChange = widget.handleChange,
            wantsMarkdown = true,
            supportMarkDownTables = options.vellum.opts().features.markdown_tables,
            markdownOff, markdownOn, markdownOutput;

        widget.toggleMarkdown = function() {
            parent.toggleClass("has-markdown");
            widget.mug.form.fire('change');
        };

        markdownOutput = $('<div>').addClass("controls well markdown-output col-sm-9");

        if (util.isRightToLeftLanguage(options.language)) {
            markdownOutput.attr('dir', 'rtl');
        }

        widget.handleChange = function() {
            super_handleChange();
            var val = widget.getValue(),
                item = widget.getItextItem();
            if (jrUtil.looksLikeMarkdown(val, supportMarkDownTables)) {
                if (wantsMarkdown) {
                    parent.removeClass("markdown-ignorant");
                    parent.addClass("has-markdown");
                }
            } else if (!val) {
                parent.removeClass("has-markdown");
            }
            item.hasMarkdown = markdownOff.is(":visible");
            markdownOutput.html(util.markdown(val)).closest('.form-group').removeClass('hide');
        };

        widget.setValue = function (val, callback) {
            super_setValue(val, callback);
            if (!val) {
                markdownOutput.closest('.form-group').addClass('hide');
            }
            markdownOutput.html(util.markdown(val));
        };

        widget.getUIElement = function() {
            var elem = super_getUIElement(),
                val = widget.getValue(),
                markdownSpacer = $("<div />").addClass("col-sm-3"),
                markdownContainer = $("<div />").addClass("col-sm-9"),
                markdownRow = $("<div />").addClass("form-group").addClass("markdown-group");

            elem.detach('.markdown-output');
            markdownRow.append(markdownSpacer);
            markdownContainer.append(markdownOutput);
            markdownRow.append(markdownContainer);
            elem.append(markdownRow);
            elem.find('.control-label').append(markdown_help({title:options.lstring }));

            markdownOff = elem.find('.turn-markdown-off').click(function() {
                wantsMarkdown = false;
                widget.getItextItem().hasMarkdown = false;
                widget.toggleMarkdown();
                return false;
            });
            markdownOn = elem.find('.turn-markdown-on').click(function() {
                wantsMarkdown = true;
                widget.getItextItem().hasMarkdown = true;
                widget.toggleMarkdown();
                return false;
            });

            if (widget.getItextItem().hasMarkdown) {
                parent.addClass("has-markdown");
            } else if (jrUtil.looksLikeMarkdown(val, supportMarkDownTables)) {
                markdownOutput.html(util.markdown(val));
                markdownOff.removeClass('hide');
            } else {
                parent.addClass("markdown-ignorant");
            }
            return elem;
        };

        return widget;
    };

    var itextFormWidget = function (mug, language, form, options) {
        options = options || {};
        options.idSuffix = "-" + form;
        var widget = baseItextLabelWidget(mug, language, form, options);

        widget.getDisplayName = function () {
            return form + widget.getLangDesc();
        };
        return widget;
    };

    var itextMediaWidget = function (url_type) {
        return function (mug, language, form, options) {
            options.baseWidgetClass = widgets.text;
            var widget = itextFormWidget(mug, language, form, options);

            widget.getDefaultValue = function () {
                if (jrUtil.SUPPORTED_MEDIA_TYPES.indexOf(form) !== -1) {
                    // default formats
                    // image: jr://file/commcare/image/form_id/question_id.png
                    // audio: jr://file/commcare/audio/form_id/question_id.mp3
                    var extension = DEFAULT_EXTENSIONS[form];
                    return widget.getBaseMediaPath() + "." + extension;
                }
                return null;
            };

            widget.getBaseMediaPath = function () {
                return "jr://file/commcare/" + form + url_type +
                       jrUtil.getDefaultItextRoot(widget.mug);
            };

            widget.mug.form.vellum.initMediaUploaderWidget(widget);

            return widget;
        };
    };

    return {
        form: itextFormWidget,
        id: iTextIDWidget,
        label: itextLabelWidget,
        markdown: itextMarkdownWidget,
        media: itextMediaWidget,
    };
});

define('vellum/javaRosa/itextBlock',[
    'underscore',
    'jquery',
    'text!vellum/templates/button_remove.html',
    'tpl!vellum/templates/control_group',
    'vellum/widgets',
    'vellum/util',
    'vellum/javaRosa/itextWidget',
    'vellum/core'
], function (
    _,
    $,
    button_remove,
    control_group,
    widgets,
    util,
    itextWidget
) {
    var RESERVED_ITEXT_CONTENT_TYPES = _.union(
            util.SUPPORTED_MEDIA_TYPES, ['default', 'short', 'long']
        ),
        NO_MARKDOWN_MUGS = ['Choice', 'Group', 'FieldList', 'Repeat'];

    var baseItextBlock = function (mug, options) {
        var Itext = mug.form.vellum.data.javaRosa.Itext,
            block = {};
        util.eventuality(block);

        block.mug = mug;
        block.itextType = options.itextType;
        block.languages = Itext.getLanguages();
        block.defaultLang = Itext.getDefaultLanguage();
        block.forms = options.forms || ["default"];

        block.getItextItem = function () {
            return options.getItextByMug(block.mug);
        };

        block.setValue = function (val) {
            // none
        };

        block.getValue = function (val) {
            // none
        };

        var $messages = $("<div />").addClass("controls").addClass("messages"),
            $blockUI = $("<div />")
            .addClass('itext-block-container')
            .addClass("itext-block-" + block.itextType);

        block.getFormGroupClass = function (form) {
            return 'itext-block-' + block.itextType + '-group-' + form;
        };

        block.getFormGroupContainer = function (form) {
            return $("<div />")
                .addClass(block.getFormGroupClass(form))
                .addClass('itext-lang-group');
        };

        block.getForms = function () {
            return block.forms;
        };

        block.refreshMessages = function () {
            if (options.messagesPath) {
                var messages = widgets.util.getMessages(mug, options.messagesPath);
                $messages.empty().append(messages);
            }
        };

        mug.on("messages-changed",
               function () { block.refreshMessages(); }, null, "teardown-mug-properties");

        block.getUIElement = function () {
            _.each(block.getForms(), function (form) {
                var $formGroup = block.getFormGroupContainer(form);
                var langs_to_show = block.languages;
                if(options.vellum.data.javaRosa.showOnlyCurrentLang) {
                    // show default and/or current display language and
                    // ensure they are in app languages
                    langs_to_show = _.intersection(
                        [options.vellum.data.javaRosa.Itext.defaultLanguage,
                         options.vellum.data.core.currentItextDisplayLanguage],
                        block.languages
                    );
                }
                _.each(langs_to_show, function(lang){
                    var itextWidget = block.itextWidget(block.mug, lang, form,
                                                        _.extend(options, {parent: $blockUI}));
                    itextWidget.init();
                    itextWidget.on("change", function () {
                        block.fire("change");
                    });
                    var $ui = itextWidget.getUIElement();
                    widgets.util.setWidget($ui, itextWidget);
                    $formGroup.append($ui);
                });
                $blockUI.append($formGroup);
            });
            $blockUI.append($messages);
            return $blockUI;
        };

        return block;
    };

    var itextLabelBlock = function (mug, options) {
        var block = baseItextBlock(mug, options);
        if ((!options.vellum.opts().features.markdown_in_groups &&
             _.contains(NO_MARKDOWN_MUGS, mug.__className)) || mug.form.noMarkdown) {
            block.itextWidget = itextWidget.label;
        } else {
            block.itextWidget = itextWidget.markdown;
        }
        return block;
    };

    var itextConfigurableBlock = function (mug, options) {
        var block = baseItextBlock(mug, options);

        block.isCustomAllowed = options.isCustomAllowed;
        block.activeForms = block.getItextItem().getFormNames();
        block.displayName = options.displayName;
        block.formToIcon = options.formToIcon || {};

        block.itextWidget = itextWidget.form;

        block.getForms = function () {
            var customForms = _.difference(block.activeForms, RESERVED_ITEXT_CONTENT_TYPES),
                relevantForms = _.intersection(block.activeForms, block.forms);
            return _.union(customForms, relevantForms);
        };

        var _getFormGroupContainer = block.getFormGroupContainer;
        block.getFormGroupContainer = function (form) {
            var $formGroup = _getFormGroupContainer(form);
            $formGroup.addClass("itext-lang-group-config")
                .addClass("well")
                .data('formtype', form);
            return $formGroup;
        };

        block.getAddFormButtonClass = function (form) {
            return 'itext-block-' + block.itextType + '-add-form-' + form;
        };

        block.getAddFormButtons = function () {
            var $buttonGroup = $("<div />").addClass("btn-group itext-options");
            _.each(block.forms, function (form) {
                var $btn = $('<div />');
                $btn.text(' ' + form)
                    .addClass(block.getAddFormButtonClass(form))
                    .addClass('btn btn-default itext-option').click(function () {
                        block.addItext(form);
                    });

                var iconClass = block.formToIcon[form];
                if (iconClass) {
                    $btn.prepend($('<i />').addClass(iconClass).after(" "));
                }

                if (block.activeForms.indexOf(form) !== -1) {
                    $btn.addClass('disabled');
                }
                $buttonGroup.append($btn);
            });

            if (block.isCustomAllowed) {
                $buttonGroup.append(block.getAddCustomItextButton());
            }
            return $buttonGroup;
        };

        block.getAddCustomItextButton = function () {
            var $customButton = $("<button />")
                    .text(gettext("custom..."))
                    .addClass('btn btn-default')
                    .attr('type', 'button'),
                newItextBtnClass = 'fd-new-itext-button';

            $customButton.click(function () {
                var $modal, $newItemForm, $newItemInput;
                $modal = mug.form.vellum.generateNewModal(gettext("New Content Type"), [
                    {
                        title: gettext("Add"),
                        cssClasses: newItextBtnClass + " disabled ",
                        attributes: {
                            disabled: "disabled"
                        }
                    }
                ]);

                $newItemForm = $(control_group({
                    label: gettext("Content Type")
                }));

                $newItemInput = $("<input />").attr("type", "text").addClass("form-control");
                $newItemInput.keyup(function () {
                    var currentValue = $(this).val(),
                        $addButton = mug.form.vellum.$f.find('.' + newItextBtnClass);
                    if (!currentValue || 
                        RESERVED_ITEXT_CONTENT_TYPES.indexOf(currentValue) !== -1 || 
                        block.activeForms.indexOf(currentValue) !== -1) 
                    {
                        $addButton
                            .addClass('disabled')
                            .removeClass('btn-primary')
                            .prop('disabled', true);
                    } else {
                        $addButton
                            .removeClass('disabled')
                            .addClass('btn-primary')
                            .prop('disabled', false);
                    }
                });

                $newItemForm.find('.controls').append($newItemInput);
                $modal
                    .find('.modal-body')
                    .append($newItemForm);
                mug.form.vellum.$f.find('.' + newItextBtnClass).click(function () {
                    var newItemType = $newItemInput.val();
                    if (newItemType) {
                        block.addItext($newItemInput.val());
                        $modal.modal('hide');
                    }
                });
                $modal.modal('show');
                $modal.one('shown.bs.modal', function () {
                    $newItemInput.focus();
                });
            });

            return $customButton;
        };

        block.deleteItextForm = function (form) {
            var itextItem = block.getItextItem();
            if (itextItem) {
                itextItem.removeForm(form);
            }
            block.activeForms = _.without(block.activeForms, form);
            block.fire("change");
        };

        block.getDeleteFormButton = function (form) {
            var $deleteButton = $(button_remove);
            $deleteButton.addClass('pull-right')
                .addClass("delete-" + block.getFormGroupClass(form))
                .click(function () {
                    var $formGroup = $('.' + block.getFormGroupClass(form));
                    block.deleteItextForm(form);
                    $formGroup.remove();
                    $(this).remove();
                    $('.' + block.getAddFormButtonClass(form))
                        .removeClass('disabled');
                });
            return $deleteButton;
        };

        block.addItext = function (form) {
            if (block.activeForms.indexOf(form) !== -1) {
                return;
            }
            block.activeForms.push(form);
            block.fire("change");

            $('.' + block.getAddFormButtonClass(form)).addClass('disabled');
            var $groupContainer = block.getFormGroupContainer(form);
            _.each(block.languages, function (lang) {
                var itextWidget = block.itextWidget(block.mug, lang, form, options);
                itextWidget.init(true);
                itextWidget.on("change", function () {
                    block.fire("change");
                });
                var $ui = itextWidget.getUIElement();
                widgets.util.setWidget($ui, itextWidget);
                $groupContainer.append($ui);
            });
            $blockUI.find('.new-itext-form-group').after($groupContainer);
            $groupContainer.find(".col-sm-9").removeClass("col-sm-9").addClass("col-sm-8");
            $groupContainer.before(block.getDeleteFormButton(form));
        };

        var $blockUI = $('<div />'),
            _getParentUIElement = block.getUIElement;
        block.getUIElement = function () {
            $blockUI = _getParentUIElement();

            var $addFormControls = $(control_group({
                label: block.displayName,
            }));
            $addFormControls.addClass('new-itext-form-group')
                .find('.controls')
                .append(block.getAddFormButtons());
            $blockUI.prepend($addFormControls);

            var $formGroup = $blockUI.find('.itext-lang-group');
            $formGroup.each(function () {
                $(this).find(".col-sm-9").removeClass("col-sm-9").addClass("col-sm-8");
                $(this).before(block.getDeleteFormButton($(this).data('formtype')));
            });

            return $blockUI;
        };

        return block;
    };

    var itextMediaBlock = function (mug, options) {
        var block = itextConfigurableBlock(mug, options),
            pathPrefix = options.pathPrefix;

        if(!_.isString(options.pathPrefix)) {
            pathPrefix = '/' + options.itextType;
        }

        block.getForms = function () {
            return _.intersection(block.activeForms, block.forms);
        };

        block.itextWidget = itextWidget.media(pathPrefix + mug.form.getBasePath());

        return block;
    };

    return {
        configurable: itextConfigurableBlock,
        label: itextLabelBlock,
        media: itextMediaBlock,
    };
});

/*
 * A Vellum plugin to support JavaRosa extensions to the XForm spec,
 * particularly IText.
 *
 * Itext handles text that may be displayed in multiple languages. An IText block contains a translation for
 * each required language. Each translation contains a set of text elements, each with an id and containing
 * one or more values. Each value represents a different form of the text appropriate for that language.
 * (e.g., plain text versus multimedia equivalent).
 * 
 * An IText item may contain multiple forms and also contains an IText model, which tracks the languages
 * available and knows which of those languages is the default. On the UI side, an IText block contains
 * one or more IText widgets, each of which goes with a single language.
 *
 * See https://bitbucket.org/javarosa/javarosa/wiki/ITextAPI
 *
 * Mugs have the following Itext properties:
 *  labelItext: for the question label itself
 *  hintItext: for question hint (visible along with question)
 *  helpItext: for question help (one click away)
 *  constraintMsgItext: for the message to display if the question fails validation
 */
define('vellum/javaRosa/plugin',[
    'underscore',
    'jquery',
    'tpl!vellum/templates/edit_source',
    'tpl!vellum/templates/language_selector',
    'vellum/dateformats',
    'vellum/util',
    'vellum/xml',
    'vellum/hqAnalytics',
    'vellum/javaRosa/itext',
    'vellum/javaRosa/itextBlock',
    'vellum/javaRosa/itextWidget',
    'vellum/richText',
    'vellum/javaRosa/util',
    'vellum/core'
], function (
    _,
    $,
    edit_source,
    language_selector,
    dateformats,
    util,
    xml,
    analytics,
    itext,
    itextBlock,
    itextWidget,
    richText,
    jrUtil
) {
    var ICONS = {
        image: 'fa-regular fa-image',
        audio: 'fa fa-volume-up',
        video: 'fa fa-video-camera',
        'video-inline': 'fa fa-play',
    };

    $.vellum.plugin("javaRosa", {
        langs: ['en'],
        displayLanguage: 'en'
    }, {
        init: function () {
            this.data.javaRosa.ItextItem = itext.item;
            this.data.javaRosa.ItextForm = itext.form;
            this.data.javaRosa.ICONS = ICONS;
            this.data.javaRosa.showOnlyCurrentLang = this.opts().javaRosa.showOnlyCurrentLang;
        },
        handleDropFinish: function (target, path, mug, event) {
            var inItext = target &&
                target.attr('name') &&
                target.attr('name').lastIndexOf('itext-', 0) === 0,
                _this = this;

            if (inItext) {
                var mugType = mug && mug.options.typeName;
                if (mugType === 'Date') {
                    dateformats.showMenu(event.clientX, event.clientY, function (format) {
                        jrUtil.insertOutputRef(_this, target, path, mug, format);
                    });
                } else {
                    jrUtil.insertOutputRef(_this, target, path, mug);
                }
                var category = util.getReferenceName(path);
                analytics.usage(category, "Drag and Drop", "Label");
            } else {
                _this.__callOld();
            }
        },
        handleNewMug: function (mug) {
            var ret = this.__callOld();
            this.data.javaRosa.Itext.updateForMug(mug);
            return ret;
        },
        _makeLanguageSelectorDropdown: function () {
            var _this = this,
                langs = this.data.javaRosa.Itext.getLanguages(),
                $menu = this.$f.find('.fd-questions-menu'),
                $items,
                $input,
                fullLangs;

            fullLangs = _.map(langs, function (lang) {
                return {
                    code: lang,
                    name: util.langCodeToName[lang] || lang
                };
            });
            fullLangs[fullLangs.length] = {
                code: '_ids',
                name: gettext('Question ID')
            };

            if (fullLangs.length < 2) {
                return;
            }
            $menu.find('.language-selector').remove();
            $menu.find('.fd-bulk-update-menu').before(language_selector({languages: fullLangs}));
            $items = $menu.find(".fd-display-item");
            $items.click(function (e) {
                $input.val($(this).data("code")).change();
                e.preventDefault();
            });

            $input = $menu.parent().find('.fd-question-tree-display');
            $input.change(function () {
                var code = $input.val();
                _this._changeTreeDisplayLanguage(code);
                $items.removeClass("selected")
                      .filter("[data-code=" + code + "]").addClass("selected");
            });
            $input.val(this.data.core.currentItextDisplayLanguage).change();
        },
        _changeTreeDisplayLanguage: function (lang) {
            var _this = this,
                form = this.data.core.form;
           
            // todo: getMugDisplayName should not rely on this state, it should be
            // passed
            this.data.core.currentItextDisplayLanguage = lang;

            // this shares most of the same functionality as refreshVisibleData().
            // todo: refactor into one method
            this.data.core.$tree.find('li').each(function (i, el) {
                var $el = $(el),
                    mug = form.getMugByUFID($el.prop('id'));

                if (_this.data.core.currentItextDisplayLanguage === "_ids") {
                    _this.jstree('rename_node', $el, mug.getNodeID());
                }
                else {
                    if (mug.p.labelItext) {
                        var text = _this.getMugDisplayName(mug);
                        _this.jstree('rename_node', $el, text ||
                                _this.opts().core.noTextString);
                    }
                }
            });

            if (form) {
                form.fire({
                    type: 'change-display-language',
                });
            }
        },
        // parse Itext Block and populate itext model
        loadXML: function (xmlString) {
            var _this = this,
                langs = this.opts().javaRosa.langs,
                Itext, itextMap;

            this.data.javaRosa.Itext = Itext = new itext.model();
            this.data.javaRosa.itextMap = itextMap = {};

            function eachLang() {
                var el = $(this);
                var lang = el.xmlAttr('lang');
                
                function eachText() {
                    var textEl = $(this);
                    var id = textEl.xmlAttr('id');
                    var item = itextMap[id];
                    if (!item || !itextMap.hasOwnProperty(id)) {
                        item = Itext.createItem(id);
                        item.refCount = 0;
                        itextMap[id] = item;
                    }

                    function eachValue() {
                        var valEl = $(this);
                        var curForm = valEl.xmlAttr('form');
                        if(!curForm) {
                            curForm = "default";
                            if (item.hasMarkdown) {
                                return; // value already set below
                            }
                        } else if (curForm === "markdown") {
                            // the default and markdown forms will always be
                            // the same
                            item.hasMarkdown = true;
                            item.getOrCreateForm("default")
                                .setValue(lang, valEl);
                            return;
                        }
                        item.getOrCreateForm(curForm)
                            .setValue(lang, valEl);
                    }
                    textEl.children().each(eachValue);
                }

                if (langs && langs.indexOf(lang) === -1) {
                    _this.data.core.parseWarnings.push(gettext(
                        "You have languages in your form that are not specified " +
                        "in the \"Languages\" page of the application builder. " +
                        "The following language will be deleted on save " +
                        "unless you add it to the \"Languages\" page:") + " " + lang);
                    return;
                }
                Itext.addLanguage(lang);

                //loop through children
                el.children().each(eachText);
            }

            
            if (langs && langs.length > 0) {
                // override the languages with whatever is passed in
                for (var i = 0; i < langs.length; i++) {
                    Itext.addLanguage(langs[i]);
                }
                // the first language is the default
                Itext.setDefaultLanguage(langs[0]);
            }

            if (xmlString) {
                var head = xml.parseXML(xmlString).find('h\\:head, head'),
                    itextBlock = head.find('itext');
            
                $(itextBlock).children().each(eachLang);
            }

            this.data.core.currentItextDisplayLanguage = 
                this.opts().javaRosa.displayLanguage ||
                Itext.getDefaultLanguage();
            
            this._makeLanguageSelectorDropdown();

            this.__callOld();

            delete this.data.javaRosa.itextMap;
            Itext.on('change', function () { _this.onFormChange(); });
        },
        onXFormLoaded: function (form) {
            function _toHashtag(value) {
                try {
                    return form.xpath.parse(value).toHashtag();
                } catch (err) {
                    return value;
                }
            }
            var langs = this.opts().javaRosa.langs;
            // detect hashtag references in output values
            jrUtil.forEachItextItem(form, function (item, mug) {
                _(item.forms).each(function (itForm) {
                    _.each(langs, function (lang) {
                        var text = itForm.getValue(lang);
                        if (!text) { return; }
                        text = richText.sanitizeInput(text);
                        var xquery = xml.query(text);
                        xquery.find('output').replaceWith(function() {
                            var output = $(this),
                                key = output.is("[value]") ||
                                    !output.is("[ref]") ? "value" : "ref",
                                vkey = "vellum:" + key,
                                value = output.xmlAttr(key),
                                hashval = output.xmlAttr(vkey);
                            if (hashval) {
                                if (value) {
                                    form.inferHashtagMeanings(hashval, value);
                                }
                                value = hashval;
                            } else {
                                // hashtagify xpath expression if possible
                                // NOTE the success of this could depend
                                // on whether data sources are loaded,
                                // which means outputs may load differently
                                // based on network conditions.
                                value = _toHashtag(value);
                            }
                            // always use value attribute internally
                            return $("<output />").xmlAttr("value", value);
                        });
                        itForm.setValue(lang, xquery.toString());
                    });
                });
            });

            this.__callOld();
        },
        populateControlMug: function(mug, controlElement) {
            this.__callOld();

            var Itext = this.data.javaRosa.Itext,
                itextMap = this.data.javaRosa.itextMap;

            function getITextID(value) {
                try {
                    var parsed = mug.form.xpath.parse(value);
                    if (parsed instanceof mug.form.xpath.models.XPathFuncExpr &&
                        parsed.id === "jr:itext")
                    {
                        return parsed.args[0].value;
                    }
                } catch (err) {
                    // this seems like a real error since the reference should presumably
                    // have been valid xpath, but don't deal with it here
                }
                return "";
            }

            function getItextItem(id, property) {
                var auto = !id || id === jrUtil.getDefaultItextId(mug, property);
                if (id) {
                    var item = itextMap[id];
                    if (item && itextMap.hasOwnProperty(id)) {
                        if (!auto) {
                            item.autoId = false;
                        }
                        item.refCount++;
                        return item;
                    }
                }
                return Itext.createItem(id, auto);
            }

            function parseItextRef($el, property) {
                var ref = $el.xmlAttr('ref');
                return getItextItem(ref ? getITextID(ref) : "", property);
            }

            var labelEl = controlElement.children('label'),
                hintEl = controlElement.children('hint'),
                helpEl = controlElement.children('help'),
                alertEl = controlElement.children('alert');
            if (labelEl.length && mug.getPresence("label") !== 'notallowed') {
                var labelItext = parseItextRef(labelEl, "label"),
                    labelVal = xml.humanize(labelEl) || mug.getLabelValue();
                labelItext.getOrCreateForm("default").initUndefined(labelVal);
                mug.p.labelItext = labelItext;
            }
            if (hintEl.length && mug.getPresence("hintLabel") !== 'notallowed') {
                mug.p.hintItext = parseItextRef(hintEl, "hint");
            }
            if (helpEl.length && mug.getPresence("label") !== 'notallowed') {
                mug.p.helpItext = parseItextRef(helpEl, "help");
            }
            if (alertEl.length && mug.getPresence("constraintMsgAttr") !== 'notallowed') {
                mug.p.constraintMsgItext = parseItextRef(alertEl, "constraintMsg");
            } else if (mug.p.constraintMsgAttr) {
                var id = getITextID(mug.p.constraintMsgAttr);
                if (id) {
                    mug.p.constraintMsgItext = getItextItem(id, "constraintMsg");
                    mug.p.constraintMsgAttr = null;
                }
            }

            function parseRepeatItexts(mug, controlElement) {
                var repeatEl = controlElement.children('repeat');
                var addEmptyCaptionEl = repeatEl.children('jr\\:addEmptyCaption'),
                    addCaptionEl = repeatEl.children('jr\\:addCaption');
                if (addEmptyCaptionEl.length) {
                    mug.p.addEmptyCaptionItext = parseItextRef(addEmptyCaptionEl, "addEmptyCaption");
                }
                if (addCaptionEl.length) {
                    mug.p.addCaptionItext = parseItextRef(addCaptionEl, "addCaption");
                }
            }
            if (mug.options.isRepeat && mug.options.customRepeatButtonText) {
                parseRepeatItexts(mug, controlElement);
            }
        },
        handleMugParseFinish: function (mug) {
            this.__callOld();
            this.data.javaRosa.Itext.updateForMug(mug);
        },
        duplicateMugProperties: function (mug) {
            this.__callOld();
            _.each(jrUtil.ITEXT_PROPERTIES, function (path) {
                var itext = mug.p[path];
                if (itext && itext.autoId) {
                    mug.p[path] = itext.clone();
                }
            });
        },
        contributeToModelXML: function (xmlWriter, form_) {
            // here are the rules that govern itext
            // 0. iText items which aren't referenced by any questions are 
            // cleared from the form.
            // 1. iText nodes for which values in _all_ languages are empty/blank 
            // will be removed entirely from the form.
            // 2. iText nodes that have a single value in _one_ language 
            // but not others, will automatically have that value copied 
            // into the remaining languages. TBD: there should be a UI to 
            // disable this feature
            // 3. iText nodes that have multiple values in multiple languages 
            // will be properly set as such.
            // 4. duplicate itext ids will be automatically updated to create
            // non-duplicates

            function hashtags(outputRef) {
                var output = $(outputRef),
                    key = output.is("[value]") || !output.is("[ref]") ? "value" : "ref",
                    vkey = "vellum:" + key,
                    value = output.xmlAttr(vkey) || output.xmlAttr(key),
                    parsed, hashtag, xpath;
                try {
                    parsed = xpathParser.parse(value);
                    hashtag = parsed.toHashtag();
                    xpath = parsed.toXPath();
                } catch (e) {
                    // if outputs are invalid, then the user did something
                    // manually, so just write the original value to the xml
                    hashtag = value;
                    xpath = value;
                }
                if (!form_.richText || xpath === hashtag) {
                    output.xmlAttr(key, xpath).removeAttr(vkey);
                } else {
                    output.xmlAttr(key, xpath).xmlAttr(vkey, hashtag);
                }
            }

            function writeValue(xmlWriter, val) {
                val = xml.query(val);
                val.find('output').each(function() { hashtags(this); });
                xmlWriter.writeXML(val.toString());
            }

            var xpathParser = form_.xpath,
                Itext = this.data.javaRosa.Itext,
                items = this.data.javaRosa.itextItemsFromBeforeSerialize,
                languages = Itext.getLanguages(),
                item, forms, form, lang, val;
            if (languages.length > 0) {
                xmlWriter.writeStartElement("itext");
                for (var i = 0; i < languages.length; i++) {
                    lang = languages[i];
                    xmlWriter.writeStartElement("translation");
                    xmlWriter.writeAttributeString("lang", lang);
                    if (Itext.getDefaultLanguage() === lang) {
                        xmlWriter.writeAttributeString("default", '');
                    }
                    for (var j = 0; j < items.length; j++) {
                        item = items[j];
                        xmlWriter.writeStartElement("text");
                        xmlWriter.writeAttributeString("id", item.id);
                        forms = item.getForms();
                        for (var k = 0; k < forms.length; k++) {
                            form = forms[k];
                            val = form.getValueOrDefault(lang);
                            xmlWriter.writeStartElement("value");
                            if(form.name !== "default") {
                                xmlWriter.writeAttributeString('form', form.name);
                            }
                            writeValue(xmlWriter, val);
                            xmlWriter.writeEndElement();
                        }
                        if (item.hasMarkdown && !this.data.core.form.noMarkdown) {
                            val = item.getForm('default').getValueOrDefault(lang);
                            xmlWriter.writeStartElement("value");
                            xmlWriter.writeAttributeString('form', 'markdown');
                            writeValue(xmlWriter, val);
                            xmlWriter.writeEndElement();
                        }
                        xmlWriter.writeEndElement();
                    }
                    xmlWriter.writeEndElement();
                }
                xmlWriter.writeEndElement();
            }
        },
        beforeSerialize: function () {
            this.__callOld();
            // update and dedup all non-empty Itext items IDs
            this.data.javaRosa.itextItemsFromBeforeSerialize =
                jrUtil.getItextItemsFromMugs(this.data.core.form);
        },
        afterSerialize: function () {
            this.__callOld();
            delete this.data.javaRosa.itextItemsFromBeforeSerialize;
        },
        beforeBulkInsert: function (form) {
            this.__callOld();
            this.data.javaRosa.itextById = jrUtil.getItextItemsFromMugs(form, true);
        },
        afterBulkInsert: function () {
            this.__callOld();
            delete this.data.javaRosa.itextById;
        },
        getMugTypes: function () {
            var types = this.__callOld(),
                normal = types.normal;

            normal.Group.spec = util.extend(normal.Group.spec, {
                constraintMsgItext: {
                    presence: 'notallowed'
                }
            });

            return types;
        },
        getMugSpec: function () {
            var spec = this.__callOld(),
                that = this,
                databind = spec.databind,
                control = spec.control;

            function itextValidator(property, name) {
                return function (mug) {
                    var itext = mug.p[property],
                        hasItext = itext && itext.hasHumanReadableItext();
                    if (!hasItext && mug.getPresence(property) === 'required') {
                        if (itext.itextModel.languages.length === 1) {
                            return util.format(
                                gettext("{name} (or multimedia) is required."),
                                {name: name}
                            );
                        } else {
                            return util.format(
                                gettext("{name} (or multimedia) is required for all languages."),
                                {name: name}
                            );
                        }
                    }
                    if (itext && !itext.autoId && !itext.isEmpty()) {
                        // Itext ID validation
                        if (!itext.id) {
                            return util.format(
                                gettext("{name} Itext ID is required."),
                                {name: name}
                            );
                        } else if (!util.isValidAttributeValue(itext.id)) {
                            return util.format(
                                gettext("{name} is not a valid ID."),
                                {name: itext.id}
                            );
                        }
                    }
                    return "pass";
                };
            }

            function addSerializer(options) {
                options.serialize = function (value, name, mug, data) {
                    var hasText = false;
                    _.each(value.forms, function (form) {
                        if (!form.isEmpty()) {
                            hasText = true;
                            _.each(value.itextModel.languages, function (lang) {
                                var key = name + ":" + lang + "-" + form.name;
                                data[key] = form.getValue(lang);
                            });
                        }
                    });
                    if (hasText && !value.autoId) {
                        data[name] = value.id;
                    }
                    if (value.hasMarkdown) {
                        data[name + ':hasMarkdown'] = value.hasMarkdown;
                    }
                };
                options.deserialize = function (data, name, mug, context) {
                    var item = mug.p[name],
                        found = false;
                    if (data[name]) {
                        // non-autoId
                        var itext = mug.form.vellum.data.javaRosa.itextById,
                            id = data[name];
                        if (itext.hasOwnProperty(id) && !itext[id].autoId) {
                            mug.p[name] = item = itext[id];
                            item.refCount++;
                        } else {
                            item.id = data[name];
                            item.autoId = false;
                            // possibly (intentionally) overwrites autoId item
                            itext[item.id] = item;
                        }
                    }
                    var dlang = item.itextModel.getDefaultLanguage(),
                        languages = item.itextModel.languages,
                        nodeID = "",
                        mmForms = _.object(jrUtil.SUPPORTED_MEDIA_TYPES, jrUtil.SUPPORTED_MEDIA_TYPES),
                        // HACK reach into media uploader options
                        objectMap = that.data.uploader.objectMap || {};
                    if (data.id) {
                        // a little hacky, but it's a fallback default
                        nodeID = data.id.slice(data.id.lastIndexOf("/") + 1);
                    }
                    function str(val) {
                        return val === null || val === undefined ? "" : String(val);
                    }
                    var isEmptyForm = _.memoize(function (form) {
                        return !_.find(languages, function (lang) {
                            return data[name + ":" + lang + "-" + form];
                        });
                    });
                    _.each(languages, function (lang) {
                        var prelen = name.length + lang.length + 2,
                            regexp = new RegExp("^" +
                                                RegExp.escape(name) + ":" +
                                                RegExp.escape(lang) + "-"),
                            seen = {};
                        _.each(data, function (value, key) {
                            if (regexp.test(key)) {
                                var form = key.slice(prelen),
                                    isMM = mmForms.hasOwnProperty(form);
                                if (isMM && !value && isEmptyForm(form)) {
                                    // Skip empty multimedia form.
                                    return;
                                }
                                if (!seen.hasOwnProperty(form)) {
                                    seen[form] = true;
                                    // set default value(s) for this form
                                    var dkey = name + ":" + dlang + "-" + form,
                                        dval = data.hasOwnProperty(dkey) ?
                                             str(data[dkey]) : str(value);
                                    item.set(dval, form);
                                    if (!isMM && dval) {
                                        context.later(function () {
                                            item.set(hashtrans(dval, context), form);
                                        });
                                    }
                                }
                                item.set(str(value), form, lang);
                                if (!isMM && value) {
                                    context.later(function () {
                                        item.set(hashtrans(value, context), form, lang);
                                    });
                                }
                                if (isMM && !objectMap.hasOwnProperty(value)) {
                                    mug.addMessage(name, {
                                        key: "missing-multimedia-warning",
                                        level: mug.WARNING,
                                        message: gettext("Multimedia was not copied; " +
                                                 "it must be uploaded separately."),
                                    });
                                }
                                found = true;
                            }
                        });
                    });
                    if (found && !data[name]) {
                        item.id = jrUtil.getDefaultItextId(mug, name.replace(/Itext$/, ""));
                    }
                    if (data[name + ":hasMarkdown"]) {
                        item.hasMarkdown = true;
                    }
                    var WARNING_KEY = "javaRosa-discarded-languages-warning",
                        langRE = new RegExp("^" + RegExp.escape(name) + ":(\\w+)-"),
                        discardedLangs = _.filter(_.map(_.keys(data), function (key) {
                            var match = key.match(langRE);
                            if (match && languages.indexOf(match[1]) === -1) {
                                return match[1];
                            }
                        }), _.identity);
                    if (discardedLangs.length) {
                        var msg = context.errors.get(null, WARNING_KEY);
                        if (msg) {
                            msg.langs = _.union(msg.langs, discardedLangs);
                            msg.message = gettext("Discarded languages:") +
                                " " + msg.langs.join(", ");
                        } else {
                            context.errors.update(null, {
                                key: WARNING_KEY,
                                level: mug.WARNING,
                                langs: discardedLangs,
                                message: gettext("Discarded languages:") +
                                    " " + discardedLangs.join(", ")
                            });
                        }
                    }
                    mug.validate(name);
                };

                function hashtrans(val, context) {
                    var qry = xml.query(val);
                    qry.find('output').each(function() {
                        transformOutputRef(this, context);
                    });
                    return qry.toString();
                }

                function transformOutputRef(outputRef, context) {
                    var output = $(outputRef),
                        key = output.is("[value]") || !output.is("[ref]") ? "value" : "ref",
                        value = output.xmlAttr(key);
                    if (value) {
                        output.xmlAttr(key, context.transformHashtags(value));
                    }
                }

                return options;
            }

            function trackLogicRefs(widget) {
                widget.trackLogicReferences = true;
                return widget;
            }

            function validateConstraintMsgAttr(mug) {
                var itext = mug.p.constraintMsgItext;
                if (!mug.p.constraintAttr && itext && !itext.isEmpty()) {
                    return gettext('You cannot have a Validation Error ' +
                           'Message with no Validation Condition!');
                }
                return 'pass';
            }
            // hide non-itext constraint message; overwritten by javaRosa
            databind.constraintMsgAttr.visibility = "hidden";
            databind.constraintMsgItext = addSerializer({
                visibility: 'visible',
                presence: function (mug) {
                    return mug.options.isSpecialGroup ? 'notallowed' : 'optional';
                },
                lstring: gettext('Validation Message'),
                widget: trackLogicRefs(function (mug, options) {
                    return itextBlock.label(mug, $.extend(options, {
                        itextType: "constraintMsg",
                        messagesPath: "constraintMsgItext",
                        getItextByMug: function (mug) {
                            return mug.p.constraintMsgItext;
                        },
                        displayName: gettext("Validation Message")
                    }));
                }),
                validationFunc: function (mug) {
                    var itext = mug.p.constraintMsgItext;
                    if (!mug.p.constraintAttr && itext && itext.id && !itext.autoId) {
                        return gettext("Can't have a Validation Message Itext ID without a Validation Condition");
                    }
                    var result = itextValidator("constraintMsgItext", "Validation Message")(mug);
                    if (result === "pass") {
                        result = validateConstraintMsgAttr(mug);
                    }
                    return result;
                }
            });
            databind.constraintAttr.validationFunc = validateConstraintMsgAttr;
            // virtual property used to define a widget
            databind.constraintMsgItextID = {
                visibility: 'constraintMsgItext',
                presence: 'optional',
                lstring: gettext("Validation Message Itext ID"),
                widget: itextWidget.id,
                widgetValuePath: "constraintMsgItext"
            };
            databind.constraintMediaIText = function (mugOptions) {
                return mugOptions.isSpecialGroup ? undefined : {
                    visibility: function(mug) {
                        return mug.isVisible("constraintAttr");
                    },
                    presence: 'optional',
                    lstring: gettext('Add Validation Media'),
                    widget: function (mug, options) {
                        return itextBlock.media(mug, $.extend(options, {
                            displayName: gettext("Add Validation Media"),
                            itextType: "constraintMsg",
                            getItextByMug: function (mug) {
                                return mug.p.constraintMsgItext;
                            },
                            forms: jrUtil.SUPPORTED_MEDIA_TYPES,
                            formToIcon: ICONS
                        }));
                    }
                };
            };

            // CONTROL ELEMENT
            
            // hide non-itext messages unless present
            control.label.visibility = "visible_if_present";
            control.hintLabel.visibility = "visible_if_present";

            control.labelItext = addSerializer({
                visibility: 'visible',
                presence: 'optional',
                lstring: gettext("Display Text"),
                widget: trackLogicRefs(function (mug, options) {
                    return itextBlock.label(mug, $.extend(options, {
                        itextType: "label",
                        messagesPath: "labelItext",
                        getItextByMug: function (mug) {
                            return mug.p.labelItext;
                        },
                        displayName: gettext("Display Text")
                    }));
                }),
                validationFunc: itextValidator("labelItext", gettext("Display Text"))
            });
            // virtual property used to define a widget
            control.labelItextID = {
                visibility: 'labelItext',
                presence: 'optional',
                lstring: gettext("Display Text Itext ID"),
                widget: itextWidget.id,
                widgetValuePath: "labelItext"
            };

            control.hintItext = addSerializer({
                visibility: 'visible',
                presence: function (mug) {
                    return mug.options.isSpecialGroup ? 'notallowed' : 'optional';
                },
                lstring: gettext("Hint Message"),
                widget: trackLogicRefs(function (mug, options) {
                    return itextBlock.label(mug, $.extend(options, {
                        itextType: "hint",
                        messagesPath: "hintItext",
                        getItextByMug: function (mug) {
                            return mug.p.hintItext;
                        },
                        displayName: gettext("Hint Message")
                    }));
                }),
                validationFunc: itextValidator("hintItext", gettext("Hint Message"))
            });
            // virtual property used to get a widget
            control.hintItextID = {
                visibility: 'hintItext',
                lstring: gettext("Hint Itext ID"),
                widget: itextWidget.id,
                widgetValuePath: "hintItext"
            };

            control.helpItext = addSerializer({
                visibility: 'visible',
                presence: function (mug) {
                    return mug.options.isSpecialGroup ? 'notallowed' : 'optional';
                },
                lstring: gettext("Help Message"),
                widget: trackLogicRefs(function (mug, options) {
                    var block = itextBlock.label(mug, $.extend(options, {
                        itextType: "help",
                        messagesPath: "helpItext",
                        getItextByMug: function (mug) {
                            return mug.p.helpItext;
                        },
                        displayName: gettext("Help Message"),
                    }));

                    return block;
                }),
                validationFunc: itextValidator("helpItext", gettext("Help Message"))
            });
            // virtual property used to get a widget
            control.helpItextID = {
                visibility: 'helpItext',
                lstring: gettext("Help Itext ID"),
                widget: itextWidget.id,
                widgetValuePath: "helpItext"
            };

            control.addEmptyCaptionItext = addSerializer({
                visibility: 'visible',
                presence: function (mug) {
                    return mug.options.isRepeat && mug.options.customRepeatButtonText ? 'optional' : 'notallowed';
                },
                lstring: gettext("Add New Item Button Text"),
                widget: trackLogicRefs(function (mug, options) {
                    var block = itextBlock.label(mug, $.extend(options, {
                        itextType: "addEmptyCaption",
                        messagesPath: "addEmptyCaptionItext",
                        getItextByMug: function (mug) {
                            return mug.p.addEmptyCaptionItext;
                        },
                        displayName: gettext("Add New Item Button Text"),
                    }));
                    return block;
                }),
                validationFunc: itextValidator("addEmptyCaptionItext", gettext("Add New Item Button Text")),
            });
            // virtual property used to get a widget
            control.addEmptyCaptionItextID = {
                visibility: 'addEmptyCaptionItext',
                lstring: gettext("Add New Itext ID"),
                widget: itextWidget.id,
                widgetValuePath: "addEmptyCaptionItext",
            };

            control.addCaptionItext = addSerializer({
                visibility: 'visible',
                presence: function (mug) {
                    return mug.options.isRepeat && mug.options.customRepeatButtonText ? 'optional' : 'notallowed';
                },
                lstring: gettext("Add Another Item Button Text"),
                widget: trackLogicRefs(function (mug, options) {
                    var block = itextBlock.label(mug, $.extend(options, {
                        itextType: "addCaption",
                        messagesPath: "addCaptionItext",
                        getItextByMug: function (mug) {
                            return mug.p.addCaptionItext;
                        },
                        displayName: gettext("Add Another Item Button Text"),
                    }));
                    return block;
                }),
                validationFunc: itextValidator("addCaptionItext", gettext("Add Another Item Button Text")),
            });
            // virtual property used to get a widget
            control.addCaptionItextID = {
                visibility: 'addCaptionItext',
                lstring: gettext("Add Another Itext ID"),
                widget: itextWidget.id,
                widgetValuePath: "addCaptionItext",
            };

            // virtual property used to get a widget
            control.otherItext = function (mugOptions) {
                return mugOptions.isSpecialGroup ? undefined : {
                    visibility: 'labelItext',
                    presence: 'optional',
                    lstring: gettext("Add Other Content"),
                    widget: function (mug, options) {
                        return itextBlock.configurable(mug, $.extend(options, {
                            displayName: gettext("Add Other Content"),
                            itextType: "label",
                            getItextByMug: function (mug) {
                                return mug.p.labelItext;
                            },
                            forms: ['long', 'short'],
                            isCustomAllowed: true
                        }));
                    }
                };
            };
            // virtual property used to get a widget
            control.mediaItext = function (mugOptions) {
                return mugOptions.isSpecialGroup ? undefined : {
                    visibility: 'labelItext',
                    presence: 'optional',
                    lstring: gettext('Add Multimedia'),
                    widget: function (mug, options) {
                        return itextBlock.media(mug, $.extend(options, {
                            displayName: gettext("Add Multimedia"),
                            itextType: "label",
                            pathPrefix: "",
                            getItextByMug: function (mug) {
                                return mug.p.labelItext;
                            },
                            forms: jrUtil.SUPPORTED_MEDIA_TYPES,
                            formToIcon: ICONS
                        }));
                    }
                };
            };
            // virtual property used to get a widget
            control.helpMediaIText = function (mugOptions) {
                return mugOptions.isSpecialGroup ? undefined : {
                    visibility: 'helpItext',
                    presence: 'optional',
                    lstring: gettext('Add Help Media'),
                    widget: function (mug, options) {
                        return itextBlock.media(mug, $.extend(options, {
                            displayName: gettext("Add Help Media"),
                            itextType: "help",
                            getItextByMug: function (mug) {
                                return mug.p.helpItext;
                            },
                            forms: jrUtil.SUPPORTED_MEDIA_TYPES,
                            formToIcon: ICONS
                        }));
                    }
                };
            };
            return spec;
        },
        getMainProperties: function () {
            var ret = this.__callOld();
            ret.splice(1 + ret.indexOf('label'), 0, 'labelItext');
            return ret;
        },
        getLogicProperties: function () {
            var ret = this.__callOld();
            ret.splice(
                1 + ret.indexOf('constraintAttr'), 0, 'constraintMsgItext');
            return ret;
        },
        getMediaProperties: function() {
            var ret = this.__callOld();
            ret.push('constraintMediaIText');
            return ret;
        },
        getAdvancedProperties: function () {
            var ret = this.__callOld();

            ret = ret.concat([
                'labelItextID',
                'constraintMsgItextID',
                'hintItextID',
                'hintItext',
                'helpItextID',
                'helpItext',
                'addEmptyCaptionItextID',
                'addEmptyCaptionItext',
                'addCaptionItextID',
                'addCaptionItext',
                'helpMediaIText',
            ]);

            ret = ret.concat(['otherItext']);

            return ret;
        },
        getToolsMenuItems: function () {
            var _this = this;
            return this.__callOld().concat([
                {
                    name: gettext("Edit Bulk Translations"),
                    icon: "fa fa-language",
                    action: function (done) {
                        _this.showItextModal(done);
                    }
                }
            ]);
        },
        showItextModal: function (done) {
            var vellum = this,
                $modal, $updateForm, $textarea,
                Itext = vellum.data.javaRosa.Itext,
                form = vellum.data.core.form;

            $modal = vellum.generateNewModal(gettext("Edit Bulk Translations"), [
                {
                    title: gettext("Update Translations"),
                    cssClasses: "btn-primary",
                    action: function () {
                        jrUtil.parseXLSItext(form, $textarea.val(), Itext);
                        $modal.modal('hide');
                        done();
                    }
                }
            ]);
            $updateForm = $(edit_source({
                description: gettext(
                "Copy these translations into a spreadsheet program " +
                "like Excel. You can edit them there and then paste them back " +
                "here when you're done. These will update the translations used in " +
                "your form. Press 'Update Translations' to save changes, or 'Close' " +
                "to cancel.")
            }));
            $modal.find('.modal-body').html($updateForm);

            // display current values
            $textarea = $updateForm.find('textarea');
            $textarea.val(jrUtil.generateItextXLS(form, Itext));

            $modal.modal('show');
            $modal.one('shown.bs.modal', function () { $textarea.focus(); });
        }
    });
});

/*
 * Locked Questions plugin.
 *
 * Lets you lock questions by setting vellum:lock on their bind.
 *
 *    'node':  The question can't be deleted or renamed, or moved to a different
 *         parent.  Everything else can be changed.
 *    'value': The only thing that can be changed is itext IDs and itext values.
 *    'none': same as nothing
 *
 * Locking is not recursive; you must lock a node's entire hierarchy if you
 * really don't want it to be moved.
 *
 * Spec:
 * https://docs.google.com/document/d/1g4o3_OQfAYHjHdw7m7WcIAIRTomRV48yRQayL31jvIc
 */
define('vellum/lock',[
    'jquery',
    'vellum/core'
], function (
    $
) {
    $.vellum.plugin("lock", {}, {
        loadXML: function (xml) {
            this.data.lock.locks = {};
            this.__callOld();
        },
        parseBindElement: function (form, el, path) {
            this.__callOld();
            var locked = el.xmlAttr('vellum:lock');
            if (locked && locked !== 'none') {
                this.data.lock.locks[path] = locked;
            }
        },
        isPropertyLocked: function (mugPath, propertyPath) {
            if (this.__callOld()) {
                return true;
            }
            var lock = this.data.lock.locks[mugPath];
            if (!lock) { 
                return false; 
            }

            if ((lock === 'node' || lock === 'value') && 
                propertyPath === 'nodeID') 
            {
                return true;
            } else if (lock === 'value' && propertyPath.indexOf('Itext') === -1) {
                return true;
            }

            return false;
        },
        isMugPathMoveable: function (mugPath) {
            return this.__callOld() && !this.data.lock.locks[mugPath];
        },
        isMugRemoveable: function (mug, mugPath) {
            return this.__callOld() && !this.data.lock.locks[mugPath];
        },
        isMugTypeChangeable: function (mug, mugPath) {
            return this.__callOld() && this.data.lock.locks[mugPath] !== 'value';
        }
    });
});

define('vellum/window',[
    'jquery',
    'vellum/core',
    'vellum/jquery-extensions'
], function (
    $
) {
    $.vellum.plugin('windowManager', {
        minHeight: 200,
        bottomOffset: 0
    }, {
        init: function () {
            var _this = this,
                opts = this.opts().windowManager,
                adjustToWindow = function () { _this.adjustToWindow(); };

            preventDoubleScrolling(this.$f.find('.fd-scrollable'));
            setupDraggableDivider(
                this.$f.find('.fd-content-divider'),
                this.$f.find('.fd-content-left'),
                adjustToWindow
            );
            setupDraggableDivider(
                this.$f.find('.fd-content-left-divider'),
                this.$f.find('.fd-accessory-pane'),
                adjustToWindow
            );

            this.data.windowManager.offset = {
                top: opts.topOffset || this.$f.offset().top-1,
                bottom: opts.bottomOffset || 0,
                left: opts.leftOffset || this.$f.offset().left
            };
            this.data.windowManager.fullscreen = opts.fullscreen;
            this.data.windowManager.adjustToWindow = adjustToWindow;

            // start with accessory pane collapsed
            $(window).resize(adjustToWindow);
            $(document).scroll(adjustToWindow);
            $(adjustToWindow);
            _this.adjustToWindow();
        },
        adjustToWindow: function() {
            if (!this.$f.is(':visible')) {
                return;
            }

            var availableVertSpace = $(window).height() - this.getCurrentTopOffset(),
                availableHorizSpace,
                position = (this.getCurrentTopOffset() === 0) ? 'fixed' : 'static',
                $fdc = this.$f.find('.fd-ui-container');

            if (this.data.windowManager.fullscreen) {
                $fdc.parent().css({height: null, width: null});
                $fdc.css({height: null, width: null});
                $fdc.addClass("full-screen");
                $('body').addClass("vellum-full-screen");
                $fdc.parent().css({
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    backgroundColor: 'white'
                });
                $fdc.css('width', $(window).width());
            } else {
                $fdc.removeClass("full-screen");
                $('body').removeClass("vellum-full-screen");
                $fdc.parent().css({
                    top: '',
                    bottom: '',
                    left: '',
                    right: '',
                    backgroundColor: 'white'
                });
                $fdc.css('width', $fdc.parent().width());
            }
            // so that the document doesn't have to resize for the footer.
            $fdc.parent().css('height', availableVertSpace + 'px');

            availableVertSpace = availableVertSpace - this.getCurrentBottomOffset();
            $fdc.css('height', availableVertSpace + 'px');

            $fdc.css('position', position)
                .css('left', this.getCurrentLeftOffset() + 'px');

            availableHorizSpace = $fdc.width();

            var panelHeight = Math.max(availableVertSpace,
                                       this.opts().windowManager.minHeight),
                treeHeight = panelHeight,
                columnHeight = panelHeight - this.$f.find('.fd-head').outerHeight(false),
                accessoryPane = this.$f.find(".fd-accessory-pane");

            $fdc.find('.fd-content').css('height', panelHeight + 'px');

            // Decrement tree height by height of any siblings
            var $tree = $fdc.find('.fd-content-left .fd-tree');
            $tree.children(":not(.fd-scrollable)").each(function(i, child) {
                treeHeight -= $(child).outerHeight(false);
            });

            if (accessoryPane.children().length) {
                // Decrement tree height by height of accessory pane
                var accessoryHeight = accessoryPane.outerHeight(false),
                    accessoryScrollableHeight = accessoryHeight -
                        accessoryPane.find('.fd-head').outerHeight(true);
                treeHeight -= 2 + accessoryHeight +
                    this.$f.find('.fd-content-left-divider').outerHeight(true);
                accessoryPane.find(".fd-scrollable")
                             .css('height', accessoryScrollableHeight + 'px');
                accessoryPane.show();
                this.$f.find(".fd-content-left-divider").show();
            } else {
                accessoryPane.hide();
                this.$f.find(".fd-content-left-divider").hide();
            }
            $tree.find('.fd-scrollable').css('height', treeHeight + 'px');
            $tree.find('.fd-scrollable-minimal').css('max-height', treeHeight + 'px');

            $fdc.find('.fd-content-right')
                .css('width', availableHorizSpace - this.getLeftWidth() + 'px')
                .find('.fd-scrollable.full').css('height', columnHeight + 'px');

            $fdc.find('.fd-props-scrollable')
                .css('height', columnHeight -
                                $fdc.find('.fd-props-toolbar').outerHeight(true) -
                                $fdc.find('.fd-form-actions').outerHeight(false) + 'px');
        },
        getLeftWidth: function () {
            return 2 + this.$f.find('.fd-content-left').outerWidth(false) + 
               this.$f.find('.fd-content-divider').outerWidth(true);
        },
        getCurrentTopOffset: function () {
            if (this.data.windowManager.fullscreen) {
                return 0;
            }
            var scrollPosition = $(window).scrollTop(),
                offset = this.data.windowManager.offset,
                topOffset = (typeof offset.top === 'function') ? offset.top() : offset.top;
            return Math.min(Math.max(topOffset - scrollPosition, 0), topOffset);
        },
        getCurrentBottomOffset: function () {
            if (this.data.windowManager.fullscreen) {
                return 0;
            }
            var offset = this.data.windowManager.offset;
            return (typeof offset.bottom === 'function') ? offset.bottom() : offset.bottom;
        },
        getCurrentLeftOffset: function () {
            if (this.data.windowManager.fullscreen) {
                return 0;
            }
            var scrollLeft = $(window).scrollLeft(),
                offset = this.data.windowManager.offset,
                offsetLeft = (typeof offset.left === 'function') ? offset.left() : offset.left;
            return Math.min(offsetLeft - scrollLeft, offsetLeft);
        }
    });

    function preventDoubleScrolling($scrollable) {
        $scrollable.on('DOMMouseScroll mousewheel', function (ev) {
            /*
             * Copied from http://jsfiddle.net/TroyAlford/4wrxq/1/
             *
             * if your mouse is over the one of vellum's scrollable sections
             * and you use your mouse wheel (or touchpad, etc.) to scroll
             * you no longer start scrolling the window when the pane reaches the top/bottom
             *
             * up/down keys still have double scrolling behavior,
             * and you can still click the up down arrows on either scroll bar
             * for OS's that have that (i.e. most except macs)
             */
            var $this = $(this),
                scrollTop = this.scrollTop,
                scrollHeight = this.scrollHeight,
                height = $this.height(),
                delta = ev.originalEvent.wheelDelta,
                up = delta > 0,
                prevent = function() {
                    ev.stopPropagation();
                    ev.preventDefault();
                    ev.returnValue = false;
                    return false;
                };

            if (!up && -delta > scrollHeight - height - scrollTop) {
                // Scrolling down, but this will take us past the bottom.
                $this.scrollTop(scrollHeight);
                return prevent();
            } else if (up && delta > scrollTop) {
                // Scrolling up, but this will take us past the top.
                $this.scrollTop(0);
                return prevent();
            }
        });
    }

    function setupDraggableDivider($divider, $resizable, adjustToWindow) {
        var pageVar, sizeVar, before, cursor;
        if ($divider.hasClass("fd-content-vertical-divider")) {
            before = $resizable.offset().left < $divider.offset().left;
            pageVar = "pageX";
            sizeVar = "width";
            cursor = 'col-resize';
        } else {
            before = $resizable.offset().top < $divider.offset().top;
            pageVar = "pageY";
            sizeVar = "height";
            cursor = 'row-resize';
        }
        var direction = before ? 1 : -1;
        $divider.mousedown(function (mousedown) {
            var minSize = $resizable.data("min-size") || 0,
                size = $resizable[sizeVar](),
                resize = function (mousemove) {
                    var distance = mousemove[pageVar] - mousedown[pageVar];
                    $resizable[sizeVar](Math.max(size + distance * direction, minSize));
                    $resizable.resize();
                    adjustToWindow();
                };
            $(window).disableSelection()
                .on('mousemove', resize)
                .one('mouseup', function () {
                    $(this).enableSelection();
                    $(this).off('mousemove', resize);
                });
        }).hover(function (e) {
            e.target.style.cursor = cursor;
        });
    }

    return {
        preventDoubleScrolling: preventDoubleScrolling
    };
});


define('tpl/tpl!vellum/templates/external_sources_tree', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-external-sources-container">\n    <div class="fd-head fd-head-external-sources">\n        <div class="fd-head-max-indicator"><i class="fa-regular fa-circle-down"></i></div>\n        <h2>'+
((__t=(gettext("App Properties")))==null?'':_.escape(__t))+
'</h2>\n    </div>\n    <div class="fd-scrollable">\n        <div class="fd-external-resource-search">\n            <form class="form-inline">\n                <label class="control-label" for="fdExternalSearch"><i class="fa fa-search"></i></label>\n                <div class="fd-search-control">\n                    <input type="text"\n                        id="fdExternalSearch"\n                        class="form-control search-query"\n                        placeholder="'+
((__t=(gettext("Search...")))==null?'':_.escape(__t))+
'"\n                        style="width: calc(100% - 42px);"\n                        autocomplete="off" >\n                </div>\n            </form>\n        </div>\n        <div class="fd-external-sources-error container-fluid has-error hide">\n            <div class="help-block"></div>\n        </div>\n        <div class="fd-external-sources-tree"></div>\n    </div>\n</div>\n';
}
return __p;
}; });

/**
 * External data source tree/browser plugin
 */
define('vellum/databrowser',[
    'jquery',
    'underscore',
    'vellum/util',
    'vellum/widgets',
    'vellum/window',
    'tpl!vellum/templates/external_sources_tree',
], function (
    $,
    _,
    util,
    widgets,
    window_,
    external_sources_tree
) {
    var fn = {},
        DATABROWSER_HEIGHT = 0.33;

    // plugin adds an item to the Tools menu when enabled
    $.vellum.plugin('databrowser', {}, {
        init: function () {
            var vellum = this,
                tree = this.$f.find(".fd-tree"),
                pane = this.$f.find(".fd-accessory-pane"),
                head, headHeight, searchBar, paneRatio;
            vellum.data.core.databrowser = {
                errorContainer: pane,
                panelHeight: null,
            };
            fn.initDataBrowser = _.once(_initDataBrowser);
            pane.append($(external_sources_tree()));
            head = pane.find(".fd-head-external-sources");
            headHeight = head.outerHeight(true) || 0;
            pane.data("min-size", headHeight)
                .height(Math.min(tree.height() * DATABROWSER_HEIGHT, headHeight * 12))
                .resize(function () {
                    if (pane.height() > headHeight + 100) {
                        vellum.data.core.databrowser.panelHeight = pane.height();
                        paneRatio = pane.height() / $('.fd-content-left').height();
                    }
                });
            paneRatio = pane.height() / $('.fd-content-left').height();
            $(window).scroll(function() {
                if (pane.height() > headHeight) {
                    pane.height($('.fd-content-left').height() * paneRatio);
                    vellum.data.core.databrowser.panelHeight = pane.height();
                }
            });
            searchBar = pane.find('#fdExternalSearch');
            searchBar.on('keyup keypress', function(e) {
                var code = e.keyCode || e.which;
                if (code === 13) {
                    //disable submitting on enter
                    e.preventDefault();
                    return false;
                }
            });
            fn.initDataBrowser(vellum);
            window_.preventDoubleScrolling(pane.find(".fd-scrollable"));
            vellum.datasources.on("error", function(event) {
                var container = vellum.data.core.databrowser.errorContainer;
                if (container) {
                    // HQ will send a 400 (bad request) if it captures an error like an app build problem.
                    // Unexpected errors are likely to send an HTML-based response, so show a generic message for them.
                    var error = gettext("Could not load app properties.") + "<br>";
                    if (event.xhr.status === 400) {
                        error += event.xhr.responseText;
                    } else {
                        error += gettext("If this error persists, please report an issue.");
                    }
                    container.find(".fd-external-sources-error")
                        .removeClass("hide")
                        .find(".help-block")
                        .html(error);

                    container.find(".fd-external-sources-tree")
                        .addClass("hide");
                }
            });
            var toggle = _.partial(toggleExternalDataTree, vellum);
            pane.parent().find(".fd-external-sources-divider")
                .clickExceptAfterDrag(toggle);
            head.click(toggle);
        },
    });

    function _initDataBrowser(vellum) {
        // display spinner and begin loading...
        var $container = vellum.$f.find(".fd-external-sources-container"),
            $search = $container.find(".fd-external-resource-search input"),
            $tree = $container.find(".fd-external-sources-tree");
        vellum.data.core.databrowser.errorContainer = $container;
        $tree.on('after_open.jstree', function () {
            $('.jstree-anchor').popover();
        });
        $tree.on('redraw.jstree', function () {
            $('.jstree-anchor').popover();
        });
        $tree.jstree({
            core: {
                data: function (node, callback) {
                    function fillTree() {
                        var nodes = vellum.datasources.getDataNodes([]);
                        callback.call(tree, dataTreeJson(nodes, vellum));
                    }
                    var tree = this;
                    if (node.data && node.data.getNodes) {
                        // load children of recursive node
                        callback.call(this, node.data.getNodes());
                    } else {
                        if (vellum.datasources.isReady()) {
                            fillTree();
                        } else {
                            vellum.datasources.on("change", fillTree, null, "change");
                        }
                    }
                },
                worker: false,
                multiple: false,
                check_callback: function(operation, node, parent, position, more) {
                    return false;
                }
            },
            search: {
                show_only_matches: true
            },
            conditionalevents: {
                should_activate: function () { return false; }
            },
            "plugins" : [ "themes", "conditionalevents", "dnd", "search" ]
        });
        $search.keyup(_.debounce(function () {
            $tree.jstree(true).search($search.val());
        }, 250));
    }

    function dataTreeJson(data, vellum) {
        function treeNode(node) {
            var getNodes = function () { return _.map(node.getNodes(), treeNode); },
                children = node.recursive ? true : getNodes();
            return {
                text: node.name,
                icon: node.recursive || children.length ?
                        "fcc fcc-fd-external-case" :
                        "fcc fcc-fd-case-property",
                state: {opened: !node.recursive && children.length <= MAX_OPEN_NODE},
                children: children,
                data: {
                    handleDrop: _.partial(handleDrop, node, node.sourceInfo),
                    getNodes: node.recursive ? getNodes : null,
                },
                a_attr: {
                    'data-content': node.description,
                    'data-container': 'body',
                    'data-trigger': 'hover',
                }
            };
        }
        function handleDrop(node, info, target, event) {
            var widget = widgets.util.getWidget(target, vellum),
                path = widget.mug.form.richText && node.hashtag ? node.hashtag : node.xpath,
                id;
            while (info) {
                if (info.id && info.uri) {
                    id = widget.addInstanceRef({id: info.id, src: info.uri});
                    if (id !== info.id) {
                        path = widget.mug.form.updateInstanceQuery(path, id, info.id);
                    }
                }
                info = info._parent;
            }
            vellum.handleDropFinish(target, path, undefined, event);
        }
        function flattenNode(node) {
            // data sources should be in a flat list instead of hierarchy
            var subCases = _.filter(node.children, function(child) {
                return child.children.length;
            });
            node.children = _.filter(node.children, function(child) {
                return child.children.length === 0;
            });
            subCases = _.flatten(_.map(subCases, flattenNode));
            return [node].concat(subCases);
        }
        var MAX_OPEN_NODE = 50;
        return _.chain(data)
            .map(treeNode)
            .map(flattenNode)
            .flatten()
            .value();
    }

    function toggleExternalDataTree(vellum) {
        var pane = vellum.$f.find(".fd-accessory-pane"),
            headHeight = pane.find(".fd-head-external-sources").outerHeight(true);
        if (pane.height() > headHeight) {
            pane.css("height", headHeight + "px");
            pane.find('.fd-head-external-sources .fd-head-max-indicator i')
                .removeClass('fa-circle-down')
                .addClass('fa-circle-up');
            $(window).resize();
        } else {
            var tree = vellum.$f.find(".fd-tree"),
                panelHeight = vellum.data.core.databrowser.panelHeight,
                height = panelHeight || tree.height() * DATABROWSER_HEIGHT;
            pane.css("height", height + "px");
            pane.find('.fd-head-external-sources .fd-head-max-indicator i')
                .removeClass('fa-circle-up')
                .addClass('fa-circle-down');
            $(window).resize();
            fn.initDataBrowser(vellum);
        }
    }

    return fn;
});

define('vellum/commtrack',[
    'jquery',
    'underscore',
    'vellum/mugs',
    'vellum/tree',
    'vellum/util',
    'vellum/widgets',
    'vellum/core'
], function (
    $,
    _,
    mugs,
    Tree,
    util,
    widgets
) {
    var LEDGER_XMLNS = "http://commcarehq.org/ledger/v1",
        LEDGER_INSTANCE_ID = "ledger",
        LEDGER_INSTANCE_URI = "jr://instance/ledgerdb",
        nextId = 0,
        transferValues = [
            {
                attr: "entryId",
                path: "entry/@id"
            }, {
                attr: "quantity",
                path: "entry/@quantity"
            }, {
                attr: "src",
                path: "@src"
            }, {
                attr: "dest",
                path: "@dest"
            }, {
                attr: "date",
                path: "@date"
            }
        ],
        bindData = {
            Balance: [
                {
                    attr: "entryId",
                    path: "entry/@id"
                }, {
                    attr: "quantity",
                    path: "entry/@quantity"
                }, {
                    attr: "entityId",
                    path: "@entity-id"
                }, {
                    attr: "date",
                    path: "@date"
                }
            ],
            Transfer: transferValues,
            Dispense: transferValues,
            Receive: transferValues,
        },
        // {<question type>: {<path suffix>: <attr>, ...}, ...}
        bindAttributes = _.mapObject(bindData, function (items) {
            return _.object(_.map(items, function (item) {
                return [item.path, item.attr];
            }));
        }),
        basicSection = {
            slug: "main",
            displayName: gettext("Basic"),
            properties: [
                "nodeID",
                "src",
                "dest",
                "sectionId",
                "entryId",
                "quantity",
                "date",
            ],
            help: {
                title: gettext("Basic"),
                text: "<p>" + util.format(
                    gettext("The {questionid} is an internal identifier for " +
                            "a question. It does not appear on the phone. It " +
                            "is the name of the question in data exports."),
                    {questionid: "<strong>" + gettext("Question ID") + "</strong>"}
                ) + "</p>",
                link: "https://help.commcarehq.org/display/commcarepublic/Transactions",
            },
        },
        logicSection = {
            slug: "logic",
            displayName: gettext("Logic"),
            help: {
                title: gettext("Logic"),
                text: gettext("Use logic to control when questions are asked and what answers are valid. " +
                    "You can add logic to display a question based on a previous answer, to make " +
                    "the question required or ensure the answer is in a valid range."),
                link: "https://confluence.dimagi.com/display/commcarepublic/Common+Logic+and+Calculations"
            },
            properties: [
                'relevantAttr',
            ]
        },
        sectionData = {
            Balance: [
                _.extend({}, basicSection, {
                    properties: [
                        "nodeID",
                        "entityId",
                        "sectionId",
                        "entryId",
                        "quantity"
                    ],
                }),
                logicSection
            ],
            Transfer: [basicSection, logicSection],
            Dispense: [basicSection, logicSection],
            Receive: [basicSection, logicSection],
        },
        baseTransactionOptions = util.extend(mugs.defaultOptions, {
            isDataOnly: true,
            isTypeChangeable: false,
            supportsDataNodeRole: true,
            parseDataNode: function (mug, $node) {
                mug.p.nodeID = mug.p.rawDataAttributes.type || "tx-" + nextId++;
                delete mug.p.rawDataAttributes.type;
                mug.p.sectionId = mug.p.rawDataAttributes["section-id"];
                delete mug.p.rawDataAttributes["section-id"];
                return $([]);
            },
            getPathName: function (mug, name) {
                return mug.options.getTagName() + "[@type='" + name + "']";
            },
            dataChildFilter: function (children, mug) {
                return [new Tree.Node(children, {
                    getNodeID: function () { return "entry"; },
                    p: {rawDataAttributes: null},
                    options: {
                        getExtraDataAttributes: function (mug) {
                            return {id: "", quantity: ""};
                        }
                    }
                })];
            },
            getBindList: function (mug) {
                var binds = [{
                    nodeset: mug.hashtagPath,
                    relevant: mug.p.relevantAttr,
                }];
                _.each(bindData[mug.__className], function (item) {
                    var value = mug.p[item.attr];
                    if (value) {
                        binds.push({
                            nodeset: mug.hashtagPath + "/" + item.path,
                            calculate: value,
                        });
                    }
                });
                return binds;
            },
            isHashtaggable: false,
            spec: {
                date: {
                    lstring: gettext('Date'),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.xPath,
                    xpathType: 'generic',
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                    help: gettext('The date and time of the action, e.g., now() or today()'),
                },
                sectionId: {
                    lstring: gettext('Balance ID'),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.text,
                    help: gettext('The name of the balance you are tracking. ' +
                         'This is an internal identifier which does not appear on the phone.'),
                },
                entryId: {
                    lstring: gettext('Product'),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.xPath,
                    xpathType: "generic",
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                    help: gettext('A reference to a product ID, e.g., "/data/products/current_product"'),
                },
                quantity: {
                    lstring: gettext('Quantity'),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.xPath,
                    xpathType: "generic",
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                    help: gettext('A reference to an integer question in this form.'),
                },
                relevantAttr: {
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.xPath,
                    xpathType: "bool",
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                    lstring: gettext('Display Condition')
                },
            },
        }),
        balanceMugOptions = util.extend(baseTransactionOptions, {
            typeName: 'Balance',
            getTagName: function () { return "balance"; },
            getExtraDataAttributes: function (mug) {
                var attrs = mug.p.rawDataAttributes || {};
                return {
                    xmlns: LEDGER_XMLNS,
                    type: mug.p.nodeID,
                    "entity-id": attrs["entity-id"] || "",
                    "section-id": mug.p.sectionId,
                    date: attrs.date || ""
                };
            },
            icon: 'fcc fcc-fd-hash',
            init: function (mug, form) {
                mug.p.entityId = "";
                mug.p.sectionId = "";
                mug.p.entryId = "";
                mug.p.quantity = "";
                mug.p.date = "now()";
                addLedgerDBInstance(mug, form);
            },
            spec: {
                xmlnsAttr: {
                    presence: "optional",
                    serialize: function () {},
                    deserialize: function () {}
                },
                nodeID: {
                    serialize: serializeNodeId
                },
                entityId: {
                    lstring: gettext('Case'),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.xPath,
                    xpathType: "generic",
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                    help: gettext('XPath expression for the case ID associated with this balance.'),
                },
                requiredAttr: { presence: "notallowed" },
                constraintAttr: { presence : "notallowed" },
                calculateAttr: { presence: "notallowed" }
            }
        }),
        transferMugValidation = function (mug) {
            var error = {key: "commtrack-transfer-src-dest-error", level: mug.ERROR};
            if (!mug.p.dest || !mug.p.src) {
                error.message = gettext('Transfer must have both Source Case and ' +
                                'Destination Case defined.');
            }
            mug.addMessages({src: [error], dest: [error]});
            return 'pass';
        },
        transferMugOptions = util.extend(baseTransactionOptions, {
            typeName: 'Transfer',
            getTagName: function () { return "transfer"; },
            isTypeChangeable: true,
            typeChangeError: function (mug, typeName) {
                if (typeName !== "Balance" && mug.__className !== "Balance" &&
                        isTransaction(mug) &&
                        isTransaction({__className: typeName})) {
                    return "";
                }
                return gettext("Cannot change $1 to $2")
                        .replace("$1", mug.__className)
                        .replace("$2", typeName);
            },
            getExtraDataAttributes: function (mug) {
                var raw = mug.p.rawDataAttributes || {},
                    attrs = {
                        xmlns: LEDGER_XMLNS,
                        type: mug.p.nodeID,
                        date: raw.date || "",
                        "section-id": mug.p.sectionId,
                    };
                if (mug.p.src && $.trim(mug.p.src)) {
                    attrs.src = raw.src || "";
                } else {
                    delete raw.src;
                }
                if (mug.p.dest && $.trim(mug.p.dest)) {
                    attrs.dest = raw.dest || "";
                } else {
                    delete raw.dest;
                }
                return attrs;
            },
            icon: 'fa-solid fa-right-left',
            init: function (mug, form) {
                mug.p.src = "";
                mug.p.dest = "";
                mug.p.sectionId = "";
                mug.p.entryId = "";
                mug.p.quantity = "";
                mug.p.date = "now()";
                addLedgerDBInstance(mug, form);
            },
            spec: {
                nodeID: {
                    serialize: serializeNodeId
                },
                xmlnsAttr: {
                    presence: "optional",
                    serialize: function () {},
                    deserialize: function () {}
                },
                src: {
                    lstring: gettext('Source Case'),
                    visibility: 'visible',
                    presence: 'required',
                    widget: widgets.xPath,
                    xpathType: "generic",
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                    help: gettext('XPath expression for the case ID issuing the transaction.'),
                    validationFunc: transferMugValidation,
                },
                dest: {
                    lstring: gettext('Destination Case'),
                    visibility: 'visible',
                    presence: 'required',
                    widget: widgets.xPath,
                    xpathType: "generic",
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                    help: gettext('XPath expression for the case ID receiving the transaction.'),
                    validationFunc: transferMugValidation,
                },
                requiredAttr: { presence: "notallowed" },
                constraintAttr: { presence : "notallowed" },
                calculateAttr: { presence: "notallowed" }
            }
        }),
        dispenseMugOptions = util.extend(transferMugOptions, {
            typeName: 'Dispense',
            icon: 'fa fa-sign-out',
            spec: {
                src: {
                    validationFunc: function (mug) {
                        if (mug.p.src) {
                            return 'pass';
                        }
                        return gettext('Dispense must have a Source Case.');
                    },
                },
                dest: { presence: "notallowed" },
            }
        }),
        receiveMugOptions = util.extend(transferMugOptions, {
            typeName: 'Receive',
            icon: 'fa fa-sign-in',
            spec: {
                src: { presence: "notallowed" },
                dest: {
                    validationFunc: function (mug) {
                        if (mug.p.dest) {
                            return 'pass';
                        }
                        return gettext('Receive must have a Destination Case.');
                    },
                },
            }
        }),
        bindPaths = _.chain(bindData)
            .map(function (items) {
                return _.map(items, function(attrs) {
                    return RegExp.escape(attrs.path);
                });
            }).flatten().uniq().value(),
        bindPathSuffixRegex = new RegExp("/(" + bindPaths.join('|') + ")$");

    $.vellum.plugin("commtrack", {}, {
        getAdvancedQuestions: function () {
            return this.__callOld().concat([
                "Balance",
                "Transfer",
                "Dispense",
                "Receive"
            ]);
        },
        getMugTypes: function () {
            var types = this.__callOld();
            types.normal.Balance = balanceMugOptions;
            types.normal.Transfer = transferMugOptions;
            types.normal.Dispense = dispenseMugOptions;
            types.normal.Receive = receiveMugOptions;
            return types;
        },
        parseDataElement: function (form, el, parentMug, role) {
            var tag = el.nodeName;
            if (!role && (tag === "transfer" || tag === "balance") &&
                    $(el).xmlAttr("xmlns") === LEDGER_XMLNS) {
                if (tag === "transfer") {
                    var $el = $(el);
                    if (_.isUndefined($el.xmlAttr("src"))) {
                        role = "Receive";
                    } else if (_.isUndefined($el.xmlAttr("dest"))) {
                        role = "Dispense";
                    } else {
                        role = "Transfer";
                    }
                } else {
                    role = "Balance";
                }
                return this.__callOld(form, el, parentMug, role);
            }
            return this.__callOld();
        },
        parseBindElement: function (form, el, path) {
            var mug = form.getMugByPath(path);
            if (!mug) {
                var basePath = path.replace(bindPathSuffixRegex, "");
                if (path !== basePath) {
                    mug = form.getMugByPath(basePath);
                    if (isTransaction(mug)) {
                        var suffix = path.match(bindPathSuffixRegex)[1],
                            attr = bindAttributes[mug.__className][suffix];
                        mug.p[attr] = el.xmlAttr("calculate");
                        return;
                    }
                }
            } else if (isTransaction(mug)) {
                mug.p.relevantAttr = el.xmlAttr("relevant");
                return;
            }
            this.__callOld();
        },
        parseSetValue: function (form, el, path) {
            var mug = form.getMugByPath(path);
            if (!mug) {
                var basePath = path.replace(bindPathSuffixRegex, "");
                if (path !== basePath) {
                    mug = form.getMugByPath(basePath);
                    if (isTransaction(mug)) {
                        var suffix = path.match(bindPathSuffixRegex)[1],
                            attr = bindAttributes[mug.__className][suffix];
                        mug.p[attr] = el.xmlAttr("value");
                        return;
                    }
                }
            }
            this.__callOld();
        },
        getSections: function (mug) {
            if (sectionData.hasOwnProperty(mug.__className)) {
                return _.map(sectionData[mug.__className], function (section) {
                    return _.clone(section);
                });
            }
            return this.__callOld();
        },
    });

    function isTransaction(mug) {
        return mug && bindData.hasOwnProperty(mug.__className);
    }

    function addLedgerDBInstance(mug, form) {
        var data = {id: LEDGER_INSTANCE_ID, src: LEDGER_INSTANCE_URI};
        form.addInstanceIfNotExists(data, mug, "");
    }


    function serializeNodeId(value, key, mug, data) {
        var parent = mug.parentMug,
            path = parent ?
                mug.absolutePathNoRoot + "/" : "/";
        data.id = path + mug.p.nodeID;
    }
});

define('vellum/modeliteration',[
    'jquery',
    'underscore',
    'vellum/dataSourceWidgets',
    'vellum/mugs',
    'vellum/parser',
    'vellum/tree',
    'vellum/util',
    'vellum/core'
], function (
    $,
    _,
    datasourceWidgets,
    mugs,
    parser,
    Tree,
    util
) {
    var oldRepeat = mugs.baseMugTypes.normal.Repeat,
        // the order of the items in this list is important:
        // <setvalue> elements are evaluated in document order
        setvalueData = [
            {
                key: "ids",
                event: "xforms-ready",
                path: "",
                query: "join(' ', {})"
            }, {
                key: "count",
                event: "xforms-ready",
                path: "",
                query: "count-selected({}/@ids)"
            }, {
                key: "index",
                event: "jr-insert",
                path: "/item",
                query: "int({}/@current_index)"
            }, {
                key: "id",
                event: "jr-insert",
                path: "/item",
                query: "selected-at({}/@ids, ../@index)"
            }
        ],
        joinIdsRegexp = /^ *join\(['"] ['"], *(.*)\) *$/i,
        modelRepeatMugOptions = {
            //typeName: 'Model Repeat',
            supportsDataNodeRole: true,
            isRepeat: true,
            getPathName: function (mug, name) {
                if (mug.p.dataSource.idsQuery) {
                    name += "/item";
                }
                return name;
            },
            parseDataNode: function (mug, $node) {
                // temporary dataSource overwritten by handleMugParseFinish
                mug.p.dataSource = {idsQuery: "value for getPathName"};
                return $node.children("item").children();
            },
            dataChildFilter: function (children, mug) {
                if (!mug.p.dataSource.idsQuery) {
                    return children;
                }
                return [new Tree.Node(children, {
                    getNodeID: function () { return "item"; },
                    p: {rawDataAttributes: null},
                    options: {
                        getExtraDataAttributes: function (mug) {
                            return {id: "", index: "", "jr:template": ""};
                        }
                    }
                })];
            },
            controlChildFilter: function (children, mug) {
                var nodeset = mug.hashtagPath,
                    r_count = mug.p.repeat_count;
                children = oldRepeat.controlChildFilter(children, mug);
                children[0].getValue().options.writeCustomXML = function (xmlWriter, mug) {
                    if (r_count) {
                        util.writeHashtags(xmlWriter, 'jr:count', String(r_count), mug);
                        xmlWriter.writeAttributeString("jr:noAddRemove", "true()");
                    }
                    util.writeHashtags(xmlWriter, 'nodeset', nodeset, mug);
                };
                return children;
            },
            getExtraDataAttributes: function (mug) {
                if (!mug.p.dataSource.idsQuery) {
                    return oldRepeat.getExtraDataAttributes(mug);
                }
                return {
                    ids: "",
                    count: "",
                    current_index: "",
                    "vellum:role": "Repeat"
                };
            },
            getBindList: function (mug) {
                var path = mug.absolutePath,
                    binds = oldRepeat.getBindList(mug);
                if (mug.p.dataSource.idsQuery) {
                    binds.splice(0, 0, {
                        nodeset: path.replace(/\/item$/, "/@current_index"),
                        calculate: "count(" + path + ")"
                    });
                }
                return binds;
            },
            init: function (mug, form) {
                oldRepeat.init(mug, form);
                mug.p.repeat_count = "";
                mug.p.setvalues = {};
                mug.p.originalPath = null;
                mug.p.dataSource = {};
                mug.p.dataSourceChanged = false;
                mug.options.customRepeatButtonText = form.vellum.opts().features.use_custom_repeat_button_text;
            },
            spec: {
                nodeID: {
                    deserialize: function (data, key, mug, context) {
                        var deserialize = mugs.baseSpecs.databind.nodeID.deserialize;
                        if (data.dataSource) {
                            var id = data.id.slice(0, data.id.lastIndexOf("/")) || data.id,
                                copy = _.extend({}, data, {id: id});
                            return deserialize(copy, key, mug, context);
                        }
                        return deserialize(data, key, mug, context);
                    }
                },
                repeat_count: _.extend({}, oldRepeat.spec.repeat_count, {
                    visibility: function (mug) {
                        return !mug.p.dataSource.idsQuery;
                    }
                }),
                dataSource: {
                    lstring: gettext('Data Source'),
                    visibility: 'visible_if_present',
                    presence: 'optional',
                    widget: idsQueryDataSourceWidget,
                    validationFunc: function (mug) {
                        if (mug.p.dataSource.idsQuery) {
                            mug.form.updateLogicReferences(
                                mug, "dataSource", mug.p.dataSource.idsQuery);
                        }
                    },
                    serialize: function (value, key, mug, data) {
                        if (value && value.idsQuery) {
                            return {idsQuery:
                                mugs.serializeXPath(value.idsQuery, key, mug, data)};
                        }
                    },
                    deserialize: function (data, key, mug, context) {
                        var value = data[key] || {};
                        mugs.updateInstances(data, mug);
                        if (value && value.instance &&
                                     value.instance.id && value.instance.src) {
                            // legacy serialization format
                            var instances = {};
                            instances[value.instance.id] = value.instance.src;
                            mug.form.updateKnownInstances(instances);
                        }
                        var src = {},
                            fakeMug = {form: mug.form, p: src};
                        src.idsQuery = mugs.deserializeXPath(value, "idsQuery", fakeMug, context);
                        return src;
                    }
                }
            },
            ignoreReferenceWarning: function (mug) {
                return isModelRepeat(mug);
            },
            getSetValues: function (mug) {
                var path = mug.absolutePath,
                    query = mug.p.dataSource.idsQuery,
                    ret = [];

                if (query) {
                    path = path.replace(/\/item$/, "");
                    mug.p.repeat_count = path + "/@count";

                    // add/update <setvalue> elements
                    var isNested = mug.parentMug && mug.parentMug.isInRepeat(),
                        setvalues = mug.p.setvalues;
                    _.each(setvalueData, function (data) {
                        var event = isNested ? "jr-insert": data.event,
                            value = setvalues[data.key];
                        if (!value) {
                            value = {};
                        }
                        value.ref = path + data.path + "/@" + data.key;
                        value.value = data.query.replace("{}", data.key === "ids" ? query : path);
                        if (!value.event) {
                            value.event = event;
                        }
                        ret.push({
                            event: event,
                            ref: value.ref,
                            value: value.value
                        });
                    });
                }
                return ret;
            },
        };

    $.vellum.plugin("modeliteration", {}, {
        getMugTypes: function () {
            var types = this.__callOld();
            types.normal.Repeat = util.extend(oldRepeat, modelRepeatMugOptions);
            return types;
        },
        updateControlNodeAdaptorMap: function (map) {
            this.__callOld();
            var getGroupAdaptor = map.group;
            map.group = function ($element, appearance, form, parentMug) {
                var adapt = getGroupAdaptor($element, appearance, form, parentMug);
                if (adapt.repeat) {
                    var repeat = adapt.repeat,
                        path = adapt.path,
                        mug;
                    if (/\/item$/.test(path)) {
                        mug = form.getMugByPath(path.substring(0, path.length - 5));
                        if (mug && mug.__className === "Repeat") {
                            adapt = function (ignore, form) {
                                mug.p.nodeset = path;
                                mug.p.repeat_count = repeat.popAttr('jr:count') || null;
                                mug.p.rawRepeatAttributes = parser.getAttributes(repeat);
                                return mug;
                            };
                            adapt.type = 'Repeat';
                            adapt.path = path;
                            adapt.repeat = repeat;
                            adapt.ignoreDataNode = true;
                        }
                    }
                }
                return adapt;
            };
        },
        parseBindElement: function (form, el, path) {
            var mug = form.getMugByPath(path);
            if (!mug) {
                var repeatPath = path.replace(/\/@current_index$/, "/item");
                if (path !== repeatPath) {
                    mug = form.getMugByPath(repeatPath);
                    if (isModelRepeat(mug)) {
                        // ignore this bind (it will be created automatically on write)
                        return;
                    }
                }
            }
            this.__callOld();
        },
        handleMugParseFinish: function (mug) {
            this.__callOld();
            if (mug.__className !== "Repeat") {
                return;
            }
            var path = mug.absolutePath,
                container = null;
            if (mug.p.dataSource.idsQuery) {
                container = path.replace(/\/item$/, "");
            }
            mug.p.originalPath = path;
            mug.p.dataSource = {};
            mug.p.dataSourceChanged = false;
            mug.p.setvalues = {};
            if (container === null) {
                return;
            }
            var isNested = mug.parentMug && mug.parentMug.isInRepeat(),
                values = _.object(_.map(mug.form.getSetValues(), function (value) {
                    return [value.event + " " + value.ref, value];
                }));
            _.each(setvalueData, function (data) {
                var event = isNested ? "jr-insert" : data.event,
                    value = values[event + " " + container + data.path + "/@" + data.key];
                if (value) {
                    mug.p.setvalues[data.key] = value;
                    if (data.key === "ids") {
                        // get dataSource.idsQuery
                        value = value.value;
                        var match = value && value.match(joinIdsRegexp);
                        if (match) {
                            mug.p.dataSource.idsQuery = match[1];
                        } else {
                            mug.p.dataSource.idsQuery = value;
                        }
                    }
                }
            });
            if (mug.p.dataSource.idsQuery) {
                mug.p.dataSource.instance = mug.form.parseInstance(
                        mug.p.dataSource.idsQuery, mug, "dataSource");
            } else {
                // keep paths consistent for malformed model repeat with
                // missing IDs query. this XPath returns the empty set
                mug.p.dataSource.idsQuery = "''";
            }
            mug.p.rawDataAttributes = _.omit(
                mug.p.rawDataAttributes, ["ids", "count", "current_index"]);
            dropSetValues(mug);
        },
        loadXML: function () {
            this.__callOld();
            this.data.core.form.on("mug-property-change", function (event) {
                var mug = event.mug;
                if (mug.__className === "Repeat" && event.property === "dataSource") {
                    mug.p.dataSourceChanged = true;
                    updateDataSource(mug, event.val, event.previous);
                }
            });
        }
    });

    function isModelRepeat(mug) {
        return mug && mug.__className === "Repeat" && mug.p.dataSource.idsQuery;
    }

    function idsQueryDataSourceWidget(mug, options) {
        var widget = datasourceWidgets.advancedDataSourceWidget(
                                    mug, options, gettext("Model Iteration ID Query")),
            super_getValue = widget.getValue,
            super_setValue = widget.setValue;

        // Make the input in the main properties view read-only to force use of
        // the data source editor so mug properties will be reloaded on save
        // -> show/hide repeat_count depending on idsQuery value.
        widget.input.attr({"readonly": "readonly"});

        widget.getValue = function () {
            var val = super_getValue();
            return {
                instance: ($.trim(val.src) ? {id: val.id, src: val.src} : null),
                idsQuery: val.query
            };
        };

        widget.setValue = function (val) {
            val = val || {};
            super_setValue({
                id: (val.instance ? val.instance.id : ""),
                src: (val.instance ? val.instance.src : ""),
                query: val.idsQuery || ""
            });
        };

        return widget;
    }

    function updateDataSource(mug, value, previous) {
        if (previous && previous.instance && previous.instance.src) {
            mug.form.dropInstanceReference(
                        previous.instance.src, mug, "dataSource.instance");
        }
        if (value && value.instance && value.instance.src) {
            var instanceId = mug.form.addInstanceIfNotExists(
                                    value.instance, mug, "dataSource.instance");
            if (instanceId !== value.instance.id) {
                // is it too magical to replace the instance id in the query?
                // there might be edge cases where a user is entering a
                // custom instance and query and does not want this to
                // happen
                value.instance.id = instanceId;
                value.idsQuery = mug.form.updateInstanceQuery(value.idsQuery, instanceId);
            }
        }
        if (Boolean(value && value.idsQuery) !== Boolean(previous && previous.idsQuery)) {
            var nodeID = mug.p.nodeID,
                hashPath = mug.hashtagPath,
                oldParent = mug.parentMug,
                oldHash;
            if (value && value.idsQuery) {
                oldHash = hashPath.replace(/\/item$/, "");
            } else {
                oldHash = hashPath + "/item";
                if (/\/@count$/.test(mug.p.repeat_count)) {
                    mug.p.repeat_count = "";
                }
            }
            mug.form.vellum.handleMugRename(
                mug.form, mug, nodeID, nodeID, hashPath, oldHash, oldParent);
        }
    }

    function dropSetValues(mug) {
        // remove <setvalue> elements
        if (mug.p.setvalues) {
            var setvaluesToRemove = _.groupBy(mug.p.setvalues, "_id");
            mug.form.dropSetValues(function (value) {
                return setvaluesToRemove.hasOwnProperty(value._id);
            });
        }
    }
});


define('tpl/tpl!vellum/templates/widget_update_case', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 props[""] = {calculate: "", relevant: ""}; 
__p+='\n\n';
 _.each(props, function (v, k) { 
__p+='\n  <div class="fd-update-property">\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-update-property-name form-control"\n               value="'+
((__t=(k))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Property Name")))==null?'':_.escape(__t))+
'"/>\n      </div>\n      <div class="col-sm-1">\n        <a class="btn fd-remove-property btn-sm btn-danger">\n          <i class="fa fa-remove"></i>\n        </a>\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-update-property-source form-control"\n               value="'+
((__t=(v['calculate']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Calculation")))==null?'':_.escape(__t))+
'" />\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-update-property-relevant form-control"\n               value="'+
((__t=(v['relevant']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Relevant")))==null?'':_.escape(__t))+
'"/>\n      </div>\n    </div>\n  </div>\n';
 }); 
__p+='\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/widget_index_case', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 props[""] = {calculate: "", relevant: "", case_type: "", relationship: ""}; 
__p+='\n\n';
 _.each(props, function (v, k) { 
__p+='\n  <div class="fd-index-property">\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-index-property-name form-control"\n               value="'+
((__t=(k))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Relationship Identifier (e.g. parent or host)")))==null?'':_.escape(__t))+
'"/>\n      </div>\n      <div class="col-sm-1">\n        <a class="btn fd-remove-property btn-sm btn-danger">\n          <i class="fa fa-remove"></i>\n        </a>\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-index-property-source form-control"\n               value="'+
((__t=(v['calculate']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Referenced Case ID")))==null?'':_.escape(__t))+
'" />\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-index-property-case-type form-control"\n               value="'+
((__t=(v['case_type']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Referenced Case Type")))==null?'':_.escape(__t))+
'"/>\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-index-property-relationship form-control"\n               value="'+
((__t=(v['relationship']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Relationship (child or extension)")))==null?'':_.escape(__t))+
'"/>\n      </div>\n    </div>\n  </div>\n';
 }); 
__p+='\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/widget_attachment_case', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 props[""] = {calculate: "", relevant: ""}; 
__p+='\n\n';
 _.each(props, function (v, k) { 
__p+='\n  <div class="fd-attachment-property">\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-attachment-property-name form-control"\n               value="'+
((__t=(k))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Node Name")))==null?'':_.escape(__t))+
'"/>\n      </div>\n      <div class="col-sm-1">\n        <a class="btn fd-remove-property btn-sm btn-danger">\n          <i class="fa fa-remove"></i>\n        </a>\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-attachment-property-source form-control"\n               value="'+
((__t=(v['calculate']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Source")))==null?'':_.escape(__t))+
'" />\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-attachment-property-from form-control"\n               value="'+
((__t=(v['from']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("From")))==null?'':_.escape(__t))+
'"/>\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-11">\n        <input class="fd-attachment-name form-control"\n               value="'+
((__t=(v['name']))==null?'':_.escape(__t))+
'" type="text" placeholder="'+
((__t=(gettext("Attachment Name")))==null?'':_.escape(__t))+
'"/>\n      </div>\n    </div>\n  </div>\n';
 }); 
__p+='\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/widget_save_to_case', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="well well-small">\n  '+
((__t=( internal_template({props: props}) ))==null?'':__t)+
'\n  <a class="btn btn-default fd-add-property hide"><i class="fa fa-plus"></i> '+
((__t=(gettext("Add Property")))==null?'':_.escape(__t))+
'</a>\n</div>\n<div class="messages" />\n';
}
return __p;
}; });

define('vellum/saveToCase',[
    'jquery',
    'underscore',
    'vellum/mugs',
    'vellum/tree',
    'vellum/util',
    'vellum/atwho',
    'vellum/widgets',
    'tpl!vellum/templates/widget_update_case',
    'tpl!vellum/templates/widget_index_case',
    'tpl!vellum/templates/widget_attachment_case',
    'tpl!vellum/templates/widget_save_to_case',
    'vellum/core'
], function (
    $,
    _,
    mugs,
    Tree,
    util,
    atwho,
    widgets,
    widget_update_case,
    widget_index_case,
    widget_attach_case,
    widget_save_to_case
){
    function createsCase(mug) {
        return mug ? mug.p.useCreate : false;
    }

    function closesCase(mug) {
        return mug ? mug.p.useClose : false;
    }

    function updatesCase(mug) {
        return mug ? mug.p.useUpdate : false;
    }

    function indexesCase(mug) {
        return mug ? mug.p.useIndex : false;
    }

    function attachmentCase(mug) {
        return mug ? mug.p.useAttachment : false;
    }

    function usesCases(mug) {
        return createsCase(mug) || closesCase(mug) || updatesCase(mug) ||
            indexesCase(mug) || attachmentCase(mug);
    }

    var propertyWidget = function (mug, options) {
            var widget = widgets.normal(mug, options),
                id = options.id,
                internal_template = options.template;
            options.richText = false;

            widget.input = $('<div class="control-row" />').attr('name', id);

            widget.getControl = function () {
                return widget.input;
            };

            widget.refreshControl = function (value) {
                value = value ? value : widget.getValue();
                widget.input.html(widget_save_to_case({
                    internal_template: internal_template,
                    props: value
                }));
                widget.input.find('input').on('change keyup', function () {
                    widget.handleChange();
                });
                widget.input.find('.fd-add-property').click(widget.addProperty);
                widget.input.find('.fd-remove-property').click(widget.removeProperty);
                widget.input.find('input').addClass('jstree-drop');
                widget.input.find('input').each(function() {
                    atwho.autocomplete($(this), mug);
                });
            };

            widget.setValue = function (value) {
                value = _.isUndefined(value) ? {} : value;
                widget.refreshControl(value);
            };

            widget.updateValue = function () {
                var currentValues = widget.getValue();
                if (!("" in currentValues)) {
                    widget.input.find('.btn').removeClass('hide');
                    widget.input.find('.fd-remove-property').removeClass('hide');
                }
                widget.save();
            };

            widget.removeProperty = function(e) {
                $(this).parent().parent().parent().remove();
                widget.refreshControl();
                widget.save();
                e.preventDefault();
            };

            widget.addProperty = function(e) {
                widget.refreshControl();
                e.preventDefault();
            };

            return widget;
        },
        saveCasePropWidget = function (mug, options) {
            options.template = widget_update_case;
            var widget = propertyWidget(mug, options);

            widget.getValue = function () {
                var currentValues = {};
                _.each(widget.input.find('.fd-update-property'), function (kvPair) {
                    var $pair = $(kvPair);
                    currentValues[$pair.find('.fd-update-property-name').val()] = {
                        calculate: $pair.find('.fd-update-property-source').val(),
                        relevant: $pair.find('.fd-update-property-relevant').val(),
                    };
                });
                return currentValues;
            };

            return widget;
        },
        indexCaseWidget = function (mug, options) {
            options.template = widget_index_case;
            var widget = propertyWidget(mug, options);

            widget.getValue = function () {
                var currentValues = {};
                _.each(widget.input.find('.fd-index-property'), function (kvPair) {
                    var $pair = $(kvPair);
                    currentValues[$pair.find('.fd-index-property-name').val()] = {
                        calculate: $pair.find('.fd-index-property-source').val(),
                        case_type: $pair.find('.fd-index-property-case-type').val(),
                        relationship: $pair.find('.fd-index-property-relationship').val(),
                    };
                });
                return currentValues;
            };

            return widget;
        },
        attachmentCaseWidget = function (mug, options) {
            options.template = widget_attach_case;
            var widget = propertyWidget(mug, options);

            widget.getValue = function () {
                var currentValues = {};
                _.each(widget.input.find('.fd-attachment-property'), function (kvPair) {
                    var $pair = $(kvPair);
                    currentValues[$pair.find('.fd-attachment-property-name').val()] = {
                        calculate: $pair.find('.fd-attachment-property-source').val(),
                        from: $pair.find('.fd-attachment-property-from').val(),
                        name: $pair.find('.fd-attachment-name').val(),
                    };
                });
                return currentValues;
            };

            return widget;
        };

    var CASE_XMLNS = "http://commcarehq.org/case/transaction/v2",
        VALID_PROP_REGEX = /^[a-z0-9_-]+$/i,
        saveToCaseMugOptions = {
            typeName: 'Save to Case',
            isTypeChangeable: false,
            isDataOnly: true,
            supportsDataNodeRole: true,
            icon: 'fa fa-save',
            init: function (mug, form) {
                mug.p.date_modified = mug.p.date_modified || '/data/meta/timeEnd';
                mug.p.user_id = mug.p.user_id || "instance('commcaresession')/session/context/userid";
            },
            spec: {
                xmlnsAttr: { presence: "optional" },
                "date_modified": {
                    lstring: gettext("Date Modified"),
                    visibility: 'visible',
                    presence: 'required',
                    widget: widgets.xPath,
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                },
                "user_id": {
                    lstring: gettext("User ID"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.xPath,
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                },
                "case_type": {
                    lstring: gettext("Case Type"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.text,
                },
                "case_id": {
                    lstring: gettext("Case ID"),
                    visibility: 'visible',
                    presence: 'required',
                    widget: widgets.xPath,
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                },
                useCreate: {
                    lstring: gettext("Create Case"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.checkbox
                },
                createProperty: {
                    lstring: gettext("Properties To Create"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: saveCasePropWidget,
                    validationFunc: function (mug) {
                        if (mug.p.useCreate) {
                            var props = _.without(_.keys(mug.p.createProperty), ""),
                                required = ["case_type", "case_name"],
                                optional = ["owner_id"],
                                legal = _.union(required, optional),
                                illegalProps = _.difference(props, legal),
                                requiredProps = _.intersection(props, required),
                                invalidProps = _.filter(props, function(p) {
                                    return !VALID_PROP_REGEX.test(p);
                                });

                            if (requiredProps.length !== required.length) {
                                return util.format(
                                    gettext("You must include {columns} columns to create a case"),
                                    {columns: required.join(", ")}
                                );
                            } else if (illegalProps.length > 0) {
                                return gettext("You can only use the following properties:") +
                                    " " + legal.join(', ');
                            } else if (invalidProps.length > 0) {
                                return util.format(
                                    gettext("{props} are invalid properties"),
                                    {props: invalidProps.join(", ")}
                                );
                            }

                        }
                        return 'pass';
                    }
                },
                useClose: {
                    lstring: gettext("Close Case"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.checkbox
                },
                closeCondition: {
                    lstring: gettext("Close Condition"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.xPath,
                    serialize: mugs.serializeXPath,
                    deserialize: mugs.deserializeXPath,
                },
                useUpdate: {
                    lstring: gettext("Update Case"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.checkbox
                },
                updateProperty: {
                    lstring: gettext("Properties To Update"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: saveCasePropWidget,
                    validationFunc: function (mug) {
                        if (mug.p.useUpdate) {
                            var props = _.without(_.keys(mug.p.updateProperty), ""),
                                invalidProps = _.filter(props, function(p) {
                                    return !VALID_PROP_REGEX.test(p);
                                });

                            if (invalidProps.length > 0) {
                                return util.format(
                                    gettext("{props} are invalid properties"),
                                    {props: invalidProps.join(", ")}
                                );
                            }
                        }
                        return 'pass';
                    }
                },
                useIndex: {
                    lstring: gettext("Use Index"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.checkbox
                },
                indexProperty: {
                    lstring: gettext("Index Properties"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: indexCaseWidget,
                    validationFunc: function (mug) {
                        if (mug.p.useIndex) {
                            var props = _.without(_.keys(mug.p.indexProperty), ""),
                                invalidProps = _.filter(props, function(p) {
                                    return !VALID_PROP_REGEX.test(p);
                                }),
                                relationships = _.without(_.map(mug.p.indexProperty, function (v, k) {
                                    return v.relationship;
                                }), ""),
                                invalidRelationships = _.filter(relationships, function (r) {
                                    return !_.contains(['child', 'extension'], r);
                                });

                            if (invalidProps.length > 0) {
                                return util.format(
                                    gettext("{props} are invalid properties"),
                                    {props: invalidProps.join(", ")}
                                );
                            } else if (invalidRelationships.length > 0) {
                                return gettext("Relationship must be child or extension");
                            }
                        }
                        return 'pass';
                    }
                },
                useAttachment: {
                    lstring: gettext("Use Attachments"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: widgets.checkbox
                },
                attachmentProperty: {
                    lstring: gettext("Attachment Properties"),
                    visibility: 'visible',
                    presence: 'optional',
                    widget: attachmentCaseWidget,
                    validationFunc: function (mug) {
                        if (!mug.p.useAttachment) {
                            return "pass";
                        }

                        var props = _.without(_.keys(mug.p.attachmentProperty), ""),
                            invalidProps = _.filter(props, function(p) {
                                return !VALID_PROP_REGEX.test(p);
                            }),
                            invalidFroms = _.filter(props, function(p) {
                                return !_.contains(['local', 'remote', 'inline'],
                                                   mug.p.attachmentProperty[p].from);
                            }),
                            invalidInlines = _.filter(props, function(p) {
                                var prop = mug.p.attachmentProperty[p],
                                    from = prop.from,
                                    name = prop.name;
                                return from === 'inline' && !name;
                            });

                        if (invalidProps.length > 0) {
                            return util.format(
                                gettext("{props} are invalid properties"),
                                {props: invalidProps.join(", ")}
                            );
                        }

                        if (invalidFroms.length > 0) {
                            return gettext("The from attribute must be one of: " +
                                "local, remote, or inline");
                        }
                        
                        if (invalidInlines.length > 0) {
                            return gettext("Inlined attachments must have an " +
                                "attachment name");
                        }

                        return "pass";
                    }
                }
            },
            getExtraDataAttributes: function (mug) {
                return {
                    "vellum:role": "SaveToCase",
                    "vellum:case_type": mug.p.case_type || "",
                };
            },
            dataChildFilter: function (children, mug) {
                function simpleNode(name, children, dataAttributes) {
                    children = children ? children : [];
                    var node = new Tree.Node(children, {
                        getNodeID: function () { return name; },
                        p: {
                            rawDataAttributes: null
                        },
                        options: { 
                            getExtraDataAttributes: function (mug) {
                                return dataAttributes;
                            }
                        }
                    });
                    return node;
                }

                function makeColumns(properties, dataKeys) {
                    return _.chain(properties).map(function(v, k) {
                        if (k) {
                            return simpleNode(k, [], _.pick(v, dataKeys));
                        }
                    }).compact().value();
                }

                var actions = [];
                if (createsCase(mug)) {
                    actions.push(simpleNode('create', makeColumns(mug.p.createProperty)));
                }

                if (updatesCase(mug)) {
                    actions.push(simpleNode('update', makeColumns(mug.p.updateProperty)));
                }

                if (closesCase(mug)) {
                    actions.push(simpleNode('close'));
                }

                if (indexesCase(mug)) {
                    actions.push(simpleNode('index', 
                                            makeColumns(mug.p.indexProperty, 
                                                        ['case_type', 'relationship'])));
                }

                if (attachmentCase(mug)) {
                    actions.push(simpleNode('attachment', 
                                            makeColumns(mug.p.attachmentProperty, 
                                                        ['from', 'name'])));
                }

                return [new Tree.Node(actions, {
                    getNodeID: function () { return "case"; },
                    p: {rawDataAttributes: null},
                    options: { 
                        getExtraDataAttributes: function (mug) {
                            return {
                                "xmlns": CASE_XMLNS,
                                case_id: '',
                                date_modified: '',
                                user_id: '',
                            };
                        }
                    }
                })];
            },
            getBindList: function (mug) {
                var ret = [];
                function generateBinds(action, properties) {
                    return _.chain(properties).omit("").map(function(v, k) {
                        return {
                            nodeset: mug.absolutePath + "/case/" + action + "/" + k,
                            calculate: v.calculate,
                            relevant: v.relevant
                        };
                    }).value();
                }

                if (createsCase(mug)) {
                    if (mug.isInRepeat()) {
                        ret = ret.concat({
                            nodeset: mug.absolutePath + "/case/@case_id",
                            calculate: mug.p.case_id
                        });
                    }
                    ret = ret.concat(generateBinds('create', mug.p.createProperty));
                }
                if (updatesCase(mug)) {
                    ret = ret.concat(generateBinds('update', mug.p.updateProperty));
                }
                if (closesCase(mug)) {
                    ret.push({
                        nodeset: mug.absolutePath + "/case/close",
                        relevant: mug.p.closeCondition
                    });
                }
                if (indexesCase(mug)) {
                    ret = ret.concat(generateBinds('index', mug.p.indexProperty));
                }
                if (attachmentCase(mug)) {
                    ret = ret.concat(
                        _.chain(mug.p.attachmentProperty)
                         .omit("")
                         .map(function(v, k) {
                             return {
                                 nodeset: mug.absolutePath + "/case/attachment/" + k + "/@src",
                                 calculate: v.calculate
                             };
                         }).value()
                    );
                }

                if (usesCases(mug)) {
                    ret.push({
                        nodeset: mug.absolutePath + "/case/@date_modified",
                        calculate: mug.p.date_modified,
                        type: "xsd:dateTime"
                    });
                    ret.push({
                        nodeset: mug.absolutePath + "/case/@user_id",
                        calculate: mug.p.user_id
                    });

                    if (!createsCase(mug)) {
                        ret.push({
                            nodeset: mug.absolutePath + "/case/@case_id",
                            calculate: mug.p.case_id
                        });
                    }
                }
                return ret;
            },
            parseDataNode: function (mug, $node) {
                var case_type = $node.xmlAttr('vellum:case_type'),
                    case_ = $node.children(),
                    create = case_.find('create'),
                    close = case_.find('close'),
                    update = case_.find('update'),
                    index = case_.find('index'),
                    attach = case_.find('attachment');
                if (case_type) {
                    mug.p.case_type = case_type;
                }
                if (create && create.length !== 0) {
                    mug.p.useCreate = true;
                }
                if (update && update.length !== 0) {
                    mug.p.useUpdate = true;
                }
                if (close && close.length !== 0) {
                    mug.p.useClose = true;
                }
                if (index && index.length !== 0) {
                    mug.p.useIndex = true;
                    mug.p.indexProperty = {};
                    _.each(index.children(), function(child) {
                        var prop = $(child);
                        mug.p.indexProperty[prop.prop('tagName')] = {
                            case_type: prop.xmlAttr('case_type'),
                            relationship: prop.xmlAttr('relationship')
                        };
                    });
                }
                if (attach && attach.length !== 0) {
                    mug.p.useAttachment = true;
                    if (!mug.p.attachmentProperty) {
                        mug.p.attachmentProperty = {};
                    }
                    _.each(attach.children(), function(child) {
                        var prop = $(child);
                        mug.p.attachmentProperty[prop.prop('tagName')] = {
                            from: prop.xmlAttr('from'),
                            name: prop.xmlAttr('name')
                        };
                    });
                }
                return $([]);
            },
            getSetValues: function(mug) {
                if (createsCase(mug) && !mug.isInRepeat()) {
                    return [{
                        event: 'xforms-ready',
                        ref: mug.absolutePath + '/case/@case_id',
                        value: mug.p.case_id,
                    }];
                }
                return [];
            },
            getCaseSaveData: function (mug) {
                var propertyNames = _.union(
                    _.keys(mug.p.createProperty || {}),
                    _.keys(mug.p.updateProperty || {})
                );
                return {
                    case_type: mug.p.case_type || '',
                    properties: _.filter(propertyNames, _.identity), // filter out empty properties
                    create: mug.p.useCreate || false,
                    close: mug.p.useClose || false,
                };
            },
        },
        sectionData = {
            SaveToCase: [
                {
                    slug: "main",
                    displayName: gettext("Basic"),
                    properties: [
                        "nodeID",
                        "date_modified",
                        "user_id",
                        "case_type",
                        "case_id",
                    ],
                },
                {
                    slug: "create",
                    displayName: gettext("Create"),
                    properties: [
                        "useCreate",
                        "createProperty",
                    ],
                    isCollapsed: function (mug) {
                        return !createsCase(mug);
                    },
                },
                {
                    slug: "update",
                    displayName: gettext("Update"),
                    properties: [
                        "useUpdate",
                        "updateProperty",
                    ],
                    isCollapsed: function (mug) {
                        return !updatesCase(mug);
                    },
                },
                {
                    slug: "close",
                    displayName: gettext("Close"),
                    properties: [
                        "useClose",
                        "closeCondition",
                    ],
                    isCollapsed: function (mug) {
                        return !closesCase(mug);
                    },
                },
                {
                    slug: "index",
                    displayName: gettext("Index"),
                    properties: [
                        "useIndex",
                        "indexProperty",
                    ],
                    isCollapsed: function (mug) {
                        return !indexesCase(mug);
                    },
                },
                {
                    slug: "attachment",
                    displayName: gettext("Attachments"),
                    properties: [
                        "useAttachment",
                        "attachmentProperty",
                    ],
                    isCollapsed: function (mug) {
                        return !attachmentCase(mug);
                    },
                },
            ]
        };

    $.vellum.plugin("saveToCase", {}, {
        getAdvancedQuestions: function () {
            return this.__callOld().concat(["SaveToCase"]);
        },
        handleMugParseFinish: function (mug) {
            this.__callOld();
            // cases that are created use a setvalue for case_id
            if (!createsCase(mug)) {
                return;
            }
            var ref = mug.absolutePath + "/case/@case_id",
                value = _.find(mug.form.getSetValues(), function (value) {
                    return value.ref === ref;
                });
            if (value) {
                mug.p.case_id = value.value;
                mug.form.dropSetValues(function(inner) {
                    return value === inner;
                });
            }
        },
        getMugTypes: function () {
            var types = this.__callOld();
            types.normal.SaveToCase = util.extend(
                mugs.defaultOptions, saveToCaseMugOptions);
            return types;
        },
        getSections: function (mug) {
            if (sectionData.hasOwnProperty(mug.__className)) {
                return _.map(sectionData[mug.__className], function (section) {
                    var tmpSection = _.clone(section);
                    if (_.isFunction(tmpSection.isCollapsed)) {
                        tmpSection.isCollapsed = tmpSection.isCollapsed(mug);
                    }
                    return tmpSection;
                });
            }
            return this.__callOld();
        },
        parseBindElement: function (form, el, path) {
            var mug = form.getMugByPath(path);
            if (!mug) {
                var casePathRegex = /\/case\/(?:(create|update|index)\/([\w-]+)|(close|@date_modified|@user_id|@case_id))$/,
                    matchRet = path.match(casePathRegex),
                    basePath;
                if (matchRet && matchRet.length > 0) {
                    basePath = path.replace(casePathRegex, "");
                    mug = form.getMugByPath(basePath);
                    if (mug && mug.__className === "SaveToCase") {
                        if (matchRet[2]) {
                            var prop = matchRet[2],
                                pKey = {
                                    create: "createProperty",
                                    update: "updateProperty",
                                    index: "indexProperty",
                                    attachment: "attachmentProperty",
                                }[matchRet[1]];

                            if (!mug.p[pKey]) {
                                mug.p[pKey] = {};
                            }
                            if (!mug.p[pKey][prop]) {
                                mug.p[pKey][prop] = {};
                            }
                            mug.p[pKey][prop].calculate =  el.xmlAttr("calculate");
                            if (el.xmlAttr('relevant')) {
                                mug.p[pKey][prop].relevant =  el.xmlAttr("relevant");
                            }
                            return;
                        } else {
                            var attr = {
                                close: {
                                    mugProp: 'closeCondition',
                                    elAttr: 'relevant'
                                },
                                '@date_modified': {
                                    mugProp: 'date_modified',
                                    elAttr: 'calculate'
                                },
                                '@user_id': {
                                    mugProp: 'user_id',
                                    elAttr: 'calculate'
                                },
                                '@case_id': {
                                    mugProp: 'case_id',
                                    elAttr: 'calculate'
                                },
                            }[matchRet[3]];

                            mug.p[attr.mugProp] = el.xmlAttr(attr.elAttr);
                            return;
                        }
                        form.parseWarnings.push(util.format(
                            gettext("An error occurred when parsing bind " + 
                                    "node [{path}]. Please fix this."),
                            {path: path}
                        ));
                        return;
                    }
                }
                
                var attachmentRegex = /\/case\/attachment\/(\w+)\/@src$/,
                    attachRet = path.match(attachmentRegex);
                if (attachRet) {
                    basePath = path.replace(attachmentRegex, "");
                    mug = form.getMugByPath(basePath);
                    if (mug && mug.__className === "SaveToCase") {
                        var attachProperties = mug.p.attachmentProperty,
                            nodeName = attachRet[1];
                        if (!attachProperties[nodeName]) {
                            attachProperties[nodeName] = {};
                        }
                        mug.p.attachmentProperty[nodeName].calculate = el.xmlAttr('calculate');
                        return;
                    }
                }
            }
            this.__callOld();
        }
    });
});


define('tpl/tpl!vellum/templates/multimedia_modal', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="modal fade" id="'+
((__t=( modalId ))==null?'':__t)+
'">\n    <div class="modal-dialog">\n        <div class="modal-content">\n            <div class="modal-header">\n                <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n                <h4 class="modal-title">'+
((__t=(gettext("Upload")))==null?'':_.escape(__t))+
' '+
((__t=( mediaType ))==null?'':__t)+
'</h4>\n            </div>\n            <div class="modal-body form form-horizontal">\n                <div class="form-group">\n                    <label class="col-sm-4 control-label">\n                        '+
((__t=(gettext("Select new")))==null?'':_.escape(__t))+
' '+
((__t=( mediaType ))==null?'':__t)+
'\n                    </label>\n                    <div class="col-sm-8">\n                        <button class="btn btn-primary" type="button">'+
((__t=(gettext("Select File")))==null?'':_.escape(__t))+
'</button>\n                        <input type="file" class="hide" />\n                        <div class="hqm-upload-status"></div>\n                    </div>\n                </div>\n                <div class="form-group hqm-existing hide">\n                    <label class="col-sm-4 control-label">\n                        '+
((__t=(gettext("Current")))==null?'':_.escape(__t))+
' '+
((__t=( mediaType ))==null?'':__t)+
'\n                    </label>\n                    <div class="col-sm-8 hqm-existing-controls">\n                    </div>\n                </div>\n            </div>\n            <div class="modal-footer">\n                <a class="btn btn-default" data-dismiss="modal">'+
((__t=(gettext("Close")))==null?'':_.escape(__t))+
'</a>\n                <a class="btn btn-default disabled hqm-upload hqm-upload-confirm">\n                    <i class="fa-solid fa-cloud-arrow-up"></i>\n                    <i class="fa-solid fa-spin fa-refresh hide"></i>\n                    '+
((__t=(gettext("Begin Upload")))==null?'':_.escape(__t))+
'\n                </a>\n            </div>\n        </div>\n    </div>\n</div>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/multimedia_upload_trigger', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<a href="#'+
((__t=( uploaderId ))==null?'':__t)+
'"\n   class="btn btn-primary"\n   data-toggle="modal">\n    '+
((__t=( multimediaExists ? gettext("Replace") : gettext("Upload") ))==null?'':_.escape(__t))+
' '+
((__t=(mediaType))==null?'':__t)+
'\n</a>\n';
}
return __p;
}; });


define('text/text!vellum/templates/multimedia_upload_status.html',[],function () { return '<div style="clear: both;">\n    <div class="alert alert-success" style="margin-bottom: 2px; margin-top: 10px;">\n        <i class="fa fa-check"></i> <%= file_name %> <strong>[<%= file_size %> MB]</strong>\n    </div>\n    <p class="text-success hqm-begin">\n      <%=gettext("Ready to upload. Click <strong>Begin Upload</strong> below to start.")%>\n    </p>\n    <p class="text-danger hqm-error hide">\n        <span class="label label-danger"><%-gettext("There were errors.")%></span>\n    </p>\n    <div class="hqm-errors"></div>\n</div>\n';});


define('text/text!vellum/templates/multimedia_errors.html',[],function () { return '<% if (errors.length > 0) { %>\n    <div class="alert alert-danger">\n        <% for (var e = 0; e < errors.length; e++) {\n            var error = errors[e]; %>\n            <p><%- error %></p>\n        <% } %>\n    </div>\n<% } %>\n';});


define('text/text!vellum/templates/multimedia_existing_image.html',[],function () { return '<p>\n    <img src="<%=url %>?thumb=100" alt="uploaded image" />\n    <a href="<%= url %>"\n       class="btn btn-default existing-media"\n       target="_blank"\n       data-toggle="tooltip" data-title="<%-gettext("Opens image in new tab.")%>"><%-gettext("View Full Size")%></a>\n</p>\n<p class="text-success hqm-upload-completed hide">\n    <span class="label label-success"><%-gettext("New Image Uploaded Successfully")%></span>\n</p>\n';});


define('text/text!vellum/templates/multimedia_existing_audio.html',[],function () { return '<p>\n    <a href="<%= url %>"\n       class="btn btn-default existing-media"\n       target="_blank"\n       data-toggle="tooltip" data-title="<%-gettext("Opens file in new tab.")%>"><%-gettext("Open Audio")%></a>\n</p>\n<p class="text-success hqm-upload-completed hide">\n    <span class="label label-success"><%-gettext("New Audio Uploaded Successfully")%></span>\n</p>\n';});


define('text/text!vellum/templates/multimedia_existing_video.html',[],function () { return '<p>\n    <a href="<%= url %>"\n       class="btn btn-default existing-media"\n       target="_blank"\n       data-toggle="tooltip" data-title="<%-gettext("Opens file in new tab.")%>"><%-gettext("Open Video")%></a>\n</p>\n<p class="text-success hqm-upload-completed hide">\n    <span class="label label-success"><%-gettext("New Video Uploaded Successfully")%></span>\n</p>\n';});


define('text/text!vellum/templates/multimedia_existing_text.html',[],function () { return '<p>\n    <a href="<%= url %>"\n       class="btn btn-default existing-media"\n       target="_blank"\n       data-toggle="tooltip" data-title="<%-gettext("Opens file in new tab.")%>"><%-gettext("Open HTML")%></a>\n</p>\n<p class="text-success hqm-upload-completed hide">\n    <span class="label label-success"><%-gettext("New HTML Document Uploaded Successfully")%></span>\n</p>\n';});


define('tpl/tpl!vellum/templates/multimedia_nomedia', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<p class="fd-mm-no-ref">\n    <i class="'+
((__t=(iconClass))==null?'':__t)+
'"></i>\n    '+
((__t=(gettext("No Reference")))==null?'':_.escape(__t))+
'\n</p>\n';
}
return __p;
}; });


define('tpl/tpl!vellum/templates/multimedia_block', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="control-row">\n    <div class="col-sm-12">\n        <button type="button" class="btn btn-default fd-mm-path-show pull-right">\n            <i class="fa fa-cog"></i>\n            '+
((__t=(gettext("Advanced: Show Path")))==null?'':_.escape(__t))+
'\n        </button>\n        <div class="fd-mm-upload-trigger"></div>\n    </div>\n</div>\n<div class="control-row">\n    <div class="fd-mm-path hide col-sm-12">\n        <button type="button" class="btn btn-default fd-mm-path-hide pull-right">'+
((__t=(gettext("Hide Path")))==null?'':_.escape(__t))+
'</button>\n        <div class="fd-mm-path-input"></div>\n    </div>\n</div>\n';
}
return __p;
}; });

define('vellum/uploader',[
    'require',
    'module',
    'underscore',
    'jquery',
    'tpl!vellum/templates/multimedia_modal',
    'tpl!vellum/templates/multimedia_upload_trigger',
    'text!vellum/templates/multimedia_upload_status.html',
    'text!vellum/templates/multimedia_errors.html',
    'text!vellum/templates/multimedia_existing_image.html',
    'text!vellum/templates/multimedia_existing_audio.html',
    'text!vellum/templates/multimedia_existing_video.html',
    'text!vellum/templates/multimedia_existing_text.html',
    'tpl!vellum/templates/multimedia_nomedia',
    'tpl!vellum/templates/multimedia_block',
    'vellum/core'
], function (
    require,
    module,
    _,
    $,
    multimedia_modal,
    multimedia_upload_trigger,
    multimedia_upload_status,
    multimedia_errors,
    multimedia_existing_image,
    multimedia_existing_audio,
    multimedia_existing_video,
    multimedia_existing_text,
    multimedia_nomedia,
    multimedia_block
) {
    "use strict";

    var SLUG_TO_DESCRIPTION = {
        image: gettext('Image'),
        audio: gettext('Audio'),
        video: gettext('Video'),
        'video-inline': gettext('Inline Video'),
        text: gettext('HTML'),
    },
    PREVIEW_TEMPLATES = {
        image: multimedia_existing_image,
        audio: multimedia_existing_audio,
        video: multimedia_existing_video,
        'video-inline': multimedia_existing_video,
        text:  multimedia_existing_text,
    },
    SLUG_TO_CLASS = {
        image: 'CommCareImage',
        audio: 'CommCareAudio',
        video: 'CommCareVideo',
        'video-inline': 'CommCareVideo',
        text:  'CommCareMultimedia',
    },
    SLUG_TO_UPLOADER_SLUG = {
        image: 'fd_hqimage',
        audio: 'fd_hqaudio',
        video: 'fd_hqvideo',
        'video-inline': 'fd_hqInlineVideo',
        text:  'fd_hqtext',
    },
    EXT = /(\.[^\/.]+)?$/;

    // These functions were extracted out when separating the uploader code from
    // the JavaRosa Itext media widget code.  They could easily be made part of
    // the plugin interface in order to avoid passing around objectMap and
    // uploadControllers, but it seems fine either way.
    var multimediaReference = function (mediaType, objectMap, uploadControllers) {
        var ref = {};
        ref.mediaType = mediaType;

        ref.updateRef = function (path) {
            ref.path = path;
            ref.linkedObj = objectMap[path];
        };

        ref.isMediaMatched = function () {
            return _.isObject(ref.linkedObj);
        };

        ref.getUrl = function () {
            return ref.linkedObj ? ref.linkedObj.url : undefined;
        };

        ref.updateController = function (widget) {
            var uploadController = uploadControllers[ref.mediaType];
            uploadController.currentReference = ref;
            uploadController.updateMediaPath = function () {
                var params = uploadController.uploadParams;
                params.path = widget.getRandomizedMediaPath(params.path);
                widget.updateReference(params.path);
            };
            uploadController.uploadParams = {
                path: ref.path,
                media_type : SLUG_TO_CLASS[ref.mediaType],
                old_ref: (ref.isMediaMatched()) ? ref.linkedObj.m_id : "",
                replace_attachment: true
            };
        };

        return ref;
    };

    var addUploaderToWidget = function (widget, objectMap, uploadControllers) {
        widget.mediaRef = multimediaReference(widget.form, objectMap, uploadControllers);

        if (!widget.getBaseMediaPath) {
            throw new Error("required method not found: widget.getBaseMediaPath()");
        }

        widget.getRandomizedMediaPath = function (oldPath) {
            // The file type extension of the path returned here is replaced by
            // the extension of the uploaded file.
            var extension = EXT.exec(oldPath)[0].toLowerCase() || ".xyz",
                // generates 1 or 2 duplicates in 100K samples (probably random enough)
                rand6 = Math.random().toString(36).slice(2, 8);
            return widget.getBaseMediaPath() + "-" + rand6 + extension;
        };

        var getValue = widget.getItextValue || widget.getValue,
            $input = widget.getControl(),
            $uiElem = $('<div />'),
            _getParentUIElement = widget.getUIElement,
            $previewContainer = $('<div />')
                .addClass('fd-mm-preview-container'),
            ICONS = widget.mug.form.vellum.data.javaRosa.ICONS;

        widget.getUploaderModal = function () {
            return $("#" + SLUG_TO_UPLOADER_SLUG[widget.form]);
        };

        widget.updateModalExistingFile = function (objectMap, isComplete) {
            var ICONS = widget.mug.form.vellum.data.javaRosa.ICONS,
                $uploaderModal = widget.getUploaderModal(),
                $existingFile = $uploaderModal.find(".hqm-existing");
            if (widget.mediaRef.getUrl() && widget.mediaRef.isMediaMatched()) {
                $existingFile.removeClass('hide');
                $existingFile.find('.hqm-existing-controls').html(getPreviewUI(widget, objectMap, ICONS));
                if (isComplete) {
                    $uploaderModal.find(".hqm-upload-completed").removeClass('hide');
                }
            } else {
                $existingFile.addClass('hide');
                $existingFile.find('.hqm-existing-controls').empty();
            }
            $('.existing-media').tooltip({
                placement: 'bottom',
            });
        };

        widget.getUIElement = function () {
            $uiElem = _getParentUIElement();
            var $controlBlock = $uiElem.find('.controls'),
                $uploadContainer = $('<div />')
                    .addClass('fd-mm-upload-container');
            $controlBlock.empty()
                .addClass('control-row').data('form', widget.form);

            widget.updateReference();

            $previewContainer.html(getPreviewUI(widget, objectMap, ICONS));
            $controlBlock.append($previewContainer);

            $uploadContainer.html(multimedia_block());

            $uploadContainer.find('.fd-mm-upload-trigger')
                .append(getUploadButtonUI(widget, objectMap));
            $uploadContainer.find('.fd-mm-path-input')
                .append($input);

            $uploadContainer.find('.fd-mm-path-show').click(function (e) {
                var $showBtn = $(this);
                $showBtn.addClass('hide');
                $uploadContainer.find('.fd-mm-path').removeClass('hide');
                e.preventDefault();
            });

            $uploadContainer.find('.fd-mm-path-hide').click(function (e) {
                var $hideBtn = $(this);
                $hideBtn.parent().addClass('hide');
                $uploadContainer.find('.fd-mm-path-show').removeClass('hide');
                e.preventDefault();
            });
            $input.on("change keyup", function () {
                widget.updateMultimediaBlockUI(objectMap);
            });
            $uiElem.on('mediaUploadComplete', function (event, data) {
                widget.handleUploadComplete(event, data, objectMap);
            });

            $controlBlock.append($uploadContainer);

            // reapply bindings because we removed the input from the UI
            $input.on("change keyup", widget.updateValue);

            return $uiElem;
        };

        widget.handleUploadComplete = function (event, data, objectMap) {
            if (data.ref && data.ref.path) {
                if (getValue() !== data.ref.path) {
                    widget.getControl().val(data.ref.path);
                    widget.handleChange();
                }
                objectMap[data.ref.path] = data.ref;
            }

            widget.updateMultimediaBlockUI(objectMap);
            widget.updateModalExistingFile(objectMap, true);
        };

        widget.updateMultimediaBlockUI = function (objectMap) {
            $previewContainer.html(getPreviewUI(widget, objectMap, ICONS))
                .find('.existing-media').tooltip();

            $uiElem.find('.fd-mm-upload-trigger')
                .empty()
                .append(getUploadButtonUI(widget, objectMap));

            widget.updateReference();
        };

        widget.updateReference = function (path) {
            var currentPath = path || getValue();
            $uiElem.attr('data-hqmediapath', currentPath);
            widget.mediaRef.updateRef(currentPath);
        };
    };

    var getPreviewUI = function (widget, objectMap, ICONS) {
        var javarosa = _.isFunction(widget.getItextValue),
            hasItext = _.isFunction(widget.getItextItem),
            currentPath = javarosa ? widget.getItextValue() : widget.getValue(),
            previewHtml;
        if (hasItext && !javarosa && !currentPath && !widget.isDefaultLang) {
            currentPath = widget.getItextItem().get(widget.form, widget.defaultLang);
        }
        if (currentPath in objectMap) {
            var linkedObject = objectMap[currentPath];
            previewHtml = _.template(PREVIEW_TEMPLATES[widget.form])({
                url: linkedObject.url
            });
        } else {
            previewHtml = multimedia_nomedia({
                iconClass: ICONS[widget.form]
            });
        }
        return previewHtml;
    };

    var getUploadButtonUI = function (widget, objectMap) {
        var currentPath = widget.getItextValue ? widget.getItextValue() : widget.getValue(),
            $uploadBtn;
        $uploadBtn = $(multimedia_upload_trigger({
            multimediaExists: currentPath in objectMap,
            uploaderId: SLUG_TO_UPLOADER_SLUG[widget.form],
            mediaType: SLUG_TO_DESCRIPTION[widget.form],
        }));
        $uploadBtn.click(function () {
            widget.mediaRef.updateController(widget);
            var $uploaderModal = widget.getUploaderModal();
            $uploaderModal.find(".hqm-upload-status").empty();
            widget.updateModalExistingFile(objectMap);
        });

        return $uploadBtn;
    };

    $.vellum.plugin("uploader", {
        objectMap: false,
        uploadUrls: {
            image: false,
            audio: false,
            video: false,
            'video-inline': false,
            text: false
        },
    }, {
        init: function () {
            var opts = this.opts().uploader,
                uploadUrls = opts.uploadUrls,
                uploadEnabled = opts.objectMap && opts.uploadUrls && 
                    opts.uploadUrls.image;

            this.data.uploader.uploadEnabled = uploadEnabled;
            this.data.uploader.objectMap = opts.objectMap;
            if (!uploadEnabled) {
                return;
            }

            this.data.uploader.uploadControllers = {
                'image': this.initUploadController({
                    uploaderSlug: 'fd_hqimage',
                    mediaType: 'image',
                    uploadUrl: uploadUrls.image,
                }),
                'audio': this.initUploadController({
                    uploaderSlug: 'fd_hqaudio',
                    mediaType: 'audio',
                    uploadUrl: uploadUrls.audio,
                }),
                'video': this.initUploadController({
                    uploaderSlug: 'fd_hqvideo',
                    mediaType: 'video',
                    uploadUrl: uploadUrls.video,
                }),
                'video-inline': this.initUploadController({
                    uploaderSlug: 'fd_hqInlineVideo',
                    mediaType: 'video-inline',
                    uploadUrl: uploadUrls.video,
                }),
                'text': this.initUploadController({
                    uploaderSlug: 'fd_hqtext',
                    mediaType: 'text',
                    uploadUrl: uploadUrls.text,
                })
            };
        },
        initMediaUploaderWidget: function (widget) {
            this.__callOld();
            if (!this.data.uploader.uploadEnabled) {
                return;
            }

            addUploaderToWidget(widget,
                                this.data.uploader.objectMap,
                                this.data.uploader.uploadControllers);
        },
        initUploadController: function (options) {
            var $uploaderModal = $(multimedia_modal({
                mediaType: options.mediaType,
                modalId: options.uploaderSlug
            }));
            this.$f.find('.fd-multimedia-modal-container').append($uploaderModal);

            // Don't allow user to close modal while server is processing upload
            var allowClose = true;
            $uploaderModal.on('hide.bs.modal', function (event) {
                if (!allowClose) {
                    event.preventDefault();
                }
            });

            var $fileInputTrigger = $uploaderModal.find(".btn-primary"),
                $fileInput = $uploaderModal.find("input[type='file']"),
                $uploadButton = $uploaderModal.find(".hqm-upload-confirm"),
                _updateUploadButton = function (enable, spin) {
                    if (enable) {
                        $uploadButton.removeClass('disabled');
                    } else {
                        $uploadButton.addClass('disabled');
                    }
                    if (spin) {
                        $uploadButton.find(".fa-spin").removeClass("hide");
                        $uploadButton.find(".fa-cloud-arrow-up").addClass("hide");
                    } else {
                        $uploadButton.find(".fa-spin").addClass("hide");
                        $uploadButton.find(".fa-cloud-arrow-up").removeClass("hide");
                    }
                };

            $fileInputTrigger.click(function () {
                $fileInput.click();
            });

            $fileInput.change(function () {
                var MEGABYTE = 1048576,
                    $uploadStatusContainer = $uploaderModal.find(".hqm-upload-status");

                if ($fileInput.get(0).files.length) {
                    var file = $fileInput.get(0).files[0];
                    $uploadStatusContainer.html(_.template(multimedia_upload_status)({
                        file_size: (file.size / MEGABYTE).toFixed(3),
                        file_name: file.name,
                    }));
                    _updateUploadButton(true, false);
                } else {
                    $uploadStatusContainer.empty();
                    _updateUploadButton(false, false);
                }
            });

            var uploadController = {};
            $uploadButton.click(function () {
                _updateUploadButton(false, true);
                allowClose = false;

                var file = $fileInput.get(0).files[0],
                    data = new FormData();
                data.append("Filedata", file);
                uploadController.updateMediaPath();

                var newExtension = '.' + file.name.split('.').pop().toLowerCase();
                uploadController.uploadParams.path = uploadController.uploadParams.path.replace(/(\.[^/.]+)?$/, newExtension);

                _.each(uploadController.uploadParams, function (value, key) {
                    data.append(key, value);
                });

                var $uploadStatusContainer = $uploaderModal.find(".hqm-upload-status");
                $.ajax({
                    url: options.uploadUrl,
                    type: 'POST',
                    data: data,
                    contentType: false,
                    processData: false,
                    enctype: 'multipart/form-data',
                    success: function (response) {
                        response = JSON.parse(response);
                        $('[data-hqmediapath^="' + response.ref.path.replace(/\.\w+$/, ".") + '"]').trigger('mediaUploadComplete', response);
                        $uploadStatusContainer.empty();
                        _updateUploadButton(false, false);
                        allowClose = true;
                    },
                    error: function (response) {
                        response = JSON.parse(response.responseText);
                        $uploadStatusContainer.find(".hqm-error").show();
                        $uploadStatusContainer.find(".hqm-errors").html(_.template(multimedia_errors)({
                            errors: response.errors,
                        }));
                        $uploadStatusContainer.find(".hqm-begin").hide();
                        _updateUploadButton(false, false);
                        allowClose = true;
                    },
                });
            });

            return uploadController;
        },
    });
});


define('tpl/tpl!vellum/templates/copy_paste_help', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-copy-paste-help">\n    <h3>'+
((__t=(gettext("Copying and Pasting Questions")))==null?'':_.escape(__t))+
'</h3>\n    <div class="copy-paste-help">\n        '+
((__t=(gettext("These actions are available via the browser's Edit menu, and you can also use:")))==null?'':_.escape(__t))+
'\n        <div class="row">\n            <div class="col-sm-3">\n                <h1>'+
((__t=(metachar))==null?'':__t)+
'C</h1>\n                <span>'+
((__t=(gettext("for copy")))==null?'':_.escape(__t))+
'</span>\n            </div>\n            <!--div class="col-sm-3">\n                <h1>'+
((__t=(metachar))==null?'':__t)+
'X</h1>\n                <span>for cut</span>\n            </div-->\n            <div class="col-sm-3">\n                <h1>'+
((__t=(metachar))==null?'':__t)+
'V</h1>\n                <span>'+
((__t=(gettext("for paste")))==null?'':_.escape(__t))+
'</span>\n            </div>\n        </div>\n    </div>\n    <div class="copy-paste-box hide">\n        <p>'+
((__t=(gettext("Copy from or Paste into this text box:")))==null?'':_.escape(__t))+
' <textarea></textarea></p>\n        <p><button class="btn btn-default insert-questions">'+
((__t=(gettext("Insert Questions")))==null?'':_.escape(__t))+
'</button></p>\n    </div>\n    <h3>'+
((__t=(gettext("Selecting Multiple Questions")))==null?'':_.escape(__t))+
'</h3>\n    <div class="row">\n        ';

            var key = metachar.endsWith("+") ? metachar.slice(0, -1) : metachar;
            key = "<strong>" + key + "</strong>";
            print(format(gettext("Hold {key} and click on each question."), {key: key}));
        
__p+='\n    </div>\n    <h3>'+
((__t=(gettext("Other Tips")))==null?'':_.escape(__t))+
'</h3>\n    <p>'+
((__t=(gettext("Questions can be copied between forms, and even to other apps.")))==null?'':_.escape(__t))+
'</p>\n</div>\n';
}
return __p;
}; });

define('vellum/copy-paste',[
    'jquery',
    'underscore',
    'tpl!vellum/templates/copy_paste_help',
    'vellum/mugs',
    'vellum/tsv',
    'vellum/util',
    'vellum/hqAnalytics',
    'vellum/core'
], function (
    $,
    _,
    copy_paste_help,
    mugsModule,
    tsv,
    util,
    analytics
) {
    var PREAMBLE = ["Form Builder clip", "version 1"],
        vellum,
        offScreen = {top: -10000, left: -10000},
        hiddenTextarea = $('<textarea></textarea>').css({
            position: 'absolute',
            width: 0,
            height: 0
        }).css(offScreen).appendTo('body'),
        isChrome = /Chrome/.test(navigator.userAgent),
        isSafari = /Safari/.test(navigator.userAgent) && !isChrome;

    function focusTextarea($focus, value) {
        if ($focus.length === 0) {
            $focus = $("body");
        }
        hiddenTextarea.css({top: $focus.offset().top});
        hiddenTextarea.val(value);
        hiddenTextarea.focus();
        hiddenTextarea.select();
    }

    function unfocusTextarea($focus, clear) {
        $focus.focus();
        var value = hiddenTextarea.val();
        if (clear && value) {
            // HACK fix intermittent multiple-paste on Chrome (timing related?)
            hiddenTextarea.val("");
        }
        return value;
    }

    function onCut(opts) {
        var $focus = $(':focus');
        if ($focus.is('.jstree-anchor')) {
            var text = opts.cut();
            if (text) {
                focusTextarea($focus, text);
                setTimeout(function () {
                    unfocusTextarea($focus);
                }, 10);
            }
        }
    }

    function onCopy(opts) {
        var $focus = $(':focus');
        if ($focus.is('.jstree-anchor')) {
            var text = opts.copy();
            if (text) {
                focusTextarea($focus, text);
                setTimeout(function () {
                    unfocusTextarea($focus);
                }, 10);
            }
        }
    }

    function onPaste(opts) {
        var $focus = $(':focus');
        if ($focus.length === 0 || $focus.parents('.fd-tree').length ||
                                   $focus.is(hiddenTextarea)) {
            focusTextarea($focus);
            setTimeout(function () {
                var pasteValue = unfocusTextarea($focus, true);
                // on chrome this gets called twice,
                // the first time with a blank value
                if (pasteValue) {
                    var errors = opts.paste(pasteValue);
                    if (errors.length) {
                        vellum._resetMessages([{
                            level: "parse-warning",
                            message: errors,
                        }]);
                    }
                }
            }, 0);
        }
    }

    // matches strings that could be JSON; see http://json.org/
    var JSON_STRING = /^(null|true|false|\[[^]*\]|\{[^]*\}|"[^]*"|-?\d+(\.\d+)?([Ee][+-]?\d+)?)$/;

    /**
     * Convert value to string
     *
     * Does nothing to strings that do not look like JSON. The idea
     * behind this (along with valuify) is to make the output as human
     * readable as possible while maintaining lossless de/serialization.
     */
    function stringify(value) {
        if (_.isString(value) && !JSON_STRING.test(value)) {
            return value;
        }
        return JSON.stringify(value);
    }

    /**
     * Convert string to value
     *
     * Strings that look like JSON will be parsed as JSON, otherwise the
     * string value is passed through unchanged.
     */
    function valuify(string) {
        if (JSON_STRING.test(string)) {
            return JSON.parse(string);
        }
        return string;
    }

    function headerKey(item) {
        var TYPE = 1,
            LANG = 2,
            FORM = 3,
            rank = "1",
            itext = /^(.*)Itext(?::([^-]+)-(.*))?$/.exec(item);
        if (itext) {
            rank = "0"; // itext before other fields
            // label before all other itext types
            if (itext[TYPE] === "label") { itext[TYPE] = "!"; }
            if (itext[FORM] === "default") {
                itext[FORM] = "!"; // default form before other forms
            } else if (!itext[FORM]) {
                itext[FORM] = "~"; // itext ID after forms
            }
            // sort by itext type, then form, then language
            item = itext[TYPE] + " " + itext[FORM] + " " + itext[LANG];
        }
        return rank + item;
    }

    function nameOf(type) {
        var mugType = vellum.data.core.mugTypes.allTypes[type];
        return (mugType && mugType.typeName) || type;
    }

    function getInsertTargetAndPosition(node, values) {
        var pos, after;
        while (true) {
            if (!node.parent || values.id.startsWith(node.id + "/")) {
                // node is the paste root or a possible parent (by path)
                // insert after if path does not start with previous node path
                after = node.id && !values.id.startsWith(node.id + "/");
                pos = vellum.getInsertTargetAndPosition(node.mug, values.type, after);
                break;
            }
            node = node.parent;
        }
        if (!pos) {
            pos = {};
            if (!node.mug) {
                pos.error = util.format(
                    gettext("Cannot insert {type} into tree root"),
                    {type: nameOf(values.type)}
                );
            } else {
                pos.error = gettext("Cannot insert $1 into or after $2")
                        .replace("$1", nameOf(values.type))
                        .replace("$2", nameOf(node.mug.__className));
            }
        } else {
            // verify that item will be inserted inside the paste root
            while (node.mug !== pos.mug) {
                if (!node.parent) {
                    // valid insertion point was outside of the paste root
                    pos.error = gettext("Cannot insert $1 into $2")
                        .replace("$1", nameOf(values.type))
                        .replace("$2", nameOf(node.mug.parentMug.__className));
                    return pos;
                }
                node = node.parent;
            }
            if (pos.position === "after") {
                pos.parent = node.parent;
            } else if (pos.position === "last" || pos.position === "into") {
                pos.parent = node;
            } else {
                // should never happen
                pos.error = "Cannot insert $1 $2 $3"
                    .replace("$1", nameOf(values.type))
                    .replace("$2", pos.position)
                    .replace("$3", nameOf(pos.mug.__className));
            }
        }
        return pos;
    }

    function cut() {
        var data = copy(true),
            mugs = vellum.getCurrentlySelectedMug(true);
        analytics.usage("Copy Paste", "Cut", mugs.length);
        analytics.workflow("Cut questions in form builder");
        mugs = _.filter(mugs, function (mug) { return mug.options.isCopyable; });
        if (mugs && mugs.length) {
            vellum.data.core.form.removeMugsFromForm(mugs);
        }
        return data;
    }

    function copy(skip_analytics) {
        var mugs = vellum.getCurrentlySelectedMug(true, true),
            seen = {};
        if (!skip_analytics) {
            analytics.usage("Copy Paste", "Copy", mugs.length);
            analytics.workflow("Copy questions in form builder");
        }
        if (!mugs || !mugs.length) { return ""; }

        function serialize(mug) {
            if (seen.hasOwnProperty(mug.ufid)) {
                return;
            }
            seen[mug.ufid] = true;
            if (!mug.options.isCopyable) {
                return;
            }
            var row = mug.serialize(),
                children = form.getChildren(mug);
            _.each(row, function (value, key) {
                if (!headings.hasOwnProperty(key)) {
                    header.push(key);
                    headings[key] = true;
                }
            });
            if (children.length) {
                row = [row].concat(_.map(children, serialize));
            }
            return row;
        }

        var headings = {id: true, type: true},
            header = [],
            form = mugs[0].form,
            rows = _.filter(_.flatten(_.map(mugs, serialize)), _.identity);

        if (rows.length === 0) {
            return "";
        }
        header = ["id", "type"].concat(_.sortBy(header, headerKey));
        return tsv.tabDelimit([PREAMBLE, header].concat(_.map(rows, function (row) {
            return _.map(header, function (key) {
                var val = row[key];
                return stringify(_.isUndefined(val) ? null : val);
            });
        })));
    }

    function paste(data) {
        analytics.workflow("Paste questions in form builder");
        var next = tsv.makeRowParser(data);
        if (!_.isEqual(next().slice(0, 2), PREAMBLE)) {
            return [gettext("Unsupported paste format")];
        }
        var types = vellum.data.core.mugTypes.allTypes,
            form = vellum.data.core.form,
            pasted = pasteContext(form),
            context = pasted.context,
            selected = vellum.getCurrentlySelectedMug(true, true),
            mug = selected.length ? selected[selected.length - 1] : null,
            header = next(),
            row = next(),
            node = {id: null, mug: mug, parent: null},
            values, pos;
        vellum.beforeBulkInsert(form);
        for (; row; row = next()) {
            try {
                values = _.object(header, _.map(row, function (str) {
                    return valuify(str);
                }));
            } catch (err) {
                context.addError(gettext("Unsupported paste format:") + " " + row.join(", "));
                continue;
            }
            if (!types.hasOwnProperty(values.type)) {
                context.addError(gettext("Unknown question type:") + " " + row.join(", "));
                continue;
            }
            pos = getInsertTargetAndPosition(node, values);
            if (pos.hasOwnProperty("error")) {
                context.addError(pos.error);
                continue;
            }
            mug = form.createQuestion(pos.mug, pos.position, values.type, true);
            mug.deserialize(values, context);
            pasted.addMug(values.id, mug);
            node = {
                id: values.id,
                mug: mug,
                parent: pos.parent,
            };
        }
        pasted.finish();
        vellum.afterBulkInsert(form);
        if (mug && pos) {
            vellum.setCurrentMug(mug);
        }
        analytics.usage("Copy Paste", "Paste", pasted.length);
        return pasted.getErrors();
    }

    function pasteContext(form) {
        function addError(message) {
            errors.update(null, {
                key: message,
                level: mugsModule.ERROR,
                message: message
            });
        }

        function addMug(id, mug) {
            mugs[id] = mug;
            self.length++;
        }

        function transform(hashtag) {
            var path = hashtag.replace(/^#form/, "");
            return mugs.hasOwnProperty(path) ? mugs[path].hashtagPath : hashtag;
        }

        function transformHashtags(value) {
            return form.transformHashtags(value, transform);
        }

        function doLater(fn) {
            later.push(fn);
        }

        function finish() {
            _.each(later, function (fn) { fn(); });
        }

        var errors = new mugsModule.MugMessages(),
            mugs = {},
            later = [],
            context = {
                addError: addError,
                errors: errors,
                later: doLater,
                transformHashtags: transformHashtags,
            },
            self = {
                length: 0,
                context: context,
                addMug: addMug,
                getErrors: errors.get.bind(errors),
                finish: finish,
            };

        return self;
    }

    $.vellum.plugin('copyPaste', {
        cut: cut,
        copy: copy,
        paste: paste
    }, {
        init: function () {
            var opts = this.opts().copyPaste;
            vellum = this;

            // Firefox only fires copy/paste when it thinks it's appropriate
            // Chrome doesn't fire copy/paste after key down has changed the focus
            // So we need implement both copy/paste as catching keystrokes Ctrl+C/V
            $(document).on('cut copy paste keydown', function (e) {
                if (e.type === 'cut' || util.getKeyChord(e) === 'Ctrl+X') {
                    // Disable cut until undo feature is implemented
                    if (false) { onCut(opts); }
                } else if (e.type === 'copy' || util.getKeyChord(e) === 'Ctrl+C') {
                    onCopy(opts);
                } else if (e.type === 'paste' || util.getKeyChord(e) === 'Ctrl+V') {
                    onPaste(opts);
                }
            });
        },
        displayMultipleSelectionView: function () {
            this.__callOld();
            function showCopyPasteBox() {
                copyPasteHelp.hide();
                copyPasteBox.removeClass("hide");
                copyPasteArea.val(copy(true));
            }
            var html = $(copy_paste_help({
                    "metachar": (util.isMac ? "\u2318" : "Ctrl+"),
                    "format": util.format,
                })),
                copyPasteHelp = html.find(".copy-paste-help"),
                copyPasteBox = html.find(".copy-paste-box"),
                copyPasteArea = copyPasteBox.find("textarea");
            if (isSafari) {
                // HACK show textarea for copy/paste because the hidden
                // textarea dance doesn't work in Safari
                showCopyPasteBox();
                setTimeout(function () {
                    copyPasteArea.focus().select();
                }, 1);
            } else {
                // hidden feature: show copy/paste box on click help div
                copyPasteHelp.click(function () {
                    showCopyPasteBox();
                    copyPasteArea.focus().select();
                });
            }
            copyPasteArea.focus(function () {
                copyPasteArea.select().mouseup(function() {
                    copyPasteArea.off('mouseup');
                    return false;
                });
            }).keyup(function (e) {
                // workaround for webkit: http://stackoverflow.com/a/12114908
                if(e.which === 9) { // tab
                    copyPasteArea.select();
                }
            });
            html.find(".insert-questions").click(function () {
                paste(copyPasteArea.val());
            });
            this.$f.find(".fd-props-content").html(html);
        }
    });

    return {
        cut: cut,
        copy: copy,
        paste: paste,
        stringify: stringify,
        valuify: valuify
    };
});


define('tpl/tpl!vellum/templates/commander', ['underscore'], function (_) { return function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="fd-commander">\n    <i class="fa-solid fa-xmark fd-commander-close"></i>\n    <input type="text" class="form-control" placeholder="'+
((__t=(gettext('Enter command')))==null?'':_.escape(__t))+
'" />\n</div>\n';
}
return __p;
}; });

/**
 * Command bar plugin
 */
define('vellum/commander',[
    'jquery',
    'underscore',
    'vellum/hqAnalytics',
    'vellum/atwho',
    'vellum/util',
    'tpl!vellum/templates/commander',
], function (
    $,
    _,
    analytics,
    atwho,
    util,
    commanderTemplate
) {
    var fn = {},
        handlers = {};

    $.vellum.plugin('commander', {}, {
        init: function () {
            var vellum = this,
                cmd = vellum.data.commander;
            cmd.vellum = vellum;
            cmd.container = $(commanderTemplate());
            cmd.addQuestionButton = vellum.$f.find(".fd-add-question");
            cmd.input = cmd.container.find("input");
            cmd.input.on("keydown", function (e) {
                var chord = util.getKeyChord(e);
                if (handlers.hasOwnProperty(chord)) {
                    handlers[chord](cmd);
                    e.preventDefault();
                } else {
                    cmd.input.removeClass("alert-danger");
                }
            });
            cmd.container.find(".fd-commander-close").click(function (e) {
                hideCommander(cmd);
            });
            $(".fd-add-question-dropdown").append(cmd.container.hide());
        },
        getToolsMenuItems: function () {
            var menuItems = this.__callOld();
            menuItems.splice(menuItems.length - 1, 0, {
                name: gettext('Command Bar'),
                icon: "fa fa-terminal",
                hotkey: "Ctrl+;",
                action: function () { showCommander(this.data.commander); },
            });
            return menuItems;
        },
    });

    function showCommander(cmd) {
        setupAutocomplete(cmd);
        cmd.addQuestionButton.hide();
        cmd.container.show();
        cmd.input.focus().select();
    }

    function hideCommander(cmd) {
        cmd.addQuestionButton.show();
        cmd.container.hide();
        cmd.input.val("").removeClass("alert-danger");
    }

    function setupAutocomplete(cmd) {
        if (cmd.atwhoConfig) {
            return;
        }
        _.extend(cmd, configure(cmd.vellum));
        cmd.input.atwho(cmd.atwhoConfig);
        atwho.autocomplete(
            cmd.input,
            {form: cmd.vellum.data.core.form, on: _.identity},  // fake mug
            {useHashtags: true, tabSelectsMatch: true}          // options
        );
        cmd.vellum.data.core.form.on("change-display-language", function() {
            // NOTE this is tightly coupled with atwho.autocomplete(...), which
            // calls $input.atwho('destroy') on change-display-language
            cmd.input.atwho(cmd.atwhoConfig);
        });
        cmd.input.on("inserted.atwho", function (event) {
            event.preventDefault();
        });
    }

    /**
     * Create a commander configuration for the given vellum instance
     *
     * A commander configuration contains an atwho configuration as well
     * as `tokenize` and `dispatch` functions for processing commands.
     */
    function configure(vellum) {
        function getMugClassName(typeName) {
            typeName = typeName.toLowerCase();
            if (mugTypes.hasOwnProperty(typeName)) {
                return mugTypes[typeName].__className;
            }
        }

        function getPosition(position) {
            if (position) {
                position = position.toLowerCase();
                if (positionMap.hasOwnProperty(position)) {
                    position = positionMap[position];
                }
            }
            return position;
        }

        function getMug(path) {
            var refMug;
            if (path) {
                refMug = vellum.getMugByPath(path);
                if (!refMug) {
                    throw new Error("bad path: " + path);
                }
            } else {
                refMug = vellum.getCurrentlySelectedMug();
            }
            return refMug;
        }

        /**
         * Get an commander argument config for a list of literal names
         *
         * @param items - array of atwho completion items. Each item
         * must have a "name" property.
         * @param getArg - function to get argument given parsed
         * argument string.
         * @returns argument config object.
         */
        function literals(items, getArg) {
            if (!getArg) {
                throw new Error("getArg parameter is required");
            }
            var source = _.chain(items)
                .map(function (item) {
                    return RegExp.escape(item.name);
                })
                .sortBy(function (name) {
                    // long items first -> greedy match (before shorter items)
                    return -name.length;
                })
                .value()
                .join("|");
            return {regexp: source, items: items, getArg: getArg};
        }

        /**
         * Atwho filter callback
         *
         * @param query - command query (from beginning of command input
         * to caret.
         * @param data - ignored.
         * @param key - item key (searchKey) to use when matching.
         * @returns array of items that complete the given command
         * (query) string.
         */
        function filter(query, data, key) {
            var items = [];
            _.each(forms, function (form) {
                var match = form.exec(query);
                if (match) {
                    var lastMatch = match[match.length - 1],
                        prefix = lastMatch ? query.slice(0, -lastMatch.length) : query,
                        subquery = lastMatch.trimLeft(),
                        // use default atwho filter to match items
                        matched = callbacks.filter(subquery, form.items, key);
                    // add `prefix` to matched items' `full` member
                    matched = _.map(matched, function (item) {
                        return {
                            name: item.name,
                            icon: item.icon,
                            full: prefix + item.name,
                        };
                    });
                    if (subquery) {
                        subquery = subquery.toLowerCase();
                        matched = _.sortBy(matched, function (item) {
                            var index = item.name.toLowerCase().indexOf(subquery);
                            return index >= 0 ? index : Infinity;
                        });
                    }
                    Array.prototype.push.apply(items, matched);
                }
            });
            return items;
        }

        /**
         * Tokenize a command string
         *
         * @param command - command string.
         * @returns an object with two members:
         *  ```
         *  {
         *      tokens: [argument strings array],
         *      config: {command config object},
         *  }
         *  ```
         *  or `undefined` if the command was not recognized.
         */
        function tokenize(command) {
            var i, tokens;
            command = command.trim();
            for (i = 0; i < tokenizers.length; i++) {
                tokens = tokenizers[i].exec(command);
                if (tokens) {
                    return {
                        tokens: _.tail(tokens),
                        config: tokenizers[i].config,
                    };
                }
            }
        }

        /**
         * Parse and execute a command using the command config of the
         * first tokenizer that matches the given command string.
         *
         * @param command - command string.
         * @returns the result of the command, `undefined` on failure.
         */
        function dispatch(command) {
            var obj = tokenize(command), args;
            if (!obj) {
                return;
            }
            try {
                args = _.map(obj.tokens, function (token, i) {
                    return obj.config.args[i].getArg(token);
                });
            } catch (err) {
                return;  // fail on bad argument
            }
            var value = obj.config.run(args);
            return value && {name: obj.config.name, value: value};
        }

        var callbacks = $.fn.atwho["default"].callbacks,
            mugTypes = fn.getQuestionMap(vellum),
            typeItems = _.map(mugTypes, function (type) {
                return {name: type.typeName, icon: type.icon};
            }),
            positions = _.map(["after", "before", "first in", "in"], function (name) {
                return {name: name};
            }),
            positionMap = {"in": "into", "first in": "first"},
            questionRef = {regexp: /[#\/][^\s]+/.source, getArg: getMug},
            tokenizers = [],
            forms = [],
            commandConfigs = [
                // The objects in this array define the structure of
                // commands recognized by the commander.
                //
                // All arguments after the first are optional.
                //
                // The order of objects in this array is important:
                // command auto-complete lists will be constructed with
                // items of the first matching config first, items of
                // the second matching config after those of the first,
                // and so on. Normally this is only important for the
                // first argument since it is unlikely (and probably
                // undesirable) for two command forms to match the same
                // first argument.
                {
                    // add question: Type name [position [#question]]
                    name: "add question",
                    args: [
                        literals(typeItems, getMugClassName),
                        literals(positions, getPosition),
                        questionRef,
                    ],
                    run: function (args) {
                        if (!args[2] && /^(before|after)$/i.test(args[1])) {
                            // Use default position if current mug not found.
                            // Common: "<Qestion Type> after" in empty tree.
                            args[1] = undefined;
                        }
                        try {
                            return vellum.addQuestion.apply(vellum, args);
                        } catch (err) {
                            //window.console.log(err.message);
                        }
                    }
                },
                //{
                //    // delete question
                //    args: [
                //        literals([":Delete"], function () {}),
                //        // TODO implement {n: '*'} - varargs
                //        _.extend({n: '*'}, questionRef),
                //    ],
                //    run: function (args) {
                //        var mug = args[1];
                //        if (mug) {
                //            vellum.data.core.form.removeMugsFromForm([mug]);
                //            vellum.refreshCurrentMug();
                //            return mug;
                //        }
                //    }
                //},
                {
                    // select question
                    name: "select question",
                    args: [questionRef],
                    run: function (args) {
                        var mug = args[0];
                        if (mug && vellum.ensureCurrentMugIsSaved()) {
                            vellum.setCurrentMug(mug);
                            vellum.scrollTreeTo(mug.ufid);
                            vellum.focusFirstInput();
                            return mug;
                        }
                    }
                },
            ];

        /**
         * Construct command forms and tokenizers.
         *
         * A command form is a regular expression matching a potential
         * command. Each form has an `items` attribute referencing an
         * array of completion items for the command. Text matched by
         * the last capturing group in the regular expression is used
         * to match potential completions for the argument at that
         * position.
         *
         * A tokenizer is a regular expression object that matches a
         * valid command string. Its capturing groups correspond to
         * argument tokens. Each tokenizer has a `config` attribute
         * that references the original command configuration object.
         */
        _.each(commandConfigs, function (commandConfig) {
            var seen = [],
                args = [],
                index = forms.length;
            _.each(commandConfig.args, function (arg) {
                if (arg.items) {
                    var parts = seen.concat(["(.*)$"]),
                        form = new RegExp("^" + parts.join("\\s+"), "i");
                    form.items = arg.items;
                    forms.splice(index, 0, form);
                }
                seen.push("(?:" + arg.regexp + ")");
                if (args.length < 1) {
                    args.push("^(" + arg.regexp + ")");
                } else {
                    args.push("(?:\\s+(" + arg.regexp + ")");
                }
            });
            args.push.apply(args, _.map(args, function () { return ")?"; }));
            args[args.length - 1] = "$";
            var tokenizer = new RegExp(args.join(""), "i");
            tokenizer.config = commandConfig;
            tokenizers.push(tokenizer);
        });

        return {
            tokenize: tokenize,
            dispatch: dispatch,
            atwhoConfig: {
                at: "",
                data: [],
                limit: 50,
                maxLen: Infinity,
                displayTpl: '<li><i class="${icon}" /> ${name}</li>',
                insertTpl: "${full}",
                suffix: " ",
                searchKey: $.fn.atwho["default"].searchKey,
                tabSelectsMatch: true,
                callbacks: {
                    matcher: function (flag, subtext) { return subtext; },
                    filter: filter,
                    sorter: function(query, items) { return items; },
                },
            },
        };
    }

    function onCommand(cmd) {
        if (cmd.input.atwho('isSelecting')) {
            // HACK delay until value has been inserted
            _.defer(onCommand, cmd);
        } else {
            var text = cmd.input.val(),
                result = fn.doCommand(text, cmd.vellum);
            if (result) {
                hideCommander(cmd);
                analytics.usage("Commander", result.name);
            } else {
                cmd.input.addClass("alert-danger");
                analytics.usage("Commander", "bad command");
            }
        }
    }

    handlers.Tab = function () { /* prevent default */ };
    handlers.Enter = onCommand;
    handlers.Return = onCommand;
    handlers.Escape = hideCommander;
    handlers.Esc = hideCommander;  // MS Edge

    /**
     * For testing internal atwho config
     */
    fn.getCompletions = function (command, vellum) {
        var cfg = configure(vellum).atwhoConfig;
        return cfg.callbacks.filter(command, null, cfg.searchKey);
    };

    /**
     * For testing internal tokenizer
     */
    fn.tokenize = function (command, vellum) {
        return configure(vellum).tokenize(command);
    };

    fn.doCommand = function (command, vellum) {
        var cmd = vellum.data.commander;
        if (!cmd.dispatch) {
            _.extend(cmd, configure(vellum));
        }
        return cmd.dispatch(command);
    };

    fn.getQuestionMap = function (vellum) {
        var cmd = vellum.data.commander,
            types = vellum.data.core.mugTypes;
        if (!cmd.hasOwnProperty("questions")) {
            cmd.questions = _.chain(vellum.data.core.QUESTIONS_IN_TOOLBAR)
                .map(function (name) {
                    var type = types[name];
                    return [type.typeName.toLowerCase(), type];
                })
                .object()
                .value();
            cmd.questions.choice = types.Choice;
        }
        return cmd.questions;
    };

    return fn;
});

/**
 * CommCare Connect plugin for Vellum
 *
 * This plugin adds two new mug types:
 * - Learn Module
 * - Assessment Score
 * - Delivery Unit
 */
define('vellum/commcareConnect',[
    'jquery',
    'underscore',
    'vellum/mugs',
    'vellum/tree',
    'vellum/util',
    'vellum/widgets',
    'vellum/core'
], function (
    $,
    _,
    mugs,
    Tree,
    util,
    widgets
) {
    let CCC_XMLNS = 'http://commcareconnect.com/data/v1/learn',
        baseSection = {
            slug: "main",
            displayName: gettext("Basic"),
            properties: [
                "nodeID",
            ],
        },
        logicSection = {
            slug: "logic",
            displayName: gettext("Logic"),
            help: {
                title: gettext("Logic"),
                text: gettext("Use logic to control when questions are asked and what answers are valid. " +
                    "You can add logic to display a question based on a previous answer, to make " +
                    "the question required or ensure the answer is in a valid range."),
                link: "https://confluence.dimagi.com/display/commcarepublic/Common+Logic+and+Calculations"
            },
            properties: [
                'relevantAttr',
            ]
        },
        baseSpec = {
            xmlnsAttr: {
                presence: "optional",
                serialize: () => {},
                deserialize: () => {}
            },
            requiredAttr: {presence: "notallowed"},
            constraintAttr: {presence: "notallowed"},
            calculateAttr: {presence: "notallowed"}
        },
        baseMugOptions = {
            isTypeChangeable: false,
            isDataOnly: true,
            supportsDataNodeRole: true,
            getExtraDataAttributes: mug => ({
                // allows the parser to know which mug to associate with this node
                "vellum:role": mug.__className,
            }),
            getBindList: mug => {
                // return list of bind elements to add to the form
                let mugConfig = mugConfigs[mug.__className];
                let binds = [{
                    nodeset: mug.hashtagPath,
                    relevant: mug.p.relevantAttr,
                }];
                return binds.concat(mugConfig.childNodes.filter(child => !child.writeToData).map(child => {
                    return {
                        nodeset: `${mug.absolutePath}/${mugConfig.rootName}/${child.id}`,
                        calculate: mug.p[child.id],
                    };
                }));
            },
            parseDataNode: (mug, node) => {
                let children = node.children(),
                    mugConfig = mugConfigs[mug.__className];
                if (children.length === 1) {
                    let child = children[0];
                    if (child.nodeName === mugConfig.rootName && child.getAttribute("xmlns") === CCC_XMLNS) {
                        $(child).children().each((i, el) => {
                            let childConfig = mugConfig.childNodes.find(child => child.id === el.nodeName);
                            if (childConfig && childConfig.writeToData) {
                                mug.p[el.nodeName] = $(el).text();
                            }
                        });
                    }
                }
                return $([]);
            },
            dataChildFilter: (children, mug) => {
                // called during write
                // return a list nodes to add to the forms data node
                children = mugConfigs[mug.__className].childNodes.map(child => {
                    let p = {rawDataAttributes: null};
                    if (child.writeToData) {
                        p.dataValue = mug.p[child.id];
                    }
                    return new Tree.Node([], {
                        getNodeID: () => child.id,
                        p: p,
                        options: {
                            getExtraDataAttributes: () => {}
                        }
                    });
                });
                return [new Tree.Node(children, {
                    getNodeID: () => mugConfigs[mug.__className].rootName,
                    p: {rawDataAttributes: null},
                    options: {
                        getExtraDataAttributes: () => ({
                            "xmlns": CCC_XMLNS,
                            "id": mug.p.nodeID,
                        })
                    }
                })];
            },
        },
        mugConfigs = {
            ConnectLearnModule: {
                rootName: "module",
                childNodes: [
                    {id: "name", writeToData: true},
                    {id: "description", writeToData: true},
                    {id: "time_estimate", writeToData: true},
                ],
                mugOptions: util.extend(baseMugOptions, {
                    typeName: 'Learn Module',
                    icon: 'fa fa-graduation-cap',
                    init: mug => {
                        mug.p.name = "";
                        mug.p.description = "";
                        mug.p.time_estimate = "";
                    },
                    spec: util.extend(baseSpec, {
                        nodeID: {
                            lstring: gettext('Module ID'),
                        },
                        name: {
                            lstring: gettext("Name"),
                            visibility: 'visible',
                            presence: 'required',
                            widget: widgets.text,
                        },
                        description: {
                            lstring: gettext("Description"),
                            visibility: 'visible',
                            presence: 'required',
                            widget: widgets.richTextarea,
                        },
                        time_estimate: {
                            lstring: gettext("Time Estimate"),
                            visibility: 'visible',
                            presence: 'required',
                            widget: widgets.text,
                            validationFunc: mug => {
                                let val = mug.p.time_estimate;
                                return val && val.match(/^\d+$/) ? "pass" : gettext("Must be an integer");
                            },
                            help: gettext('Estimated time to complete the module in hours.'),
                        },
                        relevantAttr: {
                            visibility: 'visible',
                            presence: 'optional',
                            widget: widgets.xPath,
                            xpathType: "bool",
                            serialize: mugs.serializeXPath,
                            deserialize: mugs.deserializeXPath,
                            lstring: gettext('Display Condition'),
                        }
                    })
                }),
                sections: [
                    _.extend({}, baseSection, {
                        properties: [
                            "nodeID",
                            "name",
                            "description",
                            "time_estimate",
                        ],
                    }),
                    _.clone(logicSection),
                ],
            },
            ConnectAssessment: {
                rootName: "assessment",
                childNodes: [
                    {id: "user_score"},
                ],
                mugOptions: util.extend(baseMugOptions, {
                    typeName: 'Assessment Score',
                    icon: 'fa-brands fa-leanpub',
                    init: mug => {
                        mug.p.user_score = "";
                    },
                    spec: util.extend(baseSpec, {
                        nodeID: {
                            lstring: gettext('Assessment ID'),
                        },
                        user_score: {
                            lstring: gettext("User Score"),
                            visibility: 'visible',
                            presence: 'required',
                            widget: widgets.xPath,
                            serialize: mugs.serializeXPath,
                            deserialize: mugs.deserializeXPath,
                            help: gettext('XPath expression for the users assessment score.'),
                        },
                        relevantAttr: {
                            visibility: 'visible',
                            presence: 'optional',
                            widget: widgets.xPath,
                            xpathType: "bool",
                            serialize: mugs.serializeXPath,
                            deserialize: mugs.deserializeXPath,
                            lstring: gettext('Display Condition')
                        }
                    })
                }),
                sections: [
                    _.extend({}, baseSection, {
                        properties: [
                            "nodeID",
                            "user_score",
                        ],
                    }),
                    _.clone(logicSection),
                ],
            },
            ConnectDeliverUnit: {
                rootName: "deliver",
                childNodes: [
                    {id: "name", writeToData: true},
                    {id: "entity_id"},
                    {id: "entity_name"},
                ],
                mugOptions: util.extend(baseMugOptions, {
                    typeName: 'Deliver Unit',
                    icon: 'fa fa-briefcase',
                    init: mug => {
                        mug.p.name = "";
                        mug.p.entity_id = "";
                        mug.p.entity_name = "";
                    },
                    spec: util.extend(baseSpec, {
                        nodeID: {
                            lstring: gettext('Delivery Unit ID'),
                        },
                        name: {
                            lstring: gettext("Name"),
                            visibility: 'visible',
                            presence: 'required',
                            widget: widgets.text,
                        },
                        entity_id: {
                            lstring: gettext("Entity ID"),
                            visibility: 'visible',
                            presence: 'optional',
                            widget: widgets.xPath,
                            serialize: mugs.serializeXPath,
                            deserialize: mugs.deserializeXPath,
                            help: gettext('XPath expression for the entity ID associated with this Delivery Unit e.g. the case ID.'),
                        },
                        entity_name: {
                            lstring: gettext("Entity Name"),
                            visibility: 'visible',
                            presence: 'optional',
                            widget: widgets.xPath,
                            serialize: mugs.serializeXPath,
                            deserialize: mugs.deserializeXPath,
                            help: gettext('XPath expression for the name of the entity associated with this Delivery Unit.'),
                        },
                        relevantAttr: {
                            visibility: 'visible',
                            presence: 'optional',
                            widget: widgets.xPath,
                            xpathType: "bool",
                            serialize: mugs.serializeXPath,
                            deserialize: mugs.deserializeXPath,
                            lstring: gettext('Display Condition')
                        }
                    })
                }),
                sections: [
                    _.extend({}, baseSection, {
                        properties: [
                            "nodeID",
                            "name",
                            "entity_id",
                            "entity_name",
                        ],
                    }),
                    _.clone(logicSection),
                ],
            }
        };


    $.vellum.plugin("commcareConnect", {}, {
        getAdvancedQuestions: function () {
            return this.__callOld().concat(Object.keys(mugConfigs));
        },
        getMugTypes: function () {
            let types = this.__callOld();
            Object.entries(mugConfigs).forEach(([mugType, config]) => {
                types.normal[mugType] = util.extend(mugs.defaultOptions, config.mugOptions);
            });
            return types;
        },
        getSections: function (mug) {
            if (Object.hasOwn(mugConfigs, mug.__className)) {
                return _.map(mugConfigs[mug.__className].sections, section => _.clone(section));
            }
            return this.__callOld();
        },
        parseBindElement: function (form, el, path) {
            let mug = form.getMugByPath(path);
            if (!mug) {
                // check each mugConfig to see if this path matches
                let matched = Object.entries(mugConfigs).some(([mugName, mugConfig]) => {
                    // construct regex to match any of the child nodes
                    let children = mugConfig.childNodes.map(child => child.id).join('|'),
                        regex = new RegExp(`/${mugConfig.rootName}/(${children})`),
                        matchRet = path.match(regex);
                    if (matchRet && matchRet.length > 0) {
                        let attr = matchRet[1];
                        mug = form.getMugByPath(path.replace(regex, ""));
                        if (mug && mug.__className === mugName) {
                            mug.p[attr] = el.xmlAttr("calculate");
                            return true;
                        }
                    }
                });
                if (matched) {
                    return;
                }
            } else {
                if (Object.hasOwn(mugConfigs, mug.__className)) {
                    mug.p.relevantAttr = el.xmlAttr("relevant");
                    return;
                }
            }
            this.__callOld();
        },
    });
});

/* global requirejs */
requirejs.config({
    // For some reason when using the map config as suggested by some of the
    // plugins' documentation, and only when including vellum in another
    // app, it tries to get requirejs-promise instead of
    // requirejs-promise.js, so using packages instead.  This might be a bug
    // that should be reported.
    packages: [
        {
            name: 'less',
            location: '../node_modules/@bracken/require-less',
            main: 'less.js'
        },
        {
            name: 'css',
            location: '../node_modules/require-css',
            main: 'css.js'
        },
        {
            name: 'text',
            location: '../node_modules/requirejs-text',
            main: 'text.js'
        },
        {
            name: 'tpl',
            location: '../node_modules/requirejs-undertemplate',
            main: 'tpl.js'
        },
        {
            name: 'json',
            location: '../node_modules/requirejs-plugins/src',
            main: 'json.js'
        },
        {
            name: "codemirror",
            location: "../node_modules/codemirror",
            main: "lib/codemirror",
        },
    ],
    paths: {
        'vellum': '.',

        'CryptoJS': '../lib/sha1',
        'diff-match-patch': '../lib/diff_match_patch',
        'jquery': '../node_modules/jquery/dist/jquery',
        'jquery.jstree': '../node_modules/jstree/dist/jstree',
        'jstree-actions': '../node_modules/jstree-actions/jstree-actions',
        'jquery.bootstrap': '../node_modules/bootstrap/dist/js/bootstrap',
        'underscore': '../node_modules/underscore/underscore',
        'XMLWriter': '../node_modules/XMLWriter/XMLWriter',

        'xpath': '../node_modules/xpath/dist/js-xpath',

        'langCodes': '../node_modules/langcodes/langs.json',

        'save-button': '../lib/SaveButton',

        'jsdiff': '../node_modules/jsdiff/diff',
        'markdown-it': '../node_modules/markdown-it/dist/markdown-it',
        'caretjs': '../node_modules/Caret.js/dist/jquery.caret',
        'atjs': '../node_modules/at.js/dist/js/jquery.atwho',
        'ckeditor': '../lib/ckeditor/ckeditor',
        'ckeditor-jquery': '../lib/ckeditor/adapters/jquery',
        'fusejs': '../node_modules/fuse.js/src/fuse'
    },
    shim: {
        'CryptoJS': {
            exports: 'CryptoJS'
        },
        'diff-match-patch': {
            exports: 'diff_match_patch'
        },

        'jquery.jstree': {
            deps: ['jquery', 'css!../node_modules/jstree/dist/themes/default/style'],
            exports: '$.fn.jstree'
        },
        'jstree-actions': {
            deps: ['jquery.jstree'],
        },
        'jquery.bootstrap': {
            deps: ['jquery'],
            exports: '$.fn.popover'
        },
        'XMLWriter': {
            exports: 'XMLWriter'
        },

        'save-button': {
            deps: ['jquery'],
            exports: 'SaveButton'
        },

        'xpath': {
            exports: 'xpath'
        },
        'jsdiff': {
            exports: 'JsDiff'
        },
        'markdown-it': {
            exports: 'markdown-it'
        },
        'caretjs': {
            deps: ['jquery'],
            exports: 'caretjs'
        },
        'atjs': {
            deps: ['jquery', 'caretjs', 'css!../node_modules/at.js/dist/css/jquery.atwho'],
            exports: 'atjs'
        },
        'ckeditor': {
            exports: 'CKEDITOR'
        },
        'ckeditor-jquery': {
            deps: ['jquery', 'ckeditor'],
            exports: '$.fn.ckeditor'
        },
        'fusejs': {
            exports: 'fusejs'
        }
    },
    less: {
        logLevel: 1
    }
});

// If jQuery was loaded before RequireJS, use the existing instance.
// http://www.manuel-strehl.de/dev/load_jquery_before_requirejs.en.html
if (window.jQuery) {
    define('jquery', [], function() {
        return window.jQuery;
    });
}

if (!window.gettext) {
    window.gettext = function (arg) { return arg; };
    window.ngettext = function (singular, plural, count) {
        return count === 1 ? singular : plural;
    };
}

define('main',[
    // begin buildmain.py delimiter
    'vellum/core',
    'vellum/ignoreButRetain',
    'vellum/intentManager',
    'vellum/itemset',
    'vellum/javaRosa/plugin',
    'vellum/datasources',
    'vellum/lock',
    'vellum/databrowser',
    'vellum/commtrack',
    'vellum/modeliteration',
    'vellum/saveToCase',
    'vellum/uploader',
    'vellum/window',
    'vellum/copy-paste',
    'vellum/commander',
    'vellum/commcareConnect',
    // end buildmain.py delimiter
], function () {
    // adds $.vellum as a side-effect
});


define("main-components", function(){});
