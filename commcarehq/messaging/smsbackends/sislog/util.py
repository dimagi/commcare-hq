

GSM_03_38_POR_BASIC = {
    0x00: u"@",
    0x01: u"\u00a3",
    0x02: u"$",
    0x03: u"\u00a5",
    0x04: u"\u00ea",
    0x05: u"\u00e9",
    0x06: u"\u00fa",
    0x07: u"\u00ed",
    0x08: u"\u00f3",
    0x09: u"\u00e7",
    0x0a: u"\n",
    0x0b: u"\u00d4",
    0x0c: u"\u00f4",
    0x0d: u"\r",
    0x0e: u"\u00c1",
    0x0f: u"\u00e1",
    0x10: u"\u0394",
    0x11: u"_",
    0x12: u"\u00aa",
    0x13: u"\u00c7",
    0x14: u"\u00c0",
    0x15: u"\u221e",
    0x16: u"^",
    0x17: u"\\",
    0x18: u"\u20ac",
    0x19: u"\u00d3",
    0x1a: u"|",
    0x1b: u"",
    0x1c: u"\u00c2",
    0x1d: u"\u00e2",
    0x1e: u"\u00ca",
    0x1f: u"\u00c9",
    0x20: u" ",
    0x21: u"!",
    0x22: u'"',
    0x23: u"#",
    0x24: u"\u00ba",
    0x25: u"%",
    0x26: u"&",
    0x27: u"'",
    0x28: u"(",
    0x29: u")",
    0x2a: u"*",
    0x2b: u"+",
    0x2c: u",",
    0x2d: u"-",
    0x2e: u".",
    0x2f: u"/",
    0x30: u"0",
    0x31: u"1",
    0x32: u"2",
    0x33: u"3",
    0x34: u"4",
    0x35: u"5",
    0x36: u"6",
    0x37: u"7",
    0x38: u"8",
    0x39: u"9",
    0x3a: u":",
    0x3b: u";",
    0x3c: u"<",
    0x3d: u"=",
    0x3e: u">",
    0x3f: u"?",
    0x40: u"\u00cd",
    0x41: u"A",
    0x42: u"B",
    0x43: u"C",
    0x44: u"D",
    0x45: u"E",
    0x46: u"F",
    0x47: u"G",
    0x48: u"H",
    0x49: u"I",
    0x4a: u"J",
    0x4b: u"K",
    0x4c: u"L",
    0x4d: u"M",
    0x4e: u"N",
    0x4f: u"O",
    0x50: u"P",
    0x51: u"Q",
    0x52: u"R",
    0x53: u"S",
    0x54: u"T",
    0x55: u"U",
    0x56: u"V",
    0x57: u"W",
    0x58: u"X",
    0x59: u"Y",
    0x5a: u"Z",
    0x5b: u"\u00c3",
    0x5c: u"\u00d5",
    0x5d: u"\u00da",
    0x5e: u"\u00dc",
    0x5f: u"\u00a7",
    0x60: u"~",
    0x61: u"a",
    0x62: u"b",
    0x63: u"c",
    0x64: u"d",
    0x65: u"e",
    0x66: u"f",
    0x67: u"g",
    0x68: u"h",
    0x69: u"i",
    0x6a: u"j",
    0x6b: u"k",
    0x6c: u"l",
    0x6d: u"m",
    0x6e: u"n",
    0x6f: u"o",
    0x70: u"p",
    0x71: u"q",
    0x72: u"r",
    0x73: u"s",
    0x74: u"t",
    0x75: u"u",
    0x76: u"v",
    0x77: u"w",
    0x78: u"x",
    0x79: u"y",
    0x7a: u"z",
    0x7b: u"\u00e3",
    0x7c: u"\u00f5",
    0x7d: u"`",
    0x7e: u"\u00fc",
    0x7f: u"\u00e0",
}


GSM_03_38_POR_EXTENSION = {
    0x00: u"",
    0x01: u"",
    0x02: u"",
    0x03: u"",
    0x04: u"",
    0x05: u"\u00ea",
    0x06: u"",
    0x07: u"",
    0x08: u"",
    0x09: u"\u00e7",
    0x0a: u"\n",
    0x0b: u"\u00d4",
    0x0c: u"\u00f4",
    0x0d: u"",
    0x0e: u"\u00c1",
    0x0f: u"\u00e1",
    0x10: u"",
    0x11: u"",
    0x12: u"\u03a6",
    0x13: u"\u0393",
    0x14: u"^",
    0x15: u"\u03a9",
    0x16: u"\u03a0",
    0x17: u"\u03a8",
    0x18: u"\u03a3",
    0x19: u"\u0398",
    0x1a: u"",
    0x1b: u"",
    0x1c: u"",
    0x1d: u"",
    0x1e: u"",
    0x1f: u"\u00ca",
    0x20: u"",
    0x21: u"",
    0x22: u"",
    0x23: u"",
    0x24: u"",
    0x25: u"",
    0x26: u"",
    0x27: u"",
    0x28: u"{",
    0x29: u"}",
    0x2a: u"",
    0x2b: u"",
    0x2c: u"",
    0x2d: u"",
    0x2e: u"",
    0x2f: u"\\",
    0x30: u"",
    0x31: u"",
    0x32: u"",
    0x33: u"",
    0x34: u"",
    0x35: u"",
    0x36: u"",
    0x37: u"",
    0x38: u"",
    0x39: u"",
    0x3a: u"",
    0x3b: u"",
    0x3c: u"[",
    0x3d: u"~",
    0x3e: u"]",
    0x3f: u"",
    0x40: u"|",
    0x41: u"\u00c0",
    0x42: u"",
    0x43: u"",
    0x44: u"",
    0x45: u"",
    0x46: u"",
    0x47: u"",
    0x48: u"",
    0x49: u"\u00cd",
    0x4a: u"",
    0x4b: u"",
    0x4c: u"",
    0x4d: u"",
    0x4e: u"",
    0x4f: u"\u00d3",
    0x50: u"",
    0x51: u"",
    0x52: u"",
    0x53: u"",
    0x54: u"",
    0x55: u"\u00da",
    0x56: u"",
    0x57: u"",
    0x58: u"",
    0x59: u"",
    0x5a: u"",
    0x5b: u"\u00c3",
    0x5c: u"\u00d5",
    0x5d: u"",
    0x5e: u"",
    0x5f: u"",
    0x60: u"",
    0x61: u"\u00c2",
    0x62: u"",
    0x63: u"",
    0x64: u"",
    0x65: u"\u20ac",
    0x66: u"",
    0x67: u"",
    0x68: u"",
    0x69: u"\u00ed",
    0x6a: u"",
    0x6b: u"",
    0x6c: u"",
    0x6d: u"",
    0x6e: u"",
    0x6f: u"\u00f3",
    0x70: u"",
    0x71: u"",
    0x72: u"",
    0x73: u"",
    0x74: u"",
    0x75: u"\u00fa",
    0x76: u"",
    0x77: u"",
    0x78: u"",
    0x79: u"",
    0x7a: u"",
    0x7b: u"\u00e3",
    0x7c: u"\u00f5",
    0x7d: u"",
    0x7e: u"",
    0x7f: u"\u00e2",
}


# These are characters that shouldn't be in a properly decoded string
UNRECOGNIZED_CHAR_CODES = {
    0x00: True,
    0x01: True,
    0x02: True,
    0x03: True,
    0x04: True,
    0x05: True,
    0x06: True,
    0x07: True,
    0x08: True,
    0x09: True,
    0x0b: True,
    0x0c: True,
    0x0e: True,
    0x0f: True,
    0x10: True,
    0x11: True,
    0x12: True,
    0x13: True,
    0x14: True,
    0x15: True,
    0x16: True,
    0x17: True,
    0x18: True,
    0x19: True,
    0x1a: True,
    0x1b: True,
    0x1c: True,
    0x1d: True,
    0x1e: True,
    0x1f: True,
    0x7f: True,
}


ESCAPE_CHAR = 0x1b


def looks_like_gsm(text):
    for char in text:
        if UNRECOGNIZED_CHAR_CODES.get(ord(char), False):
            return True
    return False


def gsm_to_unicode(text):
    """
      Converts each character in text to it's equivalent GSM-decoded
    character. If the character is anything other than ESCAPE_CHAR,
    then it's decoded with GSM_03_38_POR_BASIC.
      If a character is the ESCAPE_CHAR, then it is skipped and the
    next character is decoded with GSM_03_38_POR_EXTENSION.
    """
    result = u""
    is_escape = False
    for char in text:
        gsm_char_code = ord(char)
        if gsm_char_code == ESCAPE_CHAR:
            is_escape = True
        elif is_escape:
            ext_char = GSM_03_38_POR_EXTENSION.get(gsm_char_code, "")
            if ext_char:
                result += ext_char
            else:
                result += " %s" % GSM_03_38_POR_BASIC.get(gsm_char_code, "")
            is_escape = False
        else:
            result += GSM_03_38_POR_BASIC.get(gsm_char_code, "")
    return result


def convert_raw_string(text):
    """
    Unfortunately, it's not possible to tell whether we'll get a message
    that's encoded with GSM or not. So all we can do is decode
    messages that look like they are encoded with GSM.
    """
    if looks_like_gsm(text):
        return gsm_to_unicode(text)
    else:
        return text


